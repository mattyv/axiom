<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axiom Knowledge Graph (WebGL)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #eee;
            overflow: hidden;
        }
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 20px;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            z-index: 100;
            border-bottom: 1px solid #222;
        }
        h1 { font-size: 18px; color: #e94560; font-weight: 600; }
        .stats { display: flex; gap: 15px; font-size: 12px; color: #888; }
        .stats strong { color: #4ecca3; }
        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }
        .search-box {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #111;
            color: #eee;
            width: 200px;
            font-size: 13px;
        }
        .search-box:focus { outline: none; border-color: #4ecca3; }
        .btn {
            padding: 8px 14px;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            background: #111;
            color: #eee;
            transition: all 0.2s;
        }
        .btn:hover { background: #4ecca3; color: #000; border-color: #4ecca3; }
        .layer-filters {
            position: fixed;
            top: 60px;
            left: 20px;
            background: rgba(10, 10, 15, 0.9);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #222;
            z-index: 100;
        }
        .layer-filter {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            font-size: 12px;
        }
        .layer-filter:last-child { margin-bottom: 0; }
        .layer-badge {
            padding: 3px 10px;
            border-radius: 4px;
            color: white;
            font-size: 11px;
        }
        #graph {
            width: 100vw;
            height: 100vh;
            background: #0a0a0f;
        }
        .info-panel {
            position: fixed;
            right: 20px;
            top: 70px;
            width: 320px;
            max-height: calc(100vh - 90px);
            background: rgba(15, 15, 20, 0.95);
            border-radius: 10px;
            padding: 16px;
            display: none;
            overflow-y: auto;
            z-index: 100;
            border: 1px solid #222;
            backdrop-filter: blur(10px);
        }
        .info-panel.visible { display: block; }
        .info-panel h3 {
            margin: 0 0 12px 0;
            color: #4ecca3;
            font-size: 13px;
            word-break: break-all;
            padding-right: 20px;
        }
        .info-panel .close {
            position: absolute;
            right: 12px;
            top: 12px;
            cursor: pointer;
            color: #555;
            font-size: 20px;
            line-height: 1;
        }
        .info-panel .close:hover { color: #e94560; }
        .info-field { margin-bottom: 12px; }
        .info-field label {
            display: block;
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .info-field .value { color: #ccc; font-size: 13px; line-height: 1.5; }
        .dep-link {
            display: inline-block;
            color: #4ecca3;
            cursor: pointer;
            font-size: 11px;
            font-family: monospace;
            padding: 2px 0;
        }
        .dep-link:hover { text-decoration: underline; }
        .filter-btn {
            width: 100%;
            margin-bottom: 12px;
            background: #1a3a5c;
            border-color: #2d5a87;
        }
        .filter-btn:hover { background: #2d5a87; color: #fff; border-color: #4ecca3; }
        .hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            color: #444;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Axiom Knowledge Graph</h1>
        <div class="stats">
            <span><strong>2,571</strong> nodes</span>
            <span><strong>2,489</strong> edges</span>
        </div>
        <div class="controls">
            <input type="text" class="search-box" id="search" placeholder="Search...">
            <button class="btn" onclick="resetView()">Reset</button>
            <button class="btn" onclick="zoomIn()">+</button>
            <button class="btn" onclick="zoomOut()">−</button>
        </div>
    </div>

    <div class="layer-filters">
        <label class="layer-filter"><input type="checkbox" checked data-layer="cpp20_language"><span class="layer-badge" style="background:#45aaf2">cpp20_language</span></label>
<label class="layer-filter"><input type="checkbox" checked data-layer="cpp20_stdlib"><span class="layer-badge" style="background:#0984e3">cpp20_stdlib</span></label>
<label class="layer-filter"><input type="checkbox" checked data-layer="library"><span class="layer-badge" style="background:#26de81">library</span></label>
    </div>

    <div id="graph"></div>

    <div class="info-panel" id="info-panel">
        <span class="close" onclick="closeInfo()">×</span>
        <h3 id="info-id"></h3>
        <button class="btn filter-btn" onclick="filterToSubtree()" title="Show only this axiom and its dependencies">Filter to subtree ↓</button>
        <div class="info-field">
            <label>Layer</label>
            <div class="value"><span class="layer-badge" id="info-layer"></span></div>
        </div>
        <div class="info-field">
            <label>Module</label>
            <div class="value" id="info-module"></div>
        </div>
        <div class="info-field" id="info-function-field" style="display:none;">
            <label>Function</label>
            <div class="value" id="info-function"></div>
        </div>
        <div class="info-field">
            <label>Content</label>
            <div class="value" id="info-content"></div>
        </div>
        <div class="info-field">
            <label>Dependencies</label>
            <div class="value" id="info-deps"></div>
        </div>
        <div class="info-field">
            <label>Dependents</label>
            <div class="value" id="info-dependents"></div>
        </div>
    </div>

    <div class="hint">Scroll to zoom • Drag to pan • Click node for details</div>

    <script>
        const nodesData = [{"id": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "label": "cpp20_atomics_fences_release_acquire_syn", "x": -295.9188759067462, "y": 196.59194292296098, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[atomics.fences]/2", "content": "A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y, where Y is not an atomic read-modify-write operation, both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X ", "function": ""}, {"id": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "label": "cpp20_atomics_fences_release_fence_acqui", "x": -265.3153948813734, "y": 177.1588731751464, "size": 11.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[atomics.fences]/3", "content": "A release fence A synchronizes with an atomic operation B that performs an acquire operation on an atomic object M if there exists an atomic operation X such that A is sequenced before X, X modifies M, and B reads the value written by X or a value written by any side effect in the hypothetical relea", "function": ""}, {"id": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "label": "cpp20_atomics_fences_release_op_acquire_", "x": -233.70245616471445, "y": 169.09521722176942, "size": 12.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[atomics.fences]/4", "content": "An atomic operation A that is a release operation on an atomic object M synchronizes with an acquire fence B if there exists some atomic operation X on M such that X is sequenced before B and reads the value written by A or a value written by any side effect in the release sequence headed by A.", "function": ""}, {"id": "cpp20_atomics_order_timely_visibility_2f8a3b4c", "label": "cpp20_atomics_order_timely_visibility_2f", "x": -234.610575575269, "y": 161.66857301920402, "size": 9.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[atomics.order]/12", "content": "The implementation should make atomic stores visible to atomic loads, and atomic loads should observe atomic stores, within a reasonable amount of time.", "function": ""}, {"id": "cpp20_basic_life_before_after_happens_before_5e6f7a8b", "label": "cpp20_basic_life_before_after_happens_be", "x": 259.33681326817504, "y": 600.7954805996679, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/1", "content": "In the context of object lifetime, \"before\" and \"after\" refer to the \"happens before\" relation.", "function": ""}, {"id": "cpp20_basic_life_launder_required_6c7d8e9f", "label": "cpp20_basic_life_launder_required_6c7d8e", "x": -229.65838854102677, "y": -47.31848520956052, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/10", "content": "If transparent replacement conditions are not met, a pointer to the new object can be obtained from a pointer that represents the address of its storage by calling std::launder.", "function": ""}, {"id": "cpp20_basic_life_name_auto_refers_new_obj_4e5f6a7b", "label": "cpp20_basic_life_name_auto_refers_new_ob", "x": 634.3773867306619, "y": -522.8000634913516, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/10", "content": "After transparent replacement, the name of the original object will automatically refer to the new object and can be used to manipulate it once its lifetime starts.", "function": ""}, {"id": "cpp20_basic_life_ptr_auto_refers_new_obj_8c9d0e1f", "label": "cpp20_basic_life_ptr_auto_refers_new_obj", "x": -208.1158476238594, "y": -84.94752825219388, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/10", "content": "After transparent replacement, a pointer that pointed to the original object will automatically refer to the new object and can be used to manipulate it once its lifetime starts.", "function": ""}, {"id": "cpp20_basic_life_ref_auto_refers_new_obj_0a1b2c3d", "label": "cpp20_basic_life_ref_auto_refers_new_obj", "x": 70.53314083429458, "y": -138.49235576922044, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/10", "content": "After transparent replacement, a reference that referred to the original object will automatically refer to the new object and can be used to manipulate it once its lifetime starts.", "function": ""}, {"id": "cpp20_basic_life_runtime_property_1a2b3c4d", "label": "cpp20_basic_life_runtime_property_1a2b3c", "x": 132.8418560076457, "y": -127.93086523485844, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/2", "content": "The lifetime of an object or reference is a runtime property of the object or reference.", "function": ""}, {"id": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "label": "cpp20_basic_life_vacuous_initialization_", "x": -4.4933931468978345, "y": -39.03005831916879, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/2", "content": "A variable has vacuous initialization if it is default-initialized, no other initialization is performed, and if it is of class type or a (possibly multidimensional) array thereof, a trivial constructor of that class type is selected for the default-initialization.", "function": ""}, {"id": "cpp20_basic_life_reference_lifetime_end_3f8a2b1c", "label": "cpp20_basic_life_reference_lifetime_end_", "x": 115.15606905142621, "y": -158.5643468113242, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/3", "content": "The lifetime of a reference ends as if it were a scalar object requiring storage.", "function": ""}, {"id": "cpp20_basic_life_reference_lifetime_end_scalar_7e8f9a0b", "label": "cpp20_basic_life_reference_lifetime_end_", "x": 164.52596223475877, "y": -83.63967983691165, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/3", "content": "The lifetime of a reference ends as if it were a scalar object requiring storage.", "function": ""}, {"id": "cpp20_basic_life_end_without_destructor_9c0d1e2f", "label": "cpp20_basic_life_end_without_destructor_", "x": -49.71831061868763, "y": 13.660090594495632, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/6", "content": "A program may end the lifetime of an object of class type without invoking the destructor, by reusing or releasing the storage.", "function": ""}, {"id": "cpp20_basic_life_indirection_limited_use_7f8a9b0c", "label": "cpp20_basic_life_indirection_limited_use", "x": -31.807741308375363, "y": -128.83782285097624, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/7", "content": "Indirection through a pointer to storage where an object's lifetime has not started or has ended is permitted but the resulting lvalue may only be used in limited ways.", "function": ""}, {"id": "cpp20_basic_life_ptr_void_star_well_defined_3b4c5d6e", "label": "cpp20_basic_life_ptr_void_star_well_defi", "x": -199.0519237510749, "y": -107.89685098233004, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/7", "content": "Before an object's lifetime starts or after it ends, a pointer to the storage location may be used as if the pointer were of type void* and such use is well-defined.", "function": ""}, {"id": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a", "label": "cpp20_basic_life_glvalue_properties_well", "x": -50.35115726365886, "y": -10.990422046483927, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/8", "content": "Before an object's lifetime starts or after it ends, using the properties of a glvalue that do not depend on its value is well-defined.", "function": ""}, {"id": "cpp20_basic_life_transparent_replace_subobj_mutable_4a5b6c7d", "label": "cpp20_basic_life_transparent_replace_sub", "x": 855.1993708453516, "y": 467.12888529755935, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.life]/9", "content": "Direct subobjects o1 and o2 are transparently replaceable if o1 is a mutable member subobject or a subobject thereof, even if the complete object is const.", "function": ""}, {"id": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "label": "cpp20_basic_lval_glvalue_to_prvalue_conv", "x": -35.705065165659576, "y": -10.777586554965477, "size": 11.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.lval]/6", "content": "When a glvalue appears as an operand of an operator that requires a prvalue for that operand, the lvalue-to-rvalue, array-to-pointer, or function-to-pointer standard conversions are applied to convert the expression to a prvalue.", "function": ""}, {"id": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "label": "cpp20_basic_lval_temp_materialization_b4", "x": 8.673873610597406, "y": -79.18571256274475, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.lval]/7", "content": "Unless otherwise specified, when a prvalue that is not the result of the lvalue-to-rvalue conversion appears as an operand of an operator, the temporary materialization conversion is applied to convert the expression to an xvalue.", "function": ""}, {"id": "cpp20_basic_stc_auto_block_exit_d7e8f9a0", "label": "cpp20_basic_stc_auto_block_exit_d7e8f9a0", "x": -33.34574277675264, "y": 163.97577591742888, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.auto]/1", "content": "The storage for variables with automatic storage duration lasts until the block in which they are created exits.", "function": ""}, {"id": "cpp20_basic_stc_auto_block_scope_f3a4b5c6", "label": "cpp20_basic_stc_auto_block_scope_f3a4b5c", "x": -29.45424975293172, "y": 181.76112962161338, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.auto]/1", "content": "Variables that belong to a block scope and are not explicitly declared static, thread_local, or extern have automatic storage duration.", "function": ""}, {"id": "cpp20_basic_stc_auto_parameter_lifetime_f5a6b7c8", "label": "cpp20_basic_stc_auto_parameter_lifetime_", "x": -117.39907024044935, "y": 165.13106612175778, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.auto]/1", "content": "The storage for a function parameter lasts until immediately after its destruction.", "function": ""}, {"id": "cpp20_basic_stc_auto_parameter_scope_b1c2d3e4", "label": "cpp20_basic_stc_auto_parameter_scope_b1c", "x": -38.16615230458873, "y": 209.3530611768481, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.auto]/1", "content": "Variables that belong to a parameter scope have automatic storage duration.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_alloc_disjoint_storage_c3d4e5f6", "label": "cpp20_basic_stc_dynamic_alloc_disjoint_s", "x": -207.1408716940302, "y": -94.30876452197235, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.allocation]/2", "content": "For the library allocation functions, the returned pointer p0 represents the address of a block of storage disjoint from the storage for any other object accessible to the caller.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0", "label": "cpp20_basic_stc_dynamic_alloc_unique_ptr", "x": 57.83399546337283, "y": 25.261899198332326, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.allocation]/2", "content": "The value returned by a replaceable allocation function is a non-null pointer value p0 different from any previously returned value p1, unless that value p1 was subsequently passed to a replaceable deallocation function.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_dealloc_destroying_first_param_a7b8c9d0", "label": "cpp20_basic_stc_dynamic_dealloc_destroyi", "x": -65.19046862015944, "y": -43.01923156676292, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.deallocation]/3", "content": "If a deallocation function is a destroying operator delete declared in class type C, the type of its first parameter shall be C*.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_dealloc_nonnull_first_param_c3d4e5f6", "label": "cpp20_basic_stc_dynamic_dealloc_nonnull_", "x": -87.61720080383687, "y": -105.53373371399594, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.deallocation]/3", "content": "If a deallocation function is not a destroying operator delete, the type of its first parameter shall be void*.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_dealloc_template_not_usual_e1f2a3b4", "label": "cpp20_basic_stc_dynamic_dealloc_template", "x": -206.94601679492413, "y": 101.78413880291843, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.deallocation]/3", "content": "A template instance is never a usual deallocation function, regardless of its signature.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_dealloc_stdlib_null_no_effect_b5c6d7e8", "label": "cpp20_basic_stc_dynamic_dealloc_stdlib_n", "x": -225.9795465963834, "y": -54.50430778311802, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.deallocation]/4", "content": "If the first argument supplied to a standard library deallocation function is a null pointer value, the call has no effect.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_dealloc_stdlib_shall_deallocate_f9a0b1c2", "label": "cpp20_basic_stc_dynamic_dealloc_stdlib_s", "x": -206.51130180255464, "y": -77.40293696143526, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.deallocation]/5", "content": "If the argument given to a standard library deallocation function is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, ending the duration of the region of storage.", "function": ""}, {"id": "cpp20_basic_stc_dynamic_new_expression_d9e0f1a2", "label": "cpp20_basic_stc_dynamic_new_expression_d", "x": -11.206409888062227, "y": 187.71421321990175, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.dynamic.general]/1", "content": "The dynamic storage duration is associated with objects created by a new-expression or with implicitly created objects.", "function": ""}, {"id": "cpp20_basic_stc_general_pointer_use_after_duration_e5f6a7b8", "label": "cpp20_basic_stc_general_pointer_use_afte", "x": -636.1814282640752, "y": 127.5726307998773, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.general]/1", "content": "After the duration of a region of storage has ended, the use of pointers to that region of storage is limited.", "function": ""}, {"id": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4", "label": "cpp20_basic_stc_general_storage_duration", "x": 36.6489503868473, "y": 140.72288645082205, "size": 13.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.general]/1", "content": "The storage duration is the property of an object that defines the minimum potential lifetime of the storage containing the object and is one of: static, thread, automatic, or dynamic storage duration.", "function": ""}, {"id": "cpp20_basic_stc_general_subobject_duration_c9d0e1f2", "label": "cpp20_basic_stc_general_subobject_durati", "x": 76.7788689496708, "y": 46.571814056362, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.general]/4", "content": "The storage duration of subobjects and reference members is that of their complete object.", "function": ""}, {"id": "cpp20_basic_stc_static_namespace_scope_b7c8d9e0", "label": "cpp20_basic_stc_static_namespace_scope_b", "x": 90.06541809346388, "y": 173.7549744446997, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.static]/1", "content": "All variables which do not have thread storage duration and belong to a namespace scope or are first declared with the static or extern keywords have static storage duration.", "function": ""}, {"id": "cpp20_basic_stc_static_program_duration_a3b4c5d6", "label": "cpp20_basic_stc_static_program_duration_", "x": 25.336682324119984, "y": 142.42157539830058, "size": 12.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.static]/1", "content": "The storage for entities with static storage duration lasts for the duration of the program.", "function": ""}, {"id": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "label": "cpp20_basic_stc_thread_distinct_per_thre", "x": 86.7034402264708, "y": 58.944295269943176, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.thread]/1", "content": "For variables with thread storage duration, there is a distinct object or reference per thread, and use of the declared name refers to the entity associated with the current thread.", "function": ""}, {"id": "cpp20_basic_stc_thread_duration_f1a2b3c4", "label": "cpp20_basic_stc_thread_duration_f1a2b3c4", "x": 72.4025217118422, "y": 169.59263641213775, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.thread]/1", "content": "The storage for entities with thread storage duration lasts for the duration of the thread in which they are created.", "function": ""}, {"id": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "label": "cpp20_basic_stc_thread_thread_local_keyw", "x": 126.18292328210798, "y": 117.98776918358479, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[basic.stc.thread]/1", "content": "All variables declared with the thread_local keyword have thread storage duration.", "function": ""}, {"id": "cpp20_class_copy_assign_deleted_const_member_d7e9a5c1", "label": "cpp20_class_copy_assign_deleted_const_me", "x": 789.5399377681189, "y": 257.56922310691834, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.assign]/7.1", "content": "A defaulted copy/move assignment operator for class X is defined as deleted if X has a non-static data member of const non-class type (or possibly multidimensional array thereof).", "function": ""}, {"id": "cpp20_class_copy_assign_deleted_ref_member_e8a6c4f2", "label": "cpp20_class_copy_assign_deleted_ref_memb", "x": -253.83697100027297, "y": -865.0840965632664, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.assign]/7.2", "content": "A defaulted copy/move assignment operator for class X is defined as deleted if X has a non-static data member of reference type.", "function": ""}, {"id": "cpp20_class_copy_assign_deleted_member_no_usable_assign_f1b7d3e9", "label": "cpp20_class_copy_assign_deleted_member_n", "x": -464.85435783779576, "y": -453.90044830052085, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.assign]/7.3", "content": "A defaulted copy/move assignment operator for class X is defined as deleted if X has a direct non-static data member of class type M (or possibly multidimensional array thereof) or a direct base class M that cannot be copied/moved because overload resolution, as applied to find M's corresponding ass", "function": ""}, {"id": "cpp20_class_copy_ctor_deleted_subobject_no_usable_ctor_b9e5c3a7", "label": "cpp20_class_copy_ctor_deleted_subobject_", "x": 578.5350435284214, "y": 353.8840376351564, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.ctor]/10.1", "content": "A defaulted copy/move constructor for class X is defined as deleted if X has a potentially constructed subobject of type M (or possibly multidimensional array thereof) for which overload resolution, as applied to find M's corresponding constructor, either does not result in a usable candidate or, in", "function": ""}, {"id": "cpp20_class_copy_ctor_deleted_subobject_dtor_deleted_c4f2a8e6", "label": "cpp20_class_copy_ctor_deleted_subobject_", "x": 839.312752035299, "y": -44.5994239499425, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.ctor]/10.2", "content": "A defaulted copy/move constructor for class X is defined as deleted if X has any potentially constructed subobject of class type M (or possibly multidimensional array thereof) where M has a destructor that is deleted or inaccessible from the defaulted constructor.", "function": ""}, {"id": "cpp20_class_copy_ctor_deleted_rvalue_ref_member_a6d8f4b2", "label": "cpp20_class_copy_ctor_deleted_rvalue_ref", "x": -786.3159029049667, "y": 353.2109540815912, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.ctor]/10.3", "content": "A defaulted copy constructor for class X is defined as deleted if X has a non-static data member of rvalue reference type.", "function": ""}, {"id": "cpp20_class_copy_ctor_first_param_constraint_f3c7e1a9", "label": "cpp20_class_copy_ctor_first_param_constr", "x": 661.6889737397357, "y": 139.60359269143456, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.copy.ctor]/5", "content": "A declaration of a constructor for a class X is ill-formed if its first parameter is of type cv X and either there are no other parameters or else all other parameters have default arguments.", "function": ""}, {"id": "cpp20_class_ctor_general_decl_specifier_constraint_a5c9e7b1", "label": "cpp20_class_ctor_general_decl_specifier_", "x": 697.2574665428579, "y": -54.07859433450155, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.ctor.general]/1", "content": "In a constructor declaration, each decl-specifier in the optional decl-specifier-seq shall be friend, inline, constexpr, consteval, or an explicit-specifier.", "function": ""}, {"id": "cpp20_class_ctor_general_no_address_of_constructor_d4f8b2e6", "label": "cpp20_class_ctor_general_no_address_of_c", "x": 236.87016813796455, "y": -482.42486677668273, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.ctor.general]/5", "content": "The address of a constructor shall not be taken.", "function": ""}, {"id": "cpp20_class_ctor_general_no_coroutine_constructor_e7a9c3f1", "label": "cpp20_class_ctor_general_no_coroutine_co", "x": -786.5960223120337, "y": -555.1216745831715, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.ctor.general]/6", "content": "A constructor shall not be a coroutine.", "function": ""}, {"id": "cpp20_class_ctor_general_no_explicit_object_param_f2b6d8a4", "label": "cpp20_class_ctor_general_no_explicit_obj", "x": -939.5546724352521, "y": 205.22547888671016, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.ctor.general]/7", "content": "A constructor shall not have an explicit object parameter.", "function": ""}, {"id": "cpp20_class_default_ctor_deleted_ref_no_init_b8d4f2a6", "label": "cpp20_class_default_ctor_deleted_ref_no_", "x": -612.2925503863106, "y": 34.17694239567266, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.default.ctor]/2.1", "content": "A defaulted default constructor for class X is defined as deleted if any non-static data member with no default member initializer is of reference type.", "function": ""}, {"id": "cpp20_class_default_ctor_deleted_const_no_init_c7e3a9f5", "label": "cpp20_class_default_ctor_deleted_const_n", "x": 783.5937453262103, "y": -386.22541100475974, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.default.ctor]/2.2", "content": "A defaulted default constructor for non-union class X is defined as deleted if any non-variant non-static data member of const-qualified type (or possibly multidimensional array thereof) with no brace-or-equal-initializer is not const-default-constructible.", "function": ""}, {"id": "cpp20_class_default_ctor_deleted_subobject_no_usable_ctor_d9f5b1c7", "label": "cpp20_class_default_ctor_deleted_subobje", "x": -169.72169644839775, "y": 662.8715303368319, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.default.ctor]/2.3", "content": "A defaulted default constructor for class X is defined as deleted if any non-variant potentially constructed subobject (except for a non-static data member with a brace-or-equal-initializer) has class type M and overload resolution as applied to find M's corresponding constructor does not result in ", "function": ""}, {"id": "cpp20_class_default_ctor_deleted_subobject_dtor_inaccessible_e2a8c6f4", "label": "cpp20_class_default_ctor_deleted_subobje", "x": -434.8440395824916, "y": -748.9588271512109, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.default.ctor]/2.4", "content": "A defaulted default constructor for class X is defined as deleted if any potentially constructed subobject S has class type M, M has a destructor that is deleted or inaccessible from the defaulted default constructor, and either S is non-variant or S has a default member initializer.", "function": ""}, {"id": "cpp20_class_dtor_implicit_definition_order_c8a4d9e1", "label": "cpp20_class_dtor_implicit_definition_ord", "x": -58.94918319044291, "y": 57.0041264936818, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/10", "content": "Before a defaulted destructor for a class is implicitly defined, all the non-user-provided destructors for its base classes and its non-static data members are implicitly defined.", "function": ""}, {"id": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "label": "cpp20_class_dtor_member_destruction_orde", "x": -59.469348415098985, "y": 86.67486469436086, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/13", "content": "After executing the body of the destructor and destroying any objects with automatic storage duration allocated within the body, a destructor for class X calls the destructors for X's direct non-variant non-static data members other than anonymous unions, the destructors for X's non-virtual direct b", "function": ""}, {"id": "cpp20_class_dtor_qualified_call_in_body_f8c5a3b7", "label": "cpp20_class_dtor_qualified_call_in_body_", "x": -119.55125850094709, "y": 158.23934794628093, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/13", "content": "All destructor calls for bases and members during destruction are called as if they were referenced with a qualified name, ignoring any possible virtual overriding destructors in more derived classes.", "function": ""}, {"id": "cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3", "label": "cpp20_class_dtor_implicit_declaration_in", "x": -50.22602417630047, "y": 94.04119563206223, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/2", "content": "An implicitly-declared prospective destructor is an inline public member of its class.", "function": ""}, {"id": "cpp20_class_dtor_implicit_form_e6b2c8f4", "label": "cpp20_class_dtor_implicit_form_e6b2c8f4", "x": -35.856475349039535, "y": 89.19896054305713, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/3", "content": "An implicitly-declared prospective destructor for a class X will have the form ~X().", "function": ""}, {"id": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "label": "cpp20_class_dtor_deleted_union_ctor_triv", "x": -47.64225005931823, "y": -35.73120094352169, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/7.2.1", "content": "A defaulted destructor for a union X is defined as deleted if overload resolution to select a constructor to default-initialize an object of type X either fails or selects a constructor that is either deleted or not trivial.", "function": ""}, {"id": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "label": "cpp20_class_dtor_deleted_union_variant_d", "x": -77.36025206098103, "y": 35.52224030200828, "size": 7.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/7.2.2", "content": "A defaulted destructor for a union X is defined as deleted if X has a variant member V of class type M (or possibly multi-dimensional array thereof) where V has a default member initializer and M has a destructor that is non-trivial.", "function": ""}, {"id": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "label": "cpp20_class_dtor_trivial_conditions_a9d6", "x": -56.88276337158028, "y": 14.477987072651333, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/8", "content": "A destructor for a class X is trivial if it is not user-provided, the destructor is not virtual, all of the direct base classes of X have trivial destructors, and either X is a union or for all of the non-variant non-static data members of X that are of class type (or array thereof), each such class", "function": ""}, {"id": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "label": "cpp20_class_dtor_defaulted_constexpr_b3e", "x": -80.0532384817304, "y": 81.89899118119136, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.dtor]/9", "content": "A defaulted destructor is a constexpr destructor.", "function": ""}, {"id": "cpp20_class_mem_general_default_member_init_no_recursive_ctor_b7d3f1a9", "label": "cpp20_class_mem_general_default_member_i", "x": -976.7979303764241, "y": 57.72893208890749, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/15", "content": "A brace-or-equal-initializer for a non-static data member shall not directly or indirectly cause the implicit definition of a defaulted default constructor for the enclosing class or the exception specification of that constructor.", "function": ""}, {"id": "cpp20_class_mem_general_no_extern_storage_class_c5e7a9b1", "label": "cpp20_class_mem_general_no_extern_storag", "x": -160.47158033161458, "y": -718.2595621113383, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/16", "content": "A member shall not be declared with the extern storage-class-specifier.", "function": ""}, {"id": "cpp20_class_mem_general_thread_local_requires_static_d8f2b4c6", "label": "cpp20_class_mem_general_thread_local_req", "x": -778.6417170268168, "y": -295.4892380714048, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/16", "content": "Within a class definition, a member shall not be declared with the thread_local storage-class-specifier unless also declared static.", "function": ""}, {"id": "cpp20_class_mem_general_pure_specifier_requires_virtual_a7f3e9d1", "label": "cpp20_class_mem_general_pure_specifier_r", "x": 855.4545235706981, "y": -265.86082691347394, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/17", "content": "A pure-specifier shall be used only in the declaration of a virtual function that is not a friend declaration.", "function": ""}, {"id": "cpp20_class_mem_general_incomplete_member_type_constraint_b2d4f8a3", "label": "cpp20_class_mem_general_incomplete_membe", "x": 50.8358894422665, "y": 637.7647581256206, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/20", "content": "The type of a non-static data member shall not be an incomplete type, an abstract class type, or a (possibly multidimensional) array thereof.", "function": ""}, {"id": "cpp20_class_mem_general_member_name_differs_from_class_e9a3c7d5", "label": "cpp20_class_mem_general_member_name_diff", "x": -189.79241311262757, "y": 948.8748869976125, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/25", "content": "If T is the name of a class, then every static data member, member function (excluding constructors), member type, member template, and enumerator of unscoped enumeration members shall have a name different from T.", "function": ""}, {"id": "cpp20_class_mem_general_nonstatic_member_name_differs_with_ctor_f1b5d9e7", "label": "cpp20_class_mem_general_nonstatic_member", "x": 852.547828257471, "y": -357.2100393289949, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/26", "content": "If class T has a user-declared constructor, every non-static data member of class T shall have a name different from T.", "function": ""}, {"id": "cpp20_class_mem_general_union_active_member_read_ub_a2c8e4f6", "label": "cpp20_class_mem_general_union_active_mem", "x": 4.823116283910766, "y": -633.8010176262859, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/30", "content": "Reading a volatile object through a glvalue of non-volatile type has undefined behavior.", "function": ""}, {"id": "cpp20_class_mem_general_redecl_outside_class_must_be_def_c9e5a7b3", "label": "cpp20_class_mem_general_redecl_outside_c", "x": -295.4939874261699, "y": -891.7701006499404, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[class.mem.general]/9", "content": "A redeclaration of a class member outside its class definition shall be a definition, an explicit specialization, or an explicit instantiation. The member shall not be a non-static data member.", "function": ""}, {"id": "cpp20_concepts_syn_assignable_from_constraint_d9f5b7c3", "label": "cpp20_concepts_syn_assignable_from_const", "x": 552.155981939818, "y": -93.29147047855467, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The assignable_from concept requires that LHS is assignable from RHS and returns an lvalue reference to LHS", "function": ""}, {"id": "cpp20_concepts_syn_common_reference_with_symmetric_d3f8a1b7", "label": "cpp20_concepts_syn_common_reference_with", "x": -843.9743607766292, "y": -382.1211039403751, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The common_reference_with concept requires symmetry and that both types are convertible to the common reference type", "function": ""}, {"id": "cpp20_concepts_syn_common_with_symmetric_e4a9c2d8", "label": "cpp20_concepts_syn_common_with_symmetric", "x": 767.9171201416624, "y": -427.15882003048307, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The common_with concept requires symmetry and that both types are convertible to the common type", "function": ""}, {"id": "cpp20_concepts_syn_concept_requires_boolean_c2e8a0b6", "label": "cpp20_concepts_syn_concept_requires_bool", "x": -780.8631069223458, "y": -31.61683657780249, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "All concepts in the concepts library require constraint expressions that are valid boolean expressions", "function": ""}, {"id": "cpp20_concepts_syn_constructible_from_constraint_b3d9f1a7", "label": "cpp20_concepts_syn_constructible_from_co", "x": 913.4324104820199, "y": -354.4171938425593, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The constructible_from concept requires that T can be constructed from the argument types Args...", "function": ""}, {"id": "cpp20_concepts_syn_convertible_to_explicit_implicit_c9d5e7a2", "label": "cpp20_concepts_syn_convertible_to_explic", "x": 406.33305346932144, "y": 596.445548494363, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The convertible_to concept requires both implicit and explicit conversion from From to To", "function": ""}, {"id": "cpp20_concepts_syn_copy_constructible_constraint_e6a2c4d0", "label": "cpp20_concepts_syn_copy_constructible_co", "x": -566.5378801512632, "y": 481.14209375189057, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The copy_constructible concept requires that T can be constructed from lvalue and const lvalue references", "function": ""}, {"id": "cpp20_concepts_syn_copyable_constraint_e2a8c0d6", "label": "cpp20_concepts_syn_copyable_constraint_e", "x": -352.0416337811015, "y": 462.5248274434393, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The copyable concept requires that T is copy-constructible, movable, and assignable from lvalue reference", "function": ""}, {"id": "cpp20_concepts_syn_default_initializable_constraint_c4e0a2b8", "label": "cpp20_concepts_syn_default_initializable", "x": 545.3702145547829, "y": 79.78928485805872, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The default_initializable concept requires that T can be default-initialized and is destructible", "function": ""}, {"id": "cpp20_concepts_syn_derived_from_constraint_b8e4c2f6", "label": "cpp20_concepts_syn_derived_from_constrai", "x": -771.7715484487226, "y": 516.7768729450178, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The derived_from concept requires that Derived is unambiguously derived from Base", "function": ""}, {"id": "cpp20_concepts_syn_destructible_constraint_a2c8e0f6", "label": "cpp20_concepts_syn_destructible_constrai", "x": -327.36929030963904, "y": -673.3264454488651, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The destructible concept requires that T is destructible and is not an array type, reference type, or function type", "function": ""}, {"id": "cpp20_concepts_syn_equality_comparable_constraint_f7b3d5e1", "label": "cpp20_concepts_syn_equality_comparable_c", "x": -921.4882324251997, "y": 147.981237901654, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The equality_comparable concept requires that objects of type T can be compared for equality using == and !=", "function": ""}, {"id": "cpp20_concepts_syn_equality_comparable_with_symmetric_a8c4e6f2", "label": "cpp20_concepts_syn_equality_comparable_w", "x": 248.80306020240644, "y": -953.4912611525117, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The equality_comparable_with concept requires that objects of types T and U can be compared for equality and the concept is symmetric", "function": ""}, {"id": "cpp20_concepts_syn_equivalence_relation_constraint_f9b5d7e3", "label": "cpp20_concepts_syn_equivalence_relation_", "x": 31.40339940004334, "y": -707.4597721650447, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The equivalence_relation concept requires that R is a relation that is reflexive, symmetric, and transitive", "function": ""}, {"id": "cpp20_concepts_syn_floating_point_constraint_c8e4a6b2", "label": "cpp20_concepts_syn_floating_point_constr", "x": 262.21152567121385, "y": -746.2038362578252, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The floating_point concept requires that T is a floating-point type", "function": ""}, {"id": "cpp20_concepts_syn_integral_arithmetic_f5b1d3e9", "label": "cpp20_concepts_syn_integral_arithmetic_f", "x": 580.014397137579, "y": -289.92097066519943, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The integral concept requires that T is an integral type excluding bool", "function": ""}, {"id": "cpp20_concepts_syn_invocable_constraint_b5d1f3a9", "label": "cpp20_concepts_syn_invocable_constraint_", "x": 723.6298623009196, "y": -579.0293957349293, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The invocable concept requires that F can be invoked with arguments Args... using std::invoke", "function": ""}, {"id": "cpp20_concepts_syn_movable_constraint_d1f7b9c5", "label": "cpp20_concepts_syn_movable_constraint_d1", "x": -278.17358744770786, "y": -785.428547663537, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The movable concept requires that T is move-constructible, assignable from rvalue, and swappable", "function": ""}, {"id": "cpp20_concepts_syn_move_constructible_constraint_d5f1b3c9", "label": "cpp20_concepts_syn_move_constructible_co", "x": 737.1021254405122, "y": 587.8633511948377, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The move_constructible concept requires that T can be constructed from an rvalue of type T", "function": ""}, {"id": "cpp20_concepts_syn_predicate_constraint_d7f3b5c1", "label": "cpp20_concepts_syn_predicate_constraint_", "x": -603.3114559267533, "y": 380.81760006868296, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The predicate concept requires that F is a regular invocable that returns a boolean", "function": ""}, {"id": "cpp20_concepts_syn_regular_constraint_a4c0e2f8", "label": "cpp20_concepts_syn_regular_constraint_a4", "x": 748.7708720847819, "y": 125.54727918231227, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The regular concept requires that T is semiregular and equality-comparable", "function": ""}, {"id": "cpp20_concepts_syn_regular_invocable_constraint_c6e2a4b0", "label": "cpp20_concepts_syn_regular_invocable_con", "x": -20.351179233029637, "y": -931.2081183608659, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The regular_invocable concept requires that F is invocable with Args... and does not modify arguments or have observable side effects", "function": ""}, {"id": "cpp20_concepts_syn_relation_constraint_e8a4c6d2", "label": "cpp20_concepts_syn_relation_constraint_e", "x": -692.565481573845, "y": 623.1572818903888, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The relation concept requires that R is a binary predicate on types T and U", "function": ""}, {"id": "cpp20_concepts_syn_same_as_symmetric_a7f3d9e1", "label": "cpp20_concepts_syn_same_as_symmetric_a7f", "x": 831.250636567783, "y": 292.20266956313276, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The same_as concept requires symmetry: same_as<T,U> implies same_as<U,T>", "function": ""}, {"id": "cpp20_concepts_syn_semiregular_constraint_f3b9d1e7", "label": "cpp20_concepts_syn_semiregular_constrain", "x": -403.12897015594893, "y": -499.07048896609274, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The semiregular concept requires that T is copyable and default-initializable", "function": ""}, {"id": "cpp20_concepts_syn_signed_integral_constraint_a6c2e4f0", "label": "cpp20_concepts_syn_signed_integral_const", "x": 384.46031334684227, "y": 805.3674224421999, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The signed_integral concept requires that T is an integral type and is signed", "function": ""}, {"id": "cpp20_concepts_syn_strict_weak_order_constraint_a0c6e8f4", "label": "cpp20_concepts_syn_strict_weak_order_con", "x": 764.6101216923262, "y": 460.5700238625052, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The strict_weak_order concept requires that R is a relation that defines a strict weak ordering", "function": ""}, {"id": "cpp20_concepts_syn_swappable_adl_constraint_e0a6c8d4", "label": "cpp20_concepts_syn_swappable_adl_constra", "x": 239.25233011387346, "y": -852.2306052686838, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The swappable concept requires that objects of type T can be swapped using ranges::swap", "function": ""}, {"id": "cpp20_concepts_syn_swappable_with_symmetric_f1b7d9e5", "label": "cpp20_concepts_syn_swappable_with_symmet", "x": -543.8003457919775, "y": 731.8485424600382, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The swappable_with concept requires symmetry and that objects of types T and U can be swapped with each other", "function": ""}, {"id": "cpp20_concepts_syn_totally_ordered_constraint_b9d5f7a3", "label": "cpp20_concepts_syn_totally_ordered_const", "x": 171.40335150439623, "y": -968.578391595452, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The totally_ordered concept requires that objects of type T can be compared using <, >, <=, >= operators", "function": ""}, {"id": "cpp20_concepts_syn_totally_ordered_with_symmetric_c0e6a8b4", "label": "cpp20_concepts_syn_totally_ordered_with_", "x": -831.9752999748345, "y": 270.43147303579997, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The totally_ordered_with concept requires symmetric total ordering between types T and U", "function": ""}, {"id": "cpp20_concepts_syn_unsigned_integral_constraint_b7d3f5a1", "label": "cpp20_concepts_syn_unsigned_integral_con", "x": -856.2207631581153, "y": -498.82107263791255, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[concepts.syn]/18.3", "content": "The unsigned_integral concept requires that T is an integral type and is unsigned", "function": ""}, {"id": "cpp20_dcl_enum_unscoped_integral_promotion_5e8a1b4c", "label": "cpp20_dcl_enum_unscoped_integral_promoti", "x": 143.8877179039058, "y": 595.4741729734318, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/11", "content": "The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by integral promotion.", "function": ""}, {"id": "cpp20_dcl_enum_scoped_no_implicit_bool_conversion_2b9e4f7a", "label": "cpp20_dcl_enum_scoped_no_implicit_bool_c", "x": 322.66386416007816, "y": -659.0361931340959, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/11 (Example 3)", "content": "A scoped enumeration has no implicit conversion to bool.", "function": ""}, {"id": "cpp20_dcl_enum_scoped_no_implicit_int_conversion_8c3d1e6f", "label": "cpp20_dcl_enum_scoped_no_implicit_int_co", "x": 485.9174119492169, "y": -557.0605361958062, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/11 (Example 3)", "content": "A scoped enumeration has no implicit conversion to int.", "function": ""}, {"id": "cpp20_dcl_enum_unscoped_no_implicit_conversion_5f2a7b9c", "label": "cpp20_dcl_enum_unscoped_no_implicit_conv", "x": -396.3486764123812, "y": 598.5942335138069, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/11 (Example 3)", "content": "Objects of unscoped enumeration type can be assigned only values of that enumeration type (no implicit conversion from int to unscoped enum).", "function": ""}, {"id": "cpp20_dcl_enum_base_integral_type_6f8a2b3c", "label": "cpp20_dcl_enum_base_integral_type_6f8a2b", "x": 220.684010152917, "y": 783.7262932079541, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/2", "content": "The type-specifier-seq of an enum-base shall name an integral type; any cv-qualification is ignored.", "function": ""}, {"id": "cpp20_dcl_enum_scoped_must_have_name_7f3a8b2c", "label": "cpp20_dcl_enum_scoped_must_have_name_7f3", "x": 514.9697026967679, "y": 225.0849258863103, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/2", "content": "A scoped enumeration (declared with enum class or enum struct) must not omit the optional enum-head-name.", "function": ""}, {"id": "cpp20_dcl_enum_unique_enumerator_names_8a1b5c3d", "label": "cpp20_dcl_enum_unique_enumerator_names_8", "x": -800.0031335105344, "y": -223.0357795869603, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/2", "content": "The same identifier shall not appear as the name of multiple enumerators in an enumerator-list.", "function": ""}, {"id": "cpp20_dcl_enum_unscoped_opaque_needs_base_4c9d2e1f", "label": "cpp20_dcl_enum_unscoped_opaque_needs_bas", "x": -498.31505696433146, "y": -562.3048810044282, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/2", "content": "An opaque-enum-declaration declaring an unscoped enumeration shall not omit the enum-base.", "function": ""}, {"id": "cpp20_dcl_enum_scoped_redecl_same_underlying_2b7c9d4e", "label": "cpp20_dcl_enum_scoped_redecl_same_underl", "x": 954.9861682348951, "y": -168.2540073425604, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/3", "content": "A scoped enumeration shall not be later redeclared as unscoped or with a different underlying type.", "function": ""}, {"id": "cpp20_dcl_enum_unscoped_redecl_same_base_5e3f1a6b", "label": "cpp20_dcl_enum_unscoped_redecl_same_base", "x": 821.7474443966898, "y": 257.80057852957134, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/3", "content": "An unscoped enumeration shall not be later redeclared as scoped and each redeclaration shall include an enum-base specifying the same underlying type as in the original declaration.", "function": ""}, {"id": "cpp20_dcl_enum_nested_name_not_class_scope_9d2e4f1a", "label": "cpp20_dcl_enum_nested_name_not_class_sco", "x": 732.1486700271869, "y": -16.600307814956157, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/4", "content": "If an enum-head-name contains a nested-name-specifier, the enclosing enum-specifier or opaque-enum-declaration shall not inhabit a class scope.", "function": ""}, {"id": "cpp20_dcl_enum_after_closing_brace_enumerator_type_enum_7b1c4e9f", "label": "cpp20_dcl_enum_after_closing_brace_enume", "x": 496.29918671608795, "y": -159.16071329503808, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/5", "content": "Following the closing brace of an enum-specifier, each enumerator has the type of its enumeration.", "function": ""}, {"id": "cpp20_dcl_enum_fixed_enumerator_type_underlying_3f8a2c5d", "label": "cpp20_dcl_enum_fixed_enumerator_type_und", "x": -625.5200597872391, "y": 424.4351474853397, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/5", "content": "If the underlying type is fixed, the type of each enumerator prior to the closing brace is the underlying type.", "function": ""}, {"id": "cpp20_dcl_enum_fixed_underlying_converted_const_expr_3c7d9e2f", "label": "cpp20_dcl_enum_fixed_underlying_converte", "x": -285.26670621573965, "y": -934.1056934433796, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/5", "content": "If the underlying type is fixed, the constant-expression in the enumerator-definition shall be a converted constant expression of the underlying type.", "function": ""}, {"id": "cpp20_dcl_enum_scoped_default_underlying_int_9a4b7c3d", "label": "cpp20_dcl_enum_scoped_default_underlying", "x": 289.11819268685207, "y": -709.7366221992553, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/5", "content": "For a scoped enumeration type, the underlying type is int if it is not explicitly specified.", "function": ""}, {"id": "cpp20_dcl_enum_not_fixed_initializer_integral_const_expr_1a4b8c9d", "label": "cpp20_dcl_enum_not_fixed_initializer_int", "x": 686.8989304805709, "y": 664.8845227645785, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/5.1", "content": "If the underlying type is not fixed and an initializer is specified for an enumerator, the constant-expression shall be an integral constant expression.", "function": ""}, {"id": "cpp20_dcl_enum_incremented_value_no_type_ill_formed_7e2f5a8b", "label": "cpp20_dcl_enum_incremented_value_no_type", "x": 842.3095024220681, "y": -228.4212279398037, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/5.3", "content": "If no initializer is specified for an enumerator (not the first), and the incremented value is not representable in the type of the preceding enumerator, and no integral type exists sufficient to contain the incremented value, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_enum_fixed_complete_after_base_1e7f3a5c", "label": "cpp20_dcl_enum_fixed_complete_after_base", "x": -817.5243954684269, "y": 579.6234497289354, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/6", "content": "An enumeration whose underlying type is fixed is an incomplete type until immediately after its enum-base (if any), at which point it becomes a complete type.", "function": ""}, {"id": "cpp20_dcl_enum_not_fixed_complete_after_closing_brace_6d2e8f1b", "label": "cpp20_dcl_enum_not_fixed_complete_after_", "x": -96.05019581318858, "y": 939.7390904373112, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/6", "content": "An enumeration whose underlying type is not fixed is an incomplete type until the closing brace of its enum-specifier, at which point it becomes a complete type.", "function": ""}, {"id": "cpp20_dcl_enum_not_fixed_no_representable_type_ill_formed_9b3c6d2e", "label": "cpp20_dcl_enum_not_fixed_no_representabl", "x": 826.1234417652105, "y": 491.9334641566263, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/7", "content": "For an enumeration whose underlying type is not fixed, if no integral type can represent all the enumerator values, the enumeration is ill-formed.", "function": ""}, {"id": "cpp20_dcl_enum_underlying_type_size_limit_4d8e1f9a", "label": "cpp20_dcl_enum_underlying_type_size_limi", "x": -588.3259359819161, "y": -289.55768394165233, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/7", "content": "For an enumeration whose underlying type is not fixed, the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int.", "function": ""}, {"id": "cpp20_dcl_enum_same_representation_as_underlying_2d6e9f3a", "label": "cpp20_dcl_enum_same_representation_as_un", "x": 759.5350343440249, "y": -313.62174866255594, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.enum]/9", "content": "Each value of an enumeration has the same representation as the corresponding value of the underlying type.", "function": ""}, {"id": "cpp20_dcl_init_list_std_initializer_list_not_predefined_e8f7d6c5", "label": "cpp20_dcl_init_list_std_initializer_list", "x": -110.64457515913399, "y": 21.53225482809069, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/2", "content": "The template std::initializer_list is not predefined; if a standard library declaration of std::initializer_list is not reachable from a use of std::initializer_list (even an implicit use where the type is not named), the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_designated_aggregate_class_required_b4c5d6e7", "label": "cpp20_dcl_init_list_designated_aggregate", "x": -0.8824733254738905, "y": -43.78508773921189, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.1", "content": "If a braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class. Otherwise the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_designator_order_constraint_a3b4c5d6", "label": "cpp20_dcl_init_list_designator_order_con", "x": -42.550135986252705, "y": -19.79791896413935, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.1", "content": "The ordered identifiers in the designators of the designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of the aggregate class T. Violation makes the program ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5", "label": "cpp20_dcl_init_list_copy_list_init_expli", "x": -18.13460899619298, "y": -44.487387337491995, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.10", "content": "Copy-list-initialization that would select an explicit constructor is ill-formed; the binding cannot copy-list-initialize from the source type if only an explicit constructor is available.", "function": ""}, {"id": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "label": "cpp20_dcl_init_list_ref_lvalue_nonconst_", "x": 38.267291220275034, "y": -96.16995265422001, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.10", "content": "When T is a reference type and list-initialization generates a prvalue for binding, the binding fails and the program is ill-formed if T is an lvalue reference to a non-const type.", "function": ""}, {"id": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "label": "cpp20_dcl_init_list_ref_narrowing_conver", "x": 49.58271852948784, "y": -96.18232913641347, "size": 7.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.10", "content": "When T is a reference type and list-initialization involves copy-list-initialization to produce a prvalue, if a narrowing conversion is required, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7", "label": "cpp20_dcl_init_list_no_applicable_rule_a", "x": 87.8500220715093, "y": -85.07048975600738, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.12", "content": "If none of the list-initialization rules (3.1 through 3.11) apply to initialize an object or reference of type T from the initializer list, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_aggregate_narrowing_illformed_f4a5b6c7", "label": "cpp20_dcl_init_list_aggregate_narrowing_", "x": 56.5364846215079, "y": -87.49411074964918, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.4", "content": "Aggregate initialization via list-initialization is ill-formed if a narrowing conversion is required to convert any element to its corresponding member type.", "function": ""}, {"id": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "label": "cpp20_dcl_init_list_class_constructor_na", "x": -5.049871474631152, "y": -13.028066633784547, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.7", "content": "When T is a class type and constructors are considered for list-initialization, if a narrowing conversion is required to convert any of the arguments, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_enum_direct_only_c7d8e9f0", "label": "cpp20_dcl_init_list_enum_direct_only_c7d", "x": 102.32556951476693, "y": 8.185879004821937, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.8", "content": "For an enumeration with a fixed underlying type U, list-initialization from a single scalar element v that can be implicitly converted to U is only allowed via direct-list-initialization, not copy-list-initialization.", "function": ""}, {"id": "cpp20_dcl_init_list_enum_narrowing_conversion_b8c9d0e1", "label": "cpp20_dcl_init_list_enum_narrowing_conve", "x": 67.9031380408651, "y": -52.7390314566342, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.8", "content": "For direct-list-initialization of an enumeration T with a fixed underlying type U from a single scalar element v, if a narrowing conversion is required to convert v to U, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "label": "cpp20_dcl_init_list_single_element_narro", "x": 50.47144909585377, "y": -91.11149161987879, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/3.9", "content": "When the initializer list has a single element of type E and either T is not a reference type or its referenced type is reference-related to E, if a narrowing conversion is required to convert the element to T, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_evaluation_order_guarantee_c5d6e7f8", "label": "cpp20_dcl_init_list_evaluation_order_gua", "x": 111.43918673181066, "y": 8.22036548255171, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/4", "content": "Within the initializer-list of a braced-init-list, the initializer-clauses are evaluated in the order in which they appear. Every value computation and side effect of an initializer-clause is sequenced before those of any following initializer-clause.", "function": ""}, {"id": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "label": "cpp20_dcl_init_list_backing_array_narrow", "x": -60.14284431915165, "y": -51.139187275180376, "size": 7.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/5", "content": "When constructing a std::initializer_list<E> object from an initializer list, if a narrowing conversion is required to initialize any of the elements of the backing array, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "label": "cpp20_dcl_init_list_backing_array_lifeti", "x": -42.22505883190161, "y": -50.42069919545027, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/6", "content": "The backing array for std::initializer_list has the same lifetime as any other temporary object, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like binding a reference to a temporary.", "function": ""}, {"id": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "label": "cpp20_dcl_init_list_ctor_initializer_dan", "x": -55.18904739850994, "y": -45.684967162711615, "size": 7.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/6", "content": "Initializing an initializer_list member in a constructor's ctor-initializer creates a dangling reference because the backing array's lifetime is not extended, making the program ill-formed.", "function": ""}, {"id": "cpp20_dcl_init_list_narrowing_float_to_int_a9b0c1d2", "label": "cpp20_dcl_init_list_narrowing_float_to_i", "x": 101.37034379901783, "y": -82.31539045022174, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/7.1", "content": "A narrowing conversion is an implicit conversion from a floating-point type to an integer type.", "function": ""}, {"id": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3", "label": "cpp20_dcl_init_list_narrowing_float_to_l", "x": 10.359259560036154, "y": -69.26008691518298, "size": 9.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/7.2", "content": "A narrowing conversion is an implicit conversion from a floating-point type T to another floating-point type whose floating-point conversion rank is neither greater than nor equal to that of T, except where the result of the conversion is a constant expression and either its value is finite and the ", "function": ""}, {"id": "cpp20_dcl_init_list_narrowing_int_to_float_c1d2e3f4", "label": "cpp20_dcl_init_list_narrowing_int_to_flo", "x": 95.71548329440431, "y": -79.69893987671568, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/7.3", "content": "A narrowing conversion is an implicit conversion from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to", "function": ""}, {"id": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5", "label": "cpp20_dcl_init_list_narrowing_int_to_sma", "x": 24.45790762461562, "y": -69.01228593898892, "size": 9.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/7.4", "content": "A narrowing conversion is an implicit conversion from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a bit-field whose width w is less than that of its type and the target type can represent all va", "function": ""}, {"id": "cpp20_dcl_init_list_narrowing_ptr_to_bool_e3f4a5b6", "label": "cpp20_dcl_init_list_narrowing_ptr_to_boo", "x": -14.185612251162807, "y": -63.312404582355526, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.list]/7.5", "content": "A narrowing conversion is an implicit conversion from a pointer type or a pointer-to-member type to bool.", "function": ""}, {"id": "cpp20_dcl_init_ref_arg_pass_return_init_7a3b8c2d", "label": "cpp20_dcl_init_ref_arg_pass_return_init_", "x": 65.35692160538352, "y": -124.02132869807674, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/2", "content": "Argument passing and function value return are initializations.", "function": ""}, {"id": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "label": "cpp20_dcl_init_ref_assign_to_referent_e4", "x": 63.363316285192376, "y": -66.70340342585442, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/2", "content": "Assignment to a reference assigns to the object referred to by the reference, not rebinding the reference.", "function": ""}, {"id": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "label": "cpp20_dcl_init_ref_reference_compatible_", "x": 1.7519001390514661, "y": -69.73894538356551, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/4", "content": "Type \"cv1 T1\" is reference-compatible with \"cv2 T2\" if a prvalue of type \"pointer to cv2 T2\" can be converted to type \"pointer to cv1 T1\" via a standard conversion sequence.", "function": ""}, {"id": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "label": "cpp20_dcl_init_ref_reference_related_def", "x": -7.913337116937868, "y": -31.612783746290443, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/4", "content": "Type \"cv1 T1\" is reference-related to \"cv2 T2\" if T1 is similar to T2, or T1 is a base class of T2.", "function": ""}, {"id": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "label": "cpp20_dcl_init_ref_standard_conv_suppres", "x": -10.24809940363289, "y": -42.46855677859489, "size": 8.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.1", "content": "When an lvalue reference binds directly to an lvalue, the usual lvalue-to-rvalue, array-to-pointer, and function-to-pointer standard conversions are suppressed.", "function": ""}, {"id": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "label": "cpp20_dcl_init_ref_lvalue_ref_direct_bin", "x": 24.871834149039547, "y": -62.029841873479796, "size": 16.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.1.1", "content": "An lvalue reference binds directly to an lvalue initializer (not a bit-field) when cv1 T1 is reference-compatible with cv2 T2.", "function": ""}, {"id": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "label": "cpp20_dcl_init_ref_lvalue_ref_conversion", "x": 21.07195111695781, "y": -51.152139701598834, "size": 7.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.1.2", "content": "An lvalue reference to cv1 T1 can bind to a class type initializer via conversion function when T1 is not reference-related to T2 and a conversion to lvalue of reference-compatible type exists.", "function": ""}, {"id": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "label": "cpp20_dcl_init_ref_conversion_func_requi", "x": 23.097853640847543, "y": -51.73578627187759, "size": 11.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.1.2 footnote 75", "content": "When an lvalue reference binds via conversion to an lvalue from a class type, this requires a conversion function returning a reference type.", "function": ""}, {"id": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "label": "cpp20_dcl_init_ref_temp_materialization_", "x": 67.00388273889281, "y": -72.51933604152863, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.3", "content": "When binding a reference to a converted initializer that is a prvalue of type T4, temporary materialization conversion is applied with the type of the prvalue considered to be cv1 T4.", "function": ""}, {"id": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "label": "cpp20_dcl_init_ref_rvalue_or_func_lvalue", "x": 65.55192175994613, "y": -69.09578507725477, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.3.1", "content": "A reference can bind to an rvalue (not a bit-field) or an lvalue of function type when cv1 T1 is reference-compatible with cv2 T2.", "function": ""}, {"id": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "label": "cpp20_dcl_init_ref_rvalue_conversion_bin", "x": 33.20384283725141, "y": -27.861483158552925, "size": 8.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.3.2", "content": "A reference to cv1 T1 can bind to a class type initializer via conversion when T1 is not reference-related to T2 and conversion to rvalue of cv3 T3 or lvalue of function type cv3 T3 exists where cv1 T1 is reference-compatible with cv3 T3.", "function": ""}, {"id": "cpp20_dcl_init_ref_user_conv_no_second_user_conv_8e9f0a1b", "label": "cpp20_dcl_init_ref_user_conv_no_second_u", "x": 79.85179274272983, "y": -101.44301254329828, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.4.1", "content": "In direct-initialization of a reference using the result of a user-defined conversion (rule 5.4.1), user-defined conversions are not considered for the direct-initialization step.", "function": ""}, {"id": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "label": "cpp20_dcl_init_ref_implicit_conv_to_t1_4", "x": -5.728046973400816, "y": -35.677519393165575, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.4.2", "content": "When none of the prior reference binding rules apply and neither T1 nor T2 is a class type, the initializer expression is implicitly converted to a prvalue of type T1, temporary materialization is applied considering the type as cv1 T1, and the reference binds to the result.", "function": ""}, {"id": "cpp20_dcl_init_ref_not_direct_bind_definition_2c3d4e5f", "label": "cpp20_dcl_init_ref_not_direct_bind_defin", "x": 57.41252232102854, "y": -97.86693403718304, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.init.ref]/5.4.2", "content": "A reference binds directly to the initializer expression in all cases except when the initializer is implicitly converted to the referenced type (rule 5.4.2).", "function": ""}, {"id": "cpp20_dcl_spec_auto_multiple_return_same_type_a8c4f1e2", "label": "cpp20_dcl_spec_auto_multiple_return_same", "x": 907.10403123531, "y": 372.7872969630985, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/10", "content": "If a function with a declared return type containing a placeholder has multiple non-discarded return statements, the return type deduced for each shall be the same, or the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_spec_auto_exported_defined_in_tu_b7e9a2f3", "label": "cpp20_dcl_spec_auto_exported_defined_in_", "x": 157.89014462614932, "y": 548.9728134310878, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/12", "content": "An exported function with a declared return type that uses a placeholder type shall be defined in the translation unit containing its exported declaration, outside the private-module-fragment.", "function": ""}, {"id": "cpp20_dcl_spec_auto_undeduced_named_ill_formed_c3f8e1a9", "label": "cpp20_dcl_spec_auto_undeduced_named_ill_", "x": -158.61287913373627, "y": -688.8900110486959, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/13", "content": "If a variable or function with an undeduced placeholder type is named by an expression, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_spec_auto_redecl_placeholder_mismatch_d9a7e3f1", "label": "cpp20_dcl_spec_auto_redecl_placeholder_m", "x": -266.8659170554826, "y": 619.1531706656847, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/16", "content": "If a function or function template F has a declared return type that uses a placeholder type, redeclarations of F shall use that placeholder type (not a deduced type or different placeholder); otherwise, they shall not use a placeholder type.", "function": ""}, {"id": "cpp20_dcl_spec_auto_virtual_ill_formed_e1c9f4a2", "label": "cpp20_dcl_spec_auto_virtual_ill_formed_e", "x": -827.0089791711466, "y": -539.2065614132205, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/17", "content": "A function declared with a return type that uses a placeholder type shall not be virtual.", "function": ""}, {"id": "cpp20_dcl_spec_auto_coroutine_ill_formed_f8e2a7c3", "label": "cpp20_dcl_spec_auto_coroutine_ill_formed", "x": -722.0924161043102, "y": -691.9202015716993, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/18", "content": "A function declared with a return type that uses a placeholder type shall not be a coroutine.", "function": ""}, {"id": "cpp20_dcl_type_class_deduct_context_restriction_e3f7a9c1", "label": "cpp20_dcl_type_class_deduct_context_rest", "x": 744.4606300044226, "y": 375.35409081661754, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/8", "content": "A placeholder for a deduced class type shall not appear in any context other than: initializing variable declaration, new-expression, explicit type conversion, or template parameter declaration.", "function": ""}, {"id": "cpp20_dcl_spec_auto_multiple_deduction_same_type_f9e2a7c3", "label": "cpp20_dcl_spec_auto_multiple_deduction_s", "x": -23.61689106379324, "y": -850.7426931396909, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.spec.auto.general]/9", "content": "If the init-declarator-list contains more than one init-declarator using auto, the type deduced for each shall be the same, or the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_type_decltype_braced_init_return_ill_formed_a7c9e3f1", "label": "cpp20_dcl_type_decltype_braced_init_retu", "x": -63.85405235586348, "y": -514.4362668248625, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/2.1.2", "content": "For a non-discarded return statement in a function with a return type containing a placeholder, if the operand is a braced-init-list, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_type_auto_const_template_param_not_array_b8d4f3e7", "label": "cpp20_dcl_type_auto_const_template_param", "x": -756.5188709364185, "y": -99.7465828378742, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/2.4", "content": "For a constant template parameter declared with a type that contains a placeholder type, T shall not be an array type.", "function": ""}, {"id": "cpp20_dcl_spec_auto_copy_list_init_initializer_list_f1e9c4a2", "label": "cpp20_dcl_spec_auto_copy_list_init_initi", "x": -364.6140651117874, "y": 419.5467102110232, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/3", "content": "If placeholder type deduction uses copy-list-initialization, a declaration of std::initializer_list shall precede the placeholder-type-specifier.", "function": ""}, {"id": "cpp20_dcl_spec_auto_decltype_auto_const_template_param_ill_formed_a9c7e2f1", "label": "cpp20_dcl_spec_auto_decltype_auto_const_", "x": 188.9161182349623, "y": -947.0566062920371, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/3", "content": "If E is a value synthesized for a constant template parameter of type decltype(auto), the declaration is ill-formed.", "function": ""}, {"id": "cpp20_dcl_spec_auto_deduction_fails_ill_formed_b8d3e7a9", "label": "cpp20_dcl_spec_auto_deduction_fails_ill_", "x": -403.87443672866675, "y": 428.62435317898877, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/3", "content": "If placeholder type deduction fails during template argument deduction, the declaration is ill-formed.", "function": ""}, {"id": "cpp20_dcl_spec_auto_decltype_auto_alone_c9a4f2e8", "label": "cpp20_dcl_spec_auto_decltype_auto_alone_", "x": 30.694955277820515, "y": 812.7859254625026, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/4", "content": "If the placeholder-type-specifier is of the form decltype(auto), T shall be the placeholder alone.", "function": ""}, {"id": "cpp20_dcl_spec_auto_decltype_auto_braced_init_ill_formed_d7f1a3e9", "label": "cpp20_dcl_spec_auto_decltype_auto_braced", "x": 293.265953374255, "y": -748.4510188472678, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/4", "content": "For decltype(auto) placeholder type deduction, if E is a braced-init-list, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_spec_auto_decltype_auto_declarator_operator_ill_formed_e3c8a1f4", "label": "cpp20_dcl_spec_auto_decltype_auto_declar", "x": -878.7149585253152, "y": 232.58766457715333, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/4", "content": "For decltype(auto) placeholder type deduction, if declarator operators (like * or &) are present, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_spec_auto_type_constraint_satisfaction_f3e8a1c9", "label": "cpp20_dcl_spec_auto_type_constraint_sati", "x": -975.7057744518771, "y": 153.78406225737692, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.auto.deduct]/5", "content": "For a placeholder-type-specifier with a type-constraint, the immediately-declared constraint of the type-constraint for the type deduced for the placeholder shall be satisfied.", "function": ""}, {"id": "cpp20_dcl_type_class_deduct_declared_type_cv_t_a7f3e9c1", "label": "cpp20_dcl_type_class_deduct_declared_typ", "x": 900.214866809152, "y": 128.5989333972601, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.class.deduct]/1", "content": "If a placeholder for a deduced class type appears as a decl-specifier in an initializing declaration of a variable, the declared type of the variable shall be cv T, where T is the placeholder.", "function": ""}, {"id": "cpp20_dcl_type_class_deduct_no_array_ill_formed_b9d4e2a8", "label": "cpp20_dcl_type_class_deduct_no_array_ill", "x": -364.90551117260435, "y": 478.38211359382694, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.class.deduct]/1", "content": "A placeholder for a deduced class type with array declarator operators is ill-formed.", "function": ""}, {"id": "cpp20_dcl_type_class_deduct_no_ref_ill_formed_c8a3f1e7", "label": "cpp20_dcl_type_class_deduct_no_ref_ill_f", "x": -309.4050925363559, "y": 408.85457874719214, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.class.deduct]/1", "content": "A placeholder for a deduced class type with reference declarator operators is ill-formed.", "function": ""}, {"id": "cpp20_dcl_type_class_deduct_same_type_multiple_decl_d7e9a4f2", "label": "cpp20_dcl_type_class_deduct_same_type_mu", "x": 871.2011168450434, "y": -199.7390270091984, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.class.deduct]/1", "content": "If the decl-specifier-seq is followed by an init-declarator-list or member-declarator-list containing more than one declarator with deduced class type, the type that replaces the placeholder shall be the same in each deduction.", "function": ""}, {"id": "cpp20_dcl_type_cv_empty_declarator_list_f3b9c2a1", "label": "cpp20_dcl_type_cv_empty_declarator_list_", "x": 763.2226141497416, "y": 606.7519289156002, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.cv]/1", "content": "If a cv-qualifier appears in a decl-specifier-seq, the init-declarator-list or member-declarator-list of the declaration shall not be empty.", "function": ""}, {"id": "cpp20_dcl_type_cv_qualifier_once_a8f2e1d4", "label": "cpp20_dcl_type_cv_qualifier_once_a8f2e1d", "x": -510.9519389215682, "y": -766.7146193608862, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.cv]/1", "content": "Each cv-qualifier shall appear at most once in a cv-qualifier-seq.", "function": ""}, {"id": "cpp20_dcl_type_cv_modify_const_ub_d4e7a8b3", "label": "cpp20_dcl_type_cv_modify_const_ub_d4e7a8", "x": -594.6516285213602, "y": -743.840438559469, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.cv]/4", "content": "Any attempt to modify a const object during its lifetime results in undefined behavior.", "function": ""}, {"id": "cpp20_dcl_type_cv_volatile_access_impl_def_c1f8e3d2", "label": "cpp20_dcl_type_cv_volatile_access_impl_d", "x": -804.8135910464508, "y": 287.70578129078, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.cv]/5", "content": "The semantics of an access through a volatile glvalue are implementation-defined.", "function": ""}, {"id": "cpp20_dcl_type_cv_volatile_nonvolatile_access_ub_e9a2f1c4", "label": "cpp20_dcl_type_cv_volatile_nonvolatile_a", "x": -819.9967636063162, "y": -314.22449425986315, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.cv]/5", "content": "If an attempt is made to access an object defined with a volatile-qualified type through the use of a non-volatile glvalue, the behavior is undefined.", "function": ""}, {"id": "cpp20_dcl_type_decltype_no_entity_ill_formed_d8e2f9a4", "label": "cpp20_dcl_type_decltype_no_entity_ill_fo", "x": 501.0494262376577, "y": -828.6367962734253, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.decltype]/1.3", "content": "If E in decltype(E) is an unparenthesized id-expression or class member access and there is no entity named by E, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_type_elab_sole_constituent_ill_formed_f8c4a1d2", "label": "cpp20_dcl_type_elab_sole_constituent_ill", "x": 675.3673461090071, "y": -413.39363818567693, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.elab]/2", "content": "If an elaborated-type-specifier is the sole constituent of a declaration, the declaration is ill-formed unless it is an explicit specialization, a partial specialization, an explicit instantiation, or a forward declaration of a class or template.", "function": ""}, {"id": "cpp20_dcl_type_elab_no_attribute_specifier_a9e3f2c1", "label": "cpp20_dcl_type_elab_no_attribute_specifi", "x": -783.6878523588364, "y": 325.4333138769548, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.elab]/3", "content": "An elaborated-type-specifier that is not the sole constituent of a declaration shall not have an attribute-specifier-seq.", "function": ""}, {"id": "cpp20_dcl_type_elab_typedef_ill_formed_b7d9e4a2", "label": "cpp20_dcl_type_elab_typedef_ill_formed_b", "x": 200.95310356907714, "y": 832.0660647741618, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.elab]/6", "content": "If the identifier or simple-template-id in an elaborated-type-specifier resolves to a typedef-name, the elaborated-type-specifier is ill-formed.", "function": ""}, {"id": "cpp20_dcl_type_elab_keyword_mismatch_c3f8a1e9", "label": "cpp20_dcl_type_elab_keyword_mismatch_c3f", "x": 456.68540058630157, "y": 603.0809857998669, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.elab]/7", "content": "The class-key or enum keyword present in an elaborated-type-specifier shall agree in kind with the declaration to which the name refers.", "function": ""}, {"id": "cpp20_dcl_type_general_one_defining_specifier_b7d3e8a1", "label": "cpp20_dcl_type_general_one_defining_spec", "x": -396.7815876242059, "y": -672.9254809997027, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.general]/2", "content": "At most one defining-type-specifier is allowed in the complete decl-specifier-seq of a declaration or in a defining-type-specifier-seq, except for const/volatile combinations, signed/unsigned combinations, short/long/int combinations, and long double.", "function": ""}, {"id": "cpp20_dcl_type_general_one_type_specifier_f2c9a3e1", "label": "cpp20_dcl_type_general_one_type_specifie", "x": 488.7565545185378, "y": 607.2059475205558, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.general]/2", "content": "At most one type-specifier is allowed in a type-specifier-seq, except for const/volatile combinations, signed/unsigned combinations, short/long/int combinations, and long double.", "function": ""}, {"id": "cpp20_dcl_type_general_min_one_defining_specifier_a4b8c2d9", "label": "cpp20_dcl_type_general_min_one_defining_", "x": 996.2716274766698, "y": -112.20510498148246, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.general]/3", "content": "Except in a declaration of a constructor, destructor, or conversion function, at least one defining-type-specifier that is not a cv-qualifier shall appear in a complete type-specifier-seq or a complete decl-specifier-seq.", "function": ""}, {"id": "cpp20_dcl_type_pack_index_typedef_denotes_pack_e7f1a9c3", "label": "cpp20_dcl_type_pack_index_typedef_denote", "x": -208.75754606398647, "y": 646.3719417755706, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.pack.index]/1", "content": "The typedef-name P in a pack-index-specifier shall denote a pack.", "function": ""}, {"id": "cpp20_dcl_type_pack_index_constant_expr_range_d3a7e2b8", "label": "cpp20_dcl_type_pack_index_constant_expr_", "x": -225.52613731687, "y": 900.570810486273, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.pack.index]/2", "content": "The constant-expression in a pack-index-specifier shall be a converted constant expression of type std::size_t whose value V is such that 0 <= V < sizeof...(P).", "function": ""}, {"id": "cpp20_dcl_type_simple_deducible_nested_name_non_dependent_d8e3f9a1", "label": "cpp20_dcl_type_simple_deducible_nested_n", "x": 777.3582122547302, "y": -157.73354310555578, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.simple]/3", "content": "For a placeholder for deduced class type, the nested-name-specifier or splice-specifier, if any, shall be non-dependent.", "function": ""}, {"id": "cpp20_dcl_type_simple_deducible_template_constraint_e7a9c2f4", "label": "cpp20_dcl_type_simple_deducible_template", "x": 522.0095470462953, "y": 516.4729681242009, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.simple]/3", "content": "For a placeholder for deduced class type, the template-name or splice-specifier shall designate a deducible template.", "function": ""}, {"id": "cpp20_dcl_type_splice_colon_colon_not_splice_type_f9a2e8c4", "label": "cpp20_dcl_type_splice_colon_colon_not_sp", "x": -628.5169030118997, "y": 695.272146543014, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.splice]/1", "content": "A splice-specifier or splice-specialization-specifier immediately followed by :: is never interpreted as part of a splice-type-specifier.", "function": ""}, {"id": "cpp20_dcl_type_splice_no_typename_type_only_context_a8c4e1f9", "label": "cpp20_dcl_type_splice_no_typename_type_o", "x": 38.30321910806363, "y": 745.3422498787903, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.splice]/1", "content": "A splice-specifier or splice-specialization-specifier not preceded by typename is only interpreted as a splice-type-specifier within a type-only context.", "function": ""}, {"id": "cpp20_dcl_type_splice_designate_type_constraint_b7d9e3a2", "label": "cpp20_dcl_type_splice_designate_type_con", "x": -260.08349542911196, "y": 852.4334877385477, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.splice]/2", "content": "For a splice-type-specifier of the form typename-opt splice-specifier, the splice-specifier shall designate a type, a class template, or an alias template.", "function": ""}, {"id": "cpp20_dcl_type_splice_specialization_template_constraint_c9f1a7e4", "label": "cpp20_dcl_type_splice_specialization_tem", "x": -123.93223941101208, "y": -987.2949907311531, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.type.splice]/3", "content": "For a splice-type-specifier of the form typename-opt splice-specialization-specifier, the splice-specifier of the splice-specialization-specifier shall designate a template T that is either a class template or an alias template.", "function": ""}, {"id": "cpp20_dcl_typedef_combined_specifier_constraint_e7f8a9b2", "label": "cpp20_dcl_typedef_combined_specifier_con", "x": 660.8962438859694, "y": -685.8972041699785, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/1", "content": "The typedef specifier shall not be combined in a decl-specifier-seq with any other kind of specifier except a defining-type-specifier.", "function": ""}, {"id": "cpp20_dcl_typedef_function_definition_constraint_a1b2c3d4", "label": "cpp20_dcl_typedef_function_definition_co", "x": -240.6974889722114, "y": 930.0848094966032, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/1", "content": "The typedef specifier shall not be used in the decl-specifier-seq of a function-definition.", "function": ""}, {"id": "cpp20_dcl_typedef_no_declarator_constraint_f9a8b7c6", "label": "cpp20_dcl_typedef_no_declarator_constrai", "x": 929.1840645490036, "y": 127.93848569233387, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/1", "content": "If a typedef specifier appears in a declaration without a declarator, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_typedef_no_new_type_semantic_d5e6f7a8", "label": "cpp20_dcl_typedef_no_new_type_semantic_d", "x": 545.5232313606342, "y": -161.52086915696896, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/1", "content": "A typedef-name does not introduce a new type the way a class declaration or enum declaration does.", "function": ""}, {"id": "cpp20_dcl_typedef_parameter_declaration_constraint_c3d4e5f6", "label": "cpp20_dcl_typedef_parameter_declaration_", "x": -532.8526962283238, "y": -427.07085357908034, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/1", "content": "The typedef specifier shall not be used in the decl-specifier-seq of a parameter-declaration.", "function": ""}, {"id": "cpp20_dcl_typedef_alias_no_class_enum_definition_b8c9d1e2", "label": "cpp20_dcl_typedef_alias_no_class_enum_de", "x": 378.5014597411201, "y": 582.5363855063896, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/2", "content": "The defining-type-specifier-seq of the defining-type-id shall not define a class or enumeration if the alias-declaration is the declaration of a template-declaration.", "function": ""}, {"id": "cpp20_dcl_typedef_class_definition_constraint_c2d3e4f5", "label": "cpp20_dcl_typedef_class_definition_const", "x": 562.198988773092, "y": 570.0686288380753, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/3", "content": "If a typedef-name is used to identify the subject of a class definition, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_typedef_constructor_declaration_constraint_a6b7c8d9", "label": "cpp20_dcl_typedef_constructor_declaratio", "x": -847.8952687887203, "y": 56.69266707888816, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/3", "content": "If a typedef-name is used to identify the subject of a constructor declaration, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_typedef_destructor_declaration_constraint_f1a2b3c4", "label": "cpp20_dcl_typedef_destructor_declaration", "x": -907.2861056818492, "y": 118.9552340897909, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/3", "content": "If a typedef-name is used to identify the subject of a destructor declaration, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_typedef_elaborated_type_specifier_constraint_e7f8a9b1", "label": "cpp20_dcl_typedef_elaborated_type_specif", "x": -52.88947456964019, "y": 846.5625897258387, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/3", "content": "If a typedef-name is used to identify the subject of an elaborated-type-specifier, the program is ill-formed.", "function": ""}, {"id": "cpp20_dcl_typedef_simple_template_id_constraint_a3b4c5d6", "label": "cpp20_dcl_typedef_simple_template_id_con", "x": -211.6548589345078, "y": -777.4142255379014, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/3", "content": "A simple-template-id is only a typedef-name if its template-name names an alias template or a type template template parameter.", "function": ""}, {"id": "cpp20_dcl_typedef_unnamed_class_base_constraint_b5c6d7e8", "label": "cpp20_dcl_typedef_unnamed_class_base_con", "x": -707.0160615990395, "y": 425.34494730086516, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/5", "content": "An unnamed class with a typedef name for linkage purposes shall not have any base classes or default member initializers.", "function": ""}, {"id": "cpp20_dcl_typedef_unnamed_class_lambda_constraint_a8b9c1d2", "label": "cpp20_dcl_typedef_unnamed_class_lambda_c", "x": 189.9803394577575, "y": -837.5211113239221, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/5", "content": "An unnamed class with a typedef name for linkage purposes shall not contain a lambda-expression.", "function": ""}, {"id": "cpp20_dcl_typedef_unnamed_class_member_constraint_d9e1f2a3", "label": "cpp20_dcl_typedef_unnamed_class_member_c", "x": -823.4114978149241, "y": 344.7998867170892, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/5", "content": "An unnamed class with a typedef name for linkage purposes shall not declare any members other than non-static data members, member enumerations, or member classes.", "function": ""}, {"id": "cpp20_dcl_typedef_unnamed_class_recursive_constraint_e3f4a5b6", "label": "cpp20_dcl_typedef_unnamed_class_recursiv", "x": -805.64002945988, "y": 455.27298442332756, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[dcl.typedef]/5", "content": "All member classes of an unnamed class with a typedef name for linkage purposes shall also satisfy the constraints on unnamed classes with typedef names for linkage purposes (recursively).", "function": ""}, {"id": "cpp20_except_ctor_auto_destroy_condition_b8d4e9c3", "label": "cpp20_except_ctor_auto_destroy_condition", "x": -9.609495035838055, "y": 89.1358953990486, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/2", "content": "During stack unwinding, each object with automatic storage duration is destroyed if it has been constructed, but not yet destroyed, since the try block was entered.", "function": ""}, {"id": "cpp20_except_ctor_auto_storage_destroy_order_a7c3f8b2", "label": "cpp20_except_ctor_auto_storage_destroy_o", "x": -15.760246000268593, "y": 97.5045570110026, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/2", "content": "During stack unwinding, objects with automatic storage duration are destroyed in the reverse order of the completion of their construction.", "function": ""}, {"id": "cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4", "label": "cpp20_except_ctor_return_obj_destroy_on_", "x": -77.24192020224068, "y": 131.12697509662786, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/2", "content": "If an exception is thrown during the destruction of temporaries or local variables for a return statement, the destructor for the returned object (if any) is also invoked.", "function": ""}, {"id": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "label": "cpp20_except_ctor_destroy_before_handler", "x": -39.919788709452504, "y": 54.34941872683527, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/3", "content": "Subobject destruction during exception unwinding is sequenced before entering a handler of the function-try-block of the constructor or destructor, if any.", "function": ""}, {"id": "cpp20_except_ctor_dtor_except_continue_a3c9d4b8", "label": "cpp20_except_ctor_dtor_except_continue_a", "x": -70.69365039432265, "y": 114.88504397775593, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/3", "content": "If the destructor of an object is terminated by an exception, each destructor invocation that would be performed after executing the body of the destructor and that has not yet begun execution is performed.", "function": ""}, {"id": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "label": "cpp20_except_ctor_init_except_subobj_des", "x": -40.93903803434432, "y": 55.16866318529713, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/3", "content": "If the initialization of an object other than by delegating constructor is terminated by an exception, the destructor is invoked for each of the object's subobjects that were known to be initialized and whose initialization has completed.", "function": ""}, {"id": "cpp20_except_ctor_known_init_not_anon_union_f2b8c3a7", "label": "cpp20_except_ctor_known_init_not_anon_un", "x": 110.41653159380483, "y": -58.589463710654854, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/3", "content": "A subobject is known to be initialized only if it is not an anonymous union member.", "function": ""}, {"id": "cpp20_except_ctor_ref_member_temp_lifetime_e7adb8fc", "label": "cpp20_except_ctor_ref_member_temp_lifeti", "x": 40.28162341536573, "y": 15.458199466166588, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/3", "content": "If an object being destroyed due to exception has a reference member that extends the lifetime of a temporary object, the lifetime of the reference member ends, so the lifetime of the temporary object is effectively not extended.", "function": ""}, {"id": "cpp20_except_ctor_subobj_destroy_reverse_order_e1a7b2f6", "label": "cpp20_except_ctor_subobj_destroy_reverse", "x": -12.908346644587827, "y": 35.28279543390647, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/3", "content": "When initialization is terminated by an exception, the subobjects are destroyed in the reverse order of the completion of their construction.", "function": ""}, {"id": "cpp20_except_ctor_delegating_destroy_before_handler_d6fca7eb", "label": "cpp20_except_ctor_delegating_destroy_bef", "x": -34.7374909974778, "y": 49.63481134908254, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/4", "content": "For a delegating constructor, object destruction is sequenced before entering a handler of the function-try-block of the delegating constructor, if any.", "function": ""}, {"id": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "label": "cpp20_except_ctor_delegating_dtor_invoke", "x": -55.471787635790314, "y": 47.7999023906819, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.ctor]/4", "content": "If the compound-statement of the function-body of a delegating constructor for an object exits via an exception, the object's destructor is invoked.", "function": ""}, {"id": "cpp20_except_throw_control_transfer_nearest_handler_5a7c3d9e", "label": "cpp20_except_throw_control_transfer_near", "x": -85.06830447416219, "y": 136.44899976746694, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/2", "content": "When an exception is thrown, control is transferred to the nearest handler with a matching type, where \"nearest\" means the handler whose try block was most recently entered and not yet exited.", "function": ""}, {"id": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "label": "cpp20_except_throw_exception_object_dyna", "x": -3.005946461915966, "y": 91.63125347753598, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/3", "content": "Throwing an exception initializes an object with dynamic storage duration, called the exception object.", "function": ""}, {"id": "cpp20_except_throw_destruction_ordering_d5e1c7b9", "label": "cpp20_except_throw_destruction_ordering_", "x": -47.40444046445239, "y": 52.7820623059198, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/4", "content": "Among all points of potential destruction for the exception object, there is an unspecified last one where the exception object is destroyed. All other points happen before that last one.", "function": ""}, {"id": "cpp20_except_throw_rethrow_same_object_7f3a2c8d", "label": "cpp20_except_throw_rethrow_same_object_7", "x": -68.08684974854565, "y": 133.5493740792194, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/4", "content": "If a handler exits by rethrowing, control is passed to another handler for the same exception object.", "function": ""}, {"id": "cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6", "label": "cpp20_except_throw_destruction_after_han", "x": -84.84860336644222, "y": 95.09007562985445, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/4.1", "content": "The exception object is potentially destroyed when an active handler exits by any means other than rethrowing, immediately after destruction of the exception-declaration object.", "function": ""}, {"id": "cpp20_except_throw_destruction_exception_ptr_2b7d8a3f", "label": "cpp20_except_throw_destruction_exception", "x": -95.64202094925773, "y": 103.697139949296, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/4.2", "content": "The exception object is potentially destroyed when an object of type std::exception_ptr that refers to the exception object is destroyed, before the destructor of std::exception_ptr returns.", "function": ""}, {"id": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "label": "cpp20_except_throw_uncaught_after_init_b", "x": -26.861115116629918, "y": 67.26379335349218, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/6", "content": "An exception is considered uncaught after completing the initialization of the exception object until completing the activation of a handler for the exception.", "function": ""}, {"id": "cpp20_except_throw_rethrow_uncaught_until_caught_9d4f3a2c", "label": "cpp20_except_throw_rethrow_uncaught_unti", "x": -80.70068751561364, "y": 138.0344943769391, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/7", "content": "If an exception is rethrown, it is considered uncaught from the point of rethrow until the rethrown exception is caught.", "function": ""}, {"id": "cpp20_except_throw_active_handler_still_uncaught_if_rethrown_3b5c9d1a", "label": "cpp20_except_throw_active_handler_still_", "x": -71.69575999505744, "y": 139.67185112954317, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/8", "content": "An exception can have active handlers and still be considered uncaught if it is rethrown.", "function": ""}, {"id": "cpp20_except_throw_caught_when_handler_active_6e2a8b7d", "label": "cpp20_except_throw_caught_when_handler_a", "x": -43.49340436215462, "y": 165.68476837230563, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[except.throw]/8", "content": "An exception is considered caught when a handler for that exception becomes active.", "function": ""}, {"id": "cpp20_expr_alignof_complete_object_type_8be2f560", "label": "cpp20_expr_alignof_complete_object_type_", "x": -42.24645331426986, "y": -55.58774764695672, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.alignof]/1", "content": "The operand of alignof shall be a type-id representing a complete object type, or an array thereof, or a reference to one of those types.", "function": ""}, {"id": "cpp20_expr_await_context_697a793e", "label": "cpp20_expr_await_context_697a793e", "x": -158.30166780392503, "y": 533.4577232512266, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.await]/2", "content": "An await-expression shall appear only as a potentially-evaluated expression within the compound-statement of a function-body or lambda-expression, outside of a handler.", "function": ""}, {"id": "cpp20_expr_await_contract_assertion_e1f5b5b6", "label": "cpp20_expr_await_contract_assertion_e1f5", "x": 138.32422141486785, "y": 884.1799251595301, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.await]/2", "content": "An await-expression shall not be a potentially-evaluated subexpression of the predicate of a contract assertion.", "function": ""}, {"id": "cpp20_expr_await_default_argument_7a8b8a4f", "label": "cpp20_expr_await_default_argument_7a8b8a", "x": -872.3481273994898, "y": -333.17993477300416, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.await]/2", "content": "An await-expression shall not appear in a default argument.", "function": ""}, {"id": "cpp20_expr_await_static_storage_8b9c9b50", "label": "cpp20_expr_await_static_storage_8b9c9b50", "x": 57.81927976632336, "y": 96.74500620825228, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.await]/2", "content": "An await-expression shall not appear in the initializer of a block variable with static or thread storage duration.", "function": ""}, {"id": "cpp20_expr_await_suspend_type_9cad0c61", "label": "cpp20_expr_await_suspend_type_9cad0c61", "x": 45.15598432580131, "y": -39.931195649113214, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.await]/3.7", "content": "The await-suspend expression shall be a prvalue of type void, bool, or std::coroutine_handle<Z> for some type Z.", "function": ""}, {"id": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "label": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "x": 86.13959581790122, "y": -27.285691251895354, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/1", "content": "The result of a cast expression is an lvalue if T is an lvalue reference type or an rvalue reference to function type.", "function": ""}, {"id": "cpp20_expr_cast_prvalue_result_e1a4b7f6", "label": "cpp20_expr_cast_prvalue_result_e1a4b7f6", "x": 3.952642481842779, "y": -58.28433467516488, "size": 12.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/1", "content": "The result of a cast expression is a prvalue if T is not a reference type.", "function": ""}, {"id": "cpp20_expr_cast_result_type_a7c3f2b1", "label": "cpp20_expr_cast_result_type_a7c3f2b1", "x": 128.49514403166154, "y": -880.4100270388888, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/1", "content": "The result of the expression (T)cast-expression is of type T.", "function": ""}, {"id": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "label": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "x": 100.99711283868284, "y": -33.18019208640254, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/1", "content": "The result of a cast expression is an xvalue if T is an rvalue reference to object type.", "function": ""}, {"id": "cpp20_expr_cast_unlisted_illformed_c3d7e2a5", "label": "cpp20_expr_cast_unlisted_illformed_c3d7e", "x": 163.36225098759869, "y": 32.75301489878083, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/3", "content": "Any type conversion not mentioned in the cast notation rules and not explicitly defined by the user is ill-formed.", "function": ""}, {"id": "cpp20_expr_cast_ambiguous_base_illformed_e2c8f1a6", "label": "cpp20_expr_cast_ambiguous_base_illformed", "x": -237.0000107066404, "y": -50.92480396554658, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4", "content": "A cast from derived pointer to ambiguous base pointer using cast notation is ill-formed.", "function": ""}, {"id": "cpp20_expr_cast_interpretation_order_f8b2c4d1", "label": "cpp20_expr_cast_interpretation_order_f8b", "x": 352.83998235044436, "y": -719.1042081195433, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4", "content": "If a cast can be interpreted in more than one way (const_cast, static_cast, static_cast+const_cast, reinterpret_cast, reinterpret_cast+const_cast), the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed.", "function": ""}, {"id": "cpp20_expr_cast_static_const_ambiguous_illformed_a5c9d3e7", "label": "cpp20_expr_cast_static_const_ambiguous_i", "x": 147.78748911182248, "y": 44.236283978504915, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4", "content": "If a static_cast followed by a const_cast is used and the conversion can be interpreted in more than one way as such, the conversion is ill-formed.", "function": ""}, {"id": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "label": "cpp20_expr_cast_inaccessible_base_derive", "x": -75.37052913775929, "y": 3.4807024205790986, "size": 9.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4.6", "content": "A pointer to an object of derived class type may be explicitly converted to a pointer to an unambiguous base class type using cast notation, even if the base class is inaccessible.", "function": ""}, {"id": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "label": "cpp20_expr_cast_inaccessible_base_derive", "x": 0.9240474093327323, "y": -15.692435336466513, "size": 9.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4.6", "content": "An lvalue or rvalue of derived class type may be explicitly converted to a reference to an unambiguous base class type using cast notation, even if the base class is inaccessible.", "function": ""}, {"id": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "label": "cpp20_expr_cast_inaccessible_base_ptrmem", "x": -77.82996969850888, "y": 7.388518574952547, "size": 9.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4.7", "content": "A pointer to member of derived class type may be explicitly converted to a pointer to member of an unambiguous non-virtual base class type using cast notation, even if the base class is inaccessible.", "function": ""}, {"id": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "label": "cpp20_expr_cast_base_to_derived_ptr_e4b8", "x": -93.19190281318329, "y": 4.541535076826283, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4.8", "content": "A pointer to an object of an unambiguous non-virtual base class type may be explicitly converted to a pointer to a derived class type using cast notation, even if the base class is inaccessible.", "function": ""}, {"id": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "label": "cpp20_expr_cast_base_to_derived_ptrmem_a", "x": -79.10067512103795, "y": -19.378594485146206, "size": 10.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4.8", "content": "A pointer to member of an unambiguous non-virtual base class type may be explicitly converted to a pointer to member of a derived class type using cast notation, even if the base class is inaccessible.", "function": ""}, {"id": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "label": "cpp20_expr_cast_base_to_derived_ref_f1c7", "x": -27.16095537891673, "y": -7.135606854207351, "size": 8.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/4.8", "content": "A glvalue of an unambiguous non-virtual base class type may be explicitly converted to a reference to a derived class type using cast notation, even if the base class is inaccessible.", "function": ""}, {"id": "cpp20_expr_cast_incomplete_class_ptr_dest_c6e9d2a3", "label": "cpp20_expr_cast_incomplete_class_ptr_des", "x": -112.19760098862623, "y": 3.3838291372441494, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/5", "content": "The destination type of a cast using the cast notation can be \"pointer to incomplete class type\".", "function": ""}, {"id": "cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1", "label": "cpp20_expr_cast_incomplete_class_ptr_ope", "x": -46.46048371207705, "y": -44.92591681095806, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/5", "content": "The operand of a cast using the cast notation can be a prvalue of type \"pointer to incomplete class type\".", "function": ""}, {"id": "cpp20_expr_cast_incomplete_unspecified_d8a4b5e7", "label": "cpp20_expr_cast_incomplete_unspecified_d", "x": -15.178324299416344, "y": 18.25152877282554, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.cast]/5", "content": "If both the operand and destination types of a cast are class types and one or both are incomplete, it is unspecified whether the static_cast or the reinterpret_cast interpretation is used, even if there is an inheritance relationship between the two classes.", "function": ""}, {"id": "cpp20_expr_context_unevaluated_operand_e1f4c7a9", "label": "cpp20_expr_context_unevaluated_operand_e", "x": -188.06777384058145, "y": -626.4049066760678, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.context]/1", "content": "An unevaluated operand is not evaluated and is considered a full-expression.", "function": ""}, {"id": "cpp20_expr_context_discarded_no_arr_func_conv_f2a5d8b1", "label": "cpp20_expr_context_discarded_no_arr_func", "x": -165.51977128871548, "y": -20.70183378553788, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.context]/2", "content": "In a discarded-value expression context, the array-to-pointer and function-to-pointer standard conversions are not applied.", "function": ""}, {"id": "cpp20_expr_context_discarded_result_discard_i5d8g1e4", "label": "cpp20_expr_context_discarded_result_disc", "x": 428.95585723398847, "y": 898.5774279567323, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.context]/2", "content": "In a discarded-value expression, the expression is evaluated and its result (if any) is discarded.", "function": ""}, {"id": "cpp20_expr_context_discarded_temp_materialization_h4c7f0d3", "label": "cpp20_expr_context_discarded_temp_materi", "x": 72.77882501815142, "y": -21.08341677658499, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.context]/2", "content": "In a discarded-value expression, the temporary materialization conversion is applied if the (possibly converted) expression is a prvalue of object type.", "function": ""}, {"id": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "label": "cpp20_expr_context_discarded_volatile_lv", "x": -14.499152213102418, "y": -30.942940386488402, "size": 8.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.context]/2", "content": "In a discarded-value expression, the lvalue-to-rvalue conversion is applied if and only if the expression is a glvalue of volatile-qualified type and is one of the specified expression forms (parenthesized expression, id-expression, splice-expression, subscripting, class member access, indirection, ", "function": ""}, {"id": "cpp20_expr_delete_operand_class_conversion_8a9b0c1d", "label": "cpp20_expr_delete_operand_class_conversi", "x": 698.1744434526753, "y": -431.779539620481, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/1", "content": "If the operand of a delete-expression is of class type, it is contextually implicitly converted to a pointer to object type.", "function": ""}, {"id": "cpp20_expr_delete_operand_prvalue_pointer_2e3f4a5b", "label": "cpp20_expr_delete_operand_prvalue_pointe", "x": -27.173266827398564, "y": -816.309026320867, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/1", "content": "If the operand of a delete-expression is not of class type, it shall be a prvalue of pointer to object type.", "function": ""}, {"id": "cpp20_expr_delete_result_type_void_1e2f3a4b", "label": "cpp20_expr_delete_result_type_void_1e2f3", "x": 947.0910911200741, "y": 210.86291142908365, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/1", "content": "The delete-expression has type void.", "function": ""}, {"id": "cpp20_expr_delete_replaceable_dealloc_mismatch_4f5a6b7c", "label": "cpp20_expr_delete_replaceable_dealloc_mi", "x": -602.4404779971005, "y": 414.0381994925609, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/10", "content": "If a delete-expression results in a call to a replaceable deallocation function, and either the first argument was not the result of a prior call to a replaceable allocation function or the second or third argument was not the corresponding argument in said call, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_delete_array_nonallocating_placement_1a2b3c4d", "label": "cpp20_expr_delete_array_nonallocating_pl", "x": 385.5675532435805, "y": -459.27827124863774, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/2", "content": "In an array delete expression, the pointer value must not have resulted from a previous array new-expression whose allocation function was a non-allocating form, otherwise the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_delete_array_valid_pointer_142b24f9", "label": "cpp20_expr_delete_array_valid_pointer_14", "x": -148.23057616642095, "y": -0.8036885643701493, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/2", "content": "In an array delete expression, the value of the operand of delete may be a null pointer value or a pointer value that resulted from a previous array new-expression whose allocation function was not a non-allocating form. If not, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_delete_single_valid_pointer_031a13e8", "label": "cpp20_expr_delete_single_valid_pointer_0", "x": -99.07227642274005, "y": -4.612410571311832, "size": 7.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/2", "content": "In a single-object delete expression, the value of the operand of delete may be a null pointer value, a pointer value that resulted from a previous non-array new-expression, or a pointer to a base class subobject of an object created by such a new-expression. If not, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_delete_syntax_match_type_5c6d7e8f", "label": "cpp20_expr_delete_syntax_match_type_5c6d", "x": 57.63569247370559, "y": 805.7160967801295, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/2", "content": "The syntax of the delete-expression must match the type of the object allocated by new, not the syntax of the new-expression. Using single-object delete on array or array delete on single object is undefined behavior.", "function": ""}, {"id": "cpp20_expr_delete_array_dynamic_type_mismatch_7c8f2a1b", "label": "cpp20_expr_delete_array_dynamic_type_mis", "x": 402.440782466969, "y": 339.08856834493, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/3", "content": "In an array delete expression, if the dynamic type of the object to be deleted is not similar to its static type, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_delete_array_type_mismatch_364d460b", "label": "cpp20_expr_delete_array_type_mismatch_36", "x": -157.8386342760681, "y": -54.298945433857874, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/3", "content": "In an array delete expression, if the dynamic type of the object to be deleted is not similar to its static type, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_delete_virtual_destructor_253c350a", "label": "cpp20_expr_delete_virtual_destructor_253", "x": -86.5386248567515, "y": -3.089949926243696, "size": 9.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/3", "content": "In a single-object delete expression, if the static type of the object to be deleted is not similar to its dynamic type and the selected deallocation function is not a destroying operator delete, the static type shall be a base class of the dynamic type and shall have a virtual destructor or the beh", "function": ""}, {"id": "cpp20_expr_delete_incomplete_class_475e571c", "label": "cpp20_expr_delete_incomplete_class_475e5", "x": -10.938297021906838, "y": 34.11647187404987, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/4", "content": "If the object being deleted has incomplete class type at the point of deletion, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_delete_incomplete_type_illformed_3d4e5f6a", "label": "cpp20_expr_delete_incomplete_type_illfor", "x": 451.5468642537586, "y": -619.9103644863794, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/4", "content": "If the object being deleted has incomplete class type at the point of deletion, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_delete_array_elements_reverse_order_9a0b1c2d", "label": "cpp20_expr_delete_array_elements_reverse", "x": -547.790391043424, "y": -803.3332926201477, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/5", "content": "When deleting an array, the elements are destroyed in order of decreasing address, which is reverse order of the completion of their constructor.", "function": ""}, {"id": "cpp20_expr_delete_destructor_accessible_586f682d", "label": "cpp20_expr_delete_destructor_accessible_", "x": -98.20709286163148, "y": 177.2172312590867, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/5", "content": "When a delete-expression invokes the destructor, the destructor shall be accessible from the point where the delete-expression appears.", "function": ""}, {"id": "cpp20_expr_delete_dealloc_called_despite_exception_7f8a9b0c", "label": "cpp20_expr_delete_dealloc_called_despite", "x": -480.8070448981809, "y": -312.7133029299826, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/6", "content": "The deallocation function is called regardless of whether the destructor for the object or some element of the array throws an exception.", "function": ""}, {"id": "cpp20_expr_delete_null_dealloc_unspecified_3e4f5a6b", "label": "cpp20_expr_delete_null_dealloc_unspecifi", "x": 808.600947313171, "y": -284.38979729006564, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/6", "content": "If the value of the operand of the delete-expression is a null pointer value, it is unspecified whether a deallocation function will be called.", "function": ""}, {"id": "cpp20_expr_delete_virtual_dtor_dealloc_selection_5f6a7b8c", "label": "cpp20_expr_delete_virtual_dtor_dealloc_s", "x": 32.90789866576234, "y": 720.6795798503525, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/8.1", "content": "For a single-object delete expression, if the operand is a pointer to cv T and T has a virtual destructor, the deallocation function is the one selected at the point of definition of the dynamic type's virtual destructor.", "function": ""}, {"id": "cpp20_expr_delete_dealloc_accessible_6b7c8d9e", "label": "cpp20_expr_delete_dealloc_accessible_6b7", "x": -310.65163667425145, "y": 484.5181343925266, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9", "content": "Unless the deallocation function is selected at the point of definition of the dynamic type's virtual destructor, the selected deallocation function shall be accessible from the point where the delete-expression appears.", "function": ""}, {"id": "cpp20_expr_delete_dealloc_accessible_d0e4a4a5", "label": "cpp20_expr_delete_dealloc_accessible_d0e", "x": -102.02717642179027, "y": 193.00927693807625, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9", "content": "Unless the deallocation function is selected at the point of definition of the dynamic type's virtual destructor, the selected deallocation function shall be accessible from the point where the delete-expression appears.", "function": ""}, {"id": "cpp20_expr_delete_destroying_delete_priority_5b6c7d8e", "label": "cpp20_expr_delete_destroying_delete_prio", "x": -528.6728361721455, "y": 761.7189404711987, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9.1", "content": "When selecting a deallocation function, if any of the deallocation functions is a destroying operator delete, all deallocation functions that are not destroying operator deletes are eliminated from further consideration.", "function": ""}, {"id": "cpp20_expr_delete_align_val_t_preference_9e0f1a2b", "label": "cpp20_expr_delete_align_val_t_preference", "x": -13.812718980823394, "y": -688.2050962105752, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9.2", "content": "When selecting a deallocation function for a type with new-extended alignment, a function with a parameter of type std::align_val_t is preferred; otherwise a function without such a parameter is preferred.", "function": ""}, {"id": "cpp20_expr_delete_class_scope_no_size_param_3c4d5e6f", "label": "cpp20_expr_delete_class_scope_no_size_pa", "x": -63.476238832927535, "y": 955.0863972398806, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9.4", "content": "When selecting a deallocation function and the deallocation functions belong to a class scope, the one without a parameter of type std::size_t is selected.", "function": ""}, {"id": "cpp20_expr_delete_array_nontrivial_dtor_sized_7a8b9c0d", "label": "cpp20_expr_delete_array_nontrivial_dtor_", "x": -48.76812289465072, "y": -609.4503390800859, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9.5", "content": "For an array delete expression on a complete type, if the operand is a pointer to a class type with a non-trivial destructor or array thereof, the deallocation function with a parameter of type std::size_t is selected.", "function": ""}, {"id": "cpp20_expr_delete_size_dealloc_unspecified_1d2e3f4a", "label": "cpp20_expr_delete_size_dealloc_unspecifi", "x": 299.8959224643488, "y": -637.9977136554988, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.delete]/9.6", "content": "When selecting a deallocation function and the type is incomplete or does not meet the criteria for requiring a sized deallocation, it is unspecified whether a deallocation function with a parameter of type std::size_t is selected.", "function": ""}, {"id": "cpp20_expr_eq_array_to_pointer_conversion_h8d5f3a1", "label": "cpp20_expr_eq_array_to_pointer_conversio", "x": -89.70308734570234, "y": -47.36454559294982, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/1", "content": "If one of the operands is a pointer or a null pointer constant, the array-to-pointer conversion is performed on the other operand.", "function": ""}, {"id": "cpp20_expr_eq_lvalue_to_rvalue_conversion_g4c2e9f7", "label": "cpp20_expr_eq_lvalue_to_rvalue_conversio", "x": 29.902008619068983, "y": -30.517082595610365, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/1", "content": "The lvalue-to-rvalue and function-to-pointer standard conversions are performed on the operands of equality operators.", "function": ""}, {"id": "cpp20_expr_eq_result_type_bool_a8c4f2d1", "label": "cpp20_expr_eq_result_type_bool_a8c4f2d1", "x": -777.096502668486, "y": 227.74215611353657, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/2", "content": "The equality operators == and != yield true or false, i.e., a result of type bool.", "function": ""}, {"id": "cpp20_expr_eq_ptr_otherwise_unequal_b3e7c9a2", "label": "cpp20_expr_eq_ptr_otherwise_unequal_b3e7", "x": -706.683026828435, "y": -299.90683470497845, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/3.3", "content": "Pointers that are not both null, do not both point to the same function, and do not both represent the same address compare unequal.", "function": ""}, {"id": "cpp20_expr_eq_ptm_same_member_equal_c5d8f1a3", "label": "cpp20_expr_eq_ptm_same_member_equal_c5d8", "x": -16.121188332803946, "y": 41.91647488304116, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/4.6", "content": "Two pointers to members compare equal if they would refer to the same member of the same most derived object or the same subobject if indirection with a hypothetical object of the associated class type were performed, otherwise they compare unequal.", "function": ""}, {"id": "cpp20_expr_eq_meta_info_otherwise_unequal_i9e6g4b2", "label": "cpp20_expr_eq_meta_info_otherwise_unequa", "x": 342.8401451939947, "y": -635.6149851604125, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/6", "content": "Two operands of type std::meta::info that do not satisfy any of the equality conditions compare unequal.", "function": ""}, {"id": "cpp20_expr_eq_equal_yields_true_e7b3c1d9", "label": "cpp20_expr_eq_equal_yields_true_e7b3c1d9", "x": -38.14454162090028, "y": -202.33094327083836, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/7", "content": "If two operands compare equal, the result is true for the == operator and false for the != operator.", "function": ""}, {"id": "cpp20_expr_eq_unequal_yields_false_f1a5d8c2", "label": "cpp20_expr_eq_unequal_yields_false_f1a5d", "x": -61.9893360433378, "y": -184.4295951894112, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/7", "content": "If two operands compare unequal, the result is false for the == operator and true for the != operator.", "function": ""}, {"id": "cpp20_expr_eq_arithmetic_enum_semantics_d2f4a6b8", "label": "cpp20_expr_eq_arithmetic_enum_semantics_", "x": -567.9938031385537, "y": -706.5863562943617, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.eq]/8", "content": "If both operands are of arithmetic or enumeration type, the usual arithmetic conversions are performed on both operands; each of the operators shall yield true if the specified relationship is true and false if it is false.", "function": ""}, {"id": "cpp20_expr_new_complete_object_type_3a7c8e12", "label": "cpp20_expr_new_complete_object_type_3a7c", "x": -802.2677746495568, "y": -17.0836548771233, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/1", "content": "The allocated type in a new-expression shall be a complete object type, but not an abstract class type or array thereof.", "function": ""}, {"id": "cpp20_expr_new_complete_object_type_9cf3a671", "label": "cpp20_expr_new_complete_object_type_9cf3", "x": -121.6943268047851, "y": 9.276378392052365, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/1", "content": "The allocated type in a new-expression shall be a complete object type, but not an abstract class type or array thereof.", "function": ""}, {"id": "cpp20_expr_new_no_references_f8b2d4a1", "label": "cpp20_expr_new_no_references_f8b2d4a1", "x": 48.89292729943374, "y": 616.7543604205463, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/1", "content": "References cannot be created by new-expressions because references are not objects.", "function": ""}, {"id": "cpp20_expr_new_dynamic_storage_duration_8e2a7f4c", "label": "cpp20_expr_new_dynamic_storage_duration_", "x": -863.5603257799252, "y": 434.5914314946228, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/10", "content": "Objects created by a new-expression have dynamic storage duration.", "function": ""}, {"id": "cpp20_expr_new_array_result_type_pointer_to_element_c8f2a5d9", "label": "cpp20_expr_new_array_result_type_pointer", "x": 192.5189274080644, "y": -868.2223330029552, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/11", "content": "When the allocated type is array of N T, the new-expression yields a prvalue of type pointer to T pointing to the initial element.", "function": ""}, {"id": "cpp20_expr_new_nonarray_result_type_pointer_to_object_2e9a7b4f", "label": "cpp20_expr_new_nonarray_result_type_poin", "x": 584.6083524875778, "y": 721.2077089961205, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/11", "content": "For non-array allocated types, the new-expression is a prvalue of type pointer to T that points to the created object.", "function": ""}, {"id": "cpp20_expr_new_char_array_alignment_overhead_f2a6b8d4", "label": "cpp20_expr_new_char_array_alignment_over", "x": -795.0951931448503, "y": -417.11677031657297, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/17", "content": "For arrays of char, unsigned char, and std::byte, the difference between the new-expression result and the allocation function return value shall be an integral multiple of the strictest fundamental alignment requirement of any object type whose size is no greater than the array size.", "function": ""}, {"id": "cpp20_expr_new_size_arg_greater_only_for_array_c3f7a9e2", "label": "cpp20_expr_new_size_arg_greater_only_for", "x": 635.3530931396571, "y": 481.6108161782288, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/17", "content": "The size argument to allocation function may only be greater than the object size if the object is an array and the allocation function is not a non-allocating form.", "function": ""}, {"id": "cpp20_expr_new_size_arg_minimum_b8d4e1a7", "label": "cpp20_expr_new_size_arg_minimum_b8d4e1a7", "x": -635.0563096830142, "y": -519.9895968287075, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/17", "content": "The size argument passed to the allocation function shall be no less than the size of the object being created.", "function": ""}, {"id": "cpp20_expr_new_extended_allocation_size_limit_3b8f1d6e", "label": "cpp20_expr_new_extended_allocation_size_", "x": -557.4184033154459, "y": -56.50608669799867, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/18", "content": "When allocation is extended, the size argument shall be no greater than the sum of the sizes for the omitted calls plus the extended call size plus any necessary alignment padding.", "function": ""}, {"id": "cpp20_expr_new_nonallocating_null_ub_d4a8c2f1", "label": "cpp20_expr_new_nonallocating_null_ub_d4a", "x": 410.54588625603645, "y": -429.79268276470475, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/22", "content": "If a non-allocating form of allocation function returns null, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_new_null_return_no_init_no_dealloc_4d8c2e5a", "label": "cpp20_expr_new_null_return_no_init_no_de", "x": -51.52398134587228, "y": 673.7649504094196, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/22", "content": "If the allocation function returns null (and is not a non-allocating form), initialization shall not be done, the deallocation function shall not be called, and the new-expression value shall be null.", "function": ""}, {"id": "cpp20_expr_new_placement_null_ub_f20902d7", "label": "cpp20_expr_new_placement_null_ub_f20902d", "x": -865.0093559132787, "y": -429.48178196031563, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/22", "content": "If the allocation function is a non-allocating form (placement new) that returns null, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_new_omitted_init_default_init_7a3f9c1e", "label": "cpp20_expr_new_omitted_init_default_init", "x": 324.4461606969008, "y": 816.0881943983195, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/24.1", "content": "If the new-initializer is omitted, the object is default-initialized.", "function": ""}, {"id": "cpp20_expr_new_with_init_direct_init_5c9d4b2a", "label": "cpp20_expr_new_with_init_direct_init_5c9", "x": 111.04768615223634, "y": 511.6748639281369, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/24.2", "content": "If a new-initializer is present, it is interpreted according to the initialization rules for direct-initialization.", "function": ""}, {"id": "cpp20_expr_new_alloc_sequenced_before_init_2c5d8a4b", "label": "cpp20_expr_new_alloc_sequenced_before_in", "x": -830.3670562440652, "y": -77.14766146827695, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/25", "content": "The invocation of the allocation function is sequenced before the evaluations of expressions in the new-initializer.", "function": ""}, {"id": "cpp20_expr_new_init_sequenced_before_value_computation_9e2a7c3f", "label": "cpp20_expr_new_init_sequenced_before_val", "x": 54.13597920295909, "y": -679.9602677535837, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/25", "content": "Initialization of the allocated object is sequenced before the value computation of the new-expression.", "function": ""}, {"id": "cpp20_expr_new_array_class_destructor_potentially_invoked_5f3c8a1d", "label": "cpp20_expr_new_array_class_destructor_po", "x": -607.5358969816921, "y": -303.1341271517988, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/26", "content": "If the new-expression creates an array of objects of class type, the destructor is potentially invoked.", "function": ""}, {"id": "cpp20_expr_new_exception_cleanup_dealloc_a7c3e9f2", "label": "cpp20_expr_new_exception_cleanup_dealloc", "x": -952.0608516438274, "y": -258.8311795611525, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/27", "content": "If object initialization terminates by throwing an exception and a suitable deallocation function can be found, the deallocation function is called to free the memory before the exception propagates.", "function": ""}, {"id": "cpp20_expr_new_no_dealloc_match_no_free_6d4b8a2e", "label": "cpp20_expr_new_no_dealloc_match_no_free_", "x": -640.1258776727287, "y": -384.49026454810934, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/27", "content": "If no unambiguous matching deallocation function can be found when initialization throws, propagating the exception does not cause the object memory to be freed.", "function": ""}, {"id": "cpp20_expr_new_dealloc_accessible_bec2e283", "label": "cpp20_expr_new_dealloc_accessible_bec2e2", "x": -618.2607334357374, "y": 660.1842925104171, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/29", "content": "The matching deallocation function for a new-expression (if any) shall be non-deleted and accessible from the point where the new-expression appears.", "function": ""}, {"id": "cpp20_expr_new_usual_dealloc_match_ill_formed_cfd3f394", "label": "cpp20_expr_new_usual_dealloc_match_ill_f", "x": 226.92875711118126, "y": 570.352061676014, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/29", "content": "If the lookup for a matching deallocation function finds a usual deallocation function that would have been selected as a match for a placement allocation function, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_new_usual_dealloc_matches_placement_illformed_e7f3b9a6", "label": "cpp20_expr_new_usual_dealloc_matches_pla", "x": 716.5953183362329, "y": -40.10865870032558, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/29", "content": "If lookup finds a usual deallocation function that would have been selected as a match for a placement allocation function, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_new_dealloc_receives_alloc_return_7a2d4e9c", "label": "cpp20_expr_new_dealloc_receives_alloc_re", "x": -833.125207878375, "y": 98.95326534297962, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/30", "content": "If a new-expression calls a deallocation function, it passes the value returned from the allocation function call as the first argument.", "function": ""}, {"id": "cpp20_expr_new_placement_dealloc_same_args_8b5c2f3a", "label": "cpp20_expr_new_placement_dealloc_same_ar", "x": 196.0370103907596, "y": 658.885836904548, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/30", "content": "If a placement deallocation function is called, it is passed the same additional arguments as were passed to the placement allocation function.", "function": ""}, {"id": "cpp20_expr_new_constant_expr_positive_adb4b782", "label": "cpp20_expr_new_constant_expr_positive_ad", "x": -67.98672497826179, "y": -808.991213943603, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/6", "content": "Every constant-expression in a noptr-new-declarator shall be a converted constant expression of type std::size_t and its value shall be greater than zero.", "function": ""}, {"id": "cpp20_expr_new_unknown_bound_initializer_bec5c893", "label": "cpp20_expr_new_unknown_bound_initializer", "x": -105.67926946362643, "y": -56.7446725001818, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/7", "content": "If the type-id or new-type-id denotes an array type of unknown bound, the new-initializer shall not be omitted.", "function": ""}, {"id": "cpp20_expr_new_negative_size_nonclass_invalid_c5f9a3d2", "label": "cpp20_expr_new_negative_size_nonclass_in", "x": 497.4629331576221, "y": 286.3562951802607, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.1", "content": "The array size expression value is invalid if the expression is of non-class type and its value before converting to std::size_t is less than zero.", "function": ""}, {"id": "cpp20_expr_new_negative_size_class_invalid_a2e7b6c4", "label": "cpp20_expr_new_negative_size_class_inval", "x": -194.26589808940085, "y": 974.661096905952, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.2", "content": "The array size expression value is invalid if the expression is of class type and its value before application of the second standard conversion is less than zero.", "function": ""}, {"id": "cpp20_expr_new_exceeds_impl_limit_invalid_8f1c4d5e", "label": "cpp20_expr_new_exceeds_impl_limit_invali", "x": 187.42548736860041, "y": -679.7062556097616, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.3", "content": "The array size expression value is invalid if it would cause the size of the allocated object to exceed the implementation-defined limit.", "function": ""}, {"id": "cpp20_expr_new_initializer_exceeds_size_invalid_6b3e9a7f", "label": "cpp20_expr_new_initializer_exceeds_size_", "x": -728.557526593893, "y": -559.539703984269, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.4", "content": "The array size expression value is invalid if the new-initializer provides more initializers than the number of array elements to initialize.", "function": ""}, {"id": "cpp20_expr_new_invalid_size_constexpr_illformed_9c3e5f7a", "label": "cpp20_expr_new_invalid_size_constexpr_il", "x": -489.1928013714176, "y": -652.9806945448348, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.5", "content": "If the array size expression in a new-expression is a potentially-evaluated core constant expression and its value is invalid, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_new_invalid_size_ill_formed_cfd6d9a4", "label": "cpp20_expr_new_invalid_size_ill_formed_c", "x": -195.47220080832608, "y": -48.33044467325335, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.5", "content": "If the value of the array size expression is invalid and is a potentially-evaluated core constant expression, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_new_invalid_size_nonthrowing_null_7d4a2b8e", "label": "cpp20_expr_new_invalid_size_nonthrowing_", "x": -506.7336338196262, "y": 739.5313467891082, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.6.1", "content": "If the array size value is invalid at runtime and the allocation function has a non-throwing exception specification, the new-expression returns the null pointer value.", "function": ""}, {"id": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "label": "cpp20_expr_new_invalid_size_nothrow_null", "x": -104.29700161807037, "y": 6.343466049636146, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.6.1", "content": "If the array size value is invalid at runtime and the allocation function has a non-throwing exception specification, the value of the new-expression is the null pointer value.", "function": ""}, {"id": "cpp20_expr_new_invalid_size_throwing_e1f8f1c6", "label": "cpp20_expr_new_invalid_size_throwing_e1f", "x": -92.16794504179816, "y": 42.42399396166029, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.new]/8.6.2", "content": "If the array size value is invalid at runtime and the allocation function has a throwing exception specification, the new-expression terminates by throwing std::bad_array_new_length.", "function": ""}, {"id": "cpp20_expr_pre_incr_not_bool_25ecf90a", "label": "cpp20_expr_pre_incr_not_bool_25ecf90a", "x": -792.0181936297921, "y": -192.00009643438494, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre.incr]/1", "content": "The operand of prefix ++ or -- shall not be of type cv bool.", "function": ""}, {"id": "cpp20_expr_pre_overloaded_operator_no_associativity_e5c9d2a1", "label": "cpp20_expr_pre_overloaded_operator_no_as", "x": 803.9471280029276, "y": 555.5154239047528, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/2", "content": "Relations between operators, such as ++a meaning a+=1, are not guaranteed for overloaded operators.", "function": ""}, {"id": "cpp20_expr_pre_builtin_conversion_before_operation_a8d7c5b2", "label": "cpp20_expr_pre_builtin_conversion_before", "x": -6.202040842577045, "y": -187.65389623266063, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/3", "content": "If a built-in operator is selected during overload resolution, user-defined conversions will be applied to the operands before the operation is considered further according to the rules in [expr.compound].", "function": ""}, {"id": "cpp20_expr_pre_overload_builtin_invariant_b2e4d519", "label": "cpp20_expr_pre_overload_builtin_invarian", "x": -109.04089787605801, "y": -123.64097523945895, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/3", "content": "Operator overloading shall not modify the rules for the built-in operators, that is, for operators applied to types for which they are defined by this Standard.", "function": ""}, {"id": "cpp20_expr_pre_result_undefined_math_range_8a3f7c21", "label": "cpp20_expr_pre_result_undefined_math_ran", "x": -200.8827668552056, "y": -286.4223499563528, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/4", "content": "If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.", "function": ""}, {"id": "cpp20_expr_pre_overloaded_not_associative_commutative_f6b2e3c4", "label": "cpp20_expr_pre_overloaded_not_associativ", "x": 196.0034522780118, "y": -624.3683414753592, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/5", "content": "Overloaded operators are never assumed to be associative or commutative for the purpose of expression regrouping.", "function": ""}, {"id": "cpp20_expr_pre_cast_assignment_conversion_required_d4a1b6f8", "label": "cpp20_expr_pre_cast_assignment_conversio", "x": -224.19127894142989, "y": -285.96610642326567, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/6", "content": "Cast and assignment operators must still perform their specific conversions even when floating-point values are represented with extended precision and range.", "function": ""}, {"id": "cpp20_expr_pre_floating_point_extended_precision_c7f8a2e3", "label": "cpp20_expr_pre_floating_point_extended_p", "x": -211.03058743557975, "y": -291.5779437575877, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.pre]/6", "content": "The values of floating-point operands and the results of floating-point expressions may be represented in greater precision and range than that required by the type; the types are not changed thereby.", "function": ""}, {"id": "cpp20_expr_prim_id_dtor_pseudo_constraint_b8c2d4e5", "label": "cpp20_expr_prim_id_dtor_pseudo_constrain", "x": -81.26283309013301, "y": 65.37430583473828, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.dtor]/2", "content": "If an id-expression names a pseudo-destructor (destructor of non-class type), T shall be a scalar type and the id-expression shall appear as the right operand of a class member access that forms the postfix-expression of a function call.", "function": ""}, {"id": "cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6", "label": "cpp20_expr_prim_id_dtor_double_destroy_u", "x": -127.38859316874118, "y": 150.37669362641702, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.dtor]/3", "content": "Destroying a temporary object twice by calling its destructor explicitly results in undefined behavior.", "function": ""}, {"id": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "label": "cpp20_expr_prim_id_transform_precond_cto", "x": -57.407135409910644, "y": 40.084030776855215, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.general]/2", "content": "If id-expression transformation to class member access occurs in a precondition assertion of a constructor or postcondition assertion of a destructor, the expression is ill-formed.", "function": ""}, {"id": "cpp20_expr_prim_id_nonstatic_member_usage_d6e0f5a7", "label": "cpp20_expr_prim_id_nonstatic_member_usag", "x": -84.98528768184586, "y": -19.244774969219467, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.general]/4", "content": "An id-expression or splice-expression designating a non-static data member or implicit object member function can only be used as part of class member access, to form pointer to member, or in unevaluated operand for non-static data members.", "function": ""}, {"id": "cpp20_expr_prim_id_base_class_splice_a7b1c2d3", "label": "cpp20_expr_prim_id_base_class_splice_a7b", "x": -42.723799237760915, "y": -10.115098855830404, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.general]/5", "content": "A splice-expression that designates a direct base class relationship shall appear only as the second operand of a class member access.", "function": ""}, {"id": "cpp20_expr_prim_overload_requires_unsatisfied_a1b5c7d8", "label": "cpp20_expr_prim_overload_requires_unsati", "x": -25.366099638047785, "y": -210.91040373756775, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.general]/6", "content": "A program cannot refer to a function with a trailing requires-clause whose constraint-expression is not satisfied, because such functions are never selected by overload resolution.", "function": ""}, {"id": "cpp20_expr_prim_qual_nested_name_declarative_b6c0d2e3", "label": "cpp20_expr_prim_qual_nested_name_declara", "x": -626.1427211467109, "y": 781.7425959143156, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.qual]/3", "content": "A declarative nested-name-specifier shall not have a computed-type-specifier or a splice-scope-specifier.", "function": ""}, {"id": "cpp20_expr_prim_qual_nested_name_computed_type_c7d1e3f4", "label": "cpp20_expr_prim_qual_nested_name_compute", "x": -11.591872987686655, "y": 37.93349685314603, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.qual]/4.2", "content": "A nested-name-specifier with a computed-type-specifier shall designate a class or enumeration type.", "function": ""}, {"id": "cpp20_expr_prim_qual_splice_class_enum_namespace_d8e2f4a5", "label": "cpp20_expr_prim_qual_splice_class_enum_n", "x": 13.649164611008777, "y": 31.29567978088787, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.qual]/4.3", "content": "For a nested-name-specifier of the form splice-specifier::, the splice-specifier shall designate a class or enumeration type or a namespace.", "function": ""}, {"id": "cpp20_expr_prim_qual_splice_specialization_class_e9f3a5b6", "label": "cpp20_expr_prim_qual_splice_specializati", "x": -113.54621188769892, "y": 84.14544549042338, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.qual]/4.4", "content": "For a nested-name-specifier of the form template-opt splice-specialization-specifier::, the splice-specifier shall designate a class template or alias template, and the specialization shall be a class template specialization or alias denoting a class or enumeration type.", "function": ""}, {"id": "cpp20_expr_prim_qual_id_dtor_computed_type_a5b9c1d2", "label": "cpp20_expr_prim_qual_id_dtor_computed_ty", "x": -221.273265585018, "y": 124.9710924630016, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.qual]/5", "content": "A qualified-id shall not be of the form nested-name-specifier template-opt ~computed-type-specifier nor of the form computed-type-specifier::~type-name.", "function": ""}, {"id": "cpp20_expr_prim_contract_var_const_lvalue_f0a4b6c7", "label": "cpp20_expr_prim_contract_var_const_lvalu", "x": 93.06922814670726, "y": -55.20500154030494, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.id.unqual]/7", "content": "Modifying a variable or reference parameter within a contract assertion predicate through const lvalue conversion is ill-formed.", "function": ""}, {"id": "cpp20_expr_prim_lambda_capture_default_ampersand_a9b3c5d6", "label": "cpp20_expr_prim_lambda_capture_default_a", "x": 497.451142521518, "y": 829.207636265307, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.capture]/2", "content": "If a lambda-capture includes a capture-default that is &, no identifier in a simple-capture shall be preceded by &.", "function": ""}, {"id": "cpp20_expr_prim_lambda_capture_default_equals_b0c4d6e7", "label": "cpp20_expr_prim_lambda_capture_default_e", "x": -764.7288131110722, "y": 392.7527780394855, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.capture]/2", "content": "If a lambda-capture includes a capture-default that is =, each simple-capture shall be \"&identifier...\", \"this\", or \"*this\".", "function": ""}, {"id": "cpp20_expr_prim_lambda_capture_unique_c1d5e7f8", "label": "cpp20_expr_prim_lambda_capture_unique_c1", "x": 92.46572263715363, "y": -142.7437759550386, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.capture]/2", "content": "An identifier or this shall not appear more than once in a lambda-capture (ignoring appearances in initializers of init-captures).", "function": ""}, {"id": "cpp20_expr_prim_lambda_capture_scope_restriction_d2e6f8a9", "label": "cpp20_expr_prim_lambda_capture_scope_res", "x": -98.48311864344898, "y": -34.54976470991815, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.capture]/3", "content": "A lambda-expression shall not have a capture-default or simple-capture unless its innermost enclosing scope is a block scope, it appears within a default member initializer, or it appears within a contract assertion.", "function": ""}, {"id": "cpp20_expr_prim_lambda_simple_capture_local_e3f7a9b0", "label": "cpp20_expr_prim_lambda_simple_capture_lo", "x": 167.16324856683238, "y": 765.137619313091, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.capture]/4", "content": "The identifier in a simple-capture shall denote a local entity.", "function": ""}, {"id": "cpp20_expr_prim_lambda_capture_shadows_param_f4a8b0c1", "label": "cpp20_expr_prim_lambda_capture_shadows_p", "x": -172.36305924544143, "y": 51.10210707934175, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.capture]/5", "content": "If an identifier in a capture appears as the declarator-id of a parameter or as the name of a template parameter of the lambda-expression, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_prim_lambda_contract_only_capture_e7f1a3b4", "label": "cpp20_expr_prim_lambda_contract_only_cap", "x": -546.4321209260527, "y": -628.0173460379889, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.closure]/10", "content": "If all potential references to a local entity implicitly captured by a lambda occur only within contract assertions or assertion-statements, the program is ill-formed.", "function": ""}, {"id": "cpp20_expr_prim_lambda_closure_member_no_explicit_f8a2b4c5", "label": "cpp20_expr_prim_lambda_closure_member_no", "x": -629.6725430113657, "y": 532.4781386920977, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.closure]/19", "content": "A member of a closure type shall not be explicitly instantiated, explicitly specialized, or named in a friend declaration.", "function": ""}, {"id": "cpp20_expr_prim_lambda_capture_explicit_object_type_d6e0f2a3", "label": "cpp20_expr_prim_lambda_capture_explicit_", "x": 9.253588604858122, "y": -16.08705651924711, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.closure]/6", "content": "For a lambda with captures, the explicit object parameter type shall be the closure type, a class derived from it, or a reference to such type.", "function": ""}, {"id": "cpp20_expr_prim_lambda_explicit_object_no_mutable_static_a3b7c9d0", "label": "cpp20_expr_prim_lambda_explicit_object_n", "x": -219.3880049345859, "y": 812.1913865085219, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.general]/4", "content": "If the lambda-declarator contains an explicit object parameter, no lambda-specifier shall be mutable or static.", "function": ""}, {"id": "cpp20_expr_prim_lambda_mutable_static_exclusive_b4c8d0e1", "label": "cpp20_expr_prim_lambda_mutable_static_ex", "x": -148.92612515955403, "y": 749.0575572058231, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.general]/4", "content": "The lambda-specifier-seq shall not contain both mutable and static.", "function": ""}, {"id": "cpp20_expr_prim_lambda_specifier_unique_f2a6b8c9", "label": "cpp20_expr_prim_lambda_specifier_unique_", "x": -173.05449884433747, "y": -547.7439302540773, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.general]/4", "content": "A lambda-specifier-seq shall contain at most one of each lambda-specifier and shall not contain both constexpr and consteval.", "function": ""}, {"id": "cpp20_expr_prim_lambda_static_no_capture_c5d9e1f2", "label": "cpp20_expr_prim_lambda_static_no_capture", "x": -62.73830832434684, "y": -645.4873815780024, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.lambda.general]/4", "content": "If the lambda-specifier-seq contains static, there shall be no lambda-capture.", "function": ""}, {"id": "cpp20_expr_prim_pack_index_denotes_pack_d0e4f6a7", "label": "cpp20_expr_prim_pack_index_denotes_pack_", "x": 680.0503935128024, "y": -34.717556643693676, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.pack.index]/1", "content": "The id-expression P in a pack-index-expression shall be an identifier that denotes a pack.", "function": ""}, {"id": "cpp20_expr_prim_pack_index_bounds_e1f5a7b8", "label": "cpp20_expr_prim_pack_index_bounds_e1f5a7", "x": -400.88229818274806, "y": 810.4755076963487, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.pack.index]/2", "content": "The index V in a pack-index-expression shall satisfy 0 <= V < sizeof...(P) where P is the pack.", "function": ""}, {"id": "cpp20_expr_prim_req_general_prvalue_bool_a1c2e3f4", "label": "cpp20_expr_prim_req_general_prvalue_bool", "x": -19.393845619121073, "y": -55.2105554883998, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.req.general]/2", "content": "A requires-expression is a prvalue of type bool.", "function": ""}, {"id": "cpp20_expr_prim_req_general_success_true_b2d3f4a5", "label": "cpp20_expr_prim_req_general_success_true", "x": 874.0428808022225, "y": 226.31081239196737, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.req.general]/5", "content": "If substitution (if any) and semantic constraint checking succeed in a requires-expression, the requires-expression evaluates to true.", "function": ""}, {"id": "cpp20_expr_prim_this_static_member_forbidden_e4f8a1b2", "label": "cpp20_expr_prim_this_static_member_forbi", "x": 2.114845221239575, "y": 8.582569593970268, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.this]/4", "content": "The expression 'this' shall not appear within the declaration of a static or explicit object member function of the current class.", "function": ""}, {"id": "cpp20_expr_prim_this_context_restriction_a3b7c2d1", "label": "cpp20_expr_prim_this_context_restriction", "x": -25.869329658233653, "y": -4.111694978612142, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.prim.this]/6", "content": "The expression 'this' shall not appear in any context other than within a member function, default member initializer, or contract assertion of the current class.", "function": ""}, {"id": "cpp20_expr_sizeof_bitfield_58bfc23d", "label": "cpp20_expr_sizeof_bitfield_58bfc23d", "x": -114.32899055531026, "y": -60.61990632362, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.sizeof]/1", "content": "The sizeof operator shall not be applied to a glvalue that designates a bit-field.", "function": ""}, {"id": "cpp20_expr_sizeof_char_is_one_69c0d34e", "label": "cpp20_expr_sizeof_char_is_one_69c0d34e", "x": 527.9941803306757, "y": 109.07488238633195, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.sizeof]/1", "content": "The result of sizeof applied to any of the narrow character types is 1.", "function": ""}, {"id": "cpp20_expr_sizeof_function_type_36fda01b", "label": "cpp20_expr_sizeof_function_type_36fda01b", "x": 63.161195237190775, "y": -202.65359293745578, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.sizeof]/1", "content": "The sizeof operator shall not be applied to an expression that has function type.", "function": ""}, {"id": "cpp20_expr_sizeof_incomplete_type_47aeb12c", "label": "cpp20_expr_sizeof_incomplete_type_47aeb1", "x": -77.62684160737051, "y": -175.25615843142543, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.sizeof]/1", "content": "The sizeof operator shall not be applied to an expression that has incomplete type, or to the parenthesized name of such types.", "function": ""}, {"id": "cpp20_expr_sizeof_pack_identifier_7ad1e45f", "label": "cpp20_expr_sizeof_pack_identifier_7ad1e4", "x": -518.3902953915157, "y": 531.2299665027954, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.sizeof]/4", "content": "The identifier in a sizeof... expression shall name a pack.", "function": ""}, {"id": "cpp20_expr_type_ref_adjust_c8d2a5e7", "label": "cpp20_expr_type_ref_adjust_c8d2a5e7", "x": 132.65918460108185, "y": -149.1467123091216, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/1", "content": "If an expression initially has the type \"reference to T\", the type is adjusted to T prior to any further analysis; the value category of the expression is not altered.", "function": ""}, {"id": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "label": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f", "x": -98.11719637653934, "y": -28.95733442711097, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/2", "content": "If a prvalue initially has the type \"cv T\", where T is a cv-unqualified non-class, non-array type, the type of the expression is adjusted to T prior to any further analysis.", "function": ""}, {"id": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5", "label": "cpp20_expr_type_composite_ptr_nullptr_j6", "x": -73.3071773348252, "y": -98.31540992981029, "size": 9.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/3.1", "content": "The composite pointer type of two operands that are both null pointer constants is std::nullptr_t.", "function": ""}, {"id": "cpp20_expr_type_composite_ptr_one_null_k7f0i3g6", "label": "cpp20_expr_type_composite_ptr_one_null_k", "x": -230.97982020422205, "y": -55.614778429316374, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/3.2", "content": "The composite pointer type when one operand is a null pointer constant is the type of the other operand.", "function": ""}, {"id": "cpp20_expr_type_composite_ptr_void_l8g1j4h7", "label": "cpp20_expr_type_composite_ptr_void_l8g1j", "x": -220.82447530430727, "y": -23.007315384276403, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/3.3", "content": "The composite pointer type of \"pointer to cv1 void\" and \"pointer to cv2 T\" (where T is an object type or void) is \"pointer to cv12 void\", where cv12 is the union of cv1 and cv2.", "function": ""}, {"id": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "label": "cpp20_expr_type_composite_ptr_noexcept_f", "x": 74.09453851388002, "y": -62.36870801650788, "size": 7.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/3.4", "content": "The composite pointer type of \"pointer to noexcept function\" and \"pointer to function\" with otherwise identical function types is \"pointer to function\" (without noexcept).", "function": ""}, {"id": "cpp20_expr_type_composite_ptr_ref_related_n0i3l6j9", "label": "cpp20_expr_type_composite_ptr_ref_relate", "x": 10.87092991800279, "y": -100.17596593804373, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/3.5", "content": "When determining composite pointer type of pointers to classes C1 and C2 where one is reference-related to the other, the result is the qualification-combined type of the appropriate operand order.", "function": ""}, {"id": "cpp20_expr_type_composite_ptr_similar_o1j4m7k0", "label": "cpp20_expr_type_composite_ptr_similar_o1", "x": -264.8005587815718, "y": -14.668951165850658, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.type]/3.8", "content": "If T1 and T2 are similar types, the composite pointer type is the qualification-combined type of T1 and T2.", "function": ""}, {"id": "cpp20_expr_unary_op_indirection_operand_b8d4e5f2", "label": "cpp20_expr_unary_op_indirection_operand_", "x": -34.16096246410698, "y": -116.45359867379278, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/1", "content": "The operand of the unary * operator shall be a prvalue of type \"pointer to T\", where T is an object or function type.", "function": ""}, {"id": "cpp20_expr_unary_op_indirection_ub_a7c3f2d1", "label": "cpp20_expr_unary_op_indirection_ub_a7c3f", "x": -213.3056179848687, "y": -26.317597592857826, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/1", "content": "Dereferencing a pointer that does not point to an object or function is undefined behavior, except as specified in [expr.typeid].", "function": ""}, {"id": "cpp20_expr_unary_op_bitwise_not_operand_14dbe8f9", "label": "cpp20_expr_unary_op_bitwise_not_operand_", "x": -44.70026922654848, "y": -139.76643371593073, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/10", "content": "The operand of the ~ operator shall be a prvalue of integral or unscoped enumeration type.", "function": ""}, {"id": "cpp20_expr_unary_op_address_of_lvalue_c9e6f3a4", "label": "cpp20_expr_unary_op_address_of_lvalue_c9", "x": 5.833060398966562, "y": -166.0289881416938, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/3", "content": "The operand of the unary & operator shall be an lvalue of some type T.", "function": ""}, {"id": "cpp20_expr_unary_op_explicit_object_member_adb1d172", "label": "cpp20_expr_unary_op_explicit_object_memb", "x": -18.081406812978514, "y": 908.9262763978622, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/3.2", "content": "If the operand of unary & designates an explicit object member function, the operand shall be a qualified-id or a splice-expression.", "function": ""}, {"id": "cpp20_expr_unary_op_address_bitfield_d0f7a4b5", "label": "cpp20_expr_unary_op_address_bitfield_d0f", "x": -104.95959771923714, "y": -146.90534051477047, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/5", "content": "The operand of the unary & operator shall not be a bit-field.", "function": ""}, {"id": "cpp20_expr_unary_op_address_incomplete_class_e1a8b5c6", "label": "cpp20_expr_unary_op_address_incomplete_c", "x": -29.709170195225003, "y": -73.04353530944678, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/5", "content": "If unary & is applied to an lvalue of incomplete class type and the complete type declares operator&(), it is unspecified whether the operator has the built-in meaning or the operator function is called.", "function": ""}, {"id": "cpp20_expr_unary_op_plus_operand_f2b9c6d7", "label": "cpp20_expr_unary_op_plus_operand_f2b9c6d", "x": -35.844801902522754, "y": -87.16882875506823, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/7", "content": "The operand of the unary + operator shall be a prvalue of arithmetic, unscoped enumeration, or pointer type.", "function": ""}, {"id": "cpp20_expr_unary_op_minus_operand_03cad7e8", "label": "cpp20_expr_unary_op_minus_operand_03cad7", "x": -12.183717316700147, "y": -130.64717770273808, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[expr.unary.op]/8", "content": "The operand of the unary - operator shall be a prvalue of arithmetic or unscoped enumeration type.", "function": ""}, {"id": "cpp20_intro_multithread_freestanding_threads_impl_defined_c5d9e4f3", "label": "cpp20_intro_multithread_freestanding_thr", "x": 177.63196566728087, "y": 162.13426639132697, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.multithread.general]/1", "content": "Under a freestanding implementation, it is implementation-defined whether a program can have more than one thread of execution.", "function": ""}, {"id": "cpp20_intro_multithread_thread_object_access_d6e0f5a4", "label": "cpp20_intro_multithread_thread_object_ac", "x": 79.49868579577172, "y": 170.23269441369192, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.multithread.general]/1", "content": "Every thread in a program can potentially use every object and function in a program, though objects with automatic or thread storage duration can only be accessed by other threads indirectly through pointers or references.", "function": ""}, {"id": "cpp20_intro_multithread_signal_handler_thread_unspecified_a3f7b2c1", "label": "cpp20_intro_multithread_signal_handler_t", "x": 162.98658239893888, "y": 179.87900255900536, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.multithread.general]/2", "content": "For a signal handler that is not executed as a result of a call to std::raise, it is unspecified which thread of execution contains the signal handler invocation.", "function": ""}, {"id": "cpp20_intro_progress_thread_assumption_d4e8f3a2", "label": "cpp20_intro_progress_thread_assumption_d", "x": -46.28405913102582, "y": 173.3731249813634, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/1", "content": "The implementation may assume that any thread will eventually terminate, yield, make a library I/O call, access volatile, perform a non-RMW atomic/sync operation, or continue a trivial infinite loop.", "function": ""}, {"id": "cpp20_intro_progress_weakly_parallel_no_guarantee_d0e4f9a8", "label": "cpp20_intro_progress_weakly_parallel_no_", "x": 212.8643652867559, "y": 157.93427735807376, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/10", "content": "For a thread providing weakly parallel forward progress guarantees, the implementation does not ensure that the thread will eventually make progress.", "function": ""}, {"id": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9", "label": "cpp20_intro_progress_guarantee_ordering_", "x": 261.0633944758997, "y": 161.3141574584445, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/12", "content": "Concurrent forward progress guarantees are stronger than parallel forward progress guarantees, which in turn are stronger than weakly parallel forward progress guarantees.", "function": ""}, {"id": "cpp20_intro_progress_delegation_strengthening_f2a6b1c0", "label": "cpp20_intro_progress_delegation_strength", "x": 218.39571714707515, "y": 153.73222376850987, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/13", "content": "When thread P blocks with forward progress guarantee delegation on set S, the implementation shall ensure at least one thread in S has forward progress guarantees at least as strong as P.", "function": ""}, {"id": "cpp20_intro_progress_delegation_unblock_a3b7c2d1", "label": "cpp20_intro_progress_delegation_unblock_", "x": 204.8540272395782, "y": 144.8801998903499, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/13", "content": "When a thread in set S terminates, it is removed from S. Once S is empty, thread P that was blocking with forward progress guarantee delegation on S is unblocked.", "function": ""}, {"id": "cpp20_intro_progress_visibility_recommendation_b4c8d3e2", "label": "cpp20_intro_progress_visibility_recommen", "x": -290.41667007757206, "y": 212.84412361386214, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/17", "content": "An implementation should ensure that the last value in modification order assigned by an atomic or synchronization operation will become visible to all other threads in a finite period of time.", "function": ""}, {"id": "cpp20_intro_progress_lockfree_single_thread_completion_e5f9a4b3", "label": "cpp20_intro_progress_lockfree_single_thr", "x": 185.11058646214755, "y": 181.49496722951554, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/2.1", "content": "If there is only one thread that is not blocked in a standard library function, a lock-free execution in that thread shall complete.", "function": ""}, {"id": "cpp20_intro_progress_lockfree_concurrent_progress_f6a0b5c4", "label": "cpp20_intro_progress_lockfree_concurrent", "x": -898.3726041948537, "y": -247.7680067796904, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/2.2", "content": "When one or more lock-free executions run concurrently, at least one should complete.", "function": ""}, {"id": "cpp20_intro_progress_concurrent_guarantee_a7b1c6d5", "label": "cpp20_intro_progress_concurrent_guarante", "x": 206.5584209846268, "y": 143.57929411309212, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/6", "content": "For a thread providing concurrent forward progress guarantees, the implementation ensures that the thread will eventually make progress for as long as it has not terminated.", "function": ""}, {"id": "cpp20_intro_progress_main_thread_impl_defined_b8c2d7e6", "label": "cpp20_intro_progress_main_thread_impl_de", "x": 207.17323717649197, "y": 125.2105354362907, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/7", "content": "It is implementation-defined whether the thread executing main() and threads created by std::thread or std::jthread provide concurrent forward progress guarantees.", "function": ""}, {"id": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7", "label": "cpp20_intro_progress_parallel_guarantee_", "x": 223.39733003115043, "y": 118.60397375082889, "size": 7.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.progress]/8", "content": "For a thread providing parallel forward progress guarantees, the implementation is not required to ensure progress until the thread has executed at least one execution step; after that, it provides concurrent forward progress guarantees.", "function": ""}, {"id": "cpp20_intro_races_object_value_visibility_a3b7c9e1", "label": "cpp20_intro_races_object_value_visibilit", "x": 124.59817878220474, "y": 112.2409486804258, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/1", "content": "The value of an object visible to a thread T at a particular point is either the initial value of the object, a value assigned to the object by T, or a value assigned to the object by another thread according to the visibility rules.", "function": ""}, {"id": "cpp20_intro_races_signal_handler_ordering_h0f2g4i8", "label": "cpp20_intro_races_signal_handler_orderin", "x": 170.01779487443457, "y": 194.63759938618017, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/18", "content": "For each signal handler invocation, evaluations performed by the thread invoking a signal handler can be divided into two groups A and B, such that no evaluations in B happen before evaluations in A, and evaluations of volatile sig_atomic_t objects take values as though all evaluations in A happened", "function": ""}, {"id": "cpp20_intro_races_atomic_reorder_precluded_k3i5j7l1", "label": "cpp20_intro_races_atomic_reorder_preclud", "x": -301.26422287594625, "y": 197.23003652030812, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/19", "content": "Reordering of atomic loads in cases in which the atomics in question might alias is generally precluded, since this could violate the coherence rules.", "function": ""}, {"id": "cpp20_intro_races_compiler_no_spurious_write_i1g3h5j9", "label": "cpp20_intro_races_compiler_no_spurious_w", "x": 21.173985564684024, "y": 172.28572206180212, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/19", "content": "Compiler transformations that introduce assignments to a potentially shared memory location that would not be modified by the abstract machine are generally precluded, since such an assignment might overwrite another assignment by a different thread in cases where the abstract machine execution woul", "function": ""}, {"id": "cpp20_intro_races_no_adjacent_member_overwrite_j2h4i6k0", "label": "cpp20_intro_races_no_adjacent_member_ove", "x": -245.18092684952435, "y": 169.01499059061464, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/19", "content": "Implementations of data member assignment that overwrite adjacent members in separate memory locations are precluded by the data race rules.", "function": ""}, {"id": "cpp20_intro_races_modification_no_value_change_f2d4e6a8", "label": "cpp20_intro_races_modification_no_value_", "x": 829.6595630623764, "y": -269.1839120062931, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/2", "content": "A modification can still conflict even if it does not alter the value of any bits in the memory location.", "function": ""}, {"id": "cpp20_intro_races_fence_categories_d6b8c0e4", "label": "cpp20_intro_races_fence_categories_d6b8c", "x": -254.53509909482062, "y": 175.82351528218388, "size": 10.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/3", "content": "A synchronization operation without an associated memory location is a fence and can be either an acquire fence, a release fence, or both an acquire and release fence.", "function": ""}, {"id": "cpp20_intro_races_relaxed_not_sync_e7c9d1f5", "label": "cpp20_intro_races_relaxed_not_sync_e7c9d", "x": -283.0246395408592, "y": 207.24319983614632, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/3", "content": "Relaxed atomic operations are not synchronization operations, but they cannot contribute to data races.", "function": ""}, {"id": "cpp20_intro_races_sync_op_categories_c5a7b9d3", "label": "cpp20_intro_races_sync_op_categories_c5a", "x": -254.36594671941103, "y": 169.64126538038778, "size": 11.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/3", "content": "A synchronization operation on one or more memory locations is either an acquire operation, a release operation, or both an acquire and release operation.", "function": ""}, {"id": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6", "label": "cpp20_intro_races_store_release_load_acq", "x": -257.02630021729163, "y": 174.9358453692164, "size": 10.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/6", "content": "An atomic store-release synchronizes with a load-acquire that takes its value from the store.", "function": ""}, {"id": "cpp20_intro_races_visible_ambiguity_ub_g9e1f3h7", "label": "cpp20_intro_races_visible_ambiguity_ub_g", "x": -279.50630297011145, "y": 217.73638967503223, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[intro.races]/9", "content": "If there is ambiguity about which side effect to a non-atomic object or bit-field is visible, then the behavior is either unspecified or undefined.", "function": ""}, {"id": "cpp20_namespace_alias_splice_not_global_7a8f2b3c", "label": "cpp20_namespace_alias_splice_not_global_", "x": -76.81634571229307, "y": 518.5160607174327, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.alias]/2", "content": "A splice-specifier in a namespace-alias-definition shall not designate the global namespace.", "function": ""}, {"id": "cpp20_namespace_alias_lookup_only_namespaces_9b1c2d3e", "label": "cpp20_namespace_alias_lookup_only_namesp", "x": -860.5425600127683, "y": 380.72773727893656, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.alias]/4", "content": "When looking up a namespace-name in a namespace-alias-definition, only namespace names are considered.", "function": ""}, {"id": "cpp20_namespace_alias_underlying_entity_4c5d6e7f", "label": "cpp20_namespace_alias_underlying_entity_", "x": -444.8499064946974, "y": 789.636527564182, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.alias]/4", "content": "The underlying entity of a namespace alias is the namespace either denoted by the qualified-namespace-specifier or designated by the splice-specifier.", "function": ""}, {"id": "cpp20_namespace_def_must_inhabit_namespace_scope_7f8e9a1b", "label": "cpp20_namespace_def_must_inhabit_namespa", "x": -552.0368194051664, "y": -585.8955070804793, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/1", "content": "Every namespace-definition shall inhabit a namespace scope.", "function": ""}, {"id": "cpp20_namespace_lookup_scope_chain_e4f5a6b7", "label": "cpp20_namespace_lookup_scope_chain_e4f5a", "x": -942.7428151578658, "y": -27.26132138268681, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/2", "content": "In a named-namespace-definition D appearing in namespace A, the identifier is looked up by searching for it in the scopes of namespace A and of every element of the inline namespace set of A.", "function": ""}, {"id": "cpp20_namespace_named_lookup_extends_or_introduces_d3e4f5a6", "label": "cpp20_namespace_named_lookup_extends_or_", "x": 115.53107114396123, "y": -906.4757789318106, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/2", "content": "In a named-namespace-definition D appearing in namespace A, if lookup of the identifier finds a namespace-definition for namespace N, D extends N; otherwise the identifier is introduced as a namespace-name into A.", "function": ""}, {"id": "cpp20_namespace_def_inline_keyword_consistency_a2b3c4d5", "label": "cpp20_namespace_def_inline_keyword_consi", "x": 653.890383901234, "y": -192.78899289770476, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/4", "content": "The inline keyword may be used on a namespace-definition that extends a namespace only if it was previously used on the namespace-definition that initially declared the namespace-name for that namespace.", "function": ""}, {"id": "cpp20_namespace_inline_adl_association_a0b1c2d3", "label": "cpp20_namespace_inline_adl_association_a", "x": 376.1590618107404, "y": -374.6999812458347, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/6", "content": "The inline namespace and its enclosing namespace are both added to the set of associated namespaces used in argument-dependent lookup whenever one of them is.", "function": ""}, {"id": "cpp20_namespace_inline_member_usability_f8a9b0c1", "label": "cpp20_namespace_inline_member_usability_", "x": -413.5773194688452, "y": 343.3634410845616, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/6", "content": "Members of an inline namespace can be used in most respects as though they were members of the innermost enclosing namespace.", "function": ""}, {"id": "cpp20_namespace_inline_qualified_lookup_inclusion_c2d3e4f5", "label": "cpp20_namespace_inline_qualified_lookup_", "x": -659.0154486565447, "y": -548.9085658361422, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/6", "content": "Looking up a name in the enclosing namespace via explicit qualification will include members of the inline namespace even if there are declarations of that name in the enclosing namespace.", "function": ""}, {"id": "cpp20_namespace_inline_specialization_as_enclosing_b1c2d3e4", "label": "cpp20_namespace_inline_specialization_as", "x": 559.8791272720417, "y": 777.0535561011064, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/6", "content": "Each member of an inline namespace can subsequently be partially specialized, explicitly instantiated, or explicitly specialized as though it were a member of the enclosing namespace.", "function": ""}, {"id": "cpp20_namespace_inline_transitive_closure_d6e7f8a9", "label": "cpp20_namespace_inline_transitive_closur", "x": -310.47936297678217, "y": -618.1104173821933, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/7", "content": "The inline namespace set of a namespace N is the transitive closure of all inline namespaces in N.", "function": ""}, {"id": "cpp20_namespace_nested_inline_equivalence_b7c8d9e0", "label": "cpp20_namespace_nested_inline_equivalenc", "x": 481.09811003166544, "y": -334.28064673373456, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.def.general]/8", "content": "A nested-namespace-definition with enclosing-namespace-specifier E, identifier I and namespace-body B is equivalent to namespace E { inline_opt namespace I { B } } where inline appears if and only if identifier I is preceded by inline.", "function": ""}, {"id": "cpp20_namespace_unnamed_same_id_in_tu_c5d6e7f8", "label": "cpp20_namespace_unnamed_same_id_in_tu_c5", "x": -828.3646371707905, "y": -505.0895494358893, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.unnamed]/1", "content": "All occurrences of the placeholder 'unique' in an unnamed-namespace-definition are replaced by the same identifier within a translation unit.", "function": ""}, {"id": "cpp20_namespace_unnamed_unique_identifier_differs_e3f4a5b6", "label": "cpp20_namespace_unnamed_unique_identifie", "x": 529.1761238356172, "y": 421.0000662081599, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[namespace.unnamed]/1", "content": "The unique identifier replacing all occurrences of 'unique' in an unnamed-namespace-definition within a translation unit differs from all other identifiers in the program.", "function": ""}, {"id": "cpp20_over_call_func_postcondition_assertion_dtor_a1b3c5d7", "label": "cpp20_over_call_func_postcondition_asser", "x": -46.744641833959435, "y": -14.605086908862804, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.call.func]/3.1", "content": "If an unqualified function call appears in a postcondition assertion of a destructor and overload resolution selects a non-static member function, the call is ill-formed.", "function": ""}, {"id": "cpp20_over_call_func_precondition_assertion_ctor_d9e7b4c2", "label": "cpp20_over_call_func_precondition_assert", "x": -46.22803141807097, "y": -87.65552248128044, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.call.func]/3.1", "content": "If an unqualified function call appears in a precondition assertion of a constructor and overload resolution selects a non-static member function, the call is ill-formed.", "function": ""}, {"id": "cpp20_over_call_func_contrived_object_nonstatic_e4f6a8b9", "label": "cpp20_over_call_func_contrived_object_no", "x": -42.52231580139766, "y": -199.04900998608332, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.call.func]/3.3", "content": "If overload resolution for an unqualified function call with a contrived object argument selects a non-static member function, the call is ill-formed.", "function": ""}, {"id": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "label": "cpp20_over_call_object_surrogate_non_exp", "x": 28.93521136549152, "y": -42.882922703070236, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.call.object]/2", "content": "Surrogate call functions are only generated from non-explicit conversion functions that convert to pointer-to-function or reference-to-function types.", "function": ""}, {"id": "cpp20_over_match_call_general_member_from_address_f2c8a3b1", "label": "cpp20_over_match_call_general_member_fro", "x": -35.6435264705135, "y": -220.38025525148865, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.call.general]/2", "content": "If the postfix-expression is the address of an overload set and overload resolution selects an implicit object member function, the program is ill-formed.", "function": ""}, {"id": "cpp20_over_match_class_deduct_no_aggregate_candidate_f7a8b9c1", "label": "cpp20_over_match_class_deduct_no_aggrega", "x": -20.28040268947963, "y": -158.36981175287158, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.class.deduct]/1", "content": "If there is no aggregate element ei for any xi in list initialization, the aggregate deduction candidate is not added to the set of guides.", "function": ""}, {"id": "cpp20_over_match_conv_explicit_direct_init_only_b6c7d8e9", "label": "cpp20_over_match_conv_explicit_direct_in", "x": 69.5635605393508, "y": 6.8385993296272405, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.conv]/1.1", "content": "For direct-initialization via conversion function, explicit conversion functions are candidates only if their result type can be converted to T with a (possibly trivial) qualification conversion; otherwise no explicit functions are candidates.", "function": ""}, {"id": "cpp20_over_match_conv_permissible_types_standard_conv_d2e3f4a5", "label": "cpp20_over_match_conv_permissible_types_", "x": 60.75325630461501, "y": 0.8500898146645282, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.conv]/1.1", "content": "For initialization by conversion function, the permissible types for non-explicit conversion functions are those that can be converted to type T via a standard conversion sequence.", "function": ""}, {"id": "cpp20_over_match_ctor_explicit_default_init_copy_list_b3c4d5e6", "label": "cpp20_over_match_ctor_explicit_default_i", "x": -10.816399864306824, "y": 19.20746807523192, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.ctor]/1", "content": "For default-initialization in the context of copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.", "function": ""}, {"id": "cpp20_over_match_funcs_implicit_object_param_lvalue_ref_b6c7d8e9", "label": "cpp20_over_match_funcs_implicit_object_p", "x": 72.46048799227079, "y": -100.33726405504639, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/4.1", "content": "For implicit object member functions declared without a ref-qualifier or with the & ref-qualifier, the type of the implicit object parameter is \"lvalue reference to cv X\".", "function": ""}, {"id": "cpp20_over_match_funcs_implicit_object_param_rvalue_ref_f1a2b3c4", "label": "cpp20_over_match_funcs_implicit_object_p", "x": 124.26381549419041, "y": -17.633599799703138, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/4.2", "content": "For implicit object member functions declared with the && ref-qualifier, the type of the implicit object parameter is \"rvalue reference to cv X\".", "function": ""}, {"id": "cpp20_over_match_funcs_no_user_conv_implicit_object_d5e6f7a8", "label": "cpp20_over_match_funcs_no_user_conv_impl", "x": -424.7135391382618, "y": -894.0286178238536, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/5", "content": "No user-defined conversions can be applied to achieve a type match with the implicit object parameter.", "function": ""}, {"id": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9", "label": "cpp20_over_match_funcs_general_one_user_", "x": 43.617378256276886, "y": -23.265770880878755, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/6", "content": "Only one user-defined conversion is allowed in an implicit conversion sequence (except in list-initialization).", "function": ""}, {"id": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "label": "cpp20_over_match_funcs_value_dependent_e", "x": -69.50805498389441, "y": 24.957345899823235, "size": 6.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/8", "content": "If a constructor template or conversion function template has an explicit-specifier whose constant-expression is value-dependent, template argument deduction is performed first, then explicit candidates are removed if the context admits only non-explicit candidates.", "function": ""}, {"id": "cpp20_over_match_funcs_general_deleted_move_excluded_c7d9e1f3", "label": "cpp20_over_match_funcs_general_deleted_m", "x": 701.4542843772952, "y": -296.3918240650622, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/9", "content": "A defaulted move special member function that is defined as deleted is excluded from the set of candidate functions in all contexts.", "function": ""}, {"id": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "label": "cpp20_over_match_funcs_general_inherited", "x": 9.412591985902832, "y": -31.072155087874467, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.funcs.general]/9", "content": "A constructor inherited from class type C that has a first parameter of type \"reference to cv1 P\" is excluded from candidates when constructing cv2 D if the argument list has exactly one argument, C is reference-related to P, and P is reference-related to D.", "function": ""}, {"id": "cpp20_over_match_viable_viable_function_requirements_d2e3f4a5", "label": "cpp20_over_match_viable_viable_function_", "x": 222.22437741580228, "y": -625.8647163694185, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.general]/2.8", "content": "A candidate function is viable only if it has the proper number of arguments and meets certain other conditions related to argument-parameter matching.", "function": ""}, {"id": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "label": "cpp20_over_match_general_illfomed_no_bes", "x": -35.07537928708236, "y": -138.82147226394525, "size": 12.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.general]/3", "content": "If overload resolution does not produce a unique best viable function, the invocation is ill-formed.", "function": ""}, {"id": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a", "label": "cpp20_over_match_general_inaccessible_be", "x": -37.008133235395825, "y": -138.76935293694692, "size": 12.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.general]/3", "content": "When overload resolution succeeds but the best viable function is not accessible in the context in which it is used, the program is ill-formed.", "function": ""}, {"id": "cpp20_over_match_list_explicit_copy_list_init_f7a8b9c1", "label": "cpp20_over_match_list_explicit_copy_list", "x": -29.534238893886304, "y": -79.18415252769395, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.list]/1", "content": "In copy-list-initialization, if an explicit constructor is chosen by overload resolution, the initialization is ill-formed.", "function": ""}, {"id": "cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4", "label": "cpp20_over_match_oper_no_class_enum_buil", "x": -24.149135781994413, "y": -55.10791489395181, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/1", "content": "If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator.", "function": ""}, {"id": "cpp20_over_match_oper_rewritten_eq_bool_return_d8e9f1a2", "label": "cpp20_over_match_oper_rewritten_eq_bool_", "x": -19.505992582619083, "y": -200.46594988426477, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/10", "content": "If a rewritten operator== candidate is selected by overload resolution for an operator @, its return type shall be cv bool.", "function": ""}, {"id": "cpp20_over_match_oper_arrow_second_operand_ignored_d8e9f1a2", "label": "cpp20_over_match_oper_arrow_second_opera", "x": 66.84111434084528, "y": -126.01743768417404, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/12", "content": "The second operand of operator-> is ignored in selecting an operator-> function, and is not an argument when the operator-> function is called.", "function": ""}, {"id": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "label": "cpp20_over_match_oper_fallback_builtin_c", "x": -18.145744183563966, "y": -117.45234052036426, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/13", "content": "If the operator is comma, unary &, or ->, and there are no viable functions, then the operator is assumed to be the built-in operator.", "function": ""}, {"id": "cpp20_over_match_oper_nonmember_empty_for_assign_d5e6f7a8", "label": "cpp20_over_match_oper_nonmember_empty_fo", "x": -681.4855922686281, "y": 107.70772267158716, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/3.2", "content": "For the operators =, [], or ->, the set of non-member candidates is empty.", "function": ""}, {"id": "cpp20_over_match_oper_builtin_empty_comma_addr_arrow_b9c1d2e3", "label": "cpp20_over_match_oper_builtin_empty_comm", "x": -43.376557165491135, "y": -220.25509866241163, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/3.3", "content": "For the operator comma, the unary operator &, or the operator ->, the built-in candidates set is empty.", "function": ""}, {"id": "cpp20_over_match_oper_assignment_standard_conv_only_f4a5b6c7", "label": "cpp20_over_match_oper_assignment_standar", "x": 108.77384787638923, "y": 81.54303505625528, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.match.oper]/5", "content": "For the first parameter of the built-in assignment operators, only standard conversion sequences are considered.", "function": ""}, {"id": "cpp20_over_oper_precedence_immutable_a7c3f8e2", "label": "cpp20_over_oper_precedence_immutable_a7c", "x": 33.85085389205621, "y": -225.38989328696871, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[over.oper.general]/7", "content": "It is not possible to change the precedence, grouping, or number of operands of operators through operator overloading.", "function": ""}, {"id": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6", "label": "cpp20_range_approximately_sized_reserve_", "x": -181.39766726694282, "y": -224.51332014264142, "size": 10.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.approximately.sized]/2.1", "content": "For a type T modeling approximately_sized_range, ranges::reserve_hint(t) must be amortized O(1), must not modify t, and must return a non-negative value representable in range_difference_t<T>.", "function": ""}, {"id": "cpp20_range_approximately_sized_forward_reserve_hint_g7h8i9j0", "label": "cpp20_range_approximately_sized_forward_", "x": -824.6078115917048, "y": 539.9200084802317, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.approximately.sized]/2.2", "content": "For a type T modeling approximately_sized_range, if iterator_t<T> models forward_iterator, ranges::reserve_hint(t) is well-defined regardless of the evaluation of ranges::begin(t).", "function": ""}, {"id": "cpp20_range_approximately_sized_non_forward_reserve_hint_k1l2m3n4", "label": "cpp20_range_approximately_sized_non_forw", "x": -220.59165994786363, "y": -234.3357527148495, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.approximately.sized]/2.2 Note 1", "content": "For an approximately_sized_range whose iterator type does not model forward_iterator, ranges::reserve_hint(t) may only be well-defined if evaluated before the first call to ranges::begin(t).", "function": ""}, {"id": "cpp20_range_range_begin_end_denotes_range_a3b4c5d6", "label": "cpp20_range_range_begin_end_denotes_rang", "x": -235.57297598449853, "y": -227.2890701658964, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.range]/2.1", "content": "For a type T modeling range, [ranges::begin(t), ranges::end(t)) must denote a valid range as defined in [iterator.requirements.general].", "function": ""}, {"id": "cpp20_range_range_begin_end_amortized_constant_7e8f9a0b", "label": "cpp20_range_range_begin_end_amortized_co", "x": -236.00283379601032, "y": -297.5187895350134, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.range]/2.2", "content": "For a type T modeling range, both ranges::begin(t) and ranges::end(t) must be amortized constant time and non-modifying.", "function": ""}, {"id": "cpp20_range_range_begin_equality_preserving_c1d2e3f4", "label": "cpp20_range_range_begin_equality_preserv", "x": -259.4008326245078, "y": -301.1181413837634, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.range]/2.3", "content": "For a type T modeling range, if ranges::begin(t) returns a type modeling forward_iterator, then ranges::begin(t) must be equality-preserving.", "function": ""}, {"id": "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d", "label": "cpp20_range_borrowed_range_iterator_vali", "x": 125.96688715354537, "y": -35.216737538420745, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.range]/4", "content": "A type T models borrowed_range only if the validity of iterators obtained from a variable u of type U (where U is remove_reference_t<T> if T is rvalue reference, otherwise T) is not tied to the lifetime of that variable.", "function": ""}, {"id": "cpp20_range_enable_borrowed_range_specialization_e9f0a1b2", "label": "cpp20_range_enable_borrowed_range_specia", "x": 805.9229079130297, "y": 215.63119343133204, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.range]/6", "content": "Users may specialize enable_borrowed_range for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions and have type const bool.", "function": ""}, {"id": "cpp20_range_contiguous_data_address_a9b0c1d2", "label": "cpp20_range_contiguous_data_address_a9b0", "x": 73.73445594103343, "y": 125.34700834591514, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.refinements]/3", "content": "A type T models contiguous_range only if to_address(ranges::begin(t)) == ranges::data(t) is true.", "function": ""}, {"id": "cpp20_range_common_range_same_iterator_sentinel_e5f6a7b8", "label": "cpp20_range_common_range_same_iterator_s", "x": -410.5008611954341, "y": -332.9463390490524, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.refinements]/4", "content": "The common_range concept requires that ranges::begin and ranges::end return objects of the same type.", "function": ""}, {"id": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "label": "cpp20_range_viewable_range_non_view_lval", "x": 44.67652575991539, "y": -111.70639915303623, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.refinements]/6", "content": "For a type T satisfying viewable_range where remove_cvref_t<T> is not a view, T must be an lvalue reference, or (movable<remove_reference_t<T>> and not a specialization of initializer_list).", "function": ""}, {"id": "cpp20_range_viewable_range_view_constructible_e3f4a5b6", "label": "cpp20_range_viewable_range_view_construc", "x": -67.9975346201684, "y": 45.171772815594956, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.refinements]/6", "content": "For a type T satisfying viewable_range where remove_cvref_t<T> is a view, T must be constructible_from<remove_cvref_t<T>, T>.", "function": ""}, {"id": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "label": "cpp20_range_constant_range_non_modifiabl", "x": -246.6469864355944, "y": -274.7543890932368, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.refinements]/7", "content": "The constant_range concept specifies the requirements of a range type whose elements are not modifiable, requiring input_range and constant-iterator for iterator_t.", "function": ""}, {"id": "cpp20_range_sized_size_O1_o5p6q7r8", "label": "cpp20_range_sized_size_O1_o5p6q7r8", "x": -156.4825144243878, "y": -217.98535387224285, "size": 10.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.sized]/2.1", "content": "For a type T modeling sized_range, ranges::size(t) must be amortized O(1), must not modify t, and must equal ranges::distance(ranges::begin(t), ranges::end(t)).", "function": ""}, {"id": "cpp20_range_sized_forward_size_s9t0u1v2", "label": "cpp20_range_sized_forward_size_s9t0u1v2", "x": -640.114446873167, "y": -237.9436815665113, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.sized]/2.2", "content": "For a type T modeling sized_range, if iterator_t<T> models forward_iterator, ranges::size(t) is well-defined regardless of the evaluation of ranges::begin(t).", "function": ""}, {"id": "cpp20_range_sized_non_forward_size_w3x4y5z6", "label": "cpp20_range_sized_non_forward_size_w3x4y", "x": -205.4840288007361, "y": -257.31385243720325, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.sized]/2.2 Note 1", "content": "For a sized_range whose iterator type does not model forward_iterator, ranges::size(t) may only be well-defined if evaluated before the first call to ranges::begin(t).", "function": ""}, {"id": "cpp20_range_disable_sized_range_specialization_a7b8c9d0", "label": "cpp20_range_disable_sized_range_speciali", "x": 507.2342611470533, "y": -463.24366124357573, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.sized]/3", "content": "Users may specialize disable_sized_range for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions and have type const bool.", "function": ""}, {"id": "cpp20_range_view_O1_move_construction_e1f2a3b4", "label": "cpp20_range_view_O1_move_construction_e1", "x": 38.861734029954455, "y": 30.806617807658203, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/2.1", "content": "A type T models view only if T has O(1) move construction.", "function": ""}, {"id": "cpp20_range_view_move_assignment_complexity_c5d6e7f8", "label": "cpp20_range_view_move_assignment_complex", "x": -8.648102353946054, "y": 39.630055437962156, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/2.2", "content": "A type T models view only if move assignment of an object of type T is no more complex than destruction followed by move construction.", "function": ""}, {"id": "cpp20_range_view_copy_destruction_linear_g9h0i1j2", "label": "cpp20_range_view_copy_destruction_linear", "x": -108.91335500466128, "y": 164.7105418842108, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/2.3", "content": "For a type T modeling view, if N copies and/or moves are made from an object of type T that contained M elements, then those N objects have O(N+M) destruction.", "function": ""}, {"id": "cpp20_range_view_O1_copy_construction_k3l4m5n6", "label": "cpp20_range_view_O1_copy_construction_k3", "x": 58.150670349069564, "y": 30.324031135068008, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/2.4", "content": "A type T models view only if copy_constructible<T> is false, or T has O(1) copy construction.", "function": ""}, {"id": "cpp20_range_view_copy_assignment_complexity_o7p8q9r0", "label": "cpp20_range_view_copy_assignment_complex", "x": -19.413089080496526, "y": 19.494803636956025, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/2.5", "content": "A type T models view only if copyable<T> is false, or copy assignment of an object of type T is no more complex than destruction followed by copy construction.", "function": ""}, {"id": "cpp20_range_view_moved_from_O1_destruction_s1t2u3v4", "label": "cpp20_range_view_moved_from_O1_destructi", "x": -88.34799789671655, "y": 170.6054024208991, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/3 Note 1", "content": "The constraints on copying and moving for view imply that a moved-from object of type T has O(1) destruction.", "function": ""}, {"id": "cpp20_range_enable_view_specialization_w5x6y7z8", "label": "cpp20_range_enable_view_specialization_w", "x": -339.1034413166587, "y": 614.190640927756, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[range.view]/7", "content": "Users may specialize enable_view to true for cv-unqualified program-defined types that model view, and false for types that do not. Such specializations shall be usable in constant expressions and have type const bool.", "function": ""}, {"id": "cpp20_special_implicit_declaration_location_f2c8d4e5", "label": "cpp20_special_implicit_declaration_locat", "x": 1.8843860787734135, "y": 9.541691027507104, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/1", "content": "An implicitly-declared special member function is declared at the closing brace of the class-specifier.", "function": ""}, {"id": "cpp20_special_implicit_declaration_no_redefine_8a3f2c1d", "label": "cpp20_special_implicit_declaration_no_re", "x": 631.5773665473984, "y": -77.12572028986673, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/1", "content": "Programs shall not define implicitly-declared special member functions.", "function": ""}, {"id": "cpp20_special_member_function_kinds_e7b4a9c2", "label": "cpp20_special_member_function_kinds_e7b4", "x": 4.303660963806162, "y": -3.098566093866806, "size": 6.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/1", "content": "Special member functions are: default constructors, copy constructors, move constructors, copy assignment operators, move assignment operators, and prospective destructors.", "function": ""}, {"id": "cpp20_special_access_rules_apply_3b9e1a7f", "label": "cpp20_special_access_rules_apply_3b9e1a7", "x": -469.1344491981683, "y": 632.0333648596692, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/4", "content": "Special member functions obey the usual access rules.", "function": ""}, {"id": "cpp20_special_same_kind_default_ctor_c4d2f8a1", "label": "cpp20_special_same_kind_default_ctor_c4d", "x": 32.6391447614457, "y": 43.22425334765625, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/5.1", "content": "Two special member functions are of the same kind if they are both default constructors.", "function": ""}, {"id": "cpp20_special_same_kind_copy_move_ctor_d5e3a9b2", "label": "cpp20_special_same_kind_copy_move_ctor_d", "x": 11.430367543693187, "y": 62.92462076020075, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/5.2", "content": "Two special member functions are of the same kind if they are both copy or move constructors with the same first parameter type.", "function": ""}, {"id": "cpp20_special_same_kind_copy_move_assign_e6f4b0c3", "label": "cpp20_special_same_kind_copy_move_assign", "x": 177.8108660849817, "y": -165.02146396759682, "size": 3.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/5.3", "content": "Two special member functions are of the same kind if they are both copy or move assignment operators with the same first parameter type and the same cv-qualifiers and ref-qualifier, if any.", "function": ""}, {"id": "cpp20_special_eligible_not_deleted_f7a5c1d4", "label": "cpp20_special_eligible_not_deleted_f7a5c", "x": 704.8141647028696, "y": -602.0588211410454, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/6.1", "content": "An eligible special member function must not be deleted.", "function": ""}, {"id": "cpp20_special_eligible_constraints_satisfied_a8b6d2e5", "label": "cpp20_special_eligible_constraints_satis", "x": 873.7398161651812, "y": -68.90527596863747, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/6.2", "content": "An eligible special member function must have its associated constraints satisfied, if any.", "function": ""}, {"id": "cpp20_special_eligible_most_constrained_b9c7e3f6", "label": "cpp20_special_eligible_most_constrained_", "x": -731.6791049889196, "y": 146.28283938545056, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/6.3", "content": "An eligible special member function must not have a special member function of the same kind whose associated constraints are satisfied and is more constrained.", "function": ""}, {"id": "cpp20_special_potentially_constructed_subobjects_cad8f4a7", "label": "cpp20_special_potentially_constructed_su", "x": -51.285455309929546, "y": 9.037351024893768, "size": 10.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[special]/7", "content": "For a class, its potentially constructed subobjects are: its direct non-static data members, its non-virtual direct base classes, and (if the class is not abstract) its virtual base classes.", "function": ""}, {"id": "cpp20_temp_alias_no_deduction_from_typedef_name_7c4d9e1a", "label": "cpp20_temp_alias_no_deduction_from_typed", "x": 670.9945407929823, "y": 347.237356269476, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/2", "content": "The alias template name is not deduced from a template-id that serves as a typedef-name for a type alias.", "function": ""}, {"id": "cpp20_temp_alias_template_id_equivalence_2f9c4d7a", "label": "cpp20_temp_alias_template_id_equivalence", "x": 342.40324465205623, "y": 739.6159662368693, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/2", "content": "A template-id that is not the operand of a reflect-expression and is not a splice-specialization-specifier, naming an alias template specialization, is equivalent to the associated type obtained by substitution of its template-arguments for the template-parameters in the defining-type-id.", "function": ""}, {"id": "cpp20_temp_alias_template_id_substitution_failure_8a3f1b2e", "label": "cpp20_temp_alias_template_id_substitutio", "x": -690.3298370474179, "y": -13.51351860864554, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/2", "content": "A template-id that names a specialization of an alias template is ill-formed if forming the associated type results in substitution failure.", "function": ""}, {"id": "cpp20_temp_alias_dependent_template_id_substitution_6a2e8b1c", "label": "cpp20_temp_alias_dependent_template_id_s", "x": -389.56802568167467, "y": 906.6608473538653, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/3", "content": "If the template-id is dependent, subsequent template argument substitution still applies to the template-id even after alias template expansion.", "function": ""}, {"id": "cpp20_temp_alias_no_direct_self_use_9d1a6c4f", "label": "cpp20_temp_alias_no_direct_self_use_9d1a", "x": 637.6101446128849, "y": -738.8494451603163, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/4", "content": "The type produced by an alias template specialization shall not directly or indirectly make use of that specialization.", "function": ""}, {"id": "cpp20_temp_alias_self_reference_in_defining_type_id_5b7e2f3c", "label": "cpp20_temp_alias_self_reference_in_defin", "x": 296.40761117708405, "y": 876.8747109348194, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/4", "content": "The defining-type-id in an alias template declaration shall not refer to the alias template being declared.", "function": ""}, {"id": "cpp20_temp_alias_lambda_different_types_per_instantiation_3e8b5a2d", "label": "cpp20_temp_alias_lambda_different_types_", "x": -740.1840189338278, "y": 182.9462692249301, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.alias]/5", "content": "The type of a lambda-expression appearing in an alias template declaration is different between instantiations of that template, even when the lambda-expression is not dependent.", "function": ""}, {"id": "cpp20_temp_concept_namespace_scope_required_7a3f9e2d", "label": "cpp20_temp_concept_namespace_scope_requi", "x": 591.4674532723218, "y": -754.4310100745295, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/3", "content": "A concept-definition shall inhabit a namespace scope.", "function": ""}, {"id": "cpp20_temp_concept_no_associated_constraints_8b4c1f3e", "label": "cpp20_temp_concept_no_associated_constra", "x": 467.5072871365055, "y": -505.15861129276755, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/4", "content": "A concept shall not have associated constraints.", "function": ""}, {"id": "cpp20_temp_concept_id_evaluated_as_expression_7d8e9f0a", "label": "cpp20_temp_concept_id_evaluated_as_expre", "x": 642.4719502231607, "y": 753.8654426627489, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/5", "content": "A concept-id is evaluated as an expression.", "function": ""}, {"id": "cpp20_temp_concept_no_explicit_instantiation_9c8b7a6f", "label": "cpp20_temp_concept_no_explicit_instantia", "x": 903.5981044970754, "y": -14.476966820068379, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/5", "content": "A concept cannot be explicitly instantiated.", "function": ""}, {"id": "cpp20_temp_concept_no_explicit_specialization_4f5e6d7c", "label": "cpp20_temp_concept_no_explicit_specializ", "x": 658.2188228754678, "y": 566.6301790985984, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/5", "content": "A concept cannot be explicitly specialized.", "function": ""}, {"id": "cpp20_temp_concept_no_partial_specialization_2a3b4c5d", "label": "cpp20_temp_concept_no_partial_specializa", "x": -345.61840746949935, "y": 695.7403256636738, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/5", "content": "A concept cannot be partially specialized.", "function": ""}, {"id": "cpp20_temp_concept_not_instantiated_5d6e7f8a", "label": "cpp20_temp_concept_not_instantiated_5d6e", "x": -945.3240838421092, "y": 175.5781253598902, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/5", "content": "A concept is not instantiated.", "function": ""}, {"id": "cpp20_temp_concept_constraint_expr_unevaluated_1e2f3a4b", "label": "cpp20_temp_concept_constraint_expr_uneva", "x": -462.4039207749022, "y": -693.2911551161699, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/6", "content": "The constraint-expression of a concept-definition is an unevaluated operand.", "function": ""}, {"id": "cpp20_temp_concept_prototype_parameter_defined_6b7c8d9e", "label": "cpp20_temp_concept_prototype_parameter_d", "x": -870.2035955816532, "y": 312.3045234629642, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/7", "content": "The first declared template parameter of a concept definition is its prototype parameter.", "function": ""}, {"id": "cpp20_temp_concept_type_concept_definition_3c4d5e6f", "label": "cpp20_temp_concept_type_concept_definiti", "x": -339.31865257744886, "y": 562.8709585962122, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.concept]/7", "content": "A type concept is a concept whose prototype parameter is a type template parameter.", "function": ""}, {"id": "cpp20_temp_expl_spec_each_enclosing_template_prefix_c3d4e5f6", "label": "cpp20_temp_expl_spec_each_enclosing_temp", "x": -113.38284602301442, "y": 47.016586879562276, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.expl.spec]/15", "content": "In an explicit specialization for a member nested within many enclosing class templates, the member declaration shall be preceded by a template<> for each enclosing class template that is explicitly specialized.", "function": ""}, {"id": "cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0", "label": "cpp20_temp_expl_spec_unspecialized_enclo", "x": -129.96624835493805, "y": 73.43977727413547, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.expl.spec]/16", "content": "In an explicit specialization where some enclosing class templates remain unspecialized, the keyword template followed by a template-parameter-list shall be provided instead of the template<> preceding the member, and the types of template-parameters shall be the same as in the primary template defi", "function": ""}, {"id": "cpp20_temp_expl_spec_member_explicit_definition_required_e5f6a7b8", "label": "cpp20_temp_expl_spec_member_explicit_def", "x": -116.9275390308022, "y": 51.24479323108714, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.expl.spec]/6", "content": "A member of an explicitly specialized class is not implicitly instantiated from the class template; the member shall itself be explicitly defined if its definition is required.", "function": ""}, {"id": "cpp20_temp_expl_spec_after_use_error_f9a0b1c2", "label": "cpp20_temp_expl_spec_after_use_error_f9a", "x": -190.67222863672274, "y": 105.76598665236995, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.expl.spec]/7", "content": "If a specialization is declared after a use of the primary template that would cause an implicit instantiation, and no declaration of the explicit specialization was reachable from that use, the program is ill-formed.", "function": ""}, {"id": "cpp20_temp_explicit_class_elaborated_type_specifier_e5f6a7b8", "label": "cpp20_temp_explicit_class_elaborated_typ", "x": -120.61795380408746, "y": 55.31855323735554, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.explicit]/4", "content": "If the explicit instantiation is for a class or member class, the elaborated-type-specifier in the declaration shall include a simple-template-id.", "function": ""}, {"id": "cpp20_temp_explicit_single_init_declarator_no_initializer_a3b4c5d6", "label": "cpp20_temp_explicit_single_init_declarat", "x": 28.38860234747812, "y": 0.6051349891326313, "size": 4.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.explicit]/4", "content": "For explicit instantiation of non-class entities, the declaration shall be a simple-declaration whose init-declarator-list comprises a single init-declarator that does not have an initializer.", "function": ""}, {"id": "cpp20_temp_explicit_variable_unqualified_id_simple_template_id_c9d0e1f2", "label": "cpp20_temp_explicit_variable_unqualified", "x": -202.95440524797348, "y": 123.06977860875587, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.explicit]/4", "content": "If the explicit instantiation is for a variable template specialization, the unqualified-id in the declarator shall be a simple-template-id.", "function": ""}, {"id": "cpp20_temp_explicit_deduced_return_type_mismatch_b1c2d3e4", "label": "cpp20_temp_explicit_deduced_return_type_", "x": 818.761746819745, "y": 461.1976423609805, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.explicit]/6", "content": "An explicit instantiation of a function with a deduced return type redeclared with a non-deduced return type is ill-formed.", "function": ""}, {"id": "cpp20_temp_explicit_type_mismatch_error_d7e8f9a0", "label": "cpp20_temp_explicit_type_mismatch_error_", "x": 958.8498152465442, "y": -236.09931420107273, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.explicit]/6", "content": "The declaration in an explicit instantiation and the declaration produced by the corresponding substitution into the templated entity must have matching types, otherwise the program is ill-formed.", "function": ""}, {"id": "cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6", "label": "cpp20_temp_inst_no_implicit_unless_requi", "x": -126.7823604383373, "y": 76.6817734169654, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/11", "content": "An implementation shall not implicitly instantiate a function template, variable template, member template, non-virtual member function, member class, static data member of a templated class, or a substatement of a constexpr if statement, unless such instantiation is required.", "function": ""}, {"id": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "label": "cpp20_temp_inst_constraint_no_valid_spec", "x": -138.19200024292255, "y": 42.36788089329864, "size": 18, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/17", "content": "A template with constraints that have no valid specializations is ill-formed, no diagnostic required.", "function": ""}, {"id": "cpp20_temp_inst_requires_invalid_expression_ndr_d7e8f9a0", "label": "cpp20_temp_inst_requires_invalid_express", "x": -189.0429394028619, "y": 148.66249176898987, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/17", "content": "A template with a requires-clause containing an expression that would never result in a valid expression for any substitution is ill-formed, no diagnostic required.", "function": ""}, {"id": "cpp20_temp_inst_incomplete_class_error_a7b8c9d0", "label": "cpp20_temp_inst_incomplete_class_error_a", "x": -140.39789827876962, "y": 56.58086020034857, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/2", "content": "Using an incomplete class type X<T> where T requires a complete type results in an error when the template is declared but not defined.", "function": ""}, {"id": "cpp20_temp_inst_deleted_member_redefinition_error_c5d6e7f8", "label": "cpp20_temp_inst_deleted_member_redefinit", "x": -203.39192768184813, "y": 108.50900016697354, "size": 4.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/3", "content": "An explicit specialization of a deleted member function template is ill-formed as it constitutes a redefinition.", "function": ""}, {"id": "cpp20_temp_inst_friend_def_second_error_e1f2a3b4", "label": "cpp20_temp_inst_friend_def_second_error_", "x": -128.11228691720518, "y": 43.83062118768464, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/3", "content": "Instantiating a class template that produces a second definition of a friend function via friend function definition is ill-formed.", "function": ""}, {"id": "cpp20_temp_inst_constant_evaluation_affects_semantics_d1e2f3a4", "label": "cpp20_temp_inst_constant_evaluation_affe", "x": -347.4732367076498, "y": -576.6933902262472, "size": 3.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/8", "content": "The existence of a definition of a variable or function is considered to affect the semantics of the program if the variable or function is needed for constant evaluation by an expression, even if constant evaluation is not required or does not use the definition.", "function": ""}, {"id": "cpp20_temp_inst_narrowing_instantiation_error_b5c6d7e8", "label": "cpp20_temp_inst_narrowing_instantiation_", "x": -40.83931437245095, "y": -14.928916070240492, "size": 5.5, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.inst]/8", "content": "A function template specialization is implicitly instantiated when referenced in a context that requires the definition to exist, including when needed for constant evaluation in a narrowing conversion context.", "function": ""}, {"id": "cpp20_temp_explicit_simple_template_id_variable_class_a1b2c3d4", "label": "cpp20_temp_explicit_simple_template_id_v", "x": -106.29059814228803, "y": 57.48775144271564, "size": 5.0, "color": "#45aaf2", "layer": "cpp20_language", "module": "[temp.spec.general]/3", "content": "In an explicit specialization declaration for a variable template, class template, member of a class template, or class member template, the variable or class being specialized shall be specified with a simple-template-id.", "function": ""}, {"id": "cpp20_accumulate_precond_binary_op_no_modify_b9c4e7f2", "label": "cpp20_accumulate_precond_binary_op_no_mo", "x": 977.618964839455, "y": -79.5187858750161, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[accumulate]/1", "content": "In the range [first, last], binary_op must neither modify elements nor invalidate iterators or subranges.", "function": "std::accumulate"}, {"id": "cpp20_accumulate_precond_t_copyconstructible_a8f3d2e1", "label": "cpp20_accumulate_precond_t_copyconstruct", "x": -316.70071178843506, "y": 578.8046727922481, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[accumulate]/1", "content": "Type T must meet Cpp17CopyConstructible and Cpp17CopyAssignable requirements for std::accumulate.", "function": "std::accumulate"}, {"id": "cpp20_adjacent_difference_mandate_no_exec_e3f8b6c1", "label": "cpp20_adjacent_difference_mandate_no_exe", "x": -415.6549999009149, "y": 833.8848599166089, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[adjacent.difference]/2", "content": "For overloads with no ExecutionPolicy, T (value type of decltype(first)) must be constructible from *first, acc must be writable to result, and the result of binary_op(val, std::move(acc)) must be writable to result.", "function": "std::adjacent_difference"}, {"id": "cpp20_adjacent_difference_mandate_with_exec_f4a9c7d2", "label": "cpp20_adjacent_difference_mandate_with_e", "x": 480.7143278572538, "y": -784.044280610665, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[adjacent.difference]/2", "content": "For overloads with ExecutionPolicy, the results of binary_op(*first, *first) and *first must be writable to result.", "function": "std::adjacent_difference"}, {"id": "cpp20_adjacent_difference_precond_no_exec_a5b0d8e3", "label": "cpp20_adjacent_difference_precond_no_exe", "x": -103.26864385857816, "y": 817.2646399723776, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[adjacent.difference]/3", "content": "For overloads with no ExecutionPolicy, T must meet Cpp17MoveAssignable requirements.", "function": "std::adjacent_difference"}, {"id": "cpp20_adjacent_difference_precond_no_modify_b6c1e9f4", "label": "cpp20_adjacent_difference_precond_no_mod", "x": 892.2161508547811, "y": -48.21265154121527, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[adjacent.difference]/3", "content": "In the ranges [first, last] and [result, result+(last-first)], binary_op must neither modify elements nor invalidate iterators or subranges.", "function": "std::adjacent_difference"}, {"id": "cpp20_algorithms_requirements_condition_boolean_result_c3d4e5f6", "label": "cpp20_algorithms_requirements_condition_", "x": 189.25688620517857, "y": -777.0924292453178, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/10", "content": "When the description of an algorithm gives an expression such as *first == value for a condition, the expression shall evaluate to either true or false in boolean contexts.", "function": ""}, {"id": "cpp20_algorithms_requirements_integer_like_difference_type_cast_s9t0u1v2", "label": "cpp20_algorithms_requirements_integer_li", "x": -168.16932734102562, "y": -266.1785319386628, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/12", "content": "Given an iterator a whose difference type is D, and an expression n of integer-like type other than cv D, the semantics of a+n and a-n are, respectively, those of a+D(n) and a-D(n).", "function": ""}, {"id": "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6", "label": "cpp20_algorithms_requirements_sentinel_t", "x": -215.14163904671238, "y": -227.50141293985322, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/13", "content": "In algorithm return values, when a sentinel value s denoting the end of a range [i, s) is returned where an iterator is expected, the semantics are as if the sentinel is converted into an iterator using ranges::next(i, s).", "function": ""}, {"id": "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4", "label": "cpp20_algorithms_requirements_ranges_dis", "x": -126.90937423009358, "y": -159.86125417361407, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/14.1", "content": "Overloads of algorithms that take range arguments behave as if a corresponding iterator argument is initialized with ranges::begin(r).", "function": ""}, {"id": "cpp20_algorithms_requirements_ranges_dispatch_end_o5p6q7r8", "label": "cpp20_algorithms_requirements_ranges_dis", "x": -116.08049047501986, "y": -154.63322956975097, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/14.2", "content": "Overloads of algorithms that take range arguments behave as if a corresponding sentinel argument is initialized with ranges::end(r), or ranges::next(ranges::begin(r), ranges::end(r)) if the type of r models forward_range and computing ranges::next meets the specified complexity requirements.", "function": ""}, {"id": "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0", "label": "cpp20_algorithms_requirements_explicit_t", "x": -177.85751539979094, "y": 32.070994895652035, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/15", "content": "The well-formedness and behavior of a call to an algorithm with an explicitly-specified template argument list is unspecified, except where explicitly stated otherwise.", "function": ""}, {"id": "cpp20_algorithms_requirements_no_data_race_modify_a3b7c9d1", "label": "cpp20_algorithms_requirements_no_data_ra", "x": -209.0434423206932, "y": -236.10762074584204, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/3", "content": "Algorithms shall not modify objects referenced through an iterator argument unless the specification requires such modification, for purposes of determining the existence of data races.", "function": ""}, {"id": "cpp20_algorithms_requirements_mutable_iterator_required_e5f2a8b4", "label": "cpp20_algorithms_requirements_mutable_it", "x": -276.9774323189176, "y": -203.85850084499603, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.1", "content": "If an algorithm's Effects element specifies that a value pointed to by any iterator passed as argument is modified, then the type of that argument shall meet the requirements of a mutable iterator.", "function": ""}, {"id": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "label": "cpp20_algorithms_requirements_inputitera", "x": -157.0516165769612, "y": -9.756674050455121, "size": 12.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.2", "content": "If an algorithm's template parameter is named InputIterator, InputIterator1, or InputIterator2, the template argument shall meet the Cpp17InputIterator requirements.", "function": ""}, {"id": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "label": "cpp20_algorithms_requirements_outputiter", "x": -160.90681197018077, "y": 37.35050447015677, "size": 11.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.3", "content": "If an algorithm's template parameter is named OutputIterator, OutputIterator1, or OutputIterator2, the template argument shall meet the Cpp17OutputIterator requirements.", "function": ""}, {"id": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "label": "cpp20_algorithms_requirements_forwardite", "x": -180.55746743714775, "y": -49.43147727065591, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.4", "content": "If an algorithm's template parameter is named ForwardIterator, ForwardIterator1, ForwardIterator2, or NoThrowForwardIterator, the template argument shall meet the Cpp17ForwardIterator requirements if it is required to be a mutable iterator, or model forward_iterator otherwise.", "function": ""}, {"id": "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2", "label": "cpp20_algorithms_requirements_nothrow_fo", "x": -192.61419906161075, "y": 60.1813495956235, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.5", "content": "If an algorithm's template parameter is named NoThrowForwardIterator, the template argument is required to have the property that no exceptions are thrown from increment, assignment, or comparison of, or indirection through, valid iterators.", "function": ""}, {"id": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "label": "cpp20_algorithms_requirements_bidirectio", "x": -191.25342734443038, "y": -40.08189104110174, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.6", "content": "If an algorithm's template parameter is named BidirectionalIterator, BidirectionalIterator1, or BidirectionalIterator2, the template argument shall meet the Cpp17BidirectionalIterator requirements if it is required to be a mutable iterator, or model bidirectional_iterator otherwise.", "function": ""}, {"id": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "label": "cpp20_algorithms_requirements_randomacce", "x": -170.68122553166404, "y": -44.370568908467654, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/4.7", "content": "If an algorithm's template parameter is named RandomAccessIterator, RandomAccessIterator1, or RandomAccessIterator2, the template argument shall meet the Cpp17RandomAccessIterator requirements if it is required to be a mutable iterator, or model random_access_iterator otherwise.", "function": ""}, {"id": "cpp20_algorithms_requirements_predicate_glvalue_equivalence_k9l0m1n2", "label": "cpp20_algorithms_requirements_predicate_", "x": -74.96240082764861, "y": 24.34797770668323, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/6", "content": "Given a glvalue u of type (possibly const) T that designates the same object as *first, pred(u) shall be a valid expression that is equal to pred(*first).", "function": ""}, {"id": "cpp20_algorithms_requirements_predicate_no_nonconst_apply_g5h6i7j8", "label": "cpp20_algorithms_requirements_predicate_", "x": -708.7659957807185, "y": 569.0954414835052, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/6", "content": "The Predicate function object shall not apply any non-constant function through its argument.", "function": ""}, {"id": "cpp20_algorithms_requirements_predicate_wellformed_c1d2e3f4", "label": "cpp20_algorithms_requirements_predicate_", "x": -259.9722801384483, "y": -222.0165200163077, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/6", "content": "When Predicate pred is an algorithm argument and first is its iterator argument with value type T, the expression pred(*first) shall be well-formed and the type decltype(pred(*first)) shall model boolean-testable.", "function": ""}, {"id": "cpp20_algorithms_requirements_binarypredicate_glvalue_equivalence_a5b6c7d8", "label": "cpp20_algorithms_requirements_binarypred", "x": 579.7699498961322, "y": 764.8317229780451, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/7", "content": "Given glvalues u of type (possibly const) T1 designating the same object as *first1, and v of type (possibly const) T2 designating the same object as *first2, binary_pred(u, *first2), binary_pred(*first1, v), and binary_pred(u, v) shall each be a valid expression equal to binary_pred(*first1, *first", "function": ""}, {"id": "cpp20_algorithms_requirements_binarypredicate_no_nonconst_apply_w1x2y3z4", "label": "cpp20_algorithms_requirements_binarypred", "x": 691.0884644952433, "y": 522.4709972844979, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/7", "content": "The BinaryPredicate function object shall not apply any non-constant function through any of its arguments.", "function": ""}, {"id": "cpp20_algorithms_requirements_binarypredicate_value_glvalue_equiv_e9f0a1b2", "label": "cpp20_algorithms_requirements_binarypred", "x": -81.0489092547282, "y": 26.044791096405316, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/7", "content": "Given a glvalue u of type (possibly const) T1 designating the same object as *first1, binary_pred(u, value) shall be a valid expression that is equal to binary_pred(*first1, value).", "function": ""}, {"id": "cpp20_algorithms_requirements_binarypredicate_value_wellformed_s7t8u9v0", "label": "cpp20_algorithms_requirements_binarypred", "x": -836.4089374033532, "y": -105.20595426994484, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/7", "content": "When T value is part of the signature, the expression binary_pred(*first1, value) shall be well-formed and the type decltype(binary_pred(*first1, value)) shall model boolean-testable.", "function": ""}, {"id": "cpp20_algorithms_requirements_binarypredicate_wellformed_o3p4q5r6", "label": "cpp20_algorithms_requirements_binarypred", "x": -238.39058793839465, "y": -224.44208071107457, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[algorithms.requirements]/7", "content": "If an algorithm takes BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments with respective value types T1 and T2, the expression binary_pred(*first1, *first2) shall be well-formed and the type decltype(binary_pred(*first1, *first2)) shall model boolean-testable", "function": ""}, {"id": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "label": "cpp20_any_copy_assignment_exception_safe", "x": 13.417811445133923, "y": -19.38482480369263, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.assign]/1", "content": "any::operator=(const any&) has no effects if an exception is thrown during copy construction.", "function": "std::any::operator="}, {"id": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "label": "cpp20_any_template_assignment_exception_", "x": -3.6444515023907837, "y": -14.464878156759937, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.assign]/10", "content": "any::operator=(T&&) has no effects if an exception is thrown during construction.", "function": "std::any::operator="}, {"id": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "label": "cpp20_any_move_assignment_noexcept_f9a0b", "x": 97.36324741294288, "y": -106.18999898244152, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.assign]/4", "content": "The move assignment operator any::operator=(any&&) is noexcept.", "function": "std::any::operator="}, {"id": "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4", "label": "cpp20_any_template_assign_precondition_c", "x": -36.26451328059943, "y": -6.7660186757272704, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.assign]/9", "content": "The template assignment operator any::operator=(T&&) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.", "function": "std::any::operator="}, {"id": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4", "label": "cpp20_any_bad_any_cast_exception_purpose", "x": 201.17121861809375, "y": -51.57601991275953, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.bad.any.cast]/1", "content": "Objects of type bad_any_cast are thrown by a failed any_cast operation.", "function": "bad_any_cast"}, {"id": "cpp20_any_small_object_optimization_constraint_e5f6a7b8", "label": "cpp20_any_small_object_optimization_cons", "x": 724.8389317147153, "y": -275.2296122246128, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.class.general]/3", "content": "Small-object optimization for std::any shall only be applied to types T for which is_nothrow_move_constructible_v<T> is true.", "function": ""}, {"id": "cpp20_any_default_ctor_postcondition_no_value_d1e2f3a4", "label": "cpp20_any_default_ctor_postcondition_no_", "x": 26.02674863411585, "y": 60.4382100425778, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.cons]/1", "content": "After default construction, any::has_value() is false.", "function": "std::any::any"}, {"id": "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6", "label": "cpp20_any_inplace_ctor_precondition_copy", "x": 37.49763359506759, "y": -26.550350133980395, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.cons]/12", "content": "The in-place constructor any(in_place_type_t<T>, Args&&...) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.", "function": "std::any::any"}, {"id": "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0", "label": "cpp20_any_inplace_initlist_ctor_precondi", "x": 67.72169935016242, "y": -37.10655705579832, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.cons]/18", "content": "The in-place constructor with initializer_list any(in_place_type_t<T>, initializer_list<U>, Args&&...) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.", "function": "std::any::any"}, {"id": "cpp20_any_destructor_calls_reset_d9e0f1a2", "label": "cpp20_any_destructor_calls_reset_d9e0f1a", "x": -107.35127803787323, "y": 184.1930965651978, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.cons]/22", "content": "The any destructor has the effect of calling reset().", "function": "std::any::~any"}, {"id": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "label": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "x": 84.41790683250471, "y": -70.84922212175611, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.cons]/4", "content": "The move constructor any(any&&) is noexcept.", "function": "std::any::any"}, {"id": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "label": "cpp20_any_template_ctor_precondition_cop", "x": -25.368929674171984, "y": 9.959799635837172, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.cons]/7", "content": "The template constructor any(T&& value) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.", "function": "std::any::any"}, {"id": "cpp20_any_emplace_initlist_precondition_copyconstruct_d9e0f1a2", "label": "cpp20_any_emplace_initlist_precondition_", "x": 81.23180033285527, "y": -72.89930260002791, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/11", "content": "The emplace member function with initializer_list requires that decay_t<T> meets the Cpp17CopyConstructible requirements.", "function": "std::any::emplace"}, {"id": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "label": "cpp20_any_emplace_initlist_exception_sta", "x": 25.177638082686155, "y": -12.4268372447227, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/16", "content": "If an exception is thrown during emplace with initializer_list's call to VT's constructor, the any object does not contain a value, and any previously contained value has been destroyed.", "function": "std::any::emplace"}, {"id": "cpp20_any_reset_destroys_contained_value_f5a6b7c8", "label": "cpp20_any_reset_destroys_contained_value", "x": 63.07812277849184, "y": -26.637822071668865, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/17", "content": "any::reset() destroys the contained value if has_value() is true.", "function": "std::any::reset"}, {"id": "cpp20_any_reset_noexcept_b7c8d9e0", "label": "cpp20_any_reset_noexcept_b7c8d9e0", "x": 163.73651381769977, "y": -69.61819761104816, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/17", "content": "The reset member function any::reset() is noexcept.", "function": "std::any::reset"}, {"id": "cpp20_any_swap_noexcept_d3e4f5a6", "label": "cpp20_any_swap_noexcept_d3e4f5a6", "x": 132.54113309751196, "y": -97.88135883134308, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/19", "content": "The swap member function any::swap(any&) is noexcept.", "function": "std::any::swap"}, {"id": "cpp20_any_emplace_precondition_copyconstruct_f5a6b7c8", "label": "cpp20_any_emplace_precondition_copyconst", "x": 125.10409801600258, "y": -145.40467340946353, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/3", "content": "The emplace member function requires that decay_t<T> meets the Cpp17CopyConstructible requirements.", "function": "std::any::emplace"}, {"id": "cpp20_any_emplace_exception_state_b3c4d5e6", "label": "cpp20_any_emplace_exception_state_b3c4d5", "x": 21.538872098563044, "y": 8.082921725730161, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.modifiers]/8", "content": "If an exception is thrown during emplace's call to VT's constructor, the any object does not contain a value, and any previously contained value has been destroyed.", "function": "std::any::emplace"}, {"id": "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6", "label": "cpp20_any_cast_const_pointer_returns_nul", "x": -118.39530520719171, "y": -94.96272811491599, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/10", "content": "any_cast<T>(const any*) returns nullptr if operand is nullptr or if operand->type() != typeid(T).", "function": "any_cast"}, {"id": "cpp20_any_cast_pointer_returns_nullptr_type_mismatch_b9c0d1e2", "label": "cpp20_any_cast_pointer_returns_nullptr_t", "x": -155.02859384532533, "y": -58.401513203717535, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/10", "content": "any_cast<T>(any*) returns nullptr if operand is nullptr or if operand->type() != typeid(T).", "function": "any_cast"}, {"id": "cpp20_any_cast_const_ref_mandates_constructible_d3e4f5a6", "label": "cpp20_any_cast_const_ref_mandates_constr", "x": 141.14262805907345, "y": -112.30030197570196, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/5", "content": "any_cast<T>(const any&) mandates that is_constructible_v<T, const U&> is true where U is remove_cvref_t<T>.", "function": "any_cast"}, {"id": "cpp20_any_cast_lvalue_ref_mandates_constructible_b7c8d9e0", "label": "cpp20_any_cast_lvalue_ref_mandates_const", "x": 160.44073766396133, "y": -114.18077878697075, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/5", "content": "any_cast<T>(any&) mandates that is_constructible_v<T, U&> is true where U is remove_cvref_t<T>.", "function": "any_cast"}, {"id": "cpp20_any_cast_rvalue_ref_mandates_constructible_f1a2b3c4", "label": "cpp20_any_cast_rvalue_ref_mandates_const", "x": 110.91172019299819, "y": -150.5794953555396, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/5", "content": "any_cast<T>(any&&) mandates that is_constructible_v<T, U> is true where U is remove_cvref_t<T>.", "function": "any_cast"}, {"id": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "label": "cpp20_any_cast_ref_lvalue_throws_bad_any", "x": 111.44755517720415, "y": -61.793162430759054, "size": 8.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/7", "content": "any_cast for lvalue reference throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>).", "function": "any_cast"}, {"id": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "label": "cpp20_any_cast_ref_throws_bad_any_cast_d", "x": 146.71505973133182, "y": -69.04990858670126, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/7", "content": "any_cast for reference types throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>).", "function": "any_cast"}, {"id": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "label": "cpp20_any_cast_rvalue_throws_bad_any_cas", "x": 132.81751613689775, "y": -58.88429292520952, "size": 8.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/7", "content": "any_cast for rvalue reference throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>).", "function": "any_cast"}, {"id": "cpp20_any_cast_pointer_mandates_not_void_d5e6f7a8", "label": "cpp20_any_cast_pointer_mandates_not_void", "x": -153.3379990508264, "y": -34.255398604086956, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.nonmembers]/9", "content": "any_cast<T>(const any*) and any_cast<T>(any*) mandate that is_void_v<T> is false.", "function": "any_cast"}, {"id": "cpp20_any_has_value_returns_true_when_contains_b1c2d3e4", "label": "cpp20_any_has_value_returns_true_when_co", "x": 321.3998203237138, "y": -859.8870168009753, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.observers]/1", "content": "any::has_value() returns true if the any object contains an object, otherwise false.", "function": "std::any::has_value"}, {"id": "cpp20_any_type_returns_void_when_empty_d7e8f9a0", "label": "cpp20_any_type_returns_void_when_empty_d", "x": 155.91592818732622, "y": -48.997503755208605, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[any.observers]/2", "content": "any::type() returns typeid(void) if the any object has no contained value.", "function": "std::any::type"}, {"id": "cpp20_atomics_fences_thread_fence_relaxed_no_effect_1e9a4c7b", "label": "cpp20_atomics_fences_thread_fence_relaxe", "x": -311.63885465817907, "y": 222.96782877750505, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/5.1", "content": "atomic_thread_fence with memory_order::relaxed has no synchronization effects.", "function": "atomic_thread_fence"}, {"id": "cpp20_atomics_fences_thread_fence_acquire_effect_8f2d6a3e", "label": "cpp20_atomics_fences_thread_fence_acquir", "x": -320.5131840728048, "y": 215.82349105835758, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/5.2", "content": "atomic_thread_fence with memory_order::acquire is an acquire fence.", "function": "atomic_thread_fence"}, {"id": "cpp20_atomics_fences_thread_fence_release_effect_4b7c9e2d", "label": "cpp20_atomics_fences_thread_fence_releas", "x": -293.1358562580923, "y": 205.5694485677267, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/5.3", "content": "atomic_thread_fence with memory_order::release is a release fence.", "function": "atomic_thread_fence"}, {"id": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f", "label": "cpp20_atomics_fences_thread_fence_acq_re", "x": -291.8842662688281, "y": 184.1428634208678, "size": 8.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/5.4", "content": "atomic_thread_fence with memory_order::acq_rel is both an acquire fence and a release fence.", "function": "atomic_thread_fence"}, {"id": "cpp20_atomics_fences_thread_fence_seq_cst_effect_9c3e7f1a", "label": "cpp20_atomics_fences_thread_fence_seq_cs", "x": -313.9045457859561, "y": 221.80135350555088, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/5.5", "content": "atomic_thread_fence with memory_order::seq_cst is a sequentially consistent acquire and release fence.", "function": "atomic_thread_fence"}, {"id": "cpp20_atomics_fences_signal_fence_scope_6d2b8e5c", "label": "cpp20_atomics_fences_signal_fence_scope_", "x": 163.60211071853274, "y": 182.06623249950695, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/6", "content": "atomic_signal_fence is equivalent to atomic_thread_fence except that the resulting ordering constraints are established only between a thread and a signal handler executed in the same thread.", "function": "atomic_signal_fence"}, {"id": "cpp20_atomics_fences_signal_fence_no_hw_fence_a4f2c9d7", "label": "cpp20_atomics_fences_signal_fence_no_hw_", "x": -355.90692463779976, "y": 166.1929129881591, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.fences]/7", "content": "atomic_signal_fence inhibits compiler optimizations and reorderings like atomic_thread_fence but does not emit hardware fence instructions.", "function": "atomic_signal_fence"}, {"id": "cpp20_atomics_ref_float_store_key_const_constraint_a7b1c5d9", "label": "cpp20_atomics_ref_float_store_key_const_", "x": -7.7527992796633, "y": 702.6363458898362, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/11", "content": "The store_key operations on floating-point types are constrained: is_const_v<floating-point-type> must be false.", "function": "std::atomic_ref<floating-point-type>::store_add"}, {"id": "cpp20_atomics_ref_float_store_key_order_precondition_b8c2d6e0", "label": "cpp20_atomics_ref_float_store_key_order_", "x": 599.0486044521473, "y": -130.46934382319185, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/12", "content": "The store_key operations on floating-point types require order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic_ref<floating-point-type>::store_add"}, {"id": "cpp20_atomics_ref_float_store_unrepresentable_result_unspecified_c9d3e7f1", "label": "cpp20_atomics_ref_float_store_unrepresen", "x": -295.8168715928822, "y": 955.2475303940566, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/14", "content": "For floating-point store_key operations, if the result is not a representable value for its type, the result is unspecified, but the operations otherwise have no undefined behavior.", "function": "std::atomic_ref<floating-point-type>::store_add"}, {"id": "cpp20_atomics_ref_float_operator_compound_const_constraint_d0e4f8a2", "label": "cpp20_atomics_ref_float_operator_compoun", "x": -471.95685145709933, "y": -295.60679678447644, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/17", "content": "The compound assignment operators on floating-point atomic_ref are constrained: is_const_v<floating-point-type> must be false.", "function": "std::atomic_ref<floating-point-type>::operator+="}, {"id": "cpp20_atomics_ref_float_volatile_lock_free_constraint_d4e8f2a6", "label": "cpp20_atomics_ref_float_volatile_lock_fr", "x": -673.1205406694094, "y": 513.4697575853189, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/2", "content": "For floating-point specializations, the program is ill-formed if is_always_lock_free is false and is_volatile_v<floating-point-type> is true.", "function": "std::atomic_ref<floating-point-type>"}, {"id": "cpp20_atomics_ref_float_fetch_key_const_constraint_e5f9a3b7", "label": "cpp20_atomics_ref_float_fetch_key_const_", "x": 421.99483545823017, "y": -606.1661585297057, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/5", "content": "The fetch_key operations on floating-point types are constrained: is_const_v<floating-point-type> must be false.", "function": "std::atomic_ref<floating-point-type>::fetch_add"}, {"id": "cpp20_atomics_ref_float_unrepresentable_result_unspecified_f6a0b4c8", "label": "cpp20_atomics_ref_float_unrepresentable_", "x": -862.3241034345014, "y": 260.884859512526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.float]/8", "content": "For floating-point fetch_key operations, if the result is not a representable value for its type, the result is unspecified, but the operations otherwise have no undefined behavior.", "function": "std::atomic_ref<floating-point-type>::fetch_add"}, {"id": "cpp20_atomics_ref_generic_trivially_copyable_constraint_a3b7c9d1", "label": "cpp20_atomics_ref_generic_trivially_copy", "x": 380.6102640969933, "y": -537.0806393764019, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.generic.general]/2", "content": "The program is ill-formed if is_trivially_copyable_v<T> is false for atomic_ref<T>.", "function": "std::atomic_ref"}, {"id": "cpp20_atomics_ref_generic_exclusive_access_b4c8d2e6", "label": "cpp20_atomics_ref_generic_exclusive_acce", "x": 786.93666899384, "y": -516.0887456995697, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.generic.general]/3", "content": "While any atomic_ref instances exist that reference an object, all accesses to that object shall exclusively occur through those atomic_ref instances.", "function": "std::atomic_ref"}, {"id": "cpp20_atomics_ref_generic_lifetime_precondition_e5f2a8c4", "label": "cpp20_atomics_ref_generic_lifetime_preco", "x": -77.91548140716473, "y": 917.2151049630962, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.generic.general]/3", "content": "The lifetime of an object referenced by atomic_ref shall exceed the lifetime of all atomic_refs that reference the object.", "function": "std::atomic_ref"}, {"id": "cpp20_atomics_ref_generic_no_subobject_concurrent_ref_f9a3b7c1", "label": "cpp20_atomics_ref_generic_no_subobject_c", "x": -274.7339706269218, "y": 509.4617046368587, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.generic.general]/3", "content": "No subobject of the object referenced by atomic_ref shall be concurrently referenced by any other atomic_ref object.", "function": "std::atomic_ref"}, {"id": "cpp20_atomics_ref_generic_volatile_lock_free_constraint_d8e2f4a6", "label": "cpp20_atomics_ref_generic_volatile_lock_", "x": -261.34814568002895, "y": -605.7040608766175, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.generic.general]/5", "content": "The program is ill-formed if is_always_lock_free is false and is_volatile_v<T> is true for atomic_ref<T>.", "function": "std::atomic_ref"}, {"id": "cpp20_atomics_ref_int_store_key_const_constraint_a1b5c9d3", "label": "cpp20_atomics_ref_int_store_key_const_co", "x": 974.6146442337474, "y": -130.32638520272346, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.int]/10", "content": "The store_key operations on integral types are constrained: is_const_v<integral-type> must be false.", "function": "std::atomic_ref<integral-type>::store_add"}, {"id": "cpp20_atomics_ref_int_store_key_order_precondition_b2c6d0e4", "label": "cpp20_atomics_ref_int_store_key_order_pr", "x": 737.1651726961419, "y": -437.9666327572076, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.int]/11", "content": "The store_key operations on integral types require order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic_ref<integral-type>::store_add"}, {"id": "cpp20_atomics_ref_int_operator_compound_const_constraint_c3d7e1f5", "label": "cpp20_atomics_ref_int_operator_compound_", "x": -411.52279630994514, "y": -878.4177301167554, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.int]/14", "content": "The compound assignment operators on integral atomic_ref are constrained: is_const_v<integral-type> must be false.", "function": "std::atomic_ref<integral-type>::operator+="}, {"id": "cpp20_atomics_ref_int_volatile_lock_free_constraint_d8e2f4a6", "label": "cpp20_atomics_ref_int_volatile_lock_free", "x": 459.65803124371394, "y": -399.0683831585552, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.int]/2", "content": "For integral specializations, the program is ill-formed if is_always_lock_free is false and is_volatile_v<integral-type> is true.", "function": "std::atomic_ref<integral-type>"}, {"id": "cpp20_atomics_ref_int_fetch_key_const_constraint_e9f3a7b1", "label": "cpp20_atomics_ref_int_fetch_key_const_co", "x": 807.6235314487644, "y": -89.72743894396118, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.int]/5", "content": "The fetch_key operations on integral types are constrained: is_const_v<integral-type> must be false.", "function": "std::atomic_ref<integral-type>::fetch_add"}, {"id": "cpp20_atomics_ref_int_signed_overflow_no_ub_f0a4b8c2", "label": "cpp20_atomics_ref_int_signed_overflow_no", "x": 866.4674964225799, "y": -469.1026905916739, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.int]/8", "content": "For signed integer types in fetch_key operations (except fetch_max/fetch_min), the computation is performed as if converted to unsigned, computed, and converted back, resulting in no undefined behavior from overflow.", "function": "std::atomic_ref<integral-type>::fetch_add"}, {"id": "cpp20_atomics_ref_memop_increment_postfix_const_constraint_b0c4d8e2", "label": "cpp20_atomics_ref_memop_increment_postfi", "x": 695.4566625422852, "y": 472.93928644111566, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.memop]/2", "content": "The postfix increment operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false.", "function": "std::atomic_ref::operator++"}, {"id": "cpp20_atomics_ref_memop_decrement_postfix_const_constraint_c1d5e9f3", "label": "cpp20_atomics_ref_memop_decrement_postfi", "x": 473.2053155713857, "y": 668.0436288787631, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.memop]/4", "content": "The postfix decrement operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false.", "function": "std::atomic_ref::operator--"}, {"id": "cpp20_atomics_ref_memop_increment_prefix_const_constraint_d2e6f0a4", "label": "cpp20_atomics_ref_memop_increment_prefix", "x": 627.322865026924, "y": 314.412061112136, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.memop]/6", "content": "The prefix increment operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false.", "function": "std::atomic_ref::operator++"}, {"id": "cpp20_atomics_ref_memop_decrement_prefix_const_constraint_e3f7a1b5", "label": "cpp20_atomics_ref_memop_decrement_prefix", "x": -571.0423741824378, "y": -754.0708523008238, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.memop]/8", "content": "The prefix decrement operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false.", "function": "std::atomic_ref::operator--"}, {"id": "cpp20_atomics_ref_ops_required_alignment_minimum_a2b6c8d0", "label": "cpp20_atomics_ref_ops_required_alignment", "x": 909.1623867011174, "y": 212.5606856864586, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/1", "content": "The required_alignment for atomic_ref<T> is at least alignof(T).", "function": "std::atomic_ref::required_alignment"}, {"id": "cpp20_atomics_ref_ops_store_const_constraint_c1d5e9f3", "label": "cpp20_atomics_ref_ops_store_const_constr", "x": 738.0265930682742, "y": -79.89927331547604, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/11", "content": "The store operation is constrained: is_const_v<T> must be false.", "function": "std::atomic_ref::store"}, {"id": "cpp20_atomics_ref_ops_store_order_precondition_b8c2d6e0", "label": "cpp20_atomics_ref_ops_store_order_precon", "x": -655.1518699431214, "y": -616.5306421962202, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/12", "content": "The store operation requires order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic_ref::store"}, {"id": "cpp20_atomics_ref_ops_operator_assign_const_constraint_f4a8b2c6", "label": "cpp20_atomics_ref_ops_operator_assign_co", "x": 578.4813148661414, "y": -248.62992427975792, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/14", "content": "The assignment operator on atomic_ref is constrained: is_const_v<T> must be false.", "function": "std::atomic_ref::operator="}, {"id": "cpp20_atomics_ref_ops_load_order_precondition_a4b8c2d6", "label": "cpp20_atomics_ref_ops_load_order_precond", "x": -721.709415910942, "y": -42.52819382441701, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/16", "content": "The load operation requires order to be memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst.", "function": "std::atomic_ref::load"}, {"id": "cpp20_atomics_ref_ops_exchange_const_constraint_d2e6f0a4", "label": "cpp20_atomics_ref_ops_exchange_const_con", "x": -883.6747986996107, "y": 143.45484553864378, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/20", "content": "The exchange operation is constrained: is_const_v<T> must be false.", "function": "std::atomic_ref::exchange"}, {"id": "cpp20_atomics_ref_ops_cmpxchg_const_constraint_e3f7a1b5", "label": "cpp20_atomics_ref_ops_cmpxchg_const_cons", "x": -481.48527174976863, "y": 591.6639334385405, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/23", "content": "The compare_exchange operations are constrained: is_const_v<T> must be false.", "function": "std::atomic_ref::compare_exchange_weak"}, {"id": "cpp20_atomics_ref_ops_cmpxchg_failure_order_precondition_f4a8b2c6", "label": "cpp20_atomics_ref_ops_cmpxchg_failure_or", "x": -608.0876011257891, "y": -150.90882114634616, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/24", "content": "The compare_exchange operations require failure to be memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst.", "function": "std::atomic_ref::compare_exchange_weak"}, {"id": "cpp20_atomics_ref_ops_wait_order_precondition_a5b9c3d7", "label": "cpp20_atomics_ref_ops_wait_order_precond", "x": -793.7649023118682, "y": -602.8624184387056, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/28", "content": "The wait operation requires order to be memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst.", "function": "std::atomic_ref::wait"}, {"id": "cpp20_atomics_ref_ops_notify_one_const_constraint_b6c0d4e8", "label": "cpp20_atomics_ref_ops_notify_one_const_c", "x": -551.3061652658877, "y": -16.11574281194473, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/31", "content": "The notify_one operation is constrained: is_const_v<T> must be false.", "function": "std::atomic_ref::notify_one"}, {"id": "cpp20_atomics_ref_ops_notify_all_const_constraint_c7d1e5f9", "label": "cpp20_atomics_ref_ops_notify_all_const_c", "x": 230.8929939021466, "y": -594.1542947994548, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/34", "content": "The notify_all operation is constrained: is_const_v<T> must be false.", "function": "std::atomic_ref::notify_all"}, {"id": "cpp20_atomics_ref_ops_alignment_precondition_c7d1e5f9", "label": "cpp20_atomics_ref_ops_alignment_precondi", "x": 327.0901053695026, "y": 770.9617804046388, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/5", "content": "The object passed to atomic_ref constructor must be aligned to required_alignment.", "function": "std::atomic_ref::atomic_ref"}, {"id": "cpp20_atomics_ref_ops_converting_ctor_constraint_e4f8a2b6", "label": "cpp20_atomics_ref_ops_converting_ctor_co", "x": 437.65671105300794, "y": -854.6710588236541, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.ops]/9", "content": "The converting constructor from atomic_ref<U> requires T and U are similar types and is_convertible_v<U*, T*> is true.", "function": "std::atomic_ref::atomic_ref"}, {"id": "cpp20_atomics_ref_pointer_store_key_const_constraint_c5d9e3f7", "label": "cpp20_atomics_ref_pointer_store_key_cons", "x": -214.2356769863734, "y": -396.5534995983127, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/11", "content": "The store_key operations on pointer types are constrained: is_const_v<pointer-type> must be false.", "function": "std::atomic_ref<pointer-type>::store_add"}, {"id": "cpp20_atomics_ref_pointer_store_key_complete_type_mandate_d6e0f4a8", "label": "cpp20_atomics_ref_pointer_store_key_comp", "x": -338.8740907561492, "y": -369.45409648739667, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/12", "content": "The store_key operations on pointer types mandate that remove_pointer_t<pointer-type> is a complete object type.", "function": "std::atomic_ref<pointer-type>::store_add"}, {"id": "cpp20_atomics_ref_pointer_store_key_order_precondition_e7f1a5b9", "label": "cpp20_atomics_ref_pointer_store_key_orde", "x": -265.5951399815526, "y": -377.8920031161439, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/13", "content": "The store_key operations on pointer types require order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic_ref<pointer-type>::store_add"}, {"id": "cpp20_atomics_ref_pointer_store_undefined_address_no_ub_f8a2b6c0", "label": "cpp20_atomics_ref_pointer_store_undefine", "x": -350.83727837193715, "y": -389.1891554049259, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/15", "content": "For pointer store_key operations, the result may be an undefined address, but the operations otherwise have no undefined behavior.", "function": "std::atomic_ref<pointer-type>::store_add"}, {"id": "cpp20_atomics_ref_pointer_operator_compound_const_constraint_a9b3c7d1", "label": "cpp20_atomics_ref_pointer_operator_compo", "x": -197.29037524975797, "y": -382.5168491885833, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/16", "content": "The compound assignment operators on pointer atomic_ref are constrained: is_const_v<pointer-type> must be false.", "function": "std::atomic_ref<pointer-type>::operator+="}, {"id": "cpp20_atomics_ref_pointer_volatile_lock_free_constraint_e1f5a9b3", "label": "cpp20_atomics_ref_pointer_volatile_lock_", "x": -590.0142272646456, "y": 83.42597354504238, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/2", "content": "For pointer specializations, the program is ill-formed if is_always_lock_free is false and is_volatile_v<pointer-type> is true.", "function": "std::atomic_ref<pointer-type>"}, {"id": "cpp20_atomics_ref_pointer_fetch_key_const_constraint_f2a6b0c4", "label": "cpp20_atomics_ref_pointer_fetch_key_cons", "x": -286.9861129833246, "y": -373.4185909488927, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/5", "content": "The fetch_key operations on pointer types are constrained: is_const_v<pointer-type> must be false.", "function": "std::atomic_ref<pointer-type>::fetch_add"}, {"id": "cpp20_atomics_ref_pointer_fetch_key_complete_type_mandate_a3b7c1d5", "label": "cpp20_atomics_ref_pointer_fetch_key_comp", "x": -281.3259412637927, "y": -389.41258954945516, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/6", "content": "The fetch_key operations on pointer types mandate that remove_pointer_t<pointer-type> is a complete object type.", "function": "std::atomic_ref<pointer-type>::fetch_add"}, {"id": "cpp20_atomics_ref_pointer_undefined_address_no_ub_b4c8d2e6", "label": "cpp20_atomics_ref_pointer_undefined_addr", "x": -241.16312827967818, "y": -374.91952799399826, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.ref.pointer]/9", "content": "For pointer fetch_key operations, the result may be an undefined address, but the operations otherwise have no undefined behavior.", "function": "std::atomic_ref<pointer-type>::fetch_add"}, {"id": "cpp20_atomic_float_store_key_volatile_constraint_lock_free_e3f4a5b6", "label": "cpp20_atomic_float_store_key_volatile_co", "x": 177.81915069870288, "y": 583.8116720433429, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.float]/11", "content": "The volatile overload of atomic<floating-point-type>::store_key() is constrained by is_always_lock_free being true.", "function": "std::atomic::store_add"}, {"id": "cpp20_atomic_float_store_key_precond_order_valid_f4a5b6c7", "label": "cpp20_atomic_float_store_key_precond_ord", "x": 576.6207288408822, "y": -577.1077842248652, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.float]/12", "content": "Calling atomic<floating-point-type>::store_key() requires that order is memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic::store_add"}, {"id": "cpp20_atomic_float_operator_compound_volatile_constraint_lock_free_a5b6c7d8", "label": "cpp20_atomic_float_operator_compound_vol", "x": -571.4357177500368, "y": -663.4453696292816, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.float]/17", "content": "The volatile overload of atomic<floating-point-type>::operator+=/etc is constrained by is_always_lock_free being true.", "function": "std::atomic::operator+="}, {"id": "cpp20_atomic_float_fetch_key_volatile_constraint_lock_free_d2e3f4a5", "label": "cpp20_atomic_float_fetch_key_volatile_co", "x": 362.5807021012109, "y": 563.093995132795, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.float]/5", "content": "The volatile overload of atomic<floating-point-type>::fetch_key() is constrained by is_always_lock_free being true.", "function": "std::atomic::fetch_add"}, {"id": "cpp20_atomic_constraint_t_copy_assignable_d4e5f6a7", "label": "cpp20_atomic_constraint_t_copy_assignabl", "x": -751.683263163422, "y": 644.3800189381291, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.generic.general]/1", "content": "The template argument T for atomic<T> must satisfy is_copy_assignable_v<T> being true.", "function": "std::atomic"}, {"id": "cpp20_atomic_constraint_t_copy_constructible_b2c3d4e5", "label": "cpp20_atomic_constraint_t_copy_construct", "x": -943.3415582727605, "y": 102.8360969019996, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.generic.general]/1", "content": "The template argument T for atomic<T> must satisfy is_copy_constructible_v<T> being true.", "function": "std::atomic"}, {"id": "cpp20_atomic_constraint_t_move_assignable_e5f6a7b8", "label": "cpp20_atomic_constraint_t_move_assignabl", "x": 350.3786561818462, "y": 781.605871489983, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.generic.general]/1", "content": "The template argument T for atomic<T> must satisfy is_move_assignable_v<T> being true.", "function": "std::atomic"}, {"id": "cpp20_atomic_constraint_t_move_constructible_c3d4e5f6", "label": "cpp20_atomic_constraint_t_move_construct", "x": 433.454035361054, "y": 644.37904562048, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.generic.general]/1", "content": "The template argument T for atomic<T> must satisfy is_move_constructible_v<T> being true.", "function": "std::atomic"}, {"id": "cpp20_atomic_constraint_t_same_remove_cv_f6a7b8c9", "label": "cpp20_atomic_constraint_t_same_remove_cv", "x": -290.2249038441458, "y": 686.5494143737315, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.generic.general]/1", "content": "The template argument T for atomic<T> must satisfy is_same_v<T, remove_cv_t<T>> being true (T must not be cv-qualified).", "function": "std::atomic"}, {"id": "cpp20_atomic_constraint_t_trivially_copyable_a1b2c3d4", "label": "cpp20_atomic_constraint_t_trivially_copy", "x": -729.750303594788, "y": 602.3923437015443, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.generic.general]/1", "content": "The template argument T for atomic<T> must satisfy is_trivially_copyable_v<T> being true.", "function": "std::atomic"}, {"id": "cpp20_atomic_int_store_key_volatile_constraint_lock_free_a9b0c1d2", "label": "cpp20_atomic_int_store_key_volatile_cons", "x": 75.36431689095923, "y": 734.364365405976, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.int]/10", "content": "The volatile overload of atomic<integral-type>::store_key() is constrained by is_always_lock_free being true.", "function": "std::atomic::store_add"}, {"id": "cpp20_atomic_int_store_key_precond_order_valid_b0c1d2e3", "label": "cpp20_atomic_int_store_key_precond_order", "x": -121.6866812362677, "y": 559.6455310698212, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.int]/11", "content": "Calling atomic<integral-type>::store_key() requires that order is memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic::store_add"}, {"id": "cpp20_atomic_int_operator_compound_volatile_constraint_lock_free_c1d2e3f4", "label": "cpp20_atomic_int_operator_compound_volat", "x": 60.8659936489258, "y": 666.5853155473785, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.int]/14", "content": "The volatile overload of atomic<integral-type>::operator+=/etc is constrained by is_always_lock_free being true.", "function": "std::atomic::operator+="}, {"id": "cpp20_atomic_int_fetch_key_volatile_constraint_lock_free_f8a9b0c1", "label": "cpp20_atomic_int_fetch_key_volatile_cons", "x": -644.7549021045722, "y": -670.7720205966227, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.int]/5", "content": "The volatile overload of atomic<integral-type>::fetch_key() is constrained by is_always_lock_free being true.", "function": "std::atomic::fetch_add"}, {"id": "cpp20_atomic_default_ctor_constraint_default_constructible_a7b8c9d0", "label": "cpp20_atomic_default_ctor_constraint_def", "x": -438.09023164299435, "y": -683.6089516205859, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/1", "content": "The default constructor of atomic<T> is constrained by is_default_constructible_v<T> being true.", "function": "std::atomic::atomic"}, {"id": "cpp20_atomic_load_volatile_constraint_lock_free_f2a3b4c5", "label": "cpp20_atomic_load_volatile_constraint_lo", "x": 710.2463021575124, "y": -486.7454207642654, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/12", "content": "The volatile overload of atomic<T>::load() is constrained by is_always_lock_free being true.", "function": "std::atomic::load"}, {"id": "cpp20_atomic_load_precond_order_valid_e1f2a3b4", "label": "cpp20_atomic_load_precond_order_valid_e1", "x": 922.3375372418672, "y": -248.1514538125893, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/13", "content": "Calling atomic<T>::load() requires that order is memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst.", "function": "std::atomic::load"}, {"id": "cpp20_atomic_conversion_volatile_constraint_lock_free_a3b4c5d6", "label": "cpp20_atomic_conversion_volatile_constra", "x": -601.7120832623928, "y": 491.6475252259585, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/16", "content": "The volatile overload of atomic<T>::operator T() is constrained by is_always_lock_free being true.", "function": "std::atomic::operator T"}, {"id": "cpp20_atomic_exchange_volatile_constraint_lock_free_b4c5d6e7", "label": "cpp20_atomic_exchange_volatile_constrain", "x": 574.8868954788416, "y": -33.48251018919252, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/18", "content": "The volatile overload of atomic<T>::exchange() is constrained by is_always_lock_free being true.", "function": "std::atomic::exchange"}, {"id": "cpp20_atomic_compare_exchange_volatile_constraint_lock_free_c5d6e7f8", "label": "cpp20_atomic_compare_exchange_volatile_c", "x": 145.77496281355093, "y": 619.1498162213387, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/21", "content": "The volatile overload of atomic<T>::compare_exchange_weak/strong() is constrained by is_always_lock_free being true.", "function": "std::atomic::compare_exchange_weak"}, {"id": "cpp20_atomic_compare_exchange_precond_failure_order_d6e7f8a9", "label": "cpp20_atomic_compare_exchange_precond_fa", "x": -355.24896949470696, "y": 927.9806254469839, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/22", "content": "Calling atomic<T>::compare_exchange_weak/strong() requires that failure order is memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst.", "function": "std::atomic::compare_exchange_weak"}, {"id": "cpp20_atomic_wait_precond_order_valid_e7f8a9b0", "label": "cpp20_atomic_wait_precond_order_valid_e7", "x": 939.1608013762966, "y": 244.05647419793704, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/29", "content": "Calling atomic<T>::wait() requires that order is memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst.", "function": "std::atomic::wait"}, {"id": "cpp20_atomic_init_not_atomic_race_ub_b8c9d0e1", "label": "cpp20_atomic_init_not_atomic_race_ub_b8c", "x": -658.2935724712275, "y": 376.64464339688925, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/3", "content": "Construction/initialization of atomic<T> is not an atomic operation. Having an access to an atomic object A race with its construction results in undefined behavior.", "function": "std::atomic::atomic"}, {"id": "cpp20_atomic_store_volatile_constraint_lock_free_d0e1f2a3", "label": "cpp20_atomic_store_volatile_constraint_l", "x": -645.0293712813543, "y": -740.6924886620162, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/6", "content": "The volatile overload of atomic<T>::store() is constrained by is_always_lock_free being true.", "function": "std::atomic::store"}, {"id": "cpp20_atomic_store_precond_order_valid_c9d0e1f2", "label": "cpp20_atomic_store_precond_order_valid_c", "x": -657.3370499502977, "y": -102.12097101776355, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/7", "content": "Calling atomic<T>::store() requires that order is memory_order::relaxed, memory_order::release, or memory_order::seq_cst.", "function": "std::atomic::store"}, {"id": "cpp20_atomic_assignment_volatile_constraint_lock_free_d8e9f0a1", "label": "cpp20_atomic_assignment_volatile_constra", "x": 771.375790714909, "y": 403.5825849915159, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.operations]/9", "content": "The volatile overload of atomic<T>::operator=(T) is constrained by is_always_lock_free being true.", "function": "std::atomic::operator="}, {"id": "cpp20_atomic_pointer_fetch_key_volatile_constraint_lock_free_b6c7d8e9", "label": "cpp20_atomic_pointer_fetch_key_volatile_", "x": -256.61266725144816, "y": -433.38300128412203, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.pointer]/4", "content": "The volatile overload of atomic<T*>::fetch_key() is constrained by is_always_lock_free being true.", "function": "std::atomic::fetch_add"}, {"id": "cpp20_atomic_pointer_fetch_key_mandate_complete_type_c7d8e9f0", "label": "cpp20_atomic_pointer_fetch_key_mandate_c", "x": -184.35997786188204, "y": -351.90804554761274, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[atomics.types.pointer]/5", "content": "Calling atomic<T*>::fetch_key() mandates that T is a complete object type (pointer arithmetic on void* or function pointers is ill-formed).", "function": "std::atomic::fetch_add"}, {"id": "cpp20_bit_cast_constraint_sizeof_equality_a7f3e9d1", "label": "cpp20_bit_cast_constraint_sizeof_equalit", "x": 723.2176316373066, "y": -685.8968201164935, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/1.1", "content": "bit_cast requires that sizeof(To) == sizeof(From) is true.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constraint_to_trivially_copyable_b8e4f2c6", "label": "cpp20_bit_cast_constraint_to_trivially_c", "x": 795.8156771949114, "y": 184.22301470974773, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/1.2", "content": "bit_cast requires that To is trivially copyable (is_trivially_copyable_v<To> is true).", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constraint_from_trivially_copyable_c9d5a3e7", "label": "cpp20_bit_cast_constraint_from_trivially", "x": -149.33940106389178, "y": 643.4803394882462, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/1.3", "content": "bit_cast requires that From is trivially copyable (is_trivially_copyable_v<From> is true).", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_mandate_no_consteval_only_types_d2f6b8a4", "label": "cpp20_bit_cast_mandate_no_consteval_only", "x": 18.674497135130018, "y": 844.2409489806497, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/2", "content": "bit_cast mandates that neither To nor From are consteval-only types.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constexpr_condition_no_union_e3a7c9f5", "label": "cpp20_bit_cast_constexpr_condition_no_un", "x": 842.2494773312495, "y": -122.62771968327613, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/3.1", "content": "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_union_v<T> is false.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constexpr_condition_no_pointer_f4b8d0a6", "label": "cpp20_bit_cast_constexpr_condition_no_po", "x": -285.1789918252754, "y": -355.8815729563334, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/3.2", "content": "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_pointer_v<T> is false.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constexpr_condition_no_member_pointer_a5c9e1b7", "label": "cpp20_bit_cast_constexpr_condition_no_me", "x": 772.0309123021833, "y": -460.9116780128092, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/3.3", "content": "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_member_pointer_v<T> is false.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constexpr_condition_no_volatile_b6d0f2c8", "label": "cpp20_bit_cast_constexpr_condition_no_vo", "x": 407.6496780114692, "y": 438.83495111394814, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/3.4", "content": "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_volatile_v<T> is false.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_constexpr_condition_no_reference_members_c7e1a3d9", "label": "cpp20_bit_cast_constexpr_condition_no_re", "x": -281.7172622813137, "y": 10.867541051839453, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/3.5", "content": "bit_cast is constant evaluation eligible when To, From, and all subobjects have no non-static data members of reference type.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_erroneous_from_erroneous_value_c3e7a9d5", "label": "cpp20_bit_cast_erroneous_from_erroneous_", "x": 323.67767227602036, "y": 847.429022950542, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4", "content": "A bit in the value representation of the bit_cast result is erroneous if it corresponds to a bit for which the smallest enclosing object in from has an erroneous value.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_indeterminate_from_indeterminate_value_b2d6f8c4", "label": "cpp20_bit_cast_indeterminate_from_indete", "x": -641.6811041040197, "y": -474.56447730171493, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4", "content": "A bit in the value representation of the bit_cast result is indeterminate if it corresponds to a bit for which the smallest enclosing object in from has an indeterminate value.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_indeterminate_from_non_lifetime_a1c5e7b3", "label": "cpp20_bit_cast_indeterminate_from_non_li", "x": 649.6735908988569, "y": 188.59755994720038, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4", "content": "A bit in the value representation of the bit_cast result is indeterminate if it corresponds to a bit for which the smallest enclosing object in from is not within its lifetime.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_ub_no_valid_value_for_representation_d8f2b4e0", "label": "cpp20_bit_cast_ub_no_valid_value_for_rep", "x": 830.7259409349264, "y": -13.115646629871588, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4", "content": "If there is no value of the result object's type corresponding to the value representation produced by bit_cast, the behavior is undefined.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_uchar_erroneous_value_e5a9c1f7", "label": "cpp20_bit_cast_uchar_erroneous_value_e5a", "x": -411.69661061660213, "y": 756.3853968820519, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4.1", "content": "If the smallest enclosing object containing an indeterminate or erroneous bit is of unsigned ordinary character type or std::byte, and no bit is indeterminate but some are erroneous, the object has an erroneous value.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_uchar_indeterminate_value_d4f8b0e6", "label": "cpp20_bit_cast_uchar_indeterminate_value", "x": -468.8189367515812, "y": 215.9045688690326, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4.1", "content": "If the smallest enclosing object containing an indeterminate or erroneous bit is of unsigned ordinary character type or std::byte, and any bit in its value representation is indeterminate, the object has an indeterminate value.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_ub_indeterminate_bit_non_uchar_e9a3c5f1", "label": "cpp20_bit_cast_ub_indeterminate_bit_non_", "x": -493.8947639516261, "y": 322.12835863712513, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4.2", "content": "If a bit in the value representation of the result is indeterminate and the smallest enclosing object is not of unsigned ordinary character type or std::byte, the behavior is undefined.", "function": "std::bit_cast"}, {"id": "cpp20_bit_cast_erroneous_bit_non_uchar_f0b4d6a2", "label": "cpp20_bit_cast_erroneous_bit_non_uchar_f", "x": -747.3543393476485, "y": -186.8965266209204, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.cast]/4.3", "content": "If a bit in the value representation of the result is erroneous and the smallest enclosing object is not of unsigned ordinary character type or std::byte, the behavior is erroneous.", "function": "std::bit_cast"}, {"id": "cpp20_bit_pow_two_has_single_bit_constraint_unsigned_a1f3e7d2", "label": "cpp20_bit_pow_two_has_single_bit_constra", "x": 889.3268654670502, "y": -329.2693993819605, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/1", "content": "has_single_bit requires T to be an unsigned integer type.", "function": "std::has_single_bit"}, {"id": "cpp20_bit_pow_two_bit_floor_return_maximal_power_d9e5f2a8", "label": "cpp20_bit_pow_two_bit_floor_return_maxim", "x": 410.35970699556975, "y": -489.4118467053185, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/10", "content": "bit_floor returns the maximal value y such that has_single_bit(y) is true and y <= x, when x != 0.", "function": "std::bit_floor"}, {"id": "cpp20_bit_pow_two_bit_floor_return_zero_c8d4e1f7", "label": "cpp20_bit_pow_two_bit_floor_return_zero_", "x": 507.95999419165275, "y": -707.7683850324248, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/10", "content": "bit_floor returns 0 if x == 0.", "function": "std::bit_floor"}, {"id": "cpp20_bit_pow_two_bit_width_constraint_unsigned_e1f6a3b9", "label": "cpp20_bit_pow_two_bit_width_constraint_u", "x": 943.3456495419779, "y": -34.35256213116249, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/11", "content": "bit_width requires T to be an unsigned integer type.", "function": "std::bit_width"}, {"id": "cpp20_bit_pow_two_bit_width_return_log2_plus_one_a3b8c5d2", "label": "cpp20_bit_pow_two_bit_width_return_log2_", "x": -384.26009490391175, "y": -779.4300523647357, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/12", "content": "bit_width returns one plus the base-2 logarithm of x with fractional part discarded, when x != 0.", "function": "std::bit_width"}, {"id": "cpp20_bit_pow_two_bit_width_return_zero_f2a7b4c1", "label": "cpp20_bit_pow_two_bit_width_return_zero_", "x": -776.7486300734402, "y": 81.68623023529878, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/12", "content": "bit_width returns 0 if x == 0.", "function": "std::bit_width"}, {"id": "cpp20_bit_pow_two_has_single_bit_return_power_of_two_b8c4d9f1", "label": "cpp20_bit_pow_two_has_single_bit_return_", "x": -307.8852584371107, "y": 726.9371855332435, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/2", "content": "has_single_bit returns true if and only if x is an integral power of two.", "function": "std::has_single_bit"}, {"id": "cpp20_bit_pow_two_bit_ceil_constraint_unsigned_c7d2e8f5", "label": "cpp20_bit_pow_two_bit_ceil_constraint_un", "x": -108.18463822125568, "y": -685.3963797669543, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/4", "content": "bit_ceil requires T to be an unsigned integer type.", "function": "std::bit_ceil"}, {"id": "cpp20_bit_pow_two_bit_ceil_precondition_representable_d3e9f1a7", "label": "cpp20_bit_pow_two_bit_ceil_precondition_", "x": 330.82087927941785, "y": 576.5382360949679, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/5", "content": "bit_ceil requires that N (the smallest power of 2 >= x) is representable as a value of type T.", "function": "std::bit_ceil"}, {"id": "cpp20_bit_pow_two_bit_ceil_return_smallest_power_e4f1a2b8", "label": "cpp20_bit_pow_two_bit_ceil_return_smalle", "x": -600.6766978818935, "y": -597.1754164713017, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/6", "content": "bit_ceil returns N, the smallest power of 2 greater than or equal to x.", "function": "std::bit_ceil"}, {"id": "cpp20_bit_pow_two_bit_ceil_throws_nothing_f5a7b3c9", "label": "cpp20_bit_pow_two_bit_ceil_throws_nothin", "x": -905.0339360154883, "y": 357.9016642101858, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/7", "content": "bit_ceil throws nothing.", "function": "std::bit_ceil"}, {"id": "cpp20_bit_pow_two_bit_ceil_constexpr_precondition_violation_a6b8c4d1", "label": "cpp20_bit_pow_two_bit_ceil_constexpr_pre", "x": 571.3332760474767, "y": -96.65062229478794, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/8", "content": "A bit_ceil function call that violates the precondition (N not representable) is not a core constant expression.", "function": "std::bit_ceil"}, {"id": "cpp20_bit_pow_two_bit_floor_constraint_unsigned_b7c9d5e2", "label": "cpp20_bit_pow_two_bit_floor_constraint_u", "x": 661.5805741507938, "y": 522.876468028161, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[bit.pow.two]/9", "content": "bit_floor requires T to be an unsigned integer type.", "function": "std::bit_floor"}, {"id": "cpp20_cmp_alg_strong_order_type_mismatch_ill_formed_a7f3e2d1", "label": "cpp20_cmp_alg_strong_order_type_mismatch", "x": 136.9727697204501, "y": 809.9917970641966, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/1.1", "content": "If the decayed types of E and F differ, strong_order(E, F) is ill-formed.", "function": "std::strong_order"}, {"id": "cpp20_cmp_alg_strong_order_adl_precedence_b8d4f1c2", "label": "cpp20_cmp_alg_strong_order_adl_precedenc", "x": -523.8518060329365, "y": -664.6602561966813, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/1.2", "content": "strong_order first attempts to use argument-dependent lookup to find a user-provided strong_order function.", "function": "std::strong_order"}, {"id": "cpp20_cmp_alg_strong_order_float_comparison_consistency_d0f6b3c4", "label": "cpp20_cmp_alg_strong_order_float_compari", "x": -315.36101610652526, "y": -841.7140727483744, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/1.3", "content": "For floating-point type T, strong_order yields a value consistent with T's comparison operators.", "function": "std::strong_order"}, {"id": "cpp20_cmp_alg_strong_order_float_iec559_consistency_c9e5a2b3", "label": "cpp20_cmp_alg_strong_order_float_iec559_", "x": 66.87126214098718, "y": 898.2887115754294, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/1.3", "content": "For floating-point type T with numeric_limits<T>::is_iec559 == true, strong_order must be consistent with ISO/IEC 60559 totalOrder operation.", "function": "std::strong_order"}, {"id": "cpp20_cmp_alg_strong_order_three_way_fallback_e1a7c4d5", "label": "cpp20_cmp_alg_strong_order_three_way_fal", "x": -750.4131015225105, "y": -549.9664541419015, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/1.4", "content": "If ADL and floating-point handling do not apply, strong_order falls back to strong_ordering(compare_three_way()(E, F)) if well-formed.", "function": "std::strong_order"}, {"id": "cpp20_cmp_alg_strong_order_final_ill_formed_f2b8d5e6", "label": "cpp20_cmp_alg_strong_order_final_ill_for", "x": -44.46721676184069, "y": 893.0411677071484, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/1.5", "content": "If none of the strong_order resolution steps produce a well-formed expression, strong_order(E, F) is ill-formed.", "function": "std::strong_order"}, {"id": "cpp20_cmp_alg_weak_order_type_mismatch_ill_formed_a3c9e6f7", "label": "cpp20_cmp_alg_weak_order_type_mismatch_i", "x": -602.4377308673792, "y": -36.57000787170616, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.1", "content": "If the decayed types of E and F differ, weak_order(E, F) is ill-formed.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_weak_order_adl_precedence_b4d0a7c8", "label": "cpp20_cmp_alg_weak_order_adl_precedence_", "x": -761.6347236974152, "y": -526.6795827341156, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.2", "content": "weak_order first attempts to use argument-dependent lookup to find a user-provided weak_order function.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_weak_order_float_iec559_equivalence_classes_d6f2c9e0", "label": "cpp20_cmp_alg_weak_order_float_iec559_eq", "x": 743.4786890396808, "y": 663.4314001573324, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.3", "content": "For floating-point type T with numeric_limits<T>::is_iec559 == true, weak_order must group values into specific equivalence classes: all negative NaNs, negative infinity, normal negatives, subnormal negatives, both zeros, subnormal positives, normal positives, positive infinity, all positive NaNs.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_weak_order_float_strong_order_consistency_c5e1b8d9", "label": "cpp20_cmp_alg_weak_order_float_strong_or", "x": -784.9131818047988, "y": 622.7148256335514, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.3", "content": "For floating-point type T, weak_order must be consistent with both T's comparison operators and strong_order.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_weak_order_three_way_fallback_e7a3d0f1", "label": "cpp20_cmp_alg_weak_order_three_way_fallb", "x": 232.6176495744596, "y": 807.3939888646863, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.4", "content": "If ADL and floating-point handling do not apply, weak_order falls back to weak_ordering(compare_three_way()(E, F)) if well-formed.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_weak_order_strong_order_fallback_f8b4e1a2", "label": "cpp20_cmp_alg_weak_order_strong_order_fa", "x": -378.1223618594737, "y": 346.4567514213049, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.5", "content": "If three-way comparison is not available, weak_order falls back to weak_ordering(strong_order(E, F)) if well-formed.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_weak_order_final_ill_formed_a9c5f2b3", "label": "cpp20_cmp_alg_weak_order_final_ill_forme", "x": -24.545352368410065, "y": 588.0789374433245, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/2.6", "content": "If none of the weak_order resolution steps produce a well-formed expression, weak_order(E, F) is ill-formed.", "function": "std::weak_order"}, {"id": "cpp20_cmp_alg_partial_order_type_mismatch_ill_formed_b0d6a3c4", "label": "cpp20_cmp_alg_partial_order_type_mismatc", "x": -538.1634827245914, "y": -773.6527041178819, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/3.1", "content": "If the decayed types of E and F differ, partial_order(E, F) is ill-formed.", "function": "std::partial_order"}, {"id": "cpp20_cmp_alg_partial_order_adl_precedence_c1e7b4d5", "label": "cpp20_cmp_alg_partial_order_adl_preceden", "x": -431.761425642799, "y": 528.071654927102, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/3.2", "content": "partial_order first attempts to use argument-dependent lookup to find a user-provided partial_order function.", "function": "std::partial_order"}, {"id": "cpp20_cmp_alg_partial_order_three_way_fallback_d2f8c5e6", "label": "cpp20_cmp_alg_partial_order_three_way_fa", "x": -666.2863856012951, "y": 331.0354601009298, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/3.3", "content": "If ADL does not apply, partial_order falls back to partial_ordering(compare_three_way()(E, F)) if well-formed.", "function": "std::partial_order"}, {"id": "cpp20_cmp_alg_partial_order_weak_order_fallback_e3a9d6f7", "label": "cpp20_cmp_alg_partial_order_weak_order_f", "x": 770.8790559393539, "y": -601.2268354050581, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/3.4", "content": "If three-way comparison is not available, partial_order falls back to partial_ordering(weak_order(E, F)) if well-formed.", "function": "std::partial_order"}, {"id": "cpp20_cmp_alg_partial_order_final_ill_formed_f4b0e7a8", "label": "cpp20_cmp_alg_partial_order_final_ill_fo", "x": 570.7544969620608, "y": -167.5977314328672, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/3.5", "content": "If none of the partial_order resolution steps produce a well-formed expression, partial_order(E, F) is ill-formed.", "function": "std::partial_order"}, {"id": "cpp20_cmp_alg_compare_strong_order_fallback_type_mismatch_ill_formed_a5c1f8b9", "label": "cpp20_cmp_alg_compare_strong_order_fallb", "x": 666.6329786525622, "y": -551.6044237532483, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/4.1", "content": "If the decayed types of E and F differ, compare_strong_order_fallback(E, F) is ill-formed.", "function": "std::compare_strong_order_fallback"}, {"id": "cpp20_cmp_alg_compare_strong_order_fallback_strong_order_precedence_b6d2a9c0", "label": "cpp20_cmp_alg_compare_strong_order_fallb", "x": 378.33036669201977, "y": 710.7456080430779, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/4.2", "content": "compare_strong_order_fallback first attempts to use strong_order(E, F) if it is well-formed.", "function": "std::compare_strong_order_fallback"}, {"id": "cpp20_cmp_alg_compare_strong_order_fallback_operator_fallback_c7e3b0d1", "label": "cpp20_cmp_alg_compare_strong_order_fallb", "x": 881.5858666219038, "y": 308.39117430259574, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/4.3", "content": "If strong_order is not available and E==F and E<F are well-formed with boolean-testable results, compare_strong_order_fallback synthesizes strong_ordering from == and < operators.", "function": "std::compare_strong_order_fallback"}, {"id": "cpp20_cmp_alg_compare_strong_order_fallback_single_evaluation_d8f4c1e2", "label": "cpp20_cmp_alg_compare_strong_order_fallb", "x": -0.35585182788778236, "y": 540.1273961198633, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/4.3", "content": "In compare_strong_order_fallback operator synthesis fallback, E and F are evaluated only once.", "function": "std::compare_strong_order_fallback"}, {"id": "cpp20_cmp_alg_compare_strong_order_fallback_final_ill_formed_e9a5d2f3", "label": "cpp20_cmp_alg_compare_strong_order_fallb", "x": 818.0215807748846, "y": 102.87780542433333, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/4.4", "content": "If neither strong_order nor operator synthesis are available, compare_strong_order_fallback(E, F) is ill-formed.", "function": "std::compare_strong_order_fallback"}, {"id": "cpp20_cmp_alg_compare_weak_order_fallback_type_mismatch_ill_formed_f0b6e3a4", "label": "cpp20_cmp_alg_compare_weak_order_fallbac", "x": -767.8512613704771, "y": 603.6869267919386, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/5.1", "content": "If the decayed types of E and F differ, compare_weak_order_fallback(E, F) is ill-formed.", "function": "std::compare_weak_order_fallback"}, {"id": "cpp20_cmp_alg_compare_weak_order_fallback_weak_order_precedence_a1c7f4b5", "label": "cpp20_cmp_alg_compare_weak_order_fallbac", "x": 491.8719624777725, "y": 455.3588623902165, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/5.2", "content": "compare_weak_order_fallback first attempts to use weak_order(E, F) if it is well-formed.", "function": "std::compare_weak_order_fallback"}, {"id": "cpp20_cmp_alg_compare_weak_order_fallback_operator_fallback_b2d8e5c6", "label": "cpp20_cmp_alg_compare_weak_order_fallbac", "x": -681.0043787199941, "y": 285.10569083326953, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/5.3", "content": "If weak_order is not available and E==F and E<F are well-formed with boolean-testable results, compare_weak_order_fallback synthesizes weak_ordering from == and < operators using equivalent instead of equal.", "function": "std::compare_weak_order_fallback"}, {"id": "cpp20_cmp_alg_compare_weak_order_fallback_single_evaluation_c3e9f6d7", "label": "cpp20_cmp_alg_compare_weak_order_fallbac", "x": -266.81275346717314, "y": 533.4751077223411, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/5.3", "content": "In compare_weak_order_fallback operator synthesis fallback, E and F are evaluated only once.", "function": "std::compare_weak_order_fallback"}, {"id": "cpp20_cmp_alg_compare_weak_order_fallback_final_ill_formed_d4f0a7e8", "label": "cpp20_cmp_alg_compare_weak_order_fallbac", "x": -786.6966065829536, "y": 262.98230419408424, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/5.4", "content": "If neither weak_order nor operator synthesis are available, compare_weak_order_fallback(E, F) is ill-formed.", "function": "std::compare_weak_order_fallback"}, {"id": "cpp20_cmp_alg_compare_partial_order_fallback_type_mismatch_ill_formed_e5a1b8f9", "label": "cpp20_cmp_alg_compare_partial_order_fall", "x": 793.2322116828086, "y": -615.2076420214443, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/6.1", "content": "If the decayed types of E and F differ, compare_partial_order_fallback(E, F) is ill-formed.", "function": "std::compare_partial_order_fallback"}, {"id": "cpp20_cmp_alg_compare_partial_order_fallback_partial_order_precedence_f6b2c9a0", "label": "cpp20_cmp_alg_compare_partial_order_fall", "x": 946.2097052964012, "y": -137.02476607646472, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/6.2", "content": "compare_partial_order_fallback first attempts to use partial_order(E, F) if it is well-formed.", "function": "std::compare_partial_order_fallback"}, {"id": "cpp20_cmp_alg_compare_partial_order_fallback_operator_fallback_a7c3d0b1", "label": "cpp20_cmp_alg_compare_partial_order_fall", "x": 709.1867387535119, "y": 497.69047084844374, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/6.3", "content": "If partial_order is not available and E==F, E<F, and F<E are all well-formed with boolean-testable results, compare_partial_order_fallback synthesizes partial_ordering from ==, <, and > operators, including unordered case.", "function": "std::compare_partial_order_fallback"}, {"id": "cpp20_cmp_alg_compare_partial_order_fallback_single_evaluation_b8d4e1c2", "label": "cpp20_cmp_alg_compare_partial_order_fall", "x": 149.25023928766052, "y": 659.4677369073036, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/6.3", "content": "In compare_partial_order_fallback operator synthesis fallback, E and F are evaluated only once.", "function": "std::compare_partial_order_fallback"}, {"id": "cpp20_cmp_alg_compare_partial_order_fallback_final_ill_formed_c9e5f2d3", "label": "cpp20_cmp_alg_compare_partial_order_fall", "x": 786.2803579853899, "y": -196.50566419185174, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.alg]/6.4", "content": "If neither partial_order nor three-operator synthesis are available, compare_partial_order_fallback(E, F) is ill-formed.", "function": "std::compare_partial_order_fallback"}, {"id": "cpp20_cmp_concept_compares_as_requirement_e7f3a2d1", "label": "cpp20_cmp_concept_compares_as_requiremen", "x": -422.4435387061011, "y": 483.8461326180749, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]", "content": "For types T and Cat to satisfy compares-as<T, Cat>, common_comparison_category_t<T, Cat> must be the same type as Cat", "function": ""}, {"id": "cpp20_cmp_concept_partially_ordered_same_domain_a4b7c9e2", "label": "cpp20_cmp_concept_partially_ordered_same", "x": 622.2031526397656, "y": 504.97121819309905, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/1.1", "content": "For T and U to model partially-ordered-with<T, U>, all comparison operations (t<u, t<=u, t>u, t>=u, u<t, u<=t, u>t, u>=t) must have the same domain", "function": ""}, {"id": "cpp20_cmp_concept_partially_ordered_less_gt_symmetry_d2f8a1c5", "label": "cpp20_cmp_concept_partially_ordered_less", "x": 705.1105239662123, "y": -175.1246377151833, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/1.2", "content": "For T and U to model partially-ordered-with<T, U>, bool(t<u) must equal bool(u>t)", "function": ""}, {"id": "cpp20_cmp_concept_partially_ordered_gt_less_symmetry_b9e3f7a4", "label": "cpp20_cmp_concept_partially_ordered_gt_l", "x": 541.3940187680643, "y": -696.697476680265, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/1.3", "content": "For T and U to model partially-ordered-with<T, U>, bool(u<t) must equal bool(t>u)", "function": ""}, {"id": "cpp20_cmp_concept_partially_ordered_le_ge_symmetry_c5a2d8f1", "label": "cpp20_cmp_concept_partially_ordered_le_g", "x": 72.1821467915651, "y": -975.2705769474761, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/1.4", "content": "For T and U to model partially-ordered-with<T, U>, bool(t<=u) must equal bool(u>=t)", "function": ""}, {"id": "cpp20_cmp_concept_partially_ordered_ge_le_symmetry_f1d9a3b7", "label": "cpp20_cmp_concept_partially_ordered_ge_l", "x": -502.64010146335926, "y": -403.38000307428075, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/1.5", "content": "For T and U to model partially-ordered-with<T, U>, bool(u<=t) must equal bool(t>=u)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_eq_consistency_a7c2f4d9", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": -236.70339368642365, "y": 610.2065776398141, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.1", "content": "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b==0) must equal bool(a==b)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_neq_consistency_e3b8d1a6", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": -537.8494114473268, "y": -160.0525882031084, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.2", "content": "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b!=0) must equal bool(a!=b)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_symmetry_d9a5f2c8", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": -642.4572730762224, "y": -281.77922726093664, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.3", "content": "For T and Cat to model three_way_comparable<T, Cat>, ((a<=>b)<=>0) and (0<=>(b<=>a)) must be equal", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_less_consistency_b4d7f3a1", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": -420.3159792268917, "y": -779.3793609709975, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.4", "content": "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b<0) must equal bool(a<b)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_gt_consistency_c8a2d5f9", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": 309.2940434063145, "y": 529.3724535549115, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.5", "content": "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b>0) must equal bool(a>b)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_le_consistency_f2b9a4d7", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": 518.4340172694817, "y": -154.0476182645165, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.6", "content": "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b<=0) must equal bool(a<=b)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_spaceship_ge_consistency_a1d8c3f5", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": -155.21611214280813, "y": 803.2172447130982, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.7", "content": "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b>=0) must equal bool(a>=b)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_strong_totally_ordered_e5f1a9c2", "label": "cpp20_cmp_concept_three_way_comparable_s", "x": 336.79058473924425, "y": -388.49187164272865, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/2.8", "content": "For T and Cat to model three_way_comparable<T, Cat>, if Cat is convertible to strong_ordering, then T must model totally_ordered", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_same_domain_d7a3f8b4", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": -937.9281194623784, "y": -238.91195869576106, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.1", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, t<=>u and u<=>t must have the same domain", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_strong_totally_ordered_a9f2c6d4", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": -417.78611368856355, "y": -423.284830974859, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.10", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, if Cat is convertible to strong_ordering, then T and U must model totally_ordered_with<T, U>", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_symmetry_c9d2a7f1", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": 485.40313468309694, "y": 200.59979138577523, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.2", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, ((t<=>u)<=>0) and (0<=>(u<=>t)) must be equal", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_eq_consistency_b3f5d8a2", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": 232.99315896972436, "y": 670.731985516881, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.3", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u==0) must equal bool(t==u)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_neq_consistency_a8c4f1d7", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": 628.669392538784, "y": 279.38446414642857, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.4", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u!=0) must equal bool(t!=u)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_common_ref_consistency_f9a2d5c8", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": 657.803555032546, "y": -758.4647453028309, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.5", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, Cat(t<=>u) must equal Cat(CONVERT_TO_LVALUE<C>(t2)<=>CONVERT_TO_LVALUE<C>(u2)) where C is common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_less_consistency_e4b7a9d1", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": -442.96207937716764, "y": -909.0437328017123, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.6", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u<0) must equal bool(t<u)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_gt_consistency_d2f8c5a3", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": 222.23680241732222, "y": 863.4920517353166, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.7", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u>0) must equal bool(t>u)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_le_consistency_c7a1f4d9", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": -382.8307760337503, "y": 854.1795305471526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.8", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u<=0) must equal bool(t<=u)", "function": ""}, {"id": "cpp20_cmp_concept_three_way_comparable_with_ge_consistency_b5d3a8f2", "label": "cpp20_cmp_concept_three_way_comparable_w", "x": -722.9686712439328, "y": 632.2466709500965, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[cmp.concept]/3.9", "content": "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u>=0) must equal bool(t>=u)", "function": ""}, {"id": "cpp20_comparisons_pointer_strict_total_order_c5d6e7f8", "label": "cpp20_comparisons_pointer_strict_total_o", "x": -201.59595411245232, "y": -854.2421682915912, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.general]/2", "content": "For less, greater, less_equal, greater_equal with pointer types, the specializations yield results consistent with the implementation-defined strict total order over pointers.", "function": ""}, {"id": "cpp20_comparisons_pointer_strict_total_order_c9d0e1f2", "label": "cpp20_comparisons_pointer_strict_total_o", "x": -169.88803450524816, "y": -434.6043943741923, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.general]/2", "content": "For comparison function object templates less, greater, less_equal, and greater_equal, specializations for pointer types yield results consistent with the implementation-defined strict total order over pointers.", "function": "std::less"}, {"id": "cpp20_comparisons_void_spec_pointer_order_a7b8c9d0", "label": "cpp20_comparisons_void_spec_pointer_orde", "x": -220.81484485911986, "y": -359.22329419075487, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.general]/2", "content": "For comparison function objects less<void>, greater<void>, less_equal<void>, and greater_equal<void>, if the call operator calls a built-in operator comparing pointers, the result is consistent with the implementation-defined strict total order over pointers.", "function": "std::less<void>"}, {"id": "cpp20_compare_three_way_constraint_comparable_e5f6a7b8", "label": "cpp20_compare_three_way_constraint_compa", "x": 727.5086805019736, "y": 56.323536445963356, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.three.way]/1", "content": "std::compare_three_way::operator() requires T and U to satisfy three_way_comparable_with.", "function": "std::compare_three_way::operator()"}, {"id": "cpp20_compare_three_way_constraint_w9x0y1z2", "label": "cpp20_compare_three_way_constraint_w9x0y", "x": -541.7237288327103, "y": 315.0542089848328, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.three.way]/1", "content": "compare_three_way::operator() requires T and U to satisfy three_way_comparable_with.", "function": "std::compare_three_way::operator()"}, {"id": "cpp20_compare_three_way_precond_pointer_eq_preserving_a3b4c5d6", "label": "cpp20_compare_three_way_precond_pointer_", "x": 501.18007003002737, "y": -514.4523682675898, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.three.way]/2", "content": "For compare_three_way with built-in pointer comparison, conversion sequences from T and U to P must be equality-preserving.", "function": "std::compare_three_way::operator()"}, {"id": "cpp20_compare_three_way_precond_pointer_equality_preserving_d1e2f3a4", "label": "cpp20_compare_three_way_precond_pointer_", "x": -166.49547073244148, "y": -343.92927632150463, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[comparisons.three.way]/2", "content": "std::compare_three_way::operator() precondition: If the expression results in a call to a built-in operator<=> comparing pointers of type P, the conversion sequences from both T and U to P must be equality-preserving; otherwise, T and U model three_way_comparable_with.", "function": "std::compare_three_way::operator()"}, {"id": "cpp20_concept_same_definition_symmetric_a7c3e1f2", "label": "cpp20_concept_same_definition_symmetric_", "x": -321.91908644327685, "y": -279.6151712700585, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concept.same]/1", "content": "The same_as concept is satisfied if and only if T and U denote the same type, with the definition ensuring symmetric subsumption.", "function": ""}, {"id": "cpp20_concept_same_is_same_v_equivalence_d4b8f6a1", "label": "cpp20_concept_same_is_same_v_equivalence", "x": -391.5174343535041, "y": -341.1003065011754, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concept.same]/1", "content": "same_as<T, U> is true precisely when is_same_v<T, U> is true, meaning T and U are the same type including cv-qualifications.", "function": ""}, {"id": "cpp20_concept_same_reflexive_e8a4c7d9", "label": "cpp20_concept_same_reflexive_e8a4c7d9", "x": -351.65838649188197, "y": -305.26165562563403, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concept.same]/1", "content": "same_as is reflexive: same_as<T, T> is always satisfied for any type T.", "function": ""}, {"id": "cpp20_concept_same_subsumption_bidirectional_c2e9d5b3", "label": "cpp20_concept_same_subsumption_bidirecti", "x": -165.88902567999335, "y": -203.54878983429074, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concept.same]/1", "content": "same_as<T, U> subsumes same_as<U, T> and vice versa, enabling symmetric constraint satisfaction in overload resolution.", "function": ""}, {"id": "cpp20_concept_same_symmetric_f1b2a3c4", "label": "cpp20_concept_same_symmetric_f1b2a3c4", "x": -466.31648850710815, "y": -347.2011767275692, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concept.same]/1", "content": "same_as is symmetric: same_as<T, U> implies same_as<U, T> and vice versa.", "function": ""}, {"id": "cpp20_concepts_syn_freestanding_all_concepts_d3f9b1c7", "label": "cpp20_concepts_syn_freestanding_all_conc", "x": 733.9027028343922, "y": 91.68451238308207, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concepts.syn]/18.3", "content": "All entities declared in the <concepts> header are freestanding and available in freestanding implementations", "function": ""}, {"id": "cpp20_concepts_syn_ranges_swap_customization_b1d7f9a5", "label": "cpp20_concepts_syn_ranges_swap_customiza", "x": -906.7939061132695, "y": 210.18905931808743, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[concepts.syn]/18.3", "content": "The ranges::swap customization point object is declared in an inline unspecified namespace to enable ADL", "function": ""}, {"id": "cpp20_container_alloc_reqmts_copy_ctor_alloc_precondition_a3b4c5d6", "label": "cpp20_container_alloc_reqmts_copy_ctor_a", "x": 7.911795793153665, "y": 57.49251361695923, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.alloc.reqmts]/13", "content": "Copy constructing an allocator-aware container with a specified allocator requires T to be Cpp17CopyInsertable into X.", "function": ""}, {"id": "cpp20_container_alloc_reqmts_move_ctor_alloc_precondition_b4c5d6e7", "label": "cpp20_container_alloc_reqmts_move_ctor_a", "x": 21.80015760987101, "y": 40.215825625158985, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.alloc.reqmts]/18", "content": "Move constructing an allocator-aware container with a different allocator requires T to be Cpp17MoveInsertable into X.", "function": ""}, {"id": "cpp20_container_alloc_reqmts_copy_assign_precondition_c5d6e7f8", "label": "cpp20_container_alloc_reqmts_copy_assign", "x": -43.279853219987196, "y": -171.49742548967166, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.alloc.reqmts]/22", "content": "Copy assignment of an allocator-aware container requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.", "function": ""}, {"id": "cpp20_container_alloc_reqmts_move_assign_precondition_d6e7f8a9", "label": "cpp20_container_alloc_reqmts_move_assign", "x": 147.57829049466872, "y": -177.2763013432339, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.alloc.reqmts]/26", "content": "Move assignment of an allocator-aware container requires T to be Cpp17MoveInsertable and Cpp17MoveAssignable if propagate_on_container_move_assignment is false.", "function": ""}, {"id": "cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4", "label": "cpp20_container_alloc_reqmts_allocator_t", "x": 545.2716646073048, "y": 398.42324447318754, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.alloc.reqmts]/5", "content": "Container allocator_type::value_type must be the same as container value_type.", "function": ""}, {"id": "cpp20_container_alloc_reqmts_default_ctor_precondition_f2a3b4c5", "label": "cpp20_container_alloc_reqmts_default_cto", "x": -3.819016909772566, "y": -69.97225006924945, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.alloc.reqmts]/8", "content": "Default constructing an allocator-aware container requires the allocator type to meet Cpp17DefaultConstructible requirements.", "function": ""}, {"id": "cpp20_container_node_move_assign_precondition_d6e7f8a9", "label": "cpp20_container_node_move_assign_precond", "x": 145.35422179637482, "y": -181.91820016294687, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.cons]/2", "content": "Node handle move assignment requires either the target is empty, or propagate_on_container_move_assignment is true, or the allocators are equal.", "function": ""}, {"id": "cpp20_container_node_swap_precondition_c1d2e3f4", "label": "cpp20_container_node_swap_precondition_c", "x": 755.7001617744434, "y": -180.5196684392172, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.modifiers]/1", "content": "Swapping node handles requires either both are empty, or propagate_on_container_swap is true, or the allocators are equal.", "function": ""}, {"id": "cpp20_container_node_value_precondition_e7f8a9b0", "label": "cpp20_container_node_value_precondition_", "x": -0.03009309580074364, "y": -124.47287930978773, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.observers]/1", "content": "Calling value() on a node handle requires the node handle to be non-empty.", "function": "node_handle::value"}, {"id": "cpp20_container_node_get_allocator_precondition_b0c1d2e3", "label": "cpp20_container_node_get_allocator_preco", "x": 490.6255885941276, "y": 377.25090058928487, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.observers]/11", "content": "Calling get_allocator() on a node handle requires the node handle to be non-empty.", "function": "node_handle::get_allocator"}, {"id": "cpp20_container_node_key_precondition_f8a9b0c1", "label": "cpp20_container_node_key_precondition_f8", "x": 130.64567590471083, "y": -117.20268986993392, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.observers]/4", "content": "Calling key() on a node handle requires the node handle to be non-empty.", "function": "node_handle::key"}, {"id": "cpp20_container_node_mapped_precondition_a9b0c1d2", "label": "cpp20_container_node_mapped_precondition", "x": 169.52048237545517, "y": -56.45522136650491, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.observers]/8", "content": "Calling mapped() on a node handle requires the node handle to be non-empty.", "function": "node_handle::mapped"}, {"id": "cpp20_container_node_pair_specialization_ub_c5d6e7f8", "label": "cpp20_container_node_pair_specialization", "x": -466.0628485366086, "y": -721.2818024962982, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.node.overview]/4", "content": "If a user-defined specialization of pair exists for pair<const Key, T> or pair<Key, T>, where Key is the container's key_type and T is the container's mapped_type, the behavior of operations involving node handles is undefined.", "function": ""}, {"id": "cpp20_container_opt_reqmts_threeway_precondition_b4c5d6e7", "label": "cpp20_container_opt_reqmts_threeway_prec", "x": -107.58211397566036, "y": -127.71557082800696, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.opt.reqmts]/3", "content": "Container three-way comparison requires either T models three_way_comparable, or operator< is defined for T and is a total ordering relationship.", "function": ""}, {"id": "cpp20_container_reqmts_copy_ctor_precondition_b2c3d4e5", "label": "cpp20_container_reqmts_copy_ctor_precond", "x": 5.305999971374116, "y": 62.781468271791674, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/12", "content": "Copy constructing a container requires T to be Cpp17CopyInsertable into X.", "function": ""}, {"id": "cpp20_container_reqmts_value_type_erasable_a1b2c3d4", "label": "cpp20_container_reqmts_value_type_erasab", "x": -664.7162437179551, "y": -235.9757065936252, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/2-3", "content": "Container value_type T must be Cpp17Erasable from container X.", "function": ""}, {"id": "cpp20_container_reqmts_equality_precondition_c3d4e5f6", "label": "cpp20_container_reqmts_equality_precondi", "x": 512.8587574707899, "y": -108.78705525190644, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/42", "content": "Container equality comparison requires T to meet Cpp17EqualityComparable requirements.", "function": ""}, {"id": "cpp20_container_reqmts_swap_allocator_ub_d4e5f6a7", "label": "cpp20_container_reqmts_swap_allocator_ub", "x": 839.7143805123147, "y": -524.7810791444979, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/65", "content": "Swapping containers with unequal allocators when propagate_on_container_swap is false is undefined behavior.", "function": ""}, {"id": "cpp20_container_reqmts_insert_single_exception_safety_e5f6a7b8", "label": "cpp20_container_reqmts_insert_single_exc", "x": -85.08424399340902, "y": 152.9729542453658, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/66.1", "content": "If an exception is thrown by insert() or emplace() while inserting a single element, the function has no effects (strong exception guarantee).", "function": ""}, {"id": "cpp20_container_reqmts_push_exception_safety_f6a7b8c9", "label": "cpp20_container_reqmts_push_exception_sa", "x": -71.45837276712341, "y": 155.79817996991105, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/66.2", "content": "If an exception is thrown by push_back(), push_front(), emplace_back(), or emplace_front(), the function has no effects (strong exception guarantee).", "function": ""}, {"id": "cpp20_container_reqmts_erase_nothrow_a7b8c9d0", "label": "cpp20_container_reqmts_erase_nothrow_a7b", "x": 256.62003157953006, "y": 951.9773755606852, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/66.3", "content": "Container erase(), clear(), pop_back(), and pop_front() functions do not throw exceptions.", "function": ""}, {"id": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "label": "cpp20_container_reqmts_iterator_copy_not", "x": -88.0854284877208, "y": -67.76634002805896, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/66.4", "content": "No copy constructor or assignment operator of a returned container iterator throws an exception.", "function": ""}, {"id": "cpp20_container_reqmts_swap_nothrow_c9d0e1f2", "label": "cpp20_container_reqmts_swap_nothrow_c9d0", "x": -101.28176469565341, "y": 148.4802349433393, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/66.5", "content": "Container swap() function does not throw an exception.", "function": ""}, {"id": "cpp20_container_reqmts_swap_no_invalidate_d0e1f2a3", "label": "cpp20_container_reqmts_swap_no_invalidat", "x": -237.66590094027222, "y": -233.40445822752102, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.reqmts]/66.6", "content": "Container swap() does not invalidate any references, pointers, or iterators referring to elements of the swapped containers (end() iterator may be invalidated).", "function": ""}, {"id": "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0", "label": "cpp20_container_dataraces_concurrent_ele", "x": -118.27966927668868, "y": 177.80538502916585, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.requirements.dataraces]/2", "content": "Implementations must avoid data races when contents of different elements in the same container are modified concurrently (except for vector<bool>).", "function": ""}, {"id": "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1", "label": "cpp20_container_dataraces_vector_bool_ex", "x": -82.53620414535472, "y": 138.28993279351306, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[container.requirements.dataraces]/3", "content": "For vector<bool>, modifying different elements concurrently can result in a data race (exception to general container rule).", "function": ""}, {"id": "cpp20_coroutine_handle_default_ctor_postcond_e5a9b3c7", "label": "cpp20_coroutine_handle_default_ctor_post", "x": -230.5584260636602, "y": -364.74490392198857, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.con]/1", "content": "After default construction or construction from nullptr_t, coroutine_handle::address() returns nullptr.", "function": "std::coroutine_handle::coroutine_handle"}, {"id": "cpp20_coroutine_handle_from_promise_precond_f6b2c8d4", "label": "cpp20_coroutine_handle_from_promise_prec", "x": -100.78272520138741, "y": 180.5193086910947, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.con]/2", "content": "from_promise(p) requires p to be a reference to a promise object of a coroutine.", "function": "std::coroutine_handle::from_promise"}, {"id": "cpp20_coroutine_handle_from_promise_postcond_a7c3d9e5", "label": "cpp20_coroutine_handle_from_promise_post", "x": -163.170301947726, "y": -138.65902489324193, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.con]/3", "content": "After from_promise(p), addressof(h.promise()) == addressof(p).", "function": "std::coroutine_handle::from_promise"}, {"id": "cpp20_coroutine_handle_assign_null_postcond_b8d4e0f6", "label": "cpp20_coroutine_handle_assign_null_postc", "x": -252.56551026542334, "y": -375.04681865830054, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.con]/5", "content": "After operator=(nullptr_t), coroutine_handle::address() returns nullptr.", "function": "std::coroutine_handle::operator="}, {"id": "cpp20_coroutine_handle_from_address_void_precond_c9e5a1f7", "label": "cpp20_coroutine_handle_from_address_void", "x": -190.17534523241375, "y": -457.42261196492797, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.export.import]/2", "content": "coroutine_handle<>::from_address(addr) requires addr was obtained via a prior call to address() on an object whose type is a specialization of coroutine_handle.", "function": "std::coroutine_handle<>::from_address"}, {"id": "cpp20_coroutine_handle_from_address_void_postcond_d0f6b2a8", "label": "cpp20_coroutine_handle_from_address_void", "x": -202.19801470605032, "y": -365.07808643541, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.export.import]/3", "content": "After coroutine_handle<>::from_address(addr), from_address(address()) == *this.", "function": "std::coroutine_handle<>::from_address"}, {"id": "cpp20_coroutine_handle_from_address_typed_precond_e1a7c3d9", "label": "cpp20_coroutine_handle_from_address_type", "x": -164.85332223419488, "y": -448.23474612746327, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.export.import]/4", "content": "coroutine_handle<Promise>::from_address(addr) requires addr was obtained via a prior call to address() on an object of type cv coroutine_handle<Promise>.", "function": "std::coroutine_handle<Promise>::from_address"}, {"id": "cpp20_coroutine_handle_from_address_typed_postcond_f2b8d4e0", "label": "cpp20_coroutine_handle_from_address_type", "x": -217.71997186218906, "y": -441.26341833032563, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.export.import]/5", "content": "After coroutine_handle<Promise>::from_address(addr), from_address(address()) == *this.", "function": "std::coroutine_handle<Promise>::from_address"}, {"id": "cpp20_coroutine_handle_equality_via_address_b7c3e9f4", "label": "cpp20_coroutine_handle_equality_via_addr", "x": -339.2815676858428, "y": -380.1206992575353, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.general]/1", "content": "Two coroutine_handle objects refer to the same coroutine if and only if their member address() returns the same non-null value.", "function": "std::coroutine_handle::address"}, {"id": "cpp20_coroutine_handle_null_no_referent_a3f8d2e1", "label": "cpp20_coroutine_handle_null_no_referent_", "x": 8.99812172442948, "y": -927.2204257193322, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.general]/1", "content": "A coroutine_handle object whose member address() returns a null pointer value does not refer to any coroutine.", "function": ""}, {"id": "cpp20_coroutine_handle_specialization_ub_d4e8a2f9", "label": "cpp20_coroutine_handle_specialization_ub", "x": 110.5145439694424, "y": 916.0472200129167, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.general]/2", "content": "If a program declares an explicit or partial specialization of coroutine_handle, the behavior is undefined.", "function": ""}, {"id": "cpp20_coroutine_handle_bool_conversion_a3c9e5f1", "label": "cpp20_coroutine_handle_bool_conversion_a", "x": -299.88152390438484, "y": -355.41637320958336, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.observers]/1", "content": "Explicit conversion to bool returns true if address() != nullptr.", "function": "std::coroutine_handle::operator bool"}, {"id": "cpp20_coroutine_handle_done_precond_b4d0f6a2", "label": "cpp20_coroutine_handle_done_precond_b4d0", "x": -712.1356522277633, "y": 108.44780731270362, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.observers]/2", "content": "Calling done() requires *this refers to a suspended coroutine.", "function": "std::coroutine_handle::done"}, {"id": "cpp20_coroutine_handle_done_returns_final_c5e1a7b3", "label": "cpp20_coroutine_handle_done_returns_fina", "x": -822.4664460009383, "y": -42.27570140801545, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.observers]/3", "content": "done() returns true if the coroutine is suspended at its final suspend point, otherwise false.", "function": "std::coroutine_handle::done"}, {"id": "cpp20_coroutine_handle_promise_precond_refers_b0d6f2a8", "label": "cpp20_coroutine_handle_promise_precond_r", "x": -9.747747342867266, "y": 164.45122681562592, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.promise]/1", "content": "Calling promise() requires *this refers to a coroutine.", "function": "std::coroutine_handle::promise"}, {"id": "cpp20_coroutine_handle_promise_returns_ref_c1e7a3b9", "label": "cpp20_coroutine_handle_promise_returns_r", "x": 12.041870504940912, "y": 172.11704965529907, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.promise]/2", "content": "promise() returns a reference to the promise of the coroutine.", "function": "std::coroutine_handle::promise"}, {"id": "cpp20_coroutine_handle_resume_cross_thread_impl_def_d6f2b8c4", "label": "cpp20_coroutine_handle_resume_cross_thre", "x": 822.5857221388127, "y": -382.0475839057375, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.resumption]/1", "content": "Resuming a coroutine via resume, operator(), or destroy on an execution agent other than the one on which it was suspended has implementation-defined behavior unless each execution agent either is an instance of std::thread or std::jthread, or is the thread that executes main.", "function": ""}, {"id": "cpp20_coroutine_handle_resume_precond_not_final_f8b4d0e6", "label": "cpp20_coroutine_handle_resume_precond_no", "x": -130.358338740708, "y": -776.5003615035267, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.resumption]/2", "content": "Calling resume() or operator()() requires the coroutine is not suspended at its final suspend point.", "function": "std::coroutine_handle::resume"}, {"id": "cpp20_coroutine_handle_resume_precond_suspended_e7a3c9d5", "label": "cpp20_coroutine_handle_resume_precond_su", "x": 764.2437350044933, "y": 577.3484636235765, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.resumption]/2", "content": "Calling resume() or operator()() requires *this refers to a suspended coroutine.", "function": "std::coroutine_handle::resume"}, {"id": "cpp20_coroutine_handle_destroy_precond_suspended_a9c5e1f7", "label": "cpp20_coroutine_handle_destroy_precond_s", "x": 84.76994182681108, "y": 771.2945646951814, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.handle.resumption]/4", "content": "Calling destroy() requires *this refers to a suspended coroutine.", "function": "std::coroutine_handle::destroy"}, {"id": "cpp20_coroutine_traits_primary_no_members_when_invalid_c9d5e6f3", "label": "cpp20_coroutine_traits_primary_no_member", "x": 78.01940019191615, "y": 549.6574458451745, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.traits.primary]/1", "content": "coroutine_traits<R, ArgTypes...> has no members when R::promise_type is not a valid qualified-id or does not denote a type.", "function": "coroutine_traits"}, {"id": "cpp20_coroutine_traits_primary_promise_type_member_definition_b8c4d5e2", "label": "cpp20_coroutine_traits_primary_promise_t", "x": -807.017053516725, "y": 403.3966166986291, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.traits.primary]/1", "content": "When R::promise_type is valid and denotes a type, coroutine_traits<R, ArgTypes...>::promise_type is defined as using promise_type = R::promise_type.", "function": "coroutine_traits"}, {"id": "cpp20_coroutine_traits_primary_promise_type_public_access_f2a8b9c6", "label": "cpp20_coroutine_traits_primary_promise_t", "x": -701.1147198269274, "y": 541.7781230142625, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.traits.primary]/1", "content": "The promise_type member defined by the primary coroutine_traits template is publicly accessible.", "function": "coroutine_traits"}, {"id": "cpp20_coroutine_traits_primary_promise_type_requires_valid_qualified_id_a7f3d2e1", "label": "cpp20_coroutine_traits_primary_promise_t", "x": 553.781421149335, "y": 470.2674115751089, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.traits.primary]/1", "content": "coroutine_traits<R, ArgTypes...> has promise_type member only if R::promise_type is a valid qualified-id denoting a type.", "function": "coroutine_traits"}, {"id": "cpp20_coroutine_traits_specialization_constraint_promise_type_required_d0e6f7a4", "label": "cpp20_coroutine_traits_specialization_co", "x": -891.1643989707236, "y": -307.73515408650843, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.traits.primary]/2", "content": "Program-defined specializations of coroutine_traits must define a publicly accessible nested type named promise_type.", "function": "coroutine_traits"}, {"id": "cpp20_coroutine_traits_specialization_constraint_public_access_e1f7a8b5", "label": "cpp20_coroutine_traits_specialization_co", "x": -589.1014357081942, "y": -349.67719853373546, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[coroutine.traits.primary]/2", "content": "The promise_type member in program-defined coroutine_traits specializations must be publicly accessible.", "function": "coroutine_traits"}, {"id": "cpp20_declval_odr_use_forbidden_7c8e3f2a", "label": "cpp20_declval_odr_use_forbidden_7c8e3f2a", "x": -173.61382256303, "y": 157.0962029139698, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[declval]/2", "content": "The function template std::declval shall not be odr-used. It is only valid as an unevaluated operand.", "function": "std::declval"}, {"id": "cpp20_declval_incomplete_type_allowed_b5a9d4c1", "label": "cpp20_declval_incomplete_type_allowed_b5", "x": -197.01937929465203, "y": 53.62963484486092, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[declval]/3", "content": "The template parameter T of std::declval may be an incomplete type.", "function": "std::declval"}, {"id": "cpp20_exclusive_scan_mandate_convertible_e1f6b4c9", "label": "cpp20_exclusive_scan_mandate_convertible", "x": -515.2075559244041, "y": -232.60927489906712, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[exclusive.scan]/3", "content": "All of binary_op(init, init), binary_op(init, *first), and binary_op(*first, *first) must be convertible to T for std::exclusive_scan.", "function": "std::exclusive_scan"}, {"id": "cpp20_exclusive_scan_precond_no_invalidate_a3b8d6e1", "label": "cpp20_exclusive_scan_precond_no_invalida", "x": 535.9430317023106, "y": 44.76794004973526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[exclusive.scan]/4", "content": "binary_op must neither invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)].", "function": "std::exclusive_scan"}, {"id": "cpp20_exclusive_scan_precond_t_movable_f2a7c5d0", "label": "cpp20_exclusive_scan_precond_t_movable_f", "x": 869.1008466948766, "y": -17.018915351097334, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[exclusive.scan]/4", "content": "Type T must meet Cpp17MoveConstructible requirements for std::exclusive_scan.", "function": "std::exclusive_scan"}, {"id": "cpp20_bad_expected_access_exception_purpose_c9d0e1f2", "label": "cpp20_bad_expected_access_exception_purp", "x": -114.26087860841835, "y": 69.62502451791791, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.bad]/1", "content": "The class template bad_expected_access defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of an expected<T, E> object for which has_value() is false.", "function": ""}, {"id": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "label": "cpp20_expected_copy_assign_deleted_c3d4e", "x": 54.92149852003239, "y": -77.1432613890791, "size": 18, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.assign]/4", "content": "The copy assignment operator of expected is defined as deleted unless T and E are copy assignable, copy constructible, and at least one of T or E is nothrow move constructible.", "function": "std::expected::operator="}, {"id": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "label": "cpp20_expected_copy_ctor_deleted_e9f0a1b", "x": 44.9034031912495, "y": -76.15066583166119, "size": 18, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.cons]/9", "content": "The copy constructor of expected is defined as deleted unless both T and E are copy constructible.", "function": "std::expected::expected"}, {"id": "cpp20_expected_error_type_constraint_c9d0e1f2", "label": "cpp20_expected_error_type_constraint_c9d", "x": -152.22463986759723, "y": 17.87023681743255, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.general]/2", "content": "A program that instantiates the definition of expected<T, E> with a type for the E parameter that is not a valid template argument for unexpected is ill-formed.", "function": ""}, {"id": "cpp20_expected_value_type_constraint_e5f6a7b8", "label": "cpp20_expected_value_type_constraint_e5f", "x": -110.0694399530358, "y": -86.35380109604785, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.general]/2", "content": "A type T is a valid value type for expected if remove_cv_t<T> is void or a complete non-array object type that is not in_place_t, unexpect_t, or a specialization of unexpected.", "function": ""}, {"id": "cpp20_expected_e_destructible_e7f8a9b0", "label": "cpp20_expected_e_destructible_e7f8a9b0", "x": 644.1822579179866, "y": -374.88238727675287, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.general]/3", "content": "E shall meet the Cpp17Destructible requirements.", "function": ""}, {"id": "cpp20_expected_t_destructible_a3b4c5d6", "label": "cpp20_expected_t_destructible_a3b4c5d6", "x": -877.3453303466111, "y": -169.67955663418445, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.general]/3", "content": "When T is not cv void, T shall meet the Cpp17Destructible requirements.", "function": ""}, {"id": "cpp20_expected_or_else_mandates_e3f4a5b6", "label": "cpp20_expected_or_else_mandates_e3f4a5b6", "x": 90.57125209567448, "y": -126.98414117504767, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.monadic]/11", "content": "For or_else, the result type G must be a specialization of expected and G::value_type must be same as T.", "function": "std::expected::or_else"}, {"id": "cpp20_expected_transform_mandates_c7d8e9f0", "label": "cpp20_expected_transform_mandates_c7d8e9", "x": 90.95846824856422, "y": -106.95784556371315, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.monadic]/19", "content": "For transform, the result type U must be a valid value type for expected.", "function": "std::expected::transform"}, {"id": "cpp20_expected_transform_error_mandates_a1b2c3d4", "label": "cpp20_expected_transform_error_mandates_", "x": -57.91952038435576, "y": -4.53888167117244, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.monadic]/27", "content": "For transform_error, the result type G must be a valid template argument for unexpected.", "function": "std::expected::transform_error"}, {"id": "cpp20_expected_and_then_mandates_a9b0c1d2", "label": "cpp20_expected_and_then_mandates_a9b0c1d", "x": 95.73509649951413, "y": -116.2493885763809, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.monadic]/3", "content": "For and_then, the result type U must be a specialization of expected and U::error_type must be same as E.", "function": "std::expected::and_then"}, {"id": "cpp20_expected_arrow_precondition_c1d2e3f4", "label": "cpp20_expected_arrow_precondition_c1d2e3", "x": -10.652034389671629, "y": -103.4260186692015, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/1", "content": "Calling operator->() on expected requires has_value() to be true.", "function": "std::expected::operator->"}, {"id": "cpp20_expected_value_throws_bad_access_c3d4e5f6", "label": "cpp20_expected_value_throws_bad_access_c", "x": 113.07735852618707, "y": -108.2005680882729, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/10", "content": "Calling value() on expected when has_value() is false throws bad_expected_access with the error.", "function": "std::expected::value"}, {"id": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "label": "cpp20_expected_value_rvalue_mandates_a9b", "x": 65.7847007152736, "y": -66.4207286249167, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/11", "content": "Calling value() rvalue overloads on expected mandates that E is copy constructible and constructible from decltype(std::move(error())).", "function": "std::expected::value"}, {"id": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "label": "cpp20_expected_value_rvalue_throws_bad_a", "x": 92.49943041555267, "y": -0.5544525159650054, "size": 18, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/13", "content": "Calling value() rvalue overloads on expected when has_value() is false throws bad_expected_access with moved error.", "function": "std::expected::value"}, {"id": "cpp20_expected_error_precondition_e1f2a3b4", "label": "cpp20_expected_error_precondition_e1f2a3", "x": 85.27522590636995, "y": -118.76841663040369, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/14", "content": "Calling error() on expected requires has_value() to be false.", "function": "std::expected::error"}, {"id": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "label": "cpp20_expected_error_rvalue_precondition", "x": 92.73257147405832, "y": -44.79442263292375, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/16", "content": "Calling error() rvalue overloads on expected requires has_value() to be false.", "function": "std::expected::error"}, {"id": "cpp20_expected_value_or_mandates_e3f4a5b6", "label": "cpp20_expected_value_or_mandates_e3f4a5b", "x": 47.822137825043995, "y": -64.83155080975887, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/18", "content": "Calling value_or() const& mandates that T is copy constructible and U is convertible to T.", "function": "std::expected::value_or"}, {"id": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "label": "cpp20_expected_value_or_rvalue_mandates_", "x": 31.63775897960394, "y": -98.59394608706317, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/20", "content": "Calling value_or() && mandates that T is move constructible and U is convertible to T.", "function": "std::expected::value_or"}, {"id": "cpp20_expected_error_or_mandates_a1b2c3d4", "label": "cpp20_expected_error_or_mandates_a1b2c3d", "x": 31.87197337453219, "y": -81.5040615465201, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/22", "content": "Calling error_or() const& mandates that E is copy constructible and G is convertible to E.", "function": "std::expected::error_or"}, {"id": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "label": "cpp20_expected_error_or_rvalue_mandates_", "x": 36.3994988482359, "y": -53.1885141462375, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/24", "content": "Calling error_or() && mandates that E is move constructible and G is convertible to E.", "function": "std::expected::error_or"}, {"id": "cpp20_expected_deref_precondition_a5b6c7d8", "label": "cpp20_expected_deref_precondition_a5b6c7", "x": 7.560569238273665, "y": -90.60148146202366, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/3", "content": "Calling operator*() on expected requires has_value() to be true.", "function": "std::expected::operator*"}, {"id": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "label": "cpp20_expected_deref_rvalue_precondition", "x": 37.25330741519623, "y": -40.771183363201715, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/5", "content": "Calling operator*() rvalue overloads on expected requires has_value() to be true.", "function": "std::expected::operator*"}, {"id": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "label": "cpp20_expected_value_mandates_copy_e_c5d", "x": 61.06556526459956, "y": -28.692702653056998, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.object.obs]/8", "content": "Calling value() on expected mandates that E is copy constructible.", "function": "std::expected::value"}, {"id": "cpp20_unexpected_equality_mandates_c9d0e1f2", "label": "cpp20_unexpected_equality_mandates_c9d0e", "x": 147.34853580530677, "y": -116.32852331123502, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.un.eq]/1", "content": "The expression x.error() == y.error() must be well-formed and its result convertible to bool for unexpected equality comparison.", "function": "operator=="}, {"id": "cpp20_expected_unexpected_illformed_type_a1b2c3d4", "label": "cpp20_expected_unexpected_illformed_type", "x": -165.6720198132341, "y": -46.65773002578675, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.un.general]/2", "content": "A program that instantiates the definition of unexpected for a non-object type, an array type, a specialization of unexpected, or a cv-qualified type is ill-formed.", "function": ""}, {"id": "cpp20_unexpected_swap_mandates_e5f6a7b8", "label": "cpp20_unexpected_swap_mandates_e5f6a7b8", "x": -65.9666682307288, "y": -49.214523166038916, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.un.swap]/1", "content": "Calling swap on unexpected mandates that is_swappable_v<E> is true.", "function": "std::unexpected::swap"}, {"id": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "label": "cpp20_expected_void_copy_assign_deleted_", "x": 44.681387544911615, "y": -73.40168208305883, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.assign]/3", "content": "The copy assignment operator of expected<void, E> is defined as deleted unless E is copy assignable and copy constructible.", "function": "std::expected<void,E>::operator="}, {"id": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "label": "cpp20_expected_void_copy_ctor_deleted_a7", "x": 1.7959200922081502, "y": -13.849838871701262, "size": 18, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.cons]/5", "content": "The copy constructor of expected<void, E> is defined as deleted unless E is copy constructible.", "function": "std::expected<void,E>::expected"}, {"id": "cpp20_expected_void_e_destructible_a3b4c5d6", "label": "cpp20_expected_void_e_destructible_a3b4c", "x": -324.25594160539845, "y": -798.9421250642811, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.general]/3", "content": "For expected<void, E>, E shall meet the requirements of Cpp17Destructible.", "function": ""}, {"id": "cpp20_expected_void_or_else_mandates_e7f8a9b0", "label": "cpp20_expected_void_or_else_mandates_e7f", "x": 112.1286064035889, "y": -119.22566158996335, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.monadic]/11", "content": "For or_else on expected<void, E>, the result type G must be a specialization of expected and G::value_type must be void.", "function": "std::expected<void,E>::or_else"}, {"id": "cpp20_expected_void_transform_mandates_c1d2e3f4", "label": "cpp20_expected_void_transform_mandates_c", "x": 88.9617526417571, "y": -121.07913315255168, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.monadic]/19", "content": "For transform on expected<void, E>, the result type U must be a valid value type for expected.", "function": "std::expected<void,E>::transform"}, {"id": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "label": "cpp20_expected_void_transform_error_mand", "x": -70.17379824192992, "y": -10.519263811160252, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.monadic]/27", "content": "For transform_error on expected<void, E>, the result type G must be a valid template argument for unexpected.", "function": "std::expected<void,E>::transform_error"}, {"id": "cpp20_expected_void_and_then_mandates_a3b4c5d6", "label": "cpp20_expected_void_and_then_mandates_a3", "x": 81.48589898086648, "y": -130.79296469348287, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.monadic]/3", "content": "For and_then on expected<void, E>, the result type U must be a specialization of expected and U::error_type must be same as E.", "function": "std::expected<void,E>::and_then"}, {"id": "cpp20_expected_void_value_throws_bad_access_a5b6c7d8", "label": "cpp20_expected_void_value_throws_bad_acc", "x": 87.06201969720973, "y": -134.74822136926085, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.obs]/4", "content": "Calling value() on expected<void, E> when has_value() is false throws bad_expected_access with the error.", "function": "std::expected<void,E>::value"}, {"id": "cpp20_expected_void_error_precondition_e7f8a9b0", "label": "cpp20_expected_void_error_precondition_e", "x": 102.91031449730761, "y": -118.29150353894428, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.obs]/5", "content": "Calling error() on expected<void, E> requires has_value() to be false.", "function": "std::expected<void,E>::error"}, {"id": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "label": "cpp20_expected_void_error_rvalue_precond", "x": 95.31206395354971, "y": -52.96426492380924, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[expected.void.obs]/7", "content": "Calling error() rvalue overloads on expected<void, E> requires has_value() to be false.", "function": "std::expected<void,E>::error"}, {"id": "cpp20_format_err_report_propagates_exceptions_e1f2a3b4", "label": "cpp20_format_err_report_propagates_excep", "x": -520.2426924293623, "y": -288.5780528630838, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.err.report]/1", "content": "Formatting functions propagate exceptions thrown by operations of formatter specializations and iterators.", "function": ""}, {"id": "cpp20_format_err_report_throws_format_error_a7b8c9d0", "label": "cpp20_format_err_report_throws_format_er", "x": -49.0385230601174, "y": -78.01475855474129, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.err.report]/1", "content": "Formatting functions throw format_error if an argument fmt is passed that is not a format string for args.", "function": "std::format"}, {"id": "cpp20_basic_format_string_consteval_invalid_b5c6d7e8", "label": "cpp20_basic_format_string_consteval_inva", "x": 72.92936834472872, "y": -32.55722233549804, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.fmt.string]/3", "content": "A call to basic_format_string consteval constructor is not a core constant expression unless there exist args of types Args such that str is a format string for args.", "function": "std::basic_format_string::basic_format_string"}, {"id": "cpp20_formattable_concept_requirements_a7b8c9d0", "label": "cpp20_formattable_concept_requirements_a", "x": -525.6278574771561, "y": -81.89360638406767, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.formattable]/2", "content": "A type T and a character type charT model formattable if formatter<remove_cvref_t<T>, charT> meets the BasicFormatter requirements and, if remove_reference_t<T> is const-qualified, the Formatter requirements.", "function": ""}, {"id": "cpp20_enable_nonlocking_formatter_specialization_e1f2a3b4", "label": "cpp20_enable_nonlocking_formatter_specia", "x": -922.6055143144134, "y": -375.3331316623696, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.formatter.locking]/1", "content": "User specializations of enable_nonlocking_formatter_optimization shall be usable in constant expressions and have type const bool.", "function": ""}, {"id": "cpp20_formatter_disabled_not_constructible_f9a0b1c2", "label": "cpp20_formatter_disabled_not_constructib", "x": 461.86064239799083, "y": -713.237414425843, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.formatter.spec]/7", "content": "If F is a disabled specialization of formatter, is_default_constructible_v<F>, is_copy_constructible_v<F>, is_move_constructible_v<F>, is_copy_assignable_v<F>, and is_move_assignable_v<F> are all false.", "function": ""}, {"id": "cpp20_formatter_enabled_meets_basic_formatter_c3d4e5f6", "label": "cpp20_formatter_enabled_meets_basic_form", "x": 60.94804784485022, "y": -721.910508967013, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.formatter.spec]/8", "content": "An enabled specialization formatter<T, charT> meets the BasicFormatter requirements.", "function": ""}, {"id": "cpp20_format_functions_constexpr_requirement_f9a0b1c2", "label": "cpp20_format_functions_constexpr_require", "x": -907.0412916560771, "y": -427.44937756724187, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.functions]/1", "content": "A call to any formatting function is a constant subexpression only if each of the used formatter specializations is a constexpr-enabled specialization.", "function": ""}, {"id": "cpp20_vformat_to_precondition_output_iterator_c3d4e5f6", "label": "cpp20_vformat_to_precondition_output_ite", "x": 315.6915046884953, "y": 32.81163105495974, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.functions]/15", "content": "vformat_to requires that Out models output_iterator<const charT&>.", "function": "std::vformat_to"}, {"id": "cpp20_format_to_n_precondition_output_iterator_a7b8c9d0", "label": "cpp20_format_to_n_precondition_output_it", "x": 144.61892371588897, "y": -128.2714950232336, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.functions]/21", "content": "format_to_n requires that Out models output_iterator<const charT&> and formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements for each Ti in Args.", "function": "std::format_to_n"}, {"id": "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4", "label": "cpp20_formatted_size_precondition_basic_", "x": 110.79700063250158, "y": -146.90085410421435, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.functions]/26", "content": "formatted_size requires that formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements for each Ti in Args.", "function": "std::formatted_size"}, {"id": "cpp20_format_parse_context_check_dynamic_spec_a7b8c9d0", "label": "cpp20_format_parse_context_check_dynamic", "x": -161.35556591325852, "y": -9.751676484972203, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.parse.ctx]", "content": "The check_dynamic_spec member function of basic_format_parse_context validates that the argument at the specified index is one of the specified types.", "function": "std::basic_format_parse_context::check_dynamic_spec"}, {"id": "cpp20_format_string_arg_id_out_of_bounds_7c9d4e5f", "label": "cpp20_format_string_arg_id_out_of_bounds", "x": -804.1802789013977, "y": 15.6764705922094, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.general]/2", "content": "If there is no argument with the index arg-id in args, the string is not a format string for args.", "function": ""}, {"id": "cpp20_format_string_invalid_format_3a8f2b1c", "label": "cpp20_format_string_invalid_format_3a8f2", "x": -718.201073598255, "y": -346.74797478422124, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.general]/2", "content": "A format string that does not conform to the format string grammar for the given arguments is ill-formed.", "function": ""}, {"id": "cpp20_format_string_mixed_indexing_f4a5b6c7", "label": "cpp20_format_string_mixed_indexing_f4a5b", "x": 647.985406517939, "y": -96.70949301341102, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.general]/4", "content": "A format string cannot contain a mixture of automatic and manual argument indexing.", "function": ""}, {"id": "cpp20_format_string_invalid_format_spec_d8e9f0a1", "label": "cpp20_format_string_invalid_format_spec_", "x": -470.96687272635944, "y": -381.8200448623738, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.general]/5", "content": "If format-spec does not conform to the format specifications for the argument type referred to by arg-id, the string is not a format string for args.", "function": ""}, {"id": "cpp20_format_precision_negative_throws_f3a4b5c6", "label": "cpp20_format_precision_negative_throws_f", "x": -84.55843831580928, "y": 31.700011167377657, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/10", "content": "If the value of a dynamic precision argument is negative, an exception of type format_error is thrown.", "function": ""}, {"id": "cpp20_format_width_negative_throws_c9d0e1f2", "label": "cpp20_format_width_negative_throws_c9d0e", "x": -50.242167252962375, "y": 26.504582292643985, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/10", "content": "If the value of a dynamic width argument is negative, an exception of type format_error is thrown.", "function": ""}, {"id": "cpp20_format_width_precision_type_constraint_d7e8f9a0", "label": "cpp20_format_width_precision_type_constr", "x": 647.9630320127208, "y": -341.35632773324846, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/10", "content": "The dynamic width or precision option is valid only if the corresponding formatting argument is of standard signed or unsigned integer type.", "function": ""}, {"id": "cpp20_format_precision_valid_types_b1c2d3e4", "label": "cpp20_format_precision_valid_types_b1c2d", "x": 603.5514540864777, "y": -178.2405480758542, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/15", "content": "The precision option is valid for floating-point and string types only.", "function": ""}, {"id": "cpp20_format_locale_not_constexpr_e9f0a1b2", "label": "cpp20_format_locale_not_constexpr_e9f0a1", "x": -442.3243796562833, "y": 678.8808453189193, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/17", "content": "A call to format on a given formatter specialization is not a constant subexpression if the locale-specific form is specified.", "function": ""}, {"id": "cpp20_format_locale_option_constraint_a5b6c7d8", "label": "cpp20_format_locale_option_constraint_a5", "x": -791.4794187248782, "y": 562.609145604922, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/17", "content": "The L option is only valid for arithmetic types.", "function": ""}, {"id": "cpp20_format_c_type_throws_out_of_range_c3d4e5f6", "label": "cpp20_format_c_type_throws_out_of_range_", "x": -123.449134401634, "y": -186.908679421617, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/21 Table 107", "content": "The c type presentation for integers throws format_error if value is not in the range of representable values for charT.", "function": ""}, {"id": "cpp20_format_fill_char_utf_scalar_b5c6d7e8", "label": "cpp20_format_fill_char_utf_scalar_b5c6d7", "x": 264.3639997737645, "y": 824.5145793448581, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/3", "content": "For a format specification in UTF-8, UTF-16, or UTF-32, the fill character corresponds to a single Unicode scalar value.", "function": ""}, {"id": "cpp20_format_sign_option_constraint_b2c3d4e5", "label": "cpp20_format_sign_option_constraint_b2c3", "x": 447.9688979520668, "y": 383.94755394558894, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/5", "content": "The sign option is only valid for arithmetic types other than charT and bool or when an integer presentation type is specified.", "function": ""}, {"id": "cpp20_format_alternate_form_constraint_a1b2c3d4", "label": "cpp20_format_alternate_form_constraint_a", "x": -914.8203015110952, "y": 89.17059051232856, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/7", "content": "The # option (alternate form) is valid for arithmetic types other than charT and bool or when an integer presentation type is specified, and not otherwise.", "function": ""}, {"id": "cpp20_format_zero_option_constraint_e5f6a7b8", "label": "cpp20_format_zero_option_constraint_e5f6", "x": -226.189535285709, "y": -44.915116012275725, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.string.std]/8", "content": "The 0 option is valid for arithmetic types other than charT and bool, pointer types, or when an integer presentation type is specified.", "function": ""}, {"id": "cpp20_format_range_disabled_constraint_f9a0b1c2", "label": "cpp20_format_range_disabled_constraint_f", "x": -242.01188995468172, "y": -313.87360951580916, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.syn]", "content": "A formatter specialization for ranges is only enabled if format_kind<R> is not range_format::disabled and the range element type is formattable.", "function": ""}, {"id": "cpp20_range_formatter_constraint_same_as_c3d4e5f6", "label": "cpp20_range_formatter_constraint_same_as", "x": -419.79576726501597, "y": -320.2553842746708, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[format.syn]", "content": "range_formatter requires same_as<remove_cvref_t<T>, T> and formattable<T, charT>.", "function": ""}, {"id": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "label": "cpp20_formatter_parse_throws_on_invalid_", "x": -88.37140833405661, "y": -149.352997420592, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[formatter.requirements] Table 112", "content": "The parse member function of a formatter throws format_error unless the whole range is parsed or the unmatched character is }.", "function": "formatter::parse"}, {"id": "cpp20_forward_signal_safe_a2d4f6c8", "label": "cpp20_forward_signal_safe_a2d4f6c8", "x": 156.14545136539147, "y": -120.67644516918423, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/1", "content": "All functions specified in [forward] (std::forward, std::forward_like, std::move, std::move_if_noexcept) are signal-safe and may be called from signal handlers.", "function": "std::forward"}, {"id": "cpp20_move_returns_rvalue_ref_e4b6d2a8", "label": "cpp20_move_returns_rvalue_ref_e4b6d2a8", "x": 144.755565189589, "y": -31.835883064298233, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/10", "content": "std::move(t) returns static_cast<remove_reference_t<T>&&>(t), unconditionally casting t to an rvalue reference to enable move semantics.", "function": "std::move"}, {"id": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "label": "cpp20_move_if_noexcept_conditional_f9c5a", "x": 38.761201697226696, "y": 10.779875809608084, "size": 8.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/11-12", "content": "std::move_if_noexcept(x) returns a const lvalue reference if the type is not nothrow move constructible but is copy constructible; otherwise returns an rvalue reference. This enables strong exception safety when moving could throw.", "function": "std::move_if_noexcept"}, {"id": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "label": "cpp20_forward_rvalue_overload_mandates_a", "x": 37.613591439476714, "y": -82.55322673289284, "size": 7.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/2", "content": "The second overload of std::forward (taking remove_reference_t<T>&&) requires that is_lvalue_reference_v<T> is false. Attempting to forward an rvalue as an lvalue reference is ill-formed.", "function": "std::forward"}, {"id": "cpp20_forward_lvalue_overload_returns_f2e8a1c4", "label": "cpp20_forward_lvalue_overload_returns_f2", "x": 28.99303178062343, "y": -137.10511877455363, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/3", "content": "The first overload of std::forward (taking remove_reference_t<T>&) returns static_cast<T&&>(t), preserving the value category of the original expression.", "function": "std::forward"}, {"id": "cpp20_forward_rvalue_overload_returns_b5d9e3f7", "label": "cpp20_forward_rvalue_overload_returns_b5", "x": 29.510789987380942, "y": -127.33225910606527, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/3", "content": "The second overload of std::forward (taking remove_reference_t<T>&&) returns static_cast<T&&>(t), enabling forwarding of rvalues.", "function": "std::forward"}, {"id": "cpp20_forward_like_mandates_referenceable_c7a2b4e6", "label": "cpp20_forward_like_mandates_referenceabl", "x": 152.11473391576632, "y": -94.50331475868039, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/5", "content": "std::forward_like requires that T is a referenceable type. A type is referenceable if it can have a reference formed to it (not void, not a function type with cv-qualifiers or ref-qualifiers).", "function": "std::forward_like"}, {"id": "cpp20_forward_like_return_type_d8f1c3a9", "label": "cpp20_forward_like_return_type_d8f1c3a9", "x": 163.6502686008856, "y": -107.51995107556739, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[forward]/6-7", "content": "std::forward_like<T>(x) returns static_cast<V>(x) where V is computed as OVERRIDE_REF(T&&, COPY_CONST(remove_reference_t<T>, remove_reference_t<U>)), propagating const-ness and reference category from T to U.", "function": "std::forward_like"}, {"id": "cpp20_func_invoke_constraint_f_forwarding_ref_d6e2f7a0", "label": "cpp20_func_invoke_constraint_f_forwardin", "x": -598.0362020220498, "y": 806.7675536565192, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/1", "content": "The F&& parameter in std::invoke is a forwarding reference accepting both lvalue and rvalue callables", "function": "std::invoke"}, {"id": "cpp20_func_invoke_constraint_invocable_e5f6a7b8", "label": "cpp20_func_invoke_constraint_invocable_e", "x": -36.888805980916096, "y": 534.1983463607799, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/1", "content": "std::invoke requires is_invocable_v<F, Args...> to be true.", "function": "std::invoke"}, {"id": "cpp20_func_invoke_constraint_is_invocable_a7f3d2e1", "label": "cpp20_func_invoke_constraint_is_invocabl", "x": 394.7977887961651, "y": -418.53691827206444, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/1", "content": "std::invoke requires is_invocable_v<F, Args...> to be true", "function": "std::invoke"}, {"id": "cpp20_func_invoke_noexcept_conditional_d0e6f1a4", "label": "cpp20_func_invoke_noexcept_conditional_d", "x": -519.6727763527647, "y": -631.283272841617, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/1", "content": "std::invoke is noexcept if and only if is_nothrow_invocable_v<F, Args...> is true", "function": "std::invoke"}, {"id": "cpp20_func_invoke_effect_forward_args_c9d5e0f3", "label": "cpp20_func_invoke_effect_forward_args_c9", "x": 217.35884738064982, "y": 691.5559821848211, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/2", "content": "std::invoke perfectly forwards each argument using std::forward<Args>(args)...", "function": "std::invoke"}, {"id": "cpp20_func_invoke_effect_forward_f_b8c4d9e2", "label": "cpp20_func_invoke_effect_forward_f_b8c4d", "x": 569.8152196466336, "y": 51.95304382439163, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/2", "content": "std::invoke perfectly forwards f using std::forward<F>(f)", "function": "std::invoke"}, {"id": "cpp20_func_invoke_r_constraint_f_forwarding_ref_e7f3a8b1", "label": "cpp20_func_invoke_r_constraint_f_forward", "x": -692.2107278315347, "y": 723.8161704003097, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/3", "content": "The F&& parameter in std::invoke_r is a forwarding reference accepting both lvalue and rvalue callables", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_constraint_invocable_r_c9d0e1f2", "label": "cpp20_func_invoke_r_constraint_invocable", "x": 658.2893919500294, "y": -392.53825370914205, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/3", "content": "std::invoke_r requires is_invocable_r_v<R, F, Args...> to be true.", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_constraint_invocable_r_d9e0f1a2", "label": "cpp20_func_invoke_r_constraint_invocable", "x": -41.088008069664895, "y": 568.5873918100998, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/3", "content": "std::invoke_r requires is_invocable_r_v<R, F, Args...> to be true.", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_constraint_is_invocable_r_e1f7a2b5", "label": "cpp20_func_invoke_r_constraint_is_invoca", "x": 148.07751870085895, "y": 689.1308969991879, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/3", "content": "std::invoke_r requires is_invocable_r_v<R, F, Args...> to be true", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_noexcept_conditional_b4c0d5e8", "label": "cpp20_func_invoke_r_noexcept_conditional", "x": 699.5030536374745, "y": 327.9330668690566, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/3", "content": "std::invoke_r is noexcept if and only if is_nothrow_invocable_r_v<R, F, Args...> is true", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_effect_explicit_result_type_c5d1e6f9", "label": "cpp20_func_invoke_r_effect_explicit_resu", "x": -746.147992927984, "y": -304.97475397855527, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/4", "content": "std::invoke_r explicitly converts or casts the result to type R as specified by INVOKE<R>", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_effect_forward_args_a3b9c4d7", "label": "cpp20_func_invoke_r_effect_forward_args_", "x": 812.197311497084, "y": -448.3768656878812, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/4", "content": "std::invoke_r perfectly forwards each argument using std::forward<Args>(args)...", "function": "std::invoke_r"}, {"id": "cpp20_func_invoke_r_effect_forward_f_f2a8b3c6", "label": "cpp20_func_invoke_r_effect_forward_f_f2a", "x": -539.2971841363044, "y": -201.0104832701516, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.invoke]/4", "content": "std::invoke_r perfectly forwards f using std::forward<F>(f)", "function": "std::invoke_r"}, {"id": "cpp20_func_require_invoke_r_illformed_temp_ref_a1b2c3d4", "label": "cpp20_func_require_invoke_r_illformed_te", "x": -269.84061191095344, "y": 467.31933249123153, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.require]/2", "content": "INVOKE<R>(f, t1, t2, ..., tN) is ill-formed if reference_converts_from_temporary_v<R, decltype(INVOKE(f, t1, t2, ..., tN))> is true.", "function": ""}, {"id": "cpp20_func_require_invoke_reference_converts_ill_formed_a1b2c3d4", "label": "cpp20_func_require_invoke_reference_conv", "x": 540.6266837665105, "y": -97.16973425097687, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.require]/2", "content": "If reference_converts_from_temporary_v<R, decltype(INVOKE(f, t1, t2,..., tN))> is true, INVOKE<R>(f, t1, t2,..., tN) is ill-formed.", "function": "INVOKE"}, {"id": "cpp20_call_wrapper_moveconstructible_destructible_w3x4y5z6", "label": "cpp20_call_wrapper_moveconstructible_des", "x": -708.6958148798469, "y": -532.5462017692402, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.require]/3", "content": "Every call wrapper meets the Cpp17MoveConstructible and Cpp17Destructible requirements.", "function": ""}, {"id": "cpp20_perfect_forwarding_call_wrapper_cv_qual_e1f2a3b4", "label": "cpp20_perfect_forwarding_call_wrapper_cv", "x": 791.9412273000983, "y": 291.4537737784668, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.require]/4", "content": "A perfect forwarding call wrapper delivers state entities with cv-qualifiers matching the call wrapper, and cv shall be neither volatile nor const volatile.", "function": ""}, {"id": "cpp20_simple_call_wrapper_copyconstructible_copyassignable_a7b8c9d0", "label": "cpp20_simple_call_wrapper_copyconstructi", "x": -394.9535090729465, "y": 660.0974532641785, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.require]/6", "content": "A simple call wrapper meets Cpp17CopyConstructible and Cpp17CopyAssignable requirements and has constexpr non-throwing copy/move constructors and assignment operators.", "function": ""}, {"id": "cpp20_func_bind_call_wrapper_same_type_w5x6y7z8", "label": "cpp20_func_bind_call_wrapper_same_type_w", "x": 625.3191676267483, "y": 610.658855329598, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.require]/8", "content": "Argument forwarding call wrappers returned by a given standard library function template have the same type if the types of their corresponding state entities are the same.", "function": ""}, {"id": "cpp20_boyer_moore_searcher_precond_random_access_e3f4a5b6", "label": "cpp20_boyer_moore_searcher_precond_rando", "x": 824.4198020422143, "y": -348.8733025349501, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.search.bm]", "content": "boyer_moore_searcher requires RandomAccessIterator for the pattern.", "function": "std::boyer_moore_searcher"}, {"id": "cpp20_boyer_moore_horspool_searcher_precond_random_access_g7h8i9j0", "label": "cpp20_boyer_moore_horspool_searcher_prec", "x": 671.2644634051745, "y": -101.6120777558, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.search.bmh]", "content": "boyer_moore_horspool_searcher requires RandomAccessIterator for the pattern.", "function": "std::boyer_moore_horspool_searcher"}, {"id": "cpp20_func_wrap_copy_inv_precond_valid_target_g7h8i9j0", "label": "cpp20_func_wrap_copy_inv_precond_valid_t", "x": 713.6904675164523, "y": 414.2621535284186, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.wrap.copy.inv]/1", "content": "Calling operator() on copyable_function has precondition that *this has a target.", "function": "std::copyable_function::operator()"}, {"id": "cpp20_func_wrap_func_inv_throws_bad_function_call_e9f0a1b2", "label": "cpp20_func_wrap_func_inv_throws_bad_func", "x": 625.0473422228397, "y": 340.8825989782546, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.wrap.func.inv]/2", "content": "Calling operator() on an empty std::function throws bad_function_call.", "function": "std::function::operator()"}, {"id": "cpp20_func_wrap_move_inv_precond_valid_target_c3d4e5f6", "label": "cpp20_func_wrap_move_inv_precond_valid_t", "x": -766.961514004634, "y": 123.01026935649018, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.wrap.move.inv]/1", "content": "Calling operator() on move_only_function has precondition that *this has a target.", "function": "std::move_only_function::operator()"}, {"id": "cpp20_func_wrap_ref_ctor_precond_callable_k1l2m3n4", "label": "cpp20_func_wrap_ref_ctor_precond_callabl", "x": 749.1508971144773, "y": 629.8639095527099, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.wrap.ref.ctor]/3", "content": "function_ref constructor from F has precondition that f is a callable for R(ArgTypes...) with cv-qualifications and noexcept.", "function": "std::function_ref::function_ref"}, {"id": "cpp20_func_wrap_ref_ctor_precond_not_null_o5p6q7r8", "label": "cpp20_func_wrap_ref_ctor_precond_not_nul", "x": -797.8642069718039, "y": -525.9621034286802, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.wrap.ref.ctor]/3", "content": "function_ref constructor from function pointer has precondition that f is not a null pointer.", "function": "std::function_ref::function_ref"}, {"id": "cpp20_func_wrap_ref_dangling_precond_s9t0u1v2", "label": "cpp20_func_wrap_ref_dangling_precond_s9t", "x": -738.514639368447, "y": 394.6996575709884, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[func.wrap.ref.ctor]/7", "content": "function_ref constructed from nontype template parameter must not outlive the referenced callable when it refers to a pointer to member.", "function": "std::function_ref::function_ref"}, {"id": "cpp20_ref_cref_deleted_rvalue_s5t6u7v8", "label": "cpp20_ref_cref_deleted_rvalue_s5t6u7v8", "x": 605.7551637624974, "y": -523.9069558513393, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[functional.syn]", "content": "The ref and cref functions are deleted for rvalue arguments to prevent dangling references.", "function": "std::ref"}, {"id": "cpp20_inclusive_scan_mandate_init_convertible_b4c9e7f2", "label": "cpp20_inclusive_scan_mandate_init_conver", "x": 35.49083588832548, "y": 776.9950222098884, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[inclusive.scan]/4", "content": "If init is provided, all of binary_op(init, init), binary_op(init, *first), and binary_op(*first, *first) must be convertible to T; otherwise, binary_op(*first, *first) must be convertible to U (value type of decltype(first)).", "function": "std::inclusive_scan"}, {"id": "cpp20_inclusive_scan_precond_movable_c5d0f8a3", "label": "cpp20_inclusive_scan_precond_movable_c5d", "x": 645.5751372528475, "y": 100.53056618385686, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[inclusive.scan]/5", "content": "If init is provided, T must meet Cpp17MoveConstructible requirements; otherwise, U (value type of decltype(first)) must meet Cpp17MoveConstructible requirements.", "function": "std::inclusive_scan"}, {"id": "cpp20_inclusive_scan_precond_no_invalidate_d6e1a9b4", "label": "cpp20_inclusive_scan_precond_no_invalida", "x": 516.0712886580019, "y": -28.270672598777857, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[inclusive.scan]/5", "content": "binary_op must neither invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)].", "function": "std::inclusive_scan"}, {"id": "cpp20_inner_product_precond_no_modify_a1b6d4e9", "label": "cpp20_inner_product_precond_no_modify_a1", "x": -613.0569828609089, "y": 227.01061213024235, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[inner.product]/1", "content": "In the ranges [first1, last1] and [first2, first2+(last1-first1)], binary_op1 and binary_op2 must neither modify elements nor invalidate iterators or subranges.", "function": "std::inner_product"}, {"id": "cpp20_inner_product_precond_t_copyable_f0a5c3d8", "label": "cpp20_inner_product_precond_t_copyable_f", "x": 295.71993153491826, "y": 802.6027526938254, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[inner.product]/1", "content": "Type T must meet Cpp17CopyConstructible and Cpp17CopyAssignable requirements for std::inner_product.", "function": "std::inner_product"}, {"id": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "label": "cpp20_iterator_operations_advance_negati", "x": -76.83649086913086, "y": -118.7274866720759, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[iterator.operations]/2", "content": "Calling std::advance with a negative distance n requires the iterator to be a bidirectional iterator.", "function": "std::advance"}, {"id": "cpp20_iterator_operations_distance_reachable_precondition_b4e8d1f6", "label": "cpp20_iterator_operations_distance_reach", "x": -266.9680433761022, "y": -2.81354182840979, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[iterator.operations]/4", "content": "Calling std::distance requires that last is reachable from first, or for random access iterators, first is reachable from last.", "function": "std::distance"}, {"id": "cpp20_iterator_operations_next_effect_c5f9a2b7", "label": "cpp20_iterator_operations_next_effect_c5", "x": -187.4053106509659, "y": -157.54836038476165, "size": 16.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[iterator.operations]/6", "content": "std::next advances a copy of the iterator by n positions and returns the result.", "function": "std::next"}, {"id": "cpp20_iterator_operations_prev_effect_d6a0b3c8", "label": "cpp20_iterator_operations_prev_effect_d6", "x": -194.12516498004862, "y": -171.23212861580126, "size": 16.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[iterator.operations]/7", "content": "std::prev retreats a copy of the iterator by n positions and returns the result.", "function": "std::prev"}, {"id": "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9", "label": "cpp20_iterator_operations_prev_requires_", "x": -159.26030126030014, "y": -144.82175702419588, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[iterator.operations]/7", "content": "std::prev requires a bidirectional iterator because it calls advance with a negative value (-n).", "function": "std::prev"}, {"id": "cpp20_meta_trans_cv_remove_const_example_volatile_preserved_4d8e9c2a", "label": "cpp20_meta_trans_cv_remove_const_example", "x": 557.9651648886572, "y": -528.0709817086931, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Example1", "content": "remove_const_t<const volatile int> preserves volatile qualifier and evaluates to volatile int.", "function": "std::remove_const"}, {"id": "cpp20_meta_trans_cv_remove_const_pointer_target_unchanged_6f1a4b7c", "label": "cpp20_meta_trans_cv_remove_const_pointer", "x": 123.73920682678906, "y": 643.6356416679843, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Example1", "content": "remove_const_t<const int*> does not remove const from pointed-to type, evaluates to const int*.", "function": "std::remove_const"}, {"id": "cpp20_meta_trans_cv_remove_volatile_example_const_preserved_3e7f1a9d", "label": "cpp20_meta_trans_cv_remove_volatile_exam", "x": 188.36655726070197, "y": -719.0075677127539, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Example2", "content": "remove_volatile_t<const volatile int> preserves const qualifier and evaluates to const int.", "function": "std::remove_volatile"}, {"id": "cpp20_meta_trans_cv_remove_volatile_pointer_target_unchanged_8c4d2e6f", "label": "cpp20_meta_trans_cv_remove_volatile_poin", "x": -250.7233826017091, "y": 657.1651520610293, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Example2", "content": "remove_volatile_t<volatile int*> does not remove volatile from pointed-to type, evaluates to volatile int*.", "function": "std::remove_volatile"}, {"id": "cpp20_meta_trans_cv_remove_cv_example_int_unqualified_2f8a4b6c", "label": "cpp20_meta_trans_cv_remove_cv_example_in", "x": 106.36144549145128, "y": -970.0833138474394, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Example3", "content": "remove_cv_t<const volatile int> removes both qualifiers and evaluates to int.", "function": "std::remove_cv"}, {"id": "cpp20_meta_trans_cv_remove_cv_pointer_target_unchanged_7d3e9f1a", "label": "cpp20_meta_trans_cv_remove_cv_pointer_ta", "x": 389.70302974577737, "y": -906.6537103517506, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Example3", "content": "remove_cv_t<const volatile int*> does not remove qualifiers from pointed-to type, evaluates to const volatile int*.", "function": "std::remove_cv"}, {"id": "cpp20_meta_trans_cv_add_const_no_effect_already_const_3f9a7b2c", "label": "cpp20_meta_trans_cv_add_const_no_effect_", "x": 486.05995243185436, "y": -605.9639265278051, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Note1", "content": "add_const has no effect when T is already a top-level const-qualified type.", "function": "std::add_const"}, {"id": "cpp20_meta_trans_cv_add_const_no_effect_function_6c8d2a4e", "label": "cpp20_meta_trans_cv_add_const_no_effect_", "x": 891.1213690139696, "y": -257.1950716775467, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Note1", "content": "add_const has no effect when T is a function type.", "function": "std::add_const"}, {"id": "cpp20_meta_trans_cv_add_const_no_effect_reference_9e1f5a3b", "label": "cpp20_meta_trans_cv_add_const_no_effect_", "x": -331.92074397717494, "y": -720.7730855978144, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Note1", "content": "add_const has no effect when T is a reference type.", "function": "std::add_const"}, {"id": "cpp20_meta_trans_cv_add_volatile_no_effect_already_volatile_9b3c7e2f", "label": "cpp20_meta_trans_cv_add_volatile_no_effe", "x": -312.4800067385126, "y": 794.3829116104067, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Note2", "content": "add_volatile has no effect when T is already a top-level volatile-qualified type.", "function": "std::add_volatile"}, {"id": "cpp20_meta_trans_cv_add_volatile_no_effect_function_5c1d8a6e", "label": "cpp20_meta_trans_cv_add_volatile_no_effe", "x": 979.6844602523577, "y": -205.99027604408423, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Note2", "content": "add_volatile has no effect when T is a function type.", "function": "std::add_volatile"}, {"id": "cpp20_meta_trans_cv_add_volatile_no_effect_reference_2e7f9a3b", "label": "cpp20_meta_trans_cv_add_volatile_no_effe", "x": -124.827722013635, "y": 617.9165617261206, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Note2", "content": "add_volatile has no effect when T is a reference type.", "function": "std::add_volatile"}, {"id": "cpp20_meta_trans_cv_add_const_denotes_const_t_4b7c2e8f", "label": "cpp20_meta_trans_cv_add_const_denotes_co", "x": 832.6103408053503, "y": 192.21736306904137, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Table57", "content": "add_const<T>::type denotes const T.", "function": "std::add_const"}, {"id": "cpp20_meta_trans_cv_add_cv_composition_6d2e8f4a", "label": "cpp20_meta_trans_cv_add_cv_composition_6", "x": -425.79291529841396, "y": -394.24773997331874, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Table57", "content": "add_cv<T>::type is equivalent to add_const_t<add_volatile_t<T>>.", "function": "std::add_cv"}, {"id": "cpp20_meta_trans_cv_add_volatile_denotes_volatile_t_8a4b6c1d", "label": "cpp20_meta_trans_cv_add_volatile_denotes", "x": 285.67783334847303, "y": -942.4734951459624, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Table57", "content": "add_volatile<T>::type denotes volatile T.", "function": "std::add_volatile"}, {"id": "cpp20_meta_trans_cv_remove_const_top_level_only_7a3f2b1e", "label": "cpp20_meta_trans_cv_remove_const_top_lev", "x": 411.32043956639166, "y": -462.7718381324301, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Table57", "content": "remove_const only removes top-level const-qualifier from T, not const qualifiers from pointer or reference targets.", "function": "std::remove_const"}, {"id": "cpp20_meta_trans_cv_remove_cv_removes_both_qualifiers_5a9b3c7d", "label": "cpp20_meta_trans_cv_remove_cv_removes_bo", "x": 518.7364377177361, "y": -772.2385666375018, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Table57", "content": "remove_cv removes both top-level const and volatile qualifiers from T.", "function": "std::remove_cv"}, {"id": "cpp20_meta_trans_cv_remove_volatile_top_level_only_9b2c5d8e", "label": "cpp20_meta_trans_cv_remove_volatile_top_", "x": 481.77121805128564, "y": -220.76467104012372, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.cv]/Table57", "content": "remove_volatile only removes top-level volatile-qualifier from T, not volatile qualifiers from pointer or reference targets.", "function": "std::remove_volatile"}, {"id": "cpp20_meta_trans_other_unwrap_functional_header_b5c6d7e8", "label": "cpp20_meta_trans_other_unwrap_functional", "x": 202.95016257538748, "y": -894.8107786945338, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/2", "content": "The templates unwrap_reference, unwrap_ref_decay, unwrap_reference_t, and unwrap_ref_decay_t are available when the header <functional> is included, in addition to <type_traits>.", "function": "std::unwrap_reference"}, {"id": "cpp20_meta_trans_other_common_type_zero_args_f9a0b1c2", "label": "cpp20_meta_trans_other_common_type_zero_", "x": 456.38421746810764, "y": 270.37993524362133, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/4.1", "content": "For common_type applied to zero types (sizeof...(T) == 0), there shall be no member type.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_one_arg_d3e4f5a6", "label": "cpp20_meta_trans_other_common_type_one_a", "x": 190.55133509759764, "y": 529.0752253546726, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/4.2", "content": "For common_type applied to one type T0 (sizeof...(T) == 1), the member typedef type shall denote the same type as common_type_t<T0, T0>, or there shall be no member type if that is ill-formed.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_two_args_decay_differs_b7c8d9e0", "label": "cpp20_meta_trans_other_common_type_two_a", "x": 372.1737107422706, "y": 641.6964275997295, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/4.3.1", "content": "For common_type applied to two types T1 and T2, if is_same_v<T1, D1> is false or is_same_v<T2, D2> is false (where D1 = decay_t<T1>, D2 = decay_t<T2>), let C denote the same type as common_type_t<D1, D2>, and the member type shall denote C if well-formed, otherwise no member type.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_two_args_ternary_f1a2b3c4", "label": "cpp20_meta_trans_other_common_type_two_a", "x": -415.28056323559855, "y": 676.108751253012, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/4.3.3", "content": "For common_type applied to two already-decayed types D1 and D2, if decay_t<decltype(false ? declval<D1>() : declval<D2>())> denotes a valid type, let C denote that type, and the member type shall denote C.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_two_args_cond_res_e5f6a7b8", "label": "cpp20_meta_trans_other_common_type_two_a", "x": 29.851906507925047, "y": -888.0935861760032, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/4.3.4", "content": "For common_type applied to two already-decayed types D1 and D2, if the ternary operator approach does not apply and COND-RES(CREF(D1), CREF(D2)) denotes a type, let C denote decay_t<COND-RES(CREF(D1), CREF(D2))>, and the member type shall denote C.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_multiple_args_c9d0e1f2", "label": "cpp20_meta_trans_other_common_type_multi", "x": -858.2962265072667, "y": -271.8281843568313, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/4.4", "content": "For common_type applied to more than two types (sizeof...(T) > 2), let T1, T2, and R denote the first, second, and remaining types. Let C denote common_type_t<T1, T2>. If C is well-formed, the member type shall denote common_type_t<C, R...> if well-formed, otherwise no member type. If C is ill-forme", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_spec_cv_unqualified_f5a6b7c8", "label": "cpp20_meta_trans_other_common_type_spec_", "x": 605.4508517613224, "y": 443.5109200814222, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/5", "content": "A specialization of common_type<T1, T2>, if it has a member named type, the qualified-id common_type<T1, T2>::type shall denote a cv-unqualified non-reference type to which each of T1 and T2 is explicitly convertible.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_spec_symmetric_d9e0f1a2", "label": "cpp20_meta_trans_other_common_type_spec_", "x": 709.3112487513275, "y": 27.267802458735346, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/5", "content": "A specialization of common_type<T1, T2> must ensure that common_type_t<T1, T2> denotes the same type as common_type_t<T2, T1>.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_type_specialization_allowed_a7b8c9d0", "label": "cpp20_meta_trans_other_common_type_speci", "x": -38.682720833673535, "y": -788.8297725252723, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/5", "content": "A program may specialize common_type<T1, T2> for types T1 and T2 such that is_same_v<T1, decay_t<T1>> and is_same_v<T2, decay_t<T2>> are each true.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_common_reference_zero_args_b3c4d5e6", "label": "cpp20_meta_trans_other_common_reference_", "x": -576.5891928543377, "y": -197.34488242455055, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.1", "content": "For common_reference applied to zero types (sizeof...(T) == 0), there shall be no member type.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_one_arg_a8b9c0d1", "label": "cpp20_meta_trans_other_common_reference_", "x": -757.3997760948049, "y": -468.3313455990038, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.2", "content": "For common_reference applied to one type T0 (sizeof...(T) == 1), the member typedef type shall denote the same type as T0.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_two_args_common_ref_e2f3a4b5", "label": "cpp20_meta_trans_other_common_reference_", "x": 277.6366718354561, "y": 637.5073176766929, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.3.1", "content": "For common_reference applied to two reference types T1 and T2, let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is well-formed, and is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> && is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is true, then the member typedef type den", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_two_args_basic_c7d8e9f0", "label": "cpp20_meta_trans_other_common_reference_", "x": 794.8910156482655, "y": 607.3766229094334, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.3.2", "content": "For common_reference applied to two types T1 and T2, if the COMMON-REF approach does not apply and basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, XREF(T1), XREF(T2)>::type is well-formed, then the member typedef type denotes that type.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_two_args_cond_res_a5b6c7d8", "label": "cpp20_meta_trans_other_common_reference_", "x": 507.05594913845454, "y": -278.16606383876774, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.3.3", "content": "For common_reference applied to two types T1 and T2, if previous approaches do not apply and COND-RES(T1, T2) is well-formed, then the member typedef type denotes that type.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_two_args_common_type_f9a0b1c2", "label": "cpp20_meta_trans_other_common_reference_", "x": 281.18682829582906, "y": 671.1914299436977, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.3.4", "content": "For common_reference applied to two types T1 and T2, if previous approaches do not apply and common_type_t<T1, T2> is well-formed, then the member typedef type denotes that type.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_two_args_no_type_d3e4f5a6", "label": "cpp20_meta_trans_other_common_reference_", "x": -780.6692575713432, "y": -117.88200551718326, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.3.5", "content": "For common_reference applied to two types T1 and T2, if none of the specified approaches apply, there shall be no member type.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_multiple_args_b7c8d9e0", "label": "cpp20_meta_trans_other_common_reference_", "x": 751.9587684020438, "y": -219.73493030212873, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/6.4", "content": "For common_reference applied to more than two types (sizeof...(T) > 2), let T1, T2, and Rest denote the first, second, and remaining types. Let C denote common_reference_t<T1, T2>. If C is well-formed, the member typedef type shall denote common_reference_t<C, Rest...> if well-formed, otherwise no m", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_basic_common_reference_spec_convertible_e5f6a7b8", "label": "cpp20_meta_trans_other_basic_common_refe", "x": 384.4043251953775, "y": 383.2242706198248, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/7", "content": "A specialization of basic_common_reference<T, U, TQual, UQual>, if it has a member named type, the qualified-id basic_common_reference<T, U, TQual, UQual>::type shall denote a type to which each of TQual<T> and UQual<U> is convertible.", "function": "std::basic_common_reference"}, {"id": "cpp20_meta_trans_other_basic_common_reference_spec_symmetric_c9d0e1f2", "label": "cpp20_meta_trans_other_basic_common_refe", "x": -688.4376782157118, "y": -279.61126941633773, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/7", "content": "A specialization of basic_common_reference<T, U, TQual, UQual> must ensure that basic_common_reference<T, U, TQual, UQual>::type denotes the same type as basic_common_reference<U, T, UQual, TQual>::type.", "function": "std::basic_common_reference"}, {"id": "cpp20_meta_trans_other_basic_common_reference_specialization_allowed_f1a2b3c4", "label": "cpp20_meta_trans_other_basic_common_refe", "x": -233.1718040918604, "y": -941.7379184877194, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/7", "content": "A program may partially specialize basic_common_reference<T, U, TQual, UQual> for types T and U such that is_same_v<T, decay_t<T>> and is_same_v<U, decay_t<U>> are each true.", "function": "std::basic_common_reference"}, {"id": "cpp20_meta_trans_other_apply_result_access_checking_f1a2b3c4", "label": "cpp20_meta_trans_other_apply_result_acce", "x": -845.6115172661413, "y": 457.7410365009009, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For apply_result<Fn, Tuple>, access checking is performed as if in a context unrelated to Fn and Tuple.", "function": "std::apply_result"}, {"id": "cpp20_meta_trans_other_apply_result_ill_formed_case_b7c8d9e0", "label": "cpp20_meta_trans_other_apply_result_ill_", "x": -659.8245629730407, "y": 30.550966597285505, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For apply_result<Fn, Tuple>, if tuple-like<Tuple> is false or INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...) is not well-formed, there shall be no member type.", "function": "std::apply_result"}, {"id": "cpp20_meta_trans_other_apply_result_immediate_context_e5f6a7b8", "label": "cpp20_meta_trans_other_apply_result_imme", "x": -264.44243776517663, "y": 914.2127596991867, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For apply_result<Fn, Tuple>, only the validity of the immediate context of the INVOKE expression is considered.", "function": "std::apply_result"}, {"id": "cpp20_meta_trans_other_apply_result_precond_complete_c9d0e1f2", "label": "cpp20_meta_trans_other_apply_result_prec", "x": -651.5292839647071, "y": -167.4921452911063, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "Precondition for apply_result<Fn, Tuple>: Fn and Tuple are complete types, cv void, or arrays of unknown bound.", "function": "std::apply_result"}, {"id": "cpp20_meta_trans_other_apply_result_well_formed_case_d3e4f5a6", "label": "cpp20_meta_trans_other_apply_result_well", "x": 694.143135965366, "y": 567.152376445188, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For apply_result<Fn, Tuple>, if tuple-like<Tuple> is true and INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...) is well-formed when treated as unevaluated operand, the member typedef type denotes decltype(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...)).", "function": "std::apply_result"}, {"id": "cpp20_meta_trans_other_basic_common_reference_no_default_e2f3a4b5", "label": "cpp20_meta_trans_other_basic_common_refe", "x": -555.4077885221608, "y": 604.0546069766447, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "Unless basic_common_reference trait is specialized, there shall be no member type.", "function": "std::basic_common_reference"}, {"id": "cpp20_meta_trans_other_common_reference_completeness_a7b8c9d0", "label": "cpp20_meta_trans_other_common_reference_", "x": -468.55746943718435, "y": -255.39878827260142, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "Each type in the parameter pack T of common_reference shall be complete or cv void.", "function": "std::common_reference"}, {"id": "cpp20_meta_trans_other_common_type_completeness_b4c5d6e7", "label": "cpp20_meta_trans_other_common_type_compl", "x": -600.2700770323103, "y": -661.9576069188074, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "Each type in the template parameter pack T of common_type shall be complete, cv void, or an array of unknown bound.", "function": "std::common_type"}, {"id": "cpp20_meta_trans_other_conditional_false_case_c7d8e9f0", "label": "cpp20_meta_trans_other_conditional_false", "x": 634.351792995089, "y": 28.97687821574945, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For conditional<B, T, F>, if B is false, the member typedef type denotes F.", "function": "std::conditional"}, {"id": "cpp20_meta_trans_other_conditional_true_case_f8a9b1c2", "label": "cpp20_meta_trans_other_conditional_true_", "x": -145.9910728614379, "y": 678.5480613073197, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For conditional<B, T, F>, if B is true, the member typedef type denotes T.", "function": "std::conditional"}, {"id": "cpp20_meta_trans_other_decay_array_case_f7a8b3c2", "label": "cpp20_meta_trans_other_decay_array_case_", "x": 514.8070215969494, "y": -656.0262000177137, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For decay<T>, let U = remove_reference_t<T>. If is_array_v<U> is true, the member typedef type denotes remove_extent_t<U>*.", "function": "std::decay"}, {"id": "cpp20_meta_trans_other_decay_default_case_e9f1a4b7", "label": "cpp20_meta_trans_other_decay_default_cas", "x": 191.29285526852954, "y": -807.0976982025022, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For decay<T>, let U = remove_reference_t<T>. If is_array_v<U> and is_function_v<U> are both false, the member typedef type denotes remove_cv_t<U>.", "function": "std::decay"}, {"id": "cpp20_meta_trans_other_decay_function_case_b2c5d8e1", "label": "cpp20_meta_trans_other_decay_function_ca", "x": 588.9721685991775, "y": 409.7688550358454, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For decay<T>, let U = remove_reference_t<T>. If is_function_v<U> is true, the member typedef type denotes add_pointer_t<U>.", "function": "std::decay"}, {"id": "cpp20_meta_trans_other_enable_if_false_case_d3e4f5a6", "label": "cpp20_meta_trans_other_enable_if_false_c", "x": 682.3843756623398, "y": -639.9786583108173, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For enable_if<B, T>, if B is false, there shall be no member type.", "function": "std::enable_if"}, {"id": "cpp20_meta_trans_other_enable_if_true_case_a5b6c7d8", "label": "cpp20_meta_trans_other_enable_if_true_ca", "x": -840.7998403131354, "y": -341.42986051216997, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For enable_if<B, T>, if B is true, the member typedef type denotes T.", "function": "std::enable_if"}, {"id": "cpp20_meta_trans_other_invoke_result_access_checking_c7d8e9f0", "label": "cpp20_meta_trans_other_invoke_result_acc", "x": -533.1243241953534, "y": -532.1172575605865, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For invoke_result<Fn, ArgTypes...>, access checking is performed as if in a context unrelated to Fn and ArgTypes.", "function": "std::invoke_result"}, {"id": "cpp20_meta_trans_other_invoke_result_ill_formed_case_e2f3a4b5", "label": "cpp20_meta_trans_other_invoke_result_ill", "x": 732.6754819566085, "y": -376.43739709488295, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For invoke_result<Fn, ArgTypes...>, if INVOKE(declval<Fn>(), declval<ArgTypes>()...) is not well-formed, there shall be no member type.", "function": "std::invoke_result"}, {"id": "cpp20_meta_trans_other_invoke_result_immediate_context_a5b6c7d8", "label": "cpp20_meta_trans_other_invoke_result_imm", "x": -467.1003487567853, "y": 558.1034966287475, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For invoke_result<Fn, ArgTypes...>, only the validity of the immediate context of the INVOKE expression is considered.", "function": "std::invoke_result"}, {"id": "cpp20_meta_trans_other_invoke_result_precond_complete_f9a0b1c2", "label": "cpp20_meta_trans_other_invoke_result_pre", "x": -63.757886552325566, "y": 697.7967039410956, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "Precondition for invoke_result<Fn, ArgTypes...>: Fn and all types in the template parameter pack ArgTypes are complete types, cv void, or arrays of unknown bound.", "function": "std::invoke_result"}, {"id": "cpp20_meta_trans_other_invoke_result_well_formed_case_a8b9c0d1", "label": "cpp20_meta_trans_other_invoke_result_wel", "x": -885.6496548783848, "y": 7.273277752991279, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For invoke_result<Fn, ArgTypes...>, if INVOKE(declval<Fn>(), declval<ArgTypes>()...) is well-formed when treated as unevaluated operand, the member typedef type denotes decltype(INVOKE(declval<Fn>(), declval<ArgTypes>()...)).", "function": "std::invoke_result"}, {"id": "cpp20_meta_trans_other_remove_cvref_typedef_c4d9e2f1", "label": "cpp20_meta_trans_other_remove_cvref_type", "x": -731.467298272082, "y": -623.4733490385197, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "The member typedef type of remove_cvref<T> denotes remove_cv_t<remove_reference_t<T>>.", "function": "std::remove_cvref"}, {"id": "cpp20_meta_trans_other_type_identity_typedef_8a3f2b1c", "label": "cpp20_meta_trans_other_type_identity_typ", "x": 672.5278460489711, "y": -604.5619501996497, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "The member typedef type of type_identity<T> denotes T exactly.", "function": "std::type_identity"}, {"id": "cpp20_meta_trans_other_underlying_type_enum_case_f5a6b7c8", "label": "cpp20_meta_trans_other_underlying_type_e", "x": 202.99401666237958, "y": -517.625434377089, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For underlying_type<T>, if T is an enumeration type, the member typedef type denotes the underlying type of T.", "function": "std::underlying_type"}, {"id": "cpp20_meta_trans_other_underlying_type_mandate_complete_b3c4d5e6", "label": "cpp20_meta_trans_other_underlying_type_m", "x": -224.9276850821312, "y": 851.3452910722748, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For underlying_type<T>, T must not be an incomplete enumeration type (Mandates).", "function": "std::underlying_type"}, {"id": "cpp20_meta_trans_other_underlying_type_non_enum_case_d9e0f1a2", "label": "cpp20_meta_trans_other_underlying_type_n", "x": -952.641358273525, "y": 267.07328795119304, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For underlying_type<T>, if T is not an enumeration type, there is no member type.", "function": "std::underlying_type"}, {"id": "cpp20_meta_trans_other_unwrap_ref_decay_typedef_c1d2e3f4", "label": "cpp20_meta_trans_other_unwrap_ref_decay_", "x": 947.3862756739586, "y": 79.35435272627652, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "The member typedef type of unwrap_ref_decay<T> denotes unwrap_reference_t<decay_t<T>>.", "function": "std::unwrap_ref_decay"}, {"id": "cpp20_meta_trans_other_unwrap_reference_non_wrapper_case_e7f8a9b0", "label": "cpp20_meta_trans_other_unwrap_reference_", "x": 634.640365021089, "y": -690.871868935014, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For unwrap_reference<T>, if T is not a specialization of reference_wrapper, the member typedef type denotes T.", "function": "std::unwrap_reference"}, {"id": "cpp20_meta_trans_other_unwrap_reference_wrapper_case_a3b4c5d6", "label": "cpp20_meta_trans_other_unwrap_reference_", "x": -151.08950849986473, "y": -665.7132151358242, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.other]/Table62", "content": "For unwrap_reference<T>, if T is a specialization reference_wrapper<X> for some type X, the member typedef type denotes X&.", "function": "std::unwrap_reference"}, {"id": "cpp20_meta_trans_ptr_add_pointer_non_referenceable_d9e2f4a6", "label": "cpp20_meta_trans_ptr_add_pointer_non_ref", "x": 344.01551065795644, "y": 933.0637373049959, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ptr]/Table61", "content": "If T is not a referenceable type and not a cv void type, then add_pointer<T>::type denotes T unchanged.", "function": "std::add_pointer"}, {"id": "cpp20_meta_trans_ptr_add_pointer_reference_removal_e3f7b9c2", "label": "cpp20_meta_trans_ptr_add_pointer_referen", "x": -127.47364940836512, "y": -156.54668333968593, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ptr]/Table61", "content": "add_pointer first removes any reference from T (via remove_reference_t) before adding pointer, so reference types become pointer-to-referred-type.", "function": "std::add_pointer"}, {"id": "cpp20_meta_trans_ptr_add_pointer_referenceable_c5d8a1e7", "label": "cpp20_meta_trans_ptr_add_pointer_referen", "x": -274.6237888475005, "y": -363.4357461353055, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ptr]/Table61", "content": "If T is a referenceable type or a cv void type, then add_pointer<T>::type denotes remove_reference_t<T>*.", "function": "std::add_pointer"}, {"id": "cpp20_meta_trans_ptr_remove_pointer_cv_qualified_a8f3d2e1", "label": "cpp20_meta_trans_ptr_remove_pointer_cv_q", "x": -27.61993011813305, "y": 934.6518036532957, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ptr]/Table61", "content": "If T has type \"(possibly cv-qualified) pointer to T1\" then remove_pointer<T>::type denotes T1.", "function": "std::remove_pointer"}, {"id": "cpp20_meta_trans_ptr_remove_pointer_non_pointer_b7c9e4f2", "label": "cpp20_meta_trans_ptr_remove_pointer_non_", "x": 343.96092367448193, "y": -509.14785076264474, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ptr]/Table61", "content": "If T is not a pointer type, then remove_pointer<T>::type denotes T unchanged.", "function": "std::remove_pointer"}, {"id": "cpp20_meta_trans_ref_add_lvalue_reference_nonreferenceable_a9b3e7f2", "label": "cpp20_meta_trans_ref_add_lvalue_referenc", "x": -682.705447951078, "y": -569.9539308629772, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58", "content": "If T is not a referenceable type, then add_lvalue_reference<T>::type denotes T.", "function": ""}, {"id": "cpp20_meta_trans_ref_add_lvalue_reference_referenceable_c2d8f4a1", "label": "cpp20_meta_trans_ref_add_lvalue_referenc", "x": -36.83857854140714, "y": -160.7927385803955, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58", "content": "If T is a referenceable type, then add_lvalue_reference<T>::type denotes T&.", "function": ""}, {"id": "cpp20_meta_trans_ref_add_rvalue_reference_nonreferenceable_d3e7a2f9", "label": "cpp20_meta_trans_ref_add_rvalue_referenc", "x": 796.5095404659452, "y": 119.25365043024281, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58", "content": "If T is not a referenceable type, then add_rvalue_reference<T>::type denotes T.", "function": ""}, {"id": "cpp20_meta_trans_ref_add_rvalue_reference_referenceable_b8d2f5a3", "label": "cpp20_meta_trans_ref_add_rvalue_referenc", "x": -307.5315687172503, "y": -29.26295466591078, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58", "content": "If T is a referenceable type, then add_rvalue_reference<T>::type denotes T&&.", "function": ""}, {"id": "cpp20_meta_trans_ref_remove_reference_nonref_type_d7e3a9b5", "label": "cpp20_meta_trans_ref_remove_reference_no", "x": 742.9007327404095, "y": 409.2801779831198, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58", "content": "If T is not a reference type, then remove_reference<T>::type denotes T.", "function": ""}, {"id": "cpp20_meta_trans_ref_remove_reference_ref_type_f4a8b2c1", "label": "cpp20_meta_trans_ref_remove_reference_re", "x": -869.4576466959384, "y": 340.2088090854153, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58", "content": "If T has type \"reference to T1\", then remove_reference<T>::type denotes T1.", "function": ""}, {"id": "cpp20_meta_trans_ref_add_lvalue_reference_collapse_semantics_e5f1a8c4", "label": "cpp20_meta_trans_ref_add_lvalue_referenc", "x": -292.25560068360306, "y": -343.06618349020147, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58/Note1", "content": "add_lvalue_reference reflects reference collapsing semantics as specified in [dcl.ref].", "function": ""}, {"id": "cpp20_meta_trans_ref_add_rvalue_reference_collapse_semantics_f7a4b9e1", "label": "cpp20_meta_trans_ref_add_rvalue_referenc", "x": -479.1112494824673, "y": -207.19945234951933, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58/Note2", "content": "add_rvalue_reference reflects reference collapsing semantics as specified in [dcl.ref].", "function": ""}, {"id": "cpp20_meta_trans_ref_add_rvalue_reference_lvalue_ref_not_rvalue_c5d9e2f8", "label": "cpp20_meta_trans_ref_add_rvalue_referenc", "x": -109.69914401361392, "y": -140.08170498133967, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.trans.ref]/Table58/Note2", "content": "When T is a reference type T1&, add_rvalue_reference_t<T> is not an rvalue reference due to reference collapsing.", "function": ""}, {"id": "cpp20_meta_unary_cat_is_array_condition_3a9b6e0d", "label": "cpp20_meta_unary_cat_is_array_condition_", "x": 759.86950143467, "y": 335.22254229777707, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_array<T>::value is true if and only if T is an array type of known or unknown extent.", "function": "std::is_array"}, {"id": "cpp20_meta_unary_cat_is_array_excludes_std_array_4b0c7f1e", "label": "cpp20_meta_unary_cat_is_array_excludes_s", "x": -319.16141246639006, "y": -450.7448845625143, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "Class template std::array is not considered an array type for std::is_array.", "function": "std::is_array"}, {"id": "cpp20_meta_unary_cat_is_class_condition_3e9f6c0b", "label": "cpp20_meta_unary_cat_is_class_condition_", "x": 548.2410435668655, "y": 118.87664859634235, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_class<T>::value is true if and only if T is a non-union class type.", "function": "std::is_class"}, {"id": "cpp20_meta_unary_cat_is_enum_condition_1c7d4a8f", "label": "cpp20_meta_unary_cat_is_enum_condition_1", "x": -901.5531887383457, "y": 52.120370967656314, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_enum<T>::value is true if and only if T is an enumeration type.", "function": "std::is_enum"}, {"id": "cpp20_meta_unary_cat_is_floating_point_condition_2f8a5d9c", "label": "cpp20_meta_unary_cat_is_floating_point_c", "x": 730.6550220014772, "y": -132.65076411228415, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_floating_point<T>::value is true if and only if T is a floating-point type.", "function": "std::is_floating_point"}, {"id": "cpp20_meta_unary_cat_is_function_condition_4f0a7d1c", "label": "cpp20_meta_unary_cat_is_function_conditi", "x": -855.4557052885283, "y": 408.31212975028245, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_function<T>::value is true if and only if T is a function type.", "function": "std::is_function"}, {"id": "cpp20_meta_unary_cat_is_integral_condition_1e7f4c8b", "label": "cpp20_meta_unary_cat_is_integral_conditi", "x": -644.3886995104199, "y": -436.5272752010024, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_integral<T>::value is true if and only if T is an integral type.", "function": "std::is_integral"}, {"id": "cpp20_meta_unary_cat_is_lvalue_reference_condition_7e3f0c4b", "label": "cpp20_meta_unary_cat_is_lvalue_reference", "x": -276.29589738961096, "y": -341.8926849509681, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_lvalue_reference<T>::value is true if and only if T is an lvalue reference type.", "function": "std::is_lvalue_reference"}, {"id": "cpp20_meta_unary_cat_is_member_function_pointer_condition_0b6c3f7e", "label": "cpp20_meta_unary_cat_is_member_function_", "x": 682.33842692346, "y": 26.517159326074353, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_member_function_pointer<T>::value is true if and only if T is a pointer to member function.", "function": "std::is_member_function_pointer"}, {"id": "cpp20_meta_unary_cat_is_member_object_pointer_condition_9a5b2e6d", "label": "cpp20_meta_unary_cat_is_member_object_po", "x": -440.52986294823444, "y": 725.4453254392721, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_member_object_pointer<T>::value is true if and only if T is a pointer to data member.", "function": "std::is_member_object_pointer"}, {"id": "cpp20_meta_unary_cat_is_null_pointer_condition_0d6e3b7a", "label": "cpp20_meta_unary_cat_is_null_pointer_con", "x": 681.2575493532712, "y": 601.2827104941089, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_null_pointer<T>::value is true if and only if T is nullptr_t.", "function": "std::is_null_pointer"}, {"id": "cpp20_meta_unary_cat_is_pointer_condition_5c1d8a2f", "label": "cpp20_meta_unary_cat_is_pointer_conditio", "x": -227.98407357312317, "y": -338.04815443288004, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_pointer<T>::value is true if and only if T is a pointer type.", "function": "std::is_pointer"}, {"id": "cpp20_meta_unary_cat_is_pointer_includes_function_ptr_6d2e9b3a", "label": "cpp20_meta_unary_cat_is_pointer_includes", "x": -231.0762586644241, "y": -443.0164228273581, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_pointer includes pointers to functions but not pointers to non-static members.", "function": "std::is_pointer"}, {"id": "cpp20_meta_unary_cat_is_reflection_condition_5a1b8e2d", "label": "cpp20_meta_unary_cat_is_reflection_condi", "x": -763.9254761591462, "y": -608.8195740279047, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_reflection<T>::value is true if and only if T is std::meta::info.", "function": "std::is_reflection"}, {"id": "cpp20_meta_unary_cat_is_rvalue_reference_condition_8f4a1d5c", "label": "cpp20_meta_unary_cat_is_rvalue_reference", "x": -264.89204879155886, "y": 48.01118151060467, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_rvalue_reference<T>::value is true if and only if T is an rvalue reference type.", "function": "std::is_rvalue_reference"}, {"id": "cpp20_meta_unary_cat_is_union_condition_2d8e5b9a", "label": "cpp20_meta_unary_cat_is_union_condition_", "x": 497.16960272584146, "y": -179.04887478475115, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_union<T>::value is true if and only if T is a union type.", "function": "std::is_union"}, {"id": "cpp20_meta_unary_cat_is_void_condition_9c5d2a6f", "label": "cpp20_meta_unary_cat_is_void_condition_9", "x": -838.1961489749552, "y": 225.9865048299557, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat] Table 52", "content": "std::is_void<T>::value is true if and only if T is void.", "function": "std::is_void"}, {"id": "cpp20_meta_unary_cat_cv_qualification_invariance_7a3f9e2d", "label": "cpp20_meta_unary_cat_cv_qualification_in", "x": 723.9402108801877, "y": -241.37025763313326, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat]/2", "content": "For any given type T, applying a primary type category template to T and to cv T shall yield the same result.", "function": ""}, {"id": "cpp20_meta_unary_cat_mutual_exclusion_8b4c1f5e", "label": "cpp20_meta_unary_cat_mutual_exclusion_8b", "x": 403.7131586637445, "y": 890.0124208142719, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.cat]/3", "content": "For any given type T, exactly one of the primary type categories has a value member that evaluates to true.", "function": ""}, {"id": "cpp20_has_unique_object_representations_precond_e1f2a3b4", "label": "cpp20_has_unique_object_representations_", "x": -707.8496501742554, "y": 76.02357022635155, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For has_unique_object_representations<T>, remove_all_extents_t<T> shall be a complete type or cv void.", "function": "has_unique_object_representations"}, {"id": "cpp20_has_virtual_destructor_precond_complete_a7b8c9d0", "label": "cpp20_has_virtual_destructor_precond_com", "x": -446.21757419695217, "y": 605.6299552286974, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For has_virtual_destructor<T>, if T is a non-union class type, T shall be a complete type.", "function": "has_virtual_destructor"}, {"id": "cpp20_is_abstract_precond_complete_e9f0a1b2", "label": "cpp20_is_abstract_precond_complete_e9f0a", "x": 243.78237255712096, "y": 517.1712099869081, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_abstract<T>, if T is a non-union class type, T shall be a complete type.", "function": "is_abstract"}, {"id": "cpp20_is_aggregate_precond_complete_a7b8c9d0", "label": "cpp20_is_aggregate_precond_complete_a7b8", "x": 704.5391237266792, "y": -221.8661514886706, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_aggregate<T>, T shall be an array type, a complete type, or cv void.", "function": "is_aggregate"}, {"id": "cpp20_is_assignable_immediate_context_f3a4b5c6", "label": "cpp20_is_assignable_immediate_context_f3", "x": 880.4954942884707, "y": 40.482447244099625, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_assignable<T, U>, only the validity of the immediate context of the assignment expression declval<T>()=declval<U>() is considered. Side effects like template instantiation can make the program ill-formed.", "function": "is_assignable"}, {"id": "cpp20_is_assignable_precond_complete_b9c0d1e2", "label": "cpp20_is_assignable_precond_complete_b9c", "x": -721.69120762966, "y": 346.31712348662234, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_assignable<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "is_assignable"}, {"id": "cpp20_is_consteval_only_precond_complete_b1c2d3e4", "label": "cpp20_is_consteval_only_precond_complete", "x": 684.4412169670999, "y": -327.94932343788247, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_consteval_only<T>, remove_all_extents_t<T> shall be a complete type or cv void.", "function": "is_consteval_only"}, {"id": "cpp20_is_constructible_function_void_false_d9e0f1a2", "label": "cpp20_is_constructible_function_void_fal", "x": 560.1194421372845, "y": 721.5960986727704, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_constructible<T, Args...>, if T is a function type or cv void type, is_constructible_v<T, Args...> is false.", "function": "is_constructible"}, {"id": "cpp20_is_constructible_precond_complete_f5a6b7c8", "label": "cpp20_is_constructible_precond_complete_", "x": -287.6770418416784, "y": 934.172300330674, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_constructible<T, Args...>, T and all types in the template parameter pack Args shall be complete types, cv void, or arrays of unknown bound.", "function": "is_constructible"}, {"id": "cpp20_is_copy_assignable_precond_complete_d7e8f9a0", "label": "cpp20_is_copy_assignable_precond_complet", "x": -671.4033139987212, "y": -517.3374368431266, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_copy_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_copy_assignable"}, {"id": "cpp20_is_copy_constructible_precond_complete_a1b2c3d4", "label": "cpp20_is_copy_constructible_precond_comp", "x": -478.0841317253432, "y": 738.021398071646, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_copy_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_copy_constructible"}, {"id": "cpp20_is_default_constructible_precond_complete_c7d8e9f0", "label": "cpp20_is_default_constructible_precond_c", "x": 280.47958090260744, "y": -788.6885623122685, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_default_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_default_constructible"}, {"id": "cpp20_is_destructible_precond_complete_f7a8b9c0", "label": "cpp20_is_destructible_precond_complete_f", "x": -251.4527230729917, "y": 498.3311563077138, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_destructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_destructible"}, {"id": "cpp20_is_empty_precond_complete_f2a3b4c5", "label": "cpp20_is_empty_precond_complete_f2a3b4c5", "x": -742.1596923032367, "y": 562.5840304437761, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_empty<T>, if T is a non-union class type, T shall be a complete type.", "function": "is_empty"}, {"id": "cpp20_is_final_precond_complete_c3d4e5f6", "label": "cpp20_is_final_precond_complete_c3d4e5f6", "x": 758.9333857160424, "y": -34.070889171692066, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_final<T>, if T is a class type, T shall be a complete type.", "function": "is_final"}, {"id": "cpp20_is_implicit_lifetime_precond_complete_c3d4e5f6", "label": "cpp20_is_implicit_lifetime_precond_compl", "x": 927.75312899241, "y": -107.67153507952726, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_implicit_lifetime<T>, T shall be an array type, a complete type, or cv void.", "function": "is_implicit_lifetime"}, {"id": "cpp20_is_move_assignable_precond_complete_a1b2c3d4", "label": "cpp20_is_move_assignable_precond_complet", "x": 952.625143039441, "y": 267.7022742295241, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_move_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_move_assignable"}, {"id": "cpp20_is_move_constructible_precond_complete_e5f6a7b8", "label": "cpp20_is_move_constructible_precond_comp", "x": 219.9172319903402, "y": -763.9578341771485, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_move_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_move_constructible"}, {"id": "cpp20_is_nothrow_assignable_precond_complete_c9d0e1f2", "label": "cpp20_is_nothrow_assignable_precond_comp", "x": 796.3228507034582, "y": -127.02638674638517, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_assignable<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "is_nothrow_assignable"}, {"id": "cpp20_is_nothrow_constructible_precond_complete_f3a4b5c6", "label": "cpp20_is_nothrow_constructible_precond_c", "x": -468.13087416520375, "y": -849.5506617229222, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_constructible<T, Args...>, T and all types in the template parameter pack Args shall be complete types, cv void, or arrays of unknown bound.", "function": "is_nothrow_constructible"}, {"id": "cpp20_is_nothrow_copy_assignable_precond_a3b4c5d6", "label": "cpp20_is_nothrow_copy_assignable_precond", "x": 456.6574504752826, "y": 247.43058242832294, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_copy_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_copy_assignable"}, {"id": "cpp20_is_nothrow_copy_constructible_precond_b1c2d3e4", "label": "cpp20_is_nothrow_copy_constructible_prec", "x": 375.17643416242845, "y": 773.8496450928191, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_copy_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_copy_constructible"}, {"id": "cpp20_is_nothrow_default_constructible_precond_d7e8f9a0", "label": "cpp20_is_nothrow_default_constructible_p", "x": -830.3792704195413, "y": 373.1069791918355, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_default_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_default_constructible"}, {"id": "cpp20_is_nothrow_destructible_precond_complete_f9a0b1c2", "label": "cpp20_is_nothrow_destructible_precond_co", "x": -507.58327895435053, "y": 653.7438370731412, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_destructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_destructible"}, {"id": "cpp20_is_nothrow_move_assignable_precond_f7a8b9c0", "label": "cpp20_is_nothrow_move_assignable_precond", "x": 772.2821285273153, "y": 26.738670355054744, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_move_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_move_assignable"}, {"id": "cpp20_is_nothrow_move_constructible_precond_e5f6a7b8", "label": "cpp20_is_nothrow_move_constructible_prec", "x": 517.9345633844878, "y": -432.15172223185107, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_move_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_move_constructible"}, {"id": "cpp20_is_nothrow_swappable_precond_complete_b5c6d7e8", "label": "cpp20_is_nothrow_swappable_precond_compl", "x": -31.876698957276286, "y": 732.1449859138567, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_swappable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_nothrow_swappable"}, {"id": "cpp20_is_nothrow_swappable_with_precond_complete_d1e2f3a4", "label": "cpp20_is_nothrow_swappable_with_precond_", "x": -88.42022648058277, "y": -569.4467493407263, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_nothrow_swappable_with<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "is_nothrow_swappable_with"}, {"id": "cpp20_is_polymorphic_precond_complete_a5b6c7d8", "label": "cpp20_is_polymorphic_precond_complete_a5", "x": 0.934412335340104, "y": 741.9258276301042, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_polymorphic<T>, if T is a non-union class type, T shall be a complete type.", "function": "is_polymorphic"}, {"id": "cpp20_is_standard_layout_precond_complete_b8c9d0e1", "label": "cpp20_is_standard_layout_precond_complet", "x": -308.2781570968378, "y": -707.0916358430663, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_standard_layout<T>, remove_all_extents_t<T> shall be a complete type or cv void.", "function": "is_standard_layout"}, {"id": "cpp20_is_swappable_precond_complete_a3b4c5d6", "label": "cpp20_is_swappable_precond_complete_a3b4", "x": 404.60247448037154, "y": 679.8903934991822, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_swappable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_swappable"}, {"id": "cpp20_is_swappable_with_immediate_context_c9d0e1f2", "label": "cpp20_is_swappable_with_immediate_contex", "x": -730.7749366098732, "y": -467.0923679610031, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_swappable_with<T, U>, only the validity of the immediate context of the swap expressions is considered. Side effects like template instantiation can make the program ill-formed.", "function": "is_swappable_with"}, {"id": "cpp20_is_swappable_with_precond_complete_e5f6a7b8", "label": "cpp20_is_swappable_with_precond_complete", "x": -760.6764403366075, "y": -264.42995382209443, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_swappable_with<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "is_swappable_with"}, {"id": "cpp20_is_trivially_assignable_precond_complete_a7b8c9d0", "label": "cpp20_is_trivially_assignable_precond_co", "x": -98.24951195256705, "y": 633.8658575507709, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_assignable<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "is_trivially_assignable"}, {"id": "cpp20_is_trivially_constructible_precond_complete_d1e2f3a4", "label": "cpp20_is_trivially_constructible_precond", "x": 452.63239706662887, "y": 407.7996588107721, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_constructible<T, Args...>, T and all types in the template parameter pack Args shall be complete types, cv void, or arrays of unknown bound.", "function": "is_trivially_constructible"}, {"id": "cpp20_is_trivially_copy_assignable_precond_e1f2a3b4", "label": "cpp20_is_trivially_copy_assignable_preco", "x": -205.79793308466267, "y": 772.4621884526557, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_copy_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_trivially_copy_assignable"}, {"id": "cpp20_is_trivially_copy_constructible_precond_f9a0b1c2", "label": "cpp20_is_trivially_copy_constructible_pr", "x": 10.98842100244679, "y": 950.8626579636283, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_copy_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_trivially_copy_constructible"}, {"id": "cpp20_is_trivially_copyable_precond_complete_d4e5f6a7", "label": "cpp20_is_trivially_copyable_precond_comp", "x": 227.59585425302578, "y": -819.1223551579083, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_copyable<T>, remove_all_extents_t<T> shall be a complete type or cv void.", "function": "is_trivially_copyable"}, {"id": "cpp20_is_trivially_default_constructible_precond_b5c6d7e8", "label": "cpp20_is_trivially_default_constructible", "x": 450.5496369186591, "y": -448.5496679277051, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_default_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_trivially_default_constructible"}, {"id": "cpp20_is_trivially_destructible_precond_complete_a9b0c1d2", "label": "cpp20_is_trivially_destructible_precond_", "x": 287.45132459596454, "y": -826.1793119096974, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_destructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_trivially_destructible"}, {"id": "cpp20_is_trivially_move_assignable_precond_c5d6e7f8", "label": "cpp20_is_trivially_move_assignable_preco", "x": -531.5123844228422, "y": 662.475119789473, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_move_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_trivially_move_assignable"}, {"id": "cpp20_is_trivially_move_constructible_precond_c3d4e5f6", "label": "cpp20_is_trivially_move_constructible_pr", "x": -481.2331317890341, "y": 659.3625823363271, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For is_trivially_move_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound.", "function": "is_trivially_move_constructible"}, {"id": "cpp20_reference_constructs_from_temporary_immediate_a9b0c1d2", "label": "cpp20_reference_constructs_from_temporar", "x": -566.3693016386254, "y": 376.1219478599683, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For reference_constructs_from_temporary<T, U>, only the validity of the immediate context of the variable initialization T t(VAL<U>) is considered. Side effects can make the program ill-formed.", "function": "reference_constructs_from_temporary"}, {"id": "cpp20_reference_constructs_from_temporary_precond_c5d6e7f8", "label": "cpp20_reference_constructs_from_temporar", "x": 600.0802215682106, "y": -7.798002388797917, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For reference_constructs_from_temporary<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "reference_constructs_from_temporary"}, {"id": "cpp20_reference_converts_from_temporary_immediate_d7e8f9a0", "label": "cpp20_reference_converts_from_temporary_", "x": -360.4338692239936, "y": -641.8296334951904, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For reference_converts_from_temporary<T, U>, only the validity of the immediate context of the variable initialization T t=VAL<U> is considered. Side effects can make the program ill-formed.", "function": "reference_converts_from_temporary"}, {"id": "cpp20_reference_converts_from_temporary_precond_f3a4b5c6", "label": "cpp20_reference_converts_from_temporary_", "x": -931.4304651110025, "y": -301.3512017994122, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop] Table 54", "content": "For reference_converts_from_temporary<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound.", "function": "reference_converts_from_temporary"}, {"id": "cpp20_has_unique_object_representations_impl_defined_f7a8b9c0", "label": "cpp20_has_unique_object_representations_", "x": 226.29242304006195, "y": 909.9957678779225, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/10", "content": "The set of scalar types for which has_unique_object_representations holds is implementation-defined.", "function": "has_unique_object_representations"}, {"id": "cpp20_has_unique_object_representations_padding_false_d1e2f3a4", "label": "cpp20_has_unique_object_representations_", "x": 723.1869684013361, "y": 441.35915403513525, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/10", "content": "If a type has padding bits, has_unique_object_representations does not hold for that type.", "function": "has_unique_object_representations"}, {"id": "cpp20_has_unique_object_representations_same_value_a3b4c5d6", "label": "cpp20_has_unique_object_representations_", "x": 632.9725729180548, "y": 369.2141573234889, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/10", "content": "The predicate has_unique_object_representations<T> is satisfied only if any two objects of type T with the same value have the same object representation.", "function": "has_unique_object_representations"}, {"id": "cpp20_has_unique_object_representations_trivially_copyable_c9d0e1f2", "label": "cpp20_has_unique_object_representations_", "x": -353.9009683308864, "y": 849.2641060457765, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/10", "content": "The predicate has_unique_object_representations<T> is satisfied only if T is trivially copyable.", "function": "has_unique_object_representations"}, {"id": "cpp20_meta_unary_prop_implicit_instantiation_precond_7f8a9b0c", "label": "cpp20_meta_unary_prop_implicit_instantia", "x": 544.3597091841276, "y": 177.1989467151315, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/3", "content": "Instantiating any class template X declared in meta.unary.prop with a template-argument that is a class template specialization requires that the argument is a complete type if and only if the semantics of X require that the argument is a complete type.", "function": ""}, {"id": "cpp20_is_constructible_definition_well_formed_b1c2d3e4", "label": "cpp20_is_constructible_definition_well_f", "x": -800.5543526741935, "y": -80.6363521984049, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/9", "content": "The predicate condition for is_constructible<T, Args...> is satisfied if and only if the variable definition T t(declval<Args>()...) would be well-formed, considering only the immediate context.", "function": "is_constructible"}, {"id": "cpp20_is_constructible_not_function_declaration_e5f6a7b8", "label": "cpp20_is_constructible_not_function_decl", "x": -43.49823809384473, "y": 812.4777161174386, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[meta.unary.prop]/9", "content": "In the definition of is_constructible, the tokens T t(declval<Args>()...) are never interpreted as a function declaration.", "function": "is_constructible"}, {"id": "cpp20_new_delete_array_delete_alignment_match_1k2l3m4n", "label": "cpp20_new_delete_array_delete_alignment_", "x": 163.16212554258186, "y": -544.7561842073065, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/10", "content": "If alignment parameter is present in operator delete[], ptr must have been returned by allocation function with matching alignment. If absent, ptr was returned by allocation function without alignment parameter.", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_size_match_5o6p7q8r", "label": "cpp20_new_delete_array_delete_size_match", "x": 803.0650701690448, "y": -579.522901070966, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/10", "content": "If size parameter is present in operator delete[], size argument must equal the size argument passed to the allocation function that returned ptr.", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_sized_shall_define_1y2z3a4b", "label": "cpp20_new_delete_array_delete_sized_shal", "x": -67.62019700543671, "y": -899.9712224988864, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/14", "content": "If a replacement operator delete[] with size parameter is defined, the program shall also define the corresponding version without the size parameter.", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_nothrow_aligned_precondition_3w4x5y6z", "label": "cpp20_new_delete_array_delete_nothrow_al", "x": 366.8576606566434, "y": 835.4332115243543, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/15", "content": "operator delete[](void*, align_val_t, nothrow_t) precondition: ptr is null or represents address of memory allocated by operator new[](size_t) or operator new[](size_t, align_val_t) not invalidated by intervening delete[].", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_nothrow_precondition_9s0t1u2v", "label": "cpp20_new_delete_array_delete_nothrow_pr", "x": -378.14099451023833, "y": 732.7233530647572, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/15", "content": "operator delete[](void*, nothrow_t) precondition: ptr is null or represents address of memory allocated by operator new[](size_t) or operator new[](size_t, align_val_t) not invalidated by intervening delete[].", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_nothrow_alignment_match_7a8b9c0d", "label": "cpp20_new_delete_array_delete_nothrow_al", "x": -319.9875030052162, "y": 858.9340453223199, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/16", "content": "If alignment parameter is present in nothrow operator delete[], ptr must have been returned by allocation function with matching alignment. If absent, ptr was returned by allocation function without alignment parameter.", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_new_aligned_required_7m8n9o0p", "label": "cpp20_new_delete_array_new_aligned_requi", "x": 524.8235544739375, "y": 577.9685452911286, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/2", "content": "operator new[](size_t, align_val_t) has same required behavior as single-object form: return non-null aligned pointer or throw bad_alloc. This binds replacement versions.", "function": "operator new[]"}, {"id": "cpp20_new_delete_array_new_required_behavior_3i4j5k6l", "label": "cpp20_new_delete_array_new_required_beha", "x": -734.6813495501789, "y": 666.293191412884, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/2", "content": "operator new[](size_t) and operator new[](size_t, align_val_t) have same required behavior as single-object forms: return non-null aligned pointer or throw bad_alloc. This binds replacement versions.", "function": "operator new[]"}, {"id": "cpp20_new_delete_array_nothrow_required_1q2r3s4t", "label": "cpp20_new_delete_array_nothrow_required_", "x": 531.9595235433112, "y": -394.4500570308135, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/6", "content": "Nothrow versions of operator new[] are required to return non-null aligned pointer or return null pointer. This binds replacement versions.", "function": "operator new[]"}, {"id": "cpp20_new_delete_array_delete_aligned_precondition_3c4d5e6f", "label": "cpp20_new_delete_array_delete_aligned_pr", "x": 705.1474836385249, "y": -383.87910043605615, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/9", "content": "operator delete[](void*, align_val_t) precondition: ptr is null or represents address of memory allocated by operator new[](size_t) or operator new[](size_t, align_val_t) not invalidated by intervening delete[].", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_precondition_5u6v7w8x", "label": "cpp20_new_delete_array_delete_preconditi", "x": 642.2439674747213, "y": -654.6960931568118, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/9", "content": "operator delete[](void*) precondition: ptr is null or represents address of memory allocated by operator new[](size_t) or operator new[](size_t, align_val_t) not invalidated by intervening delete[].", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_sized_aligned_precondition_7g8h9i0j", "label": "cpp20_new_delete_array_delete_sized_alig", "x": 614.2687520154138, "y": 100.41603430752664, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/9", "content": "operator delete[](void*, size_t, align_val_t) precondition: ptr is null or represents address of memory allocated by operator new[](size_t) or operator new[](size_t, align_val_t) not invalidated by intervening delete[].", "function": "operator delete[]"}, {"id": "cpp20_new_delete_array_delete_sized_precondition_9y0z1a2b", "label": "cpp20_new_delete_array_delete_sized_prec", "x": -765.4151720485629, "y": -426.55788766032305, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.array]/9", "content": "operator delete[](void*, size_t) precondition: ptr is null or represents address of memory allocated by operator new[](size_t) or operator new[](size_t, align_val_t) not invalidated by intervening delete[].", "function": "operator delete[]"}, {"id": "cpp20_new_delete_dataraces_no_race_9m0n1o2p", "label": "cpp20_new_delete_dataraces_no_race_9m0n1", "x": -979.9054128054522, "y": -36.67492453363077, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.dataraces]/1", "content": "Library versions of operator new/delete, replacement versions, and C stdlib allocation functions (aligned_alloc, calloc, malloc, free, realloc) shall not introduce data races.", "function": ""}, {"id": "cpp20_new_delete_dataraces_total_order_3q4r5s6t", "label": "cpp20_new_delete_dataraces_total_order_3", "x": -587.0688187538966, "y": 269.52118726020433, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.dataraces]/1", "content": "Calls to allocation/deallocation functions that allocate or deallocate a particular unit of storage shall occur in a single total order, and each deallocation call shall happen-before the next allocation in this order.", "function": ""}, {"id": "cpp20_new_delete_general_invalid_alignment_ub_a1b2c3d4", "label": "cpp20_new_delete_general_invalid_alignme", "x": -477.22801808632397, "y": -509.2554541168867, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.general]/1", "content": "Passing an invalid alignment value to any operator new or operator delete function is undefined behavior.", "function": ""}, {"id": "cpp20_new_delete_placement_array_reserved_5i6j7k8l", "label": "cpp20_new_delete_placement_array_reserve", "x": 370.7466098500992, "y": -866.5673469471113, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.placement]/1", "content": "Placement array form of operator new[] is reserved; a C++ program may not define functions that displace this library version.", "function": "operator new[]"}, {"id": "cpp20_new_delete_placement_reserved_1e2f3g4h", "label": "cpp20_new_delete_placement_reserved_1e2f", "x": 721.499016283391, "y": 568.45234797334, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.placement]/1", "content": "Placement forms of operator new and operator delete are reserved; a C++ program may not define functions that displace these library versions.", "function": "operator new"}, {"id": "cpp20_new_delete_single_array_mismatch_ub_5c6d7e8f", "label": "cpp20_new_delete_single_array_mismatch_u", "x": 540.4161386235145, "y": 292.2962409288143, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/10", "content": "Using operator delete (single-object form) on a pointer allocated by operator new[] (array form) is undefined behavior, and vice versa.", "function": ""}, {"id": "cpp20_new_delete_single_delete_aligned_precondition_5g6h7i8j", "label": "cpp20_new_delete_single_delete_aligned_p", "x": 703.0767623077904, "y": -540.8606293262822, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/10", "content": "operator delete(void*, align_val_t) precondition: ptr is null or represents address of memory allocated by operator new(size_t) or operator new(size_t, align_val_t) not invalidated by intervening delete.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_precondition_7e8f9a0b", "label": "cpp20_new_delete_single_delete_precondit", "x": -797.2361094914003, "y": -447.7637661967979, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/10", "content": "operator delete(void*) precondition: ptr is null or represents address of memory allocated by operator new(size_t) or operator new(size_t, align_val_t) not invalidated by intervening delete.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_sized_aligned_precondition_9k0l1m2n", "label": "cpp20_new_delete_single_delete_sized_ali", "x": 461.67885900307164, "y": -850.9362942450598, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/10", "content": "operator delete(void*, size_t, align_val_t) precondition: ptr is null or represents address of memory allocated by operator new(size_t) or operator new(size_t, align_val_t) not invalidated by intervening delete.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_sized_precondition_1c2d3e4f", "label": "cpp20_new_delete_single_delete_sized_pre", "x": 133.1001341012357, "y": 982.0445904669422, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/10", "content": "operator delete(void*, size_t) precondition: ptr is null or represents address of memory allocated by operator new(size_t) or operator new(size_t, align_val_t) not invalidated by intervening delete.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_alignment_match_3o4p5q6r", "label": "cpp20_new_delete_single_delete_alignment", "x": 814.7739423389456, "y": 9.438460418952237, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/11", "content": "If alignment parameter is present in operator delete, ptr must have been returned by allocation function with matching alignment. If absent, ptr was returned by allocation function without alignment parameter.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_size_match_7s8t9u0v", "label": "cpp20_new_delete_single_delete_size_matc", "x": -817.5156912276774, "y": 485.16295835939115, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/11", "content": "If size parameter is present in operator delete, size argument must equal the size argument passed to the allocation function that returned ptr.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_sized_shall_define_7u8v9w0x", "label": "cpp20_new_delete_single_delete_sized_sha", "x": 157.6320353960767, "y": -834.2183418902039, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/16", "content": "If a replacement operator delete with size parameter is defined, the program shall also define the corresponding version without the size parameter.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_nothrow_aligned_precondition_5a6b7c8d", "label": "cpp20_new_delete_single_delete_nothrow_a", "x": -662.4053840070587, "y": 675.447372661711, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/17", "content": "operator delete(void*, align_val_t, nothrow_t) precondition: ptr is null or represents address of memory allocated by operator new(size_t) or operator new(size_t, align_val_t) not invalidated by intervening delete.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_nothrow_precondition_1w2x3y4z", "label": "cpp20_new_delete_single_delete_nothrow_p", "x": 272.4613919435768, "y": 724.7842436427352, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/17", "content": "operator delete(void*, nothrow_t) precondition: ptr is null or represents address of memory allocated by operator new(size_t) or operator new(size_t, align_val_t) not invalidated by intervening delete.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_delete_nothrow_alignment_match_9e0f1g2h", "label": "cpp20_new_delete_single_delete_nothrow_a", "x": 845.5358075384315, "y": 114.56543040520589, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/18", "content": "If alignment parameter is present in nothrow operator delete, ptr must have been returned by allocation function with matching alignment. If absent, ptr was returned by allocation function without alignment parameter.", "function": "operator delete"}, {"id": "cpp20_new_delete_single_new_aligned_required_c9d0e1f2", "label": "cpp20_new_delete_single_new_aligned_requ", "x": 119.73116607877213, "y": -511.4144880046497, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/2", "content": "operator new(size_t, align_val_t) is required to return a non-null pointer to suitably aligned storage or throw bad_alloc. This requirement binds replacement versions.", "function": "operator new"}, {"id": "cpp20_new_delete_single_new_required_behavior_e5f6a7b8", "label": "cpp20_new_delete_single_new_required_beh", "x": -599.2211072848872, "y": -207.97729786438722, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/2", "content": "operator new(size_t) and operator new(size_t, align_val_t) are required to return a non-null pointer to suitably aligned storage or throw bad_alloc. This requirement binds replacement versions.", "function": "operator new"}, {"id": "cpp20_new_delete_single_nothrow_required_3a4b5c6d", "label": "cpp20_new_delete_single_nothrow_required", "x": 665.3298184281864, "y": 289.7246183723926, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[new.delete.single]/6", "content": "Nothrow versions of operator new are required to return a non-null pointer to suitably aligned storage or return null pointer. This requirement binds replacement versions.", "function": "operator new"}, {"id": "cpp20_iota_mandate_increment_well_formed_d8e3a1b6", "label": "cpp20_iota_mandate_increment_well_formed", "x": 838.1334452129342, "y": -72.42894178183033, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.iota]/1", "content": "The expression ++val, where val has type T, must be well-formed for std::iota.", "function": "std::iota"}, {"id": "cpp20_iota_mandate_t_convertible_c7d2f0a5", "label": "cpp20_iota_mandate_t_convertible_c7d2f0a", "x": 372.73888619019027, "y": 454.9425352711764, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.iota]/1", "content": "T must be convertible to ForwardIterator's value type for std::iota.", "function": "std::iota"}, {"id": "cpp20_gcd_mandate_integer_not_bool_e9f4b2c7", "label": "cpp20_gcd_mandate_integer_not_bool_e9f4b", "x": 196.62146856660286, "y": 603.1110110769577, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.gcd]/1", "content": "M and N must both be integer types other than cv bool for std::gcd.", "function": "std::gcd"}, {"id": "cpp20_gcd_precond_representable_f0a5c3d8", "label": "cpp20_gcd_precond_representable_f0a5c3d8", "x": -672.7683349733595, "y": 51.22400528770242, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.gcd]/2", "content": "|m| and |n| must be representable as a value of common_type_t<M, N> for std::gcd.", "function": "std::gcd"}, {"id": "cpp20_lcm_mandate_integer_not_bool_a1b6d4e9", "label": "cpp20_lcm_mandate_integer_not_bool_a1b6d", "x": -825.5590461612595, "y": -178.61257550123685, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.lcm]/1", "content": "M and N must both be integer types other than cv bool for std::lcm.", "function": "std::lcm"}, {"id": "cpp20_lcm_precond_args_representable_b2c7e5f0", "label": "cpp20_lcm_precond_args_representable_b2c", "x": 3.177072552099067, "y": 567.4800318395593, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.lcm]/2", "content": "|m| and |n| must be representable as a value of common_type_t<M, N> for std::lcm.", "function": "std::lcm"}, {"id": "cpp20_lcm_precond_result_representable_c3d8f6a1", "label": "cpp20_lcm_precond_result_representable_c", "x": 916.3034429978109, "y": 186.13745485444838, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.lcm]/2", "content": "The least common multiple of |m| and |n| must be representable as a value of type common_type_t<M, N> for std::lcm.", "function": "std::lcm"}, {"id": "cpp20_midpoint_scalar_constraint_arithmetic_d4e9a7b2", "label": "cpp20_midpoint_scalar_constraint_arithme", "x": 651.7247749815094, "y": 44.74741667197247, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.midpoint]/1", "content": "T must be an arithmetic type other than cv bool for scalar std::midpoint.", "function": "std::midpoint"}, {"id": "cpp20_midpoint_pointer_constraint_object_e5f0b8c3", "label": "cpp20_midpoint_pointer_constraint_object", "x": -196.843193409397, "y": -394.95268078898744, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.midpoint]/4", "content": "T must be an object type for pointer std::midpoint.", "function": "std::midpoint"}, {"id": "cpp20_midpoint_pointer_mandate_complete_f6a1c9d4", "label": "cpp20_midpoint_pointer_mandate_complete_", "x": -241.09612663649676, "y": -339.11937280354573, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.midpoint]/5", "content": "T must be a complete type for pointer std::midpoint.", "function": "std::midpoint"}, {"id": "cpp20_midpoint_pointer_precond_same_array_a7b2d0e5", "label": "cpp20_midpoint_pointer_precond_same_arra", "x": -227.5585542205982, "y": -394.24406309913127, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.ops.midpoint]/6", "content": "a and b must point to, respectively, elements i and j of the same array object x for pointer std::midpoint.", "function": "std::midpoint"}, {"id": "cpp20_saturate_cast_constraint_integer_b4c9e7f2", "label": "cpp20_saturate_cast_constraint_integer_b", "x": -726.8288252449535, "y": -431.2267833722748, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.cast]/1", "content": "R and T must be signed or unsigned integer types for std::saturate_cast.", "function": "std::saturate_cast"}, {"id": "cpp20_div_sat_precond_not_constexpr_if_violated_a3b8d6e1", "label": "cpp20_div_sat_precond_not_constexpr_if_v", "x": 898.7875235710632, "y": -285.32746754310597, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.func]/11", "content": "A function call expression that violates the precondition y != 0 is not a core constant expression for std::div_sat.", "function": "std::div_sat"}, {"id": "cpp20_add_sat_constraint_integer_b8c3e1f6", "label": "cpp20_add_sat_constraint_integer_b8c3e1f", "x": -10.730374339305012, "y": -754.6494257901658, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.func]/2", "content": "T must be a signed or unsigned integer type for std::add_sat.", "function": "std::add_sat"}, {"id": "cpp20_sub_sat_constraint_integer_c9d4f2a7", "label": "cpp20_sub_sat_constraint_integer_c9d4f2a", "x": 307.197177648201, "y": -583.7682855027789, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.func]/4", "content": "T must be a signed or unsigned integer type for std::sub_sat.", "function": "std::sub_sat"}, {"id": "cpp20_mul_sat_constraint_integer_d0e5a3b8", "label": "cpp20_mul_sat_constraint_integer_d0e5a3b", "x": -699.1178599738258, "y": 46.28522322866243, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.func]/6", "content": "T must be a signed or unsigned integer type for std::mul_sat.", "function": "std::mul_sat"}, {"id": "cpp20_div_sat_constraint_integer_e1f6b4c9", "label": "cpp20_div_sat_constraint_integer_e1f6b4c", "x": -695.5458473185286, "y": -697.9981819965872, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.func]/8", "content": "T must be a signed or unsigned integer type for std::div_sat.", "function": "std::div_sat"}, {"id": "cpp20_div_sat_precond_y_nonzero_f2a7c5d0", "label": "cpp20_div_sat_precond_y_nonzero_f2a7c5d0", "x": -391.9269176375812, "y": -867.7407936397013, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[numeric.sat.func]/9", "content": "y != 0 must be true for std::div_sat - dividing by zero violates precondition.", "function": "std::div_sat"}, {"id": "cpp20_partial_sum_mandate_acc_writable_c9d4f2a7", "label": "cpp20_partial_sum_mandate_acc_writable_c", "x": -818.3153082608467, "y": -288.18518960336, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[partial.sum]/1", "content": "The accumulator acc must be writable to result for std::partial_sum.", "function": "std::partial_sum"}, {"id": "cpp20_partial_sum_mandate_result_convertible_b8c3e1f6", "label": "cpp20_partial_sum_mandate_result_convert", "x": 722.9103024548593, "y": 176.36677006256164, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[partial.sum]/1", "content": "The result of std::move(acc) + *i or binary_op(std::move(acc), *i) must be implicitly convertible to InputIterator's value type.", "function": "std::partial_sum"}, {"id": "cpp20_partial_sum_mandate_value_constructible_a7b2d0e5", "label": "cpp20_partial_sum_mandate_value_construc", "x": 56.20275777287796, "y": -646.9761510387424, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[partial.sum]/1", "content": "InputIterator's value type must be constructible from *first for std::partial_sum.", "function": "std::partial_sum"}, {"id": "cpp20_partial_sum_precond_no_modify_d0e5a3b8", "label": "cpp20_partial_sum_precond_no_modify_d0e5", "x": 859.8310429070463, "y": -159.09963901967512, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[partial.sum]/2", "content": "In the ranges [first, last] and [result, result+(last-first)], binary_op must neither modify elements nor invalidate iterators or subranges.", "function": "std::partial_sum"}, {"id": "cpp20_range_access_begin_rvalue_non_borrowed_illformed_a3b7c1d9", "label": "cpp20_range_access_begin_rvalue_non_borr", "x": 190.42285737437115, "y": 33.45855241881349, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.begin]/2.1", "content": "Calling ranges::begin on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::begin"}, {"id": "cpp20_range_access_begin_incomplete_array_ndr_e5f2a8c4", "label": "cpp20_range_access_begin_incomplete_arra", "x": -197.9098210848023, "y": -32.825681084728444, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.begin]/2.2", "content": "Calling ranges::begin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.", "function": "ranges::begin"}, {"id": "cpp20_range_access_begin_member_models_iterator_f3a6b0c4", "label": "cpp20_range_access_begin_member_models_i", "x": 347.82357556955856, "y": -3.787496760597349, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.begin]/2.4", "content": "For ranges::begin to use t.begin(), the expression auto(t.begin()) must be valid and its type must model input_or_output_iterator.", "function": "ranges::begin"}, {"id": "cpp20_range_access_begin_models_input_or_output_iterator_a2b5c9d3", "label": "cpp20_range_access_begin_models_input_or", "x": 336.5996199548279, "y": 7.177724254400949, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.begin]/4", "content": "Whenever ranges::begin(E) is a valid expression, its type models input_or_output_iterator.", "function": "ranges::begin"}, {"id": "cpp20_range_access_cbegin_rvalue_non_borrowed_illformed_e8f1a5b9", "label": "cpp20_range_access_cbegin_rvalue_non_bor", "x": 214.88255291136417, "y": -17.237083937107943, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.cbegin]/1.1", "content": "Calling ranges::cbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::cbegin"}, {"id": "cpp20_range_access_cbegin_models_constant_iterator_c4d7e1f5", "label": "cpp20_range_access_cbegin_models_constan", "x": -223.06974465389996, "y": -248.79884142797215, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.cbegin]/2", "content": "Whenever ranges::cbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator.", "function": "ranges::cbegin"}, {"id": "cpp20_range_access_cend_rvalue_non_borrowed_illformed_f9a2b6c0", "label": "cpp20_range_access_cend_rvalue_non_borro", "x": 179.6284036384484, "y": -10.03014897251137, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.cend]/1.1", "content": "Calling ranges::cend on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::cend"}, {"id": "cpp20_range_access_crbegin_rvalue_non_borrowed_illformed_e4f7a1b5", "label": "cpp20_range_access_crbegin_rvalue_non_bo", "x": 174.09447594064378, "y": 31.97063287322159, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.crbegin]/1.1", "content": "Calling ranges::crbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::crbegin"}, {"id": "cpp20_range_access_crbegin_models_constant_iterator_f7a0b4c8", "label": "cpp20_range_access_crbegin_models_consta", "x": -246.22039361160944, "y": -218.08138588983124, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.crbegin]/2", "content": "Whenever ranges::crbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator.", "function": "ranges::crbegin"}, {"id": "cpp20_range_access_crend_rvalue_non_borrowed_illformed_f5a8b2c6", "label": "cpp20_range_access_crend_rvalue_non_borr", "x": 177.25755323881745, "y": 29.446387464056194, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.crend]/1.1", "content": "Calling ranges::crend on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::crend"}, {"id": "cpp20_range_access_end_rvalue_non_borrowed_illformed_b4c8d2e6", "label": "cpp20_range_access_end_rvalue_non_borrow", "x": 205.802723920708, "y": -11.2935250641713, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.end]/2.1", "content": "Calling ranges::end on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::end"}, {"id": "cpp20_range_access_end_incomplete_array_ndr_c6d9e3f7", "label": "cpp20_range_access_end_incomplete_array_", "x": -185.9514822058593, "y": -70.0148523068666, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.end]/2.2", "content": "Calling ranges::end on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.", "function": "ranges::end"}, {"id": "cpp20_range_access_end_unknown_bound_array_illformed_d7e0f4a8", "label": "cpp20_range_access_end_unknown_bound_arr", "x": -169.8408855215977, "y": -70.17914465681744, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.end]/2.3", "content": "Calling ranges::end on an array of unknown bound is ill-formed.", "function": "ranges::end"}, {"id": "cpp20_range_access_end_member_models_sentinel_a4b7c1d5", "label": "cpp20_range_access_end_member_models_sen", "x": 350.2308960323413, "y": -43.18540044651549, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.end]/2.5", "content": "For ranges::end to use t.end(), the expression auto(t.end()) must be valid and its type must model sentinel_for<iterator_t<T>>.", "function": "ranges::end"}, {"id": "cpp20_range_access_end_models_sentinel_for_b3c6d0e4", "label": "cpp20_range_access_end_models_sentinel_f", "x": 295.0982910893729, "y": -144.7251322004266, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.end]/4", "content": "Whenever ranges::end(E) is a valid expression, the types S and I of ranges::end(E) and ranges::begin(E) model sentinel_for<S, I>.", "function": "ranges::end"}, {"id": "cpp20_range_access_rbegin_rvalue_non_borrowed_illformed_a0b3c7d1", "label": "cpp20_range_access_rbegin_rvalue_non_bor", "x": 193.7851923940648, "y": 19.07548367262054, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rbegin]/2.1", "content": "Calling ranges::rbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::rbegin"}, {"id": "cpp20_range_access_rbegin_incomplete_array_ndr_b1c4d8e2", "label": "cpp20_range_access_rbegin_incomplete_arr", "x": -192.57373555313555, "y": -40.71133292817948, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rbegin]/2.2", "content": "Calling ranges::rbegin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.", "function": "ranges::rbegin"}, {"id": "cpp20_range_access_rbegin_fallback_bidirectional_c6d9e3f7", "label": "cpp20_range_access_rbegin_fallback_bidir", "x": 281.8416134233328, "y": -150.65924999756692, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rbegin]/2.5", "content": "For ranges::rbegin to fall back to make_reverse_iterator(ranges::end(t)), both ranges::begin(t) and ranges::end(t) must be valid expressions of the same type which models bidirectional_iterator.", "function": "ranges::rbegin"}, {"id": "cpp20_range_access_rbegin_models_input_or_output_iterator_d5e8f2a6", "label": "cpp20_range_access_rbegin_models_input_o", "x": 274.5265982505991, "y": -151.72574242042145, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rbegin]/4", "content": "Whenever ranges::rbegin(E) is a valid expression, its type models input_or_output_iterator.", "function": "ranges::rbegin"}, {"id": "cpp20_range_access_rend_rvalue_non_borrowed_illformed_c2d5e9f3", "label": "cpp20_range_access_rend_rvalue_non_borro", "x": 166.91860788386012, "y": 34.16265692719844, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rend]/2.1", "content": "Calling ranges::rend on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::rend"}, {"id": "cpp20_range_access_rend_incomplete_array_ndr_d3e6f0a4", "label": "cpp20_range_access_rend_incomplete_array", "x": -191.66108744556277, "y": -31.900785999371585, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rend]/2.2", "content": "Calling ranges::rend on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.", "function": "ranges::rend"}, {"id": "cpp20_range_access_rend_fallback_bidirectional_d7e0f4a8", "label": "cpp20_range_access_rend_fallback_bidirec", "x": 266.7450277674552, "y": -149.70797969227465, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rend]/2.5", "content": "For ranges::rend to fall back to make_reverse_iterator(ranges::begin(t)), both ranges::begin(t) and ranges::end(t) must be valid expressions of the same type which models bidirectional_iterator.", "function": "ranges::rend"}, {"id": "cpp20_range_access_rend_models_sentinel_for_e6f9a3b7", "label": "cpp20_range_access_rend_models_sentinel_", "x": 341.40823403057783, "y": 2.754947449564956, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.access.rend]/4", "content": "Whenever ranges::rend(E) is a valid expression, the types S and I of ranges::rend(E) and ranges::rbegin(E) model sentinel_for<S, I>.", "function": "ranges::rend"}, {"id": "cpp20_ranges_equal_to_constraint_comparable_b9c0d1e2", "label": "cpp20_ranges_equal_to_constraint_compara", "x": 178.94296529920584, "y": 801.988934936865, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/1", "content": "std::ranges::equal_to::operator() requires T and U to satisfy equality_comparable_with.", "function": "std::ranges::equal_to::operator()"}, {"id": "cpp20_ranges_equal_to_constraint_e7f8a9b0", "label": "cpp20_ranges_equal_to_constraint_e7f8a9b", "x": 365.93064503619263, "y": -749.0702304704022, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/1", "content": "ranges::equal_to::operator() requires T and U to satisfy equality_comparable_with.", "function": "std::ranges::equal_to::operator()"}, {"id": "cpp20_ranges_greater_equal_constraint_totally_ordered_f7a8b9c0", "label": "cpp20_ranges_greater_equal_constraint_to", "x": 618.45605579157, "y": -718.6405925116234, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/11", "content": "std::ranges::greater_equal::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::greater_equal::operator()"}, {"id": "cpp20_ranges_greater_equal_constraint_w1x2y3z4", "label": "cpp20_ranges_greater_equal_constraint_w1", "x": 47.06279040001871, "y": -818.9429316477997, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/11", "content": "ranges::greater_equal::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::greater_equal::operator()"}, {"id": "cpp20_ranges_less_equal_constraint_a5b6c7d8", "label": "cpp20_ranges_less_equal_constraint_a5b6c", "x": -975.2780243095734, "y": -86.982058975065, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/13", "content": "ranges::less_equal::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::less_equal::operator()"}, {"id": "cpp20_ranges_less_equal_constraint_totally_ordered_d3e4f5a6", "label": "cpp20_ranges_less_equal_constraint_total", "x": -629.9144622834823, "y": -105.65390750573474, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/13", "content": "std::ranges::less_equal::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::less_equal::operator()"}, {"id": "cpp20_ranges_equal_to_precond_pointer_eq_preserving_c1d2e3f4", "label": "cpp20_ranges_equal_to_precond_pointer_eq", "x": 120.83261193927781, "y": -934.1888252232837, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/2", "content": "For ranges::equal_to with built-in pointer comparison, conversion sequences must be equality-preserving.", "function": "std::ranges::equal_to::operator()"}, {"id": "cpp20_ranges_equal_to_precond_pointer_equality_preserving_f3a4b5c6", "label": "cpp20_ranges_equal_to_precond_pointer_eq", "x": -294.0161904818325, "y": -367.12428750499754, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/2", "content": "std::ranges::equal_to::operator() precondition: If the expression results in a call to a built-in operator== comparing pointers of type P, the conversion sequences from both T and U to P must be equality-preserving; otherwise, T and U model equality_comparable_with.", "function": "std::ranges::equal_to::operator()"}, {"id": "cpp20_ranges_not_equal_to_constraint_comparable_a7b8c9d0", "label": "cpp20_ranges_not_equal_to_constraint_com", "x": -278.01047714069, "y": 587.9994156662274, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/4", "content": "std::ranges::not_equal_to::operator() requires T and U to satisfy equality_comparable_with.", "function": "std::ranges::not_equal_to::operator()"}, {"id": "cpp20_ranges_not_equal_to_constraint_g5h6i7j8", "label": "cpp20_ranges_not_equal_to_constraint_g5h", "x": 249.96552287868488, "y": 751.3968685516138, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/4", "content": "ranges::not_equal_to::operator() requires T and U to satisfy equality_comparable_with.", "function": "std::ranges::not_equal_to::operator()"}, {"id": "cpp20_ranges_greater_constraint_s7t8u9v0", "label": "cpp20_ranges_greater_constraint_s7t8u9v0", "x": 603.1282324629282, "y": -233.60549399255711, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/6", "content": "ranges::greater::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::greater::operator()"}, {"id": "cpp20_ranges_greater_constraint_totally_ordered_e1f2a3b4", "label": "cpp20_ranges_greater_constraint_totally_", "x": 441.1852484547705, "y": -501.58338439645246, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/6", "content": "std::ranges::greater::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::greater::operator()"}, {"id": "cpp20_ranges_less_constraint_k9l0m1n2", "label": "cpp20_ranges_less_constraint_k9l0m1n2", "x": -387.17006390932437, "y": 626.4293097579276, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/8", "content": "ranges::less::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::less::operator()"}, {"id": "cpp20_ranges_less_constraint_totally_ordered_c5d6e7f8", "label": "cpp20_ranges_less_constraint_totally_ord", "x": -72.74069737406099, "y": 727.0811702628151, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/8", "content": "std::ranges::less::operator() requires T and U to satisfy totally_ordered_with.", "function": "std::ranges::less::operator()"}, {"id": "cpp20_ranges_less_precond_pointer_eq_preserving_o3p4q5r6", "label": "cpp20_ranges_less_precond_pointer_eq_pre", "x": 568.9308235587339, "y": 640.8001728926645, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/9", "content": "For ranges::less with built-in pointer comparison, conversion sequences must be equality-preserving and exactly one of less(t,u), less(u,t), or equal_to(t,u) is true.", "function": "std::ranges::less::operator()"}, {"id": "cpp20_ranges_less_precond_pointer_equality_preserving_b3c4d5e6", "label": "cpp20_ranges_less_precond_pointer_equali", "x": -249.58708598047144, "y": -438.6948575860307, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/9", "content": "std::ranges::less::operator() precondition: If the expression results in a call to a built-in operator< comparing pointers of type P, the conversion sequences from both T and U to P must be equality-preserving; otherwise, T and U model totally_ordered_with.", "function": "std::ranges::less::operator()"}, {"id": "cpp20_ranges_less_precond_trichotomy_a9b0c1d2", "label": "cpp20_ranges_less_precond_trichotomy_a9b", "x": -478.65281849416266, "y": 306.63954775627747, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.cmp]/9", "content": "std::ranges::less::operator() precondition: For any expressions ET and EU such that decltype((ET)) is T and decltype((EU)) is U, exactly one of ranges::less{}(ET, EU), ranges::less{}(EU, ET), or ranges::equal_to{}(ET, EU) is true.", "function": "std::ranges::less::operator()"}, {"id": "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2", "label": "cpp20_range_access_cdata_rvalue_non_borr", "x": 11.972021965568224, "y": -35.6949398713336, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.cdata]/1.1", "content": "Calling ranges::cdata on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::cdata"}, {"id": "cpp20_range_access_cdata_returns_pointer_to_const_object_e2f5a9b3", "label": "cpp20_range_access_cdata_returns_pointer", "x": -160.16145120227995, "y": -92.23466081563402, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.cdata]/2", "content": "Whenever ranges::cdata(E) is a valid expression, it has pointer to constant object type.", "function": "ranges::cdata"}, {"id": "cpp20_range_access_data_rvalue_non_borrowed_illformed_d9e2f6a0", "label": "cpp20_range_access_data_rvalue_non_borro", "x": 171.460725559297, "y": 23.17325379619746, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.data]/2.1", "content": "Calling ranges::data on an rvalue of a type where enable_borrowed_range is false is ill-formed.", "function": "ranges::data"}, {"id": "cpp20_range_access_data_incomplete_array_ndr_e0f3a7b1", "label": "cpp20_range_access_data_incomplete_array", "x": -186.02224425853157, "y": -32.62864870212836, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.data]/2.2", "content": "Calling ranges::data on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.", "function": "ranges::data"}, {"id": "cpp20_range_access_data_contiguous_iterator_a0b3c7d1", "label": "cpp20_range_access_data_contiguous_itera", "x": 188.67131219937298, "y": 13.725193114621943, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.data]/2.4", "content": "For ranges::data to use to_address(ranges::begin(t)), the type of ranges::begin(t) must model contiguous_iterator.", "function": "ranges::data"}, {"id": "cpp20_range_access_data_returns_pointer_to_object_d1e4f8a2", "label": "cpp20_range_access_data_returns_pointer_", "x": -219.11044391654252, "y": -94.40311167962825, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.data]/4", "content": "Whenever ranges::data(E) is a valid expression, it has pointer to object type.", "function": "ranges::data"}, {"id": "cpp20_range_access_empty_unknown_bound_array_illformed_c8d1e5f9", "label": "cpp20_range_access_empty_unknown_bound_a", "x": -144.356550641028, "y": -103.7360924619515, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.empty]/2.1", "content": "Calling ranges::empty on an array of unknown bound is ill-formed.", "function": "ranges::empty"}, {"id": "cpp20_range_access_empty_fallback_forward_iterator_f9a2b6c0", "label": "cpp20_range_access_empty_fallback_forwar", "x": 281.31714741023256, "y": -143.7595401568305, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.empty]/2.4", "content": "For ranges::empty to use ranges::begin(t) == ranges::end(t), the type of ranges::begin(t) must model forward_iterator.", "function": "ranges::empty"}, {"id": "cpp20_range_access_empty_returns_bool_c0d3e7f1", "label": "cpp20_range_access_empty_returns_bool_c0", "x": -208.912854391232, "y": -592.0402530015401, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.empty]/4", "content": "Whenever ranges::empty(E) is a valid expression, it has type bool.", "function": "ranges::empty"}, {"id": "cpp20_range_access_reserve_hint_returns_integer_like_b9c2d6e0", "label": "cpp20_range_access_reserve_hint_returns_", "x": 531.5280284402212, "y": 336.2266657721995, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.size.hint]/2", "content": "Whenever ranges::reserve_hint(E) is a valid expression, its type is integer-like.", "function": "ranges::reserve_hint"}, {"id": "cpp20_range_access_size_unknown_bound_array_illformed_a6b9c3d7", "label": "cpp20_range_access_size_unknown_bound_ar", "x": -200.17228947297096, "y": -26.417284237064155, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.size]/2.1", "content": "Calling ranges::size on an array of unknown bound is ill-formed.", "function": "ranges::size"}, {"id": "cpp20_range_access_size_disable_sized_range_constraint_b5c8d2e6", "label": "cpp20_range_access_size_disable_sized_ra", "x": 973.5073705769839, "y": -29.57765519509119, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.size]/2.3", "content": "For ranges::size to use t.size(), disable_sized_range<remove_cv_t<T>> must be false.", "function": "ranges::size"}, {"id": "cpp20_range_access_size_fallback_sized_sentinel_e8f1a5b9", "label": "cpp20_range_access_size_fallback_sized_s", "x": -212.54715811062675, "y": -239.6044029569799, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.size]/2.5", "content": "For ranges::size to use ranges::end(t) - ranges::begin(t), the iterator types must model both sized_sentinel_for and forward_iterator.", "function": "ranges::size"}, {"id": "cpp20_range_access_size_returns_integer_like_a8b1c5d9", "label": "cpp20_range_access_size_returns_integer_", "x": 132.84159782554636, "y": -224.22945978240327, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.size]/4", "content": "Whenever ranges::size(E) is a valid expression, its type is integer-like.", "function": "ranges::size"}, {"id": "cpp20_range_access_ssize_requires_valid_size_b7c0d4e8", "label": "cpp20_range_access_ssize_requires_valid_", "x": 36.81948064757024, "y": 931.6414527742295, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[range.prim.ssize]/2", "content": "Calling ranges::ssize requires ranges::size to be a valid expression; if ranges::size(t) is ill-formed, ranges::ssize(E) is also ill-formed.", "function": "ranges::ssize"}, {"id": "cpp20_reduce_mandate_binary_op_convertible_c7d2f9a4", "label": "cpp20_reduce_mandate_binary_op_convertib", "x": -141.1444298848256, "y": -941.7913386217379, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[reduce]/5", "content": "All of binary_op(init, *first), binary_op(*first, init), binary_op(init, init), and binary_op(*first, *first) must be convertible to T for std::reduce.", "function": "std::reduce"}, {"id": "cpp20_reduce_precond_binary_op_no_invalidate_e9f4b2c7", "label": "cpp20_reduce_precond_binary_op_no_invali", "x": -951.3619175481447, "y": -166.61603066235168, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[reduce]/6", "content": "binary_op must neither invalidate iterators or subranges, nor modify elements in the range [first, last] for std::reduce.", "function": "std::reduce"}, {"id": "cpp20_reduce_precond_t_moveconstructible_d8e3a1f6", "label": "cpp20_reduce_precond_t_moveconstructible", "x": -509.0859299636561, "y": -823.4934711920766, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[reduce]/6", "content": "Type T must meet Cpp17MoveConstructible requirements for std::reduce.", "function": "std::reduce"}, {"id": "cpp20_refwrap_comparison_eq_constraint_k3l4m5n6", "label": "cpp20_refwrap_comparison_eq_constraint_k", "x": 667.6012163261521, "y": -156.04919886611103, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/1", "content": "reference_wrapper equality comparison requires x.get() == y.get() to be well-formed and convertible to bool.", "function": "std::reference_wrapper::operator=="}, {"id": "cpp20_refwrap_comparisons_constraint_expr_well_formed_f1a2b3c4", "label": "cpp20_refwrap_comparisons_constraint_exp", "x": -321.7376398619534, "y": 820.125275729694, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/1", "content": "reference_wrapper operator== comparison requires x.get() == y.get() to be well-formed and convertible to bool.", "function": "std::operator=="}, {"id": "cpp20_refwrap_comparisons_spaceship_const_ref_e1f2a3b4", "label": "cpp20_refwrap_comparisons_spaceship_cons", "x": -540.4024361047815, "y": 805.8330717861613, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/11", "content": "reference_wrapper operator<=>(reference_wrapper<T>, reference_wrapper<const T>) requires is_const_v<T> to be false and synth-three-way(x.get(), y.get()) to be well-formed.", "function": "std::operator<=>"}, {"id": "cpp20_refwrap_const_t_spaceship_constraint_s1t2u3v4", "label": "cpp20_refwrap_const_t_spaceship_constrai", "x": -287.9864001584441, "y": 832.7486860431127, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/11", "content": "reference_wrapper<T> three-way comparison with reference_wrapper<const T> requires is_const_v<T> to be false.", "function": "std::reference_wrapper::operator<=>"}, {"id": "cpp20_refwrap_comparisons_const_t_constraint_e9f0a1b2", "label": "cpp20_refwrap_comparisons_const_t_constr", "x": 202.73743368704842, "y": 764.6763453191978, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/3", "content": "reference_wrapper operator==(reference_wrapper, const T&) requires x.get() == y to be well-formed and convertible to bool.", "function": "std::operator=="}, {"id": "cpp20_refwrap_comparisons_const_ref_constraint_d3e4f5a6", "label": "cpp20_refwrap_comparisons_const_ref_cons", "x": 919.2944034409278, "y": -318.3881156422149, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/5", "content": "reference_wrapper operator==(reference_wrapper<T>, reference_wrapper<const T>) requires is_const_v<T> to be false and x.get() == y.get() to be well-formed and convertible to bool.", "function": "std::operator=="}, {"id": "cpp20_refwrap_comparison_spaceship_constraint_o7p8q9r0", "label": "cpp20_refwrap_comparison_spaceship_const", "x": 902.2301950060494, "y": -184.0429177070161, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/7", "content": "reference_wrapper three-way comparison requires synth-three-way(x.get(), y.get()) to be well-formed.", "function": "std::reference_wrapper::operator<=>"}, {"id": "cpp20_refwrap_comparisons_spaceship_constraint_b7c8d9e0", "label": "cpp20_refwrap_comparisons_spaceship_cons", "x": -360.17833518447696, "y": -516.9977760955469, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/7", "content": "reference_wrapper operator<=>(reference_wrapper, reference_wrapper) requires synth-three-way(x.get(), y.get()) to be well-formed.", "function": "std::operator<=>"}, {"id": "cpp20_refwrap_comparisons_spaceship_const_t_a5b6c7d8", "label": "cpp20_refwrap_comparisons_spaceship_cons", "x": 54.863913850056726, "y": -794.010769920857, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.comparisons]/9", "content": "reference_wrapper operator<=>(reference_wrapper, const T&) requires synth-three-way(x.get(), y) to be well-formed.", "function": "std::operator<=>"}, {"id": "cpp20_refwrap_const_constraint_no_rvalue_binding_k7l8m9n0", "label": "cpp20_refwrap_const_constraint_no_rvalue", "x": 395.4734783314514, "y": 331.288126429909, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.const]/1-2", "content": "reference_wrapper constructor is constrained to prevent binding to rvalue references via deleted FUN(T&&).", "function": "std::reference_wrapper::reference_wrapper"}, {"id": "cpp20_refwrap_const_constraint_fun_well_formed_a7b8c9d0", "label": "cpp20_refwrap_const_constraint_fun_well_", "x": -71.02880542473582, "y": -155.33854333355384, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.const]/2", "content": "reference_wrapper<T> constructor from U&& requires FUN(declval<U>()) to be well-formed, where FUN is void FUN(T&) noexcept; void FUN(T&&) = delete;", "function": "std::reference_wrapper::reference_wrapper"}, {"id": "cpp20_refwrap_const_constraint_not_self_b3c4d5e6", "label": "cpp20_refwrap_const_constraint_not_self_", "x": 45.400827700375544, "y": -115.46646592318064, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.const]/2", "content": "reference_wrapper<T> constructor from U&& requires is_same_v<remove_cvref_t<U>, reference_wrapper> to be false.", "function": "std::reference_wrapper::reference_wrapper"}, {"id": "cpp20_refwrap_trivially_copyable_g9h0i1j2", "label": "cpp20_refwrap_trivially_copyable_g9h0i1j", "x": -484.4266982639533, "y": -626.4572067485489, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.general]/2", "content": "reference_wrapper<T> is a trivially copyable type.", "function": ""}, {"id": "cpp20_refwrap_incomplete_type_comparison_note_o1p2q3r4", "label": "cpp20_refwrap_incomplete_type_comparison", "x": -879.4414919672593, "y": -221.5215458984162, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.general]/3", "content": "Using comparison operators on reference_wrapper<T> where T is incomplete can lead to ill-formed program with no diagnostic required.", "function": "std::reference_wrapper comparison operators"}, {"id": "cpp20_refwrap_invoke_mandate_t_complete_c5d6e7f8", "label": "cpp20_refwrap_invoke_mandate_t_complete_", "x": -26.26071524927182, "y": 539.913007779561, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.invoke]/1", "content": "reference_wrapper<T>::operator() mandates that T is a complete type.", "function": "std::reference_wrapper::operator()"}, {"id": "cpp20_refwrap_invoke_mandates_complete_type_g3h4i5j6", "label": "cpp20_refwrap_invoke_mandates_complete_t", "x": 78.6259049702923, "y": -575.9157017034652, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[refwrap.invoke]/1", "content": "Calling operator() on reference_wrapper requires T to be a complete type.", "function": "std::reference_wrapper::operator()"}, {"id": "cpp20_sequence_reqmts_push_back_copy_precondition_b8c9d0e1", "label": "cpp20_sequence_reqmts_push_back_copy_pre", "x": 137.47794767347776, "y": -129.77563691973785, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/102", "content": "Calling push_back(t) requires T to be Cpp17CopyInsertable into X.", "function": "push_back"}, {"id": "cpp20_sequence_reqmts_push_back_move_precondition_c9d0e1f2", "label": "cpp20_sequence_reqmts_push_back_move_pre", "x": 177.84770922060093, "y": -64.57130356407565, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/106", "content": "Calling push_back(rv) requires T to be Cpp17MoveInsertable into X.", "function": "push_back"}, {"id": "cpp20_sequence_reqmts_pop_front_precondition_d0e1f2a3", "label": "cpp20_sequence_reqmts_pop_front_precondi", "x": 76.62764003251345, "y": -541.7059386482817, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/114", "content": "Calling pop_front() on a container requires the container to be non-empty (hardened precondition).", "function": "pop_front"}, {"id": "cpp20_sequence_reqmts_pop_back_precondition_e1f2a3b4", "label": "cpp20_sequence_reqmts_pop_back_precondit", "x": 832.208022624773, "y": 536.6903816841173, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/118", "content": "Calling pop_back() on a container requires the container to be non-empty (hardened precondition).", "function": "pop_back"}, {"id": "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5", "label": "cpp20_sequence_reqmts_subscript_precondi", "x": 84.34342676725, "y": -161.04934858336577, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/122", "content": "Calling operator[](n) on a container requires n < a.size() (hardened precondition).", "function": "operator[]"}, {"id": "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6", "label": "cpp20_sequence_reqmts_at_throws_out_of_r", "x": 120.50871592289928, "y": -170.12690994950134, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/127", "content": "Calling at(n) throws out_of_range if n >= a.size().", "function": "at"}, {"id": "cpp20_sequence_reqmts_assign_il_precondition_c1d2e3f4", "label": "cpp20_sequence_reqmts_assign_il_precondi", "x": 46.004795527856345, "y": -148.78183153115378, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/17", "content": "Assignment from initializer_list requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.", "function": ""}, {"id": "cpp20_sequence_reqmts_emplace_precondition_d2e3f4a5", "label": "cpp20_sequence_reqmts_emplace_preconditi", "x": -154.27914974356239, "y": 491.58389137154956, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/21", "content": "Calling emplace(p, args) requires T to be Cpp17EmplaceConstructible from args. For vector, inplace_vector, and deque, T must also be Cpp17MoveInsertable and Cpp17MoveAssignable.", "function": ""}, {"id": "cpp20_sequence_reqmts_insert_copy_precondition_e3f4a5b6", "label": "cpp20_sequence_reqmts_insert_copy_precon", "x": -361.97696287585205, "y": 885.487611099987, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/25", "content": "Calling insert(p, t) requires T to be Cpp17CopyInsertable. For vector, inplace_vector, and deque, T must also be Cpp17CopyAssignable.", "function": ""}, {"id": "cpp20_sequence_reqmts_insert_move_precondition_f4a5b6c7", "label": "cpp20_sequence_reqmts_insert_move_precon", "x": 810.1094104840867, "y": 361.60041984422924, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/29", "content": "Calling insert(p, rv) requires T to be Cpp17MoveInsertable. For vector, inplace_vector, and deque, T must also be Cpp17MoveAssignable.", "function": ""}, {"id": "cpp20_sequence_reqmts_insert_n_precondition_a5b6c7d8", "label": "cpp20_sequence_reqmts_insert_n_precondit", "x": 73.99338657500272, "y": 837.9057145111263, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/33", "content": "Calling insert(p, n, t) requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.", "function": ""}, {"id": "cpp20_sequence_reqmts_insert_range_no_self_b6c7d8e9", "label": "cpp20_sequence_reqmts_insert_range_no_se", "x": -720.4817943563475, "y": 487.50178935278547, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/37", "content": "Calling insert(p, i, j) with iterators i and j that are iterators into the container a is undefined behavior.", "function": ""}, {"id": "cpp20_sequence_reqmts_insert_range_rg_no_overlap_c7d8e9f0", "label": "cpp20_sequence_reqmts_insert_range_rg_no", "x": -742.8639079795666, "y": 473.35688726539485, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/41", "content": "Calling insert_range(p, rg) requires that rg and the container a do not overlap.", "function": ""}, {"id": "cpp20_sequence_reqmts_erase_precondition_d8e9f0a1", "label": "cpp20_sequence_reqmts_erase_precondition", "x": -383.44160022419373, "y": 775.274784385822, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/46", "content": "Calling erase(q) on vector, inplace_vector, and deque requires T to be Cpp17MoveAssignable.", "function": ""}, {"id": "cpp20_sequence_reqmts_n_copies_precondition_a9b0c1d2", "label": "cpp20_sequence_reqmts_n_copies_precondit", "x": 48.4553646413972, "y": 41.441010273100034, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/5", "content": "Constructing a sequence container with n copies of t requires T to be Cpp17CopyInsertable into X.", "function": ""}, {"id": "cpp20_sequence_reqmts_assign_range_no_overlap_e9f0a1b2", "label": "cpp20_sequence_reqmts_assign_range_no_ov", "x": -20.968461418802615, "y": 969.8585401037387, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/58", "content": "Calling assign(i, j) with iterators i and j that are iterators into the container a is undefined behavior.", "function": ""}, {"id": "cpp20_sequence_reqmts_assign_range_rg_no_overlap_f0a1b2c3", "label": "cpp20_sequence_reqmts_assign_range_rg_no", "x": -0.0811833059458252, "y": 814.4411450231905, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/62", "content": "Calling assign_range(rg) requires that rg and the container a do not overlap.", "function": ""}, {"id": "cpp20_sequence_reqmts_assign_n_no_self_ref_a1b2c3d4", "label": "cpp20_sequence_reqmts_assign_n_no_self_r", "x": 146.77551129567962, "y": -106.65847975446222, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/67", "content": "Calling assign(n, t) requires that t is not a reference into the container a.", "function": ""}, {"id": "cpp20_sequence_reqmts_front_precondition_b2c3d4e5", "label": "cpp20_sequence_reqmts_front_precondition", "x": 107.01675217775761, "y": -142.7355099357181, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/72", "content": "Calling front() on a container requires the container to be non-empty (hardened precondition).", "function": "front"}, {"id": "cpp20_sequence_reqmts_back_precondition_c3d4e5f6", "label": "cpp20_sequence_reqmts_back_precondition_", "x": 145.163381281783, "y": -117.77448674084718, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/76", "content": "Calling back() on a container requires the container to be non-empty (hardened precondition).", "function": "back"}, {"id": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "label": "cpp20_sequence_reqmts_iterator_range_pre", "x": -102.68234723888402, "y": -138.92083429612887, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/8", "content": "Constructing a sequence container from iterator range [i,j) requires T to be Cpp17EmplaceConstructible from *i.", "function": ""}, {"id": "cpp20_sequence_reqmts_emplace_front_precondition_d4e5f6a7", "label": "cpp20_sequence_reqmts_emplace_front_prec", "x": 166.4742774820091, "y": -44.347891146441555, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/80", "content": "Calling emplace_front(args) requires T to be Cpp17EmplaceConstructible into X from args.", "function": "emplace_front"}, {"id": "cpp20_sequence_reqmts_emplace_back_precondition_e5f6a7b8", "label": "cpp20_sequence_reqmts_emplace_back_preco", "x": 150.0567489364956, "y": -130.4731144255149, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/85", "content": "Calling emplace_back(args) requires T to be Cpp17EmplaceConstructible into X from args. For vector, T must also be Cpp17MoveInsertable.", "function": "emplace_back"}, {"id": "cpp20_sequence_reqmts_push_front_copy_precondition_f6a7b8c9", "label": "cpp20_sequence_reqmts_push_front_copy_pr", "x": 149.9591392752654, "y": -105.02658012873208, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/90", "content": "Calling push_front(t) requires T to be Cpp17CopyInsertable into X.", "function": "push_front"}, {"id": "cpp20_sequence_reqmts_push_front_move_precondition_a7b8c9d0", "label": "cpp20_sequence_reqmts_push_front_move_pr", "x": 138.83544430313341, "y": -19.591889305260622, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[sequence.reqmts]/94", "content": "Calling push_front(rv) requires T to be Cpp17MoveInsertable into X.", "function": "push_front"}, {"id": "cpp20_span_cons_default_constraint_g3h4i5j6", "label": "cpp20_span_cons_default_constraint_g3h4i", "x": -543.0364963782663, "y": -681.1061575045121, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/1", "content": "Default constructor constraint: Extent == dynamic_extent || Extent == 0 must be true.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_sentinel_hardened_extent_m5n6o7p8", "label": "cpp20_span_cons_iter_sentinel_hardened_e", "x": 771.3199835064058, "y": -115.01288454503042, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/10", "content": "Constructor from iterator and sentinel hardened precondition: If extent is not equal to dynamic_extent, then (last - first) == extent must be true.", "function": "std::span::span"}, {"id": "cpp20_span_cons_range_precond_contiguous_q9r0s1t2", "label": "cpp20_span_cons_range_precond_contiguous", "x": 80.94750807160301, "y": 339.0730823187572, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/17.1", "content": "Constructor from range precondition: R must model ranges::contiguous_range and ranges::sized_range.", "function": "std::span::span"}, {"id": "cpp20_span_cons_range_precond_borrowed_u3v4w5x6", "label": "cpp20_span_cons_range_precond_borrowed_u", "x": -68.95668275217841, "y": 327.7578334382148, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/17.2", "content": "Constructor from range precondition: If is_const_v<element_type> is false, R must model ranges::borrowed_range.", "function": "std::span::span"}, {"id": "cpp20_span_cons_range_hardened_extent_y7z8a9b0", "label": "cpp20_span_cons_range_hardened_extent_y7", "x": -489.90950525395596, "y": 159.2204451674752, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/18", "content": "Constructor from range hardened precondition: If extent is not equal to dynamic_extent, then ranges::size(r) == extent must be true.", "function": "std::span::span"}, {"id": "cpp20_span_cons_default_postcond_k7l8m9n0", "label": "cpp20_span_cons_default_postcond_k7l8m9n", "x": -333.5619734008144, "y": -364.9523441554456, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/2", "content": "Default constructor postcondition: size() == 0 && data() == nullptr.", "function": "std::span::span"}, {"id": "cpp20_span_cons_init_list_hardened_extent_c1d2e3f4", "label": "cpp20_span_cons_init_list_hardened_exten", "x": -961.1163142017101, "y": -2.036675195997908, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/22", "content": "Constructor from initializer_list hardened precondition: If extent is not equal to dynamic_extent, then il.size() == extent must be true.", "function": "std::span::span"}, {"id": "cpp20_span_cons_converting_hardened_extent_g5h6i7j8", "label": "cpp20_span_cons_converting_hardened_exte", "x": 447.5480826014178, "y": 533.6298704954672, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/26", "content": "Converting constructor hardened precondition: If extent is not equal to dynamic_extent, then s.size() == extent must be true.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_count_precond_valid_range_o1p2q3r4", "label": "cpp20_span_cons_iter_count_precond_valid", "x": 308.24318743713883, "y": -135.50764776333392, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/4.1", "content": "Constructor from iterator and count precondition: [first, first + count) must be a valid range.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_count_precond_contiguous_s5t6u7v8", "label": "cpp20_span_cons_iter_count_precond_conti", "x": 303.5427074568446, "y": -138.5643921060487, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/4.2", "content": "Constructor from iterator and count precondition: It must model contiguous_iterator.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_count_hardened_extent_w9x0y1z2", "label": "cpp20_span_cons_iter_count_hardened_exte", "x": 646.7790919838167, "y": -431.25070079218995, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/5", "content": "Constructor from iterator and count hardened precondition: If extent is not equal to dynamic_extent, then count == extent must be true.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_sentinel_precond_valid_range_a3b4c5d6", "label": "cpp20_span_cons_iter_sentinel_precond_va", "x": 339.7275380203911, "y": -33.37920741170747, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/9.1", "content": "Constructor from iterator and sentinel precondition: [first, last) must be a valid range.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_sentinel_precond_contiguous_e7f8g9h0", "label": "cpp20_span_cons_iter_sentinel_precond_co", "x": 267.5074966133823, "y": -70.34795432375054, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/9.2", "content": "Constructor from iterator and sentinel precondition: It must model contiguous_iterator.", "function": "std::span::span"}, {"id": "cpp20_span_cons_iter_sentinel_precond_sized_sentinel_i1j2k3l4", "label": "cpp20_span_cons_iter_sentinel_precond_si", "x": 351.3547283549817, "y": 701.8753457468425, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.cons]/9.3", "content": "Constructor from iterator and sentinel precondition: End must model sized_sentinel_for<It>.", "function": "std::span::span"}, {"id": "cpp20_span_elem_subscript_hardened_u5v6w7x8", "label": "cpp20_span_elem_subscript_hardened_u5v6w", "x": -243.57794000062083, "y": -401.45657706125496, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.elem]/1", "content": "operator[](idx) hardened precondition: idx < size() must be true.", "function": "std::span::operator[]"}, {"id": "cpp20_span_elem_at_throws_y9z0a1b2", "label": "cpp20_span_elem_at_throws_y9z0a1b2", "x": 64.52285696522861, "y": 237.39144922648708, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.elem]/5", "content": "at(idx) throws out_of_range if idx >= size() is true.", "function": "std::span::at"}, {"id": "cpp20_span_elem_front_hardened_c3d4e5f6", "label": "cpp20_span_elem_front_hardened_c3d4e5f6", "x": -199.13821921121573, "y": -404.63691126386726, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.elem]/6", "content": "front() hardened precondition: empty() is false.", "function": "std::span::front"}, {"id": "cpp20_span_elem_back_hardened_g7h8i9j0", "label": "cpp20_span_elem_back_hardened_g7h8i9j0", "x": -278.47955505967235, "y": -450.5398212704414, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.elem]/9", "content": "back() hardened precondition: empty() is false.", "function": "std::span::back"}, {"id": "cpp20_span_iterators_contiguous_model_k1l2m3n4", "label": "cpp20_span_iterators_contiguous_model_k1", "x": 345.87194366287054, "y": -19.60747537377431, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.iterators]/1", "content": "span::iterator models contiguous_iterator, meets Cpp17RandomAccessIterator requirements, and meets constexpr iterator requirements.", "function": ""}, {"id": "cpp20_span_iterators_container_requirements_o5p6q7r8", "label": "cpp20_span_iterators_container_requireme", "x": 772.0741173487517, "y": 232.4860628145657, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.iterators]/2", "content": "All requirements on container iterators apply to span::iterator as well.", "function": ""}, {"id": "cpp20_span_iterators_begin_empty_s9t0u1v2", "label": "cpp20_span_iterators_begin_empty_s9t0u1v", "x": -873.5725001035069, "y": -14.058944812618135, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.iterators]/3", "content": "If empty() is true, begin() returns the same value as end().", "function": "std::span::begin"}, {"id": "cpp20_span_overview_trivially_copyable_a1b2c3d4", "label": "cpp20_span_overview_trivially_copyable_a", "x": -883.7991951128893, "y": -130.2858585208041, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.overview]/3", "content": "span<ElementType, Extent> is a trivially copyable type.", "function": ""}, {"id": "cpp20_span_overview_element_complete_object_e5f6a7b8", "label": "cpp20_span_overview_element_complete_obj", "x": -75.24470052146343, "y": -866.1774728202726, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.overview]/4", "content": "ElementType is required to be a complete object type that is not an abstract class type.", "function": ""}, {"id": "cpp20_span_overview_invalidation_c9d0e1f2", "label": "cpp20_span_overview_invalidation_c9d0e1f", "x": -231.4881741322043, "y": -798.8874415704722, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.overview]/5", "content": "For a span s, any operation that invalidates a pointer in the range [s.data(), s.data()+s.size()) invalidates pointers, iterators, and references to elements of s.", "function": ""}, {"id": "cpp20_span_sub_first_template_mandates_k9l0m1n2", "label": "cpp20_span_sub_first_template_mandates_k", "x": 460.27846044967856, "y": 825.6522892233468, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/1", "content": "first<Count>() mandates: Count <= Extent must be true.", "function": "std::span::first"}, {"id": "cpp20_span_sub_first_dynamic_hardened_i3j4k5l6", "label": "cpp20_span_sub_first_dynamic_hardened_i3", "x": -671.0113043778526, "y": 752.210868717626, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/11", "content": "first(count) hardened precondition: count <= size() must be true.", "function": "std::span::first"}, {"id": "cpp20_span_sub_last_dynamic_hardened_m7n8o9p0", "label": "cpp20_span_sub_last_dynamic_hardened_m7n", "x": 114.4565513567539, "y": -618.1639031745653, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/13", "content": "last(count) hardened precondition: count <= size() must be true.", "function": "std::span::last"}, {"id": "cpp20_span_sub_subspan_dynamic_hardened_q1r2s3t4", "label": "cpp20_span_sub_subspan_dynamic_hardened_", "x": -871.1391539218672, "y": 42.23395602580026, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/15", "content": "subspan(offset, count) hardened precondition: offset <= size() && (count == dynamic_extent || count <= size() - offset) must be true.", "function": "std::span::subspan"}, {"id": "cpp20_span_sub_first_template_hardened_o3p4q5r6", "label": "cpp20_span_sub_first_template_hardened_o", "x": 645.1301452792895, "y": 409.10511099329693, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/2", "content": "first<Count>() hardened precondition: Count <= size() must be true.", "function": "std::span::first"}, {"id": "cpp20_span_sub_last_template_mandates_s7t8u9v0", "label": "cpp20_span_sub_last_template_mandates_s7", "x": -714.5286883307833, "y": -605.5240509824258, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/4", "content": "last<Count>() mandates: Count <= Extent must be true.", "function": "std::span::last"}, {"id": "cpp20_span_sub_last_template_hardened_w1x2y3z4", "label": "cpp20_span_sub_last_template_hardened_w1", "x": -222.68129473173136, "y": -614.0503698828866, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/5", "content": "last<Count>() hardened precondition: Count <= size() must be true.", "function": "std::span::last"}, {"id": "cpp20_span_sub_subspan_template_mandates_a5b6c7d8", "label": "cpp20_span_sub_subspan_template_mandates", "x": -577.4705409802992, "y": -470.4317803395421, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/7", "content": "subspan<Offset, Count>() mandates: Offset <= Extent && (Count == dynamic_extent || Count <= Extent - Offset) must be true.", "function": "std::span::subspan"}, {"id": "cpp20_span_sub_subspan_template_hardened_e9f0g1h2", "label": "cpp20_span_sub_subspan_template_hardened", "x": 477.4036799846957, "y": 792.0546811444223, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[span.sub]/8", "content": "subspan<Offset, Count>() hardened precondition: Offset <= size() && (Count == dynamic_extent || Count <= size() - Offset) must be true.", "function": "std::span::subspan"}, {"id": "cpp20_stop_callback_mandates_invocable_c6f9a4e2", "label": "cpp20_stop_callback_mandates_invocable_c", "x": -124.7446547135415, "y": 863.7417243696189, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopcallback.general]/2", "content": "stop_callback must be instantiated with a template parameter CallbackFn that satisfies both invocable and destructible.", "function": ""}, {"id": "cpp20_inplace_stop_callback_mandates_invocable_f6c4d9e3", "label": "cpp20_inplace_stop_callback_mandates_inv", "x": -602.2086363047251, "y": -102.28456627757346, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopcallback.inplace.general]/1", "content": "inplace_stop_callback must be instantiated with a template parameter CallbackFn that satisfies both invocable and destructible.", "function": ""}, {"id": "cpp20_stop_source_constructor_postcond_e2c9a5f6", "label": "cpp20_stop_source_constructor_postcond_e", "x": -666.5967556109084, "y": 264.0727250767198, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.cons]/2", "content": "After default construction of stop_source, stop_possible() is true and stop_requested() is false.", "function": "std::stop_source::stop_source"}, {"id": "cpp20_stop_source_constructor_bad_alloc_f3d1b6a9", "label": "cpp20_stop_source_constructor_bad_alloc_", "x": 292.9428262529379, "y": -392.0394122603234, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.cons]/3", "content": "stop_source default constructor throws bad_alloc if memory cannot be allocated for the stop state.", "function": "std::stop_source::stop_source"}, {"id": "cpp20_stop_source_disengaged_definition_d1b8f4e3", "label": "cpp20_stop_source_disengaged_definition_", "x": -386.45382815441576, "y": 491.0871398667069, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.general]/1", "content": "A stop_source object is disengaged when its exposition-only stop-state member is empty.", "function": ""}, {"id": "cpp20_inplace_stop_source_constructor_postcond_b2e9f5a8", "label": "cpp20_inplace_stop_source_constructor_po", "x": -596.8365543733687, "y": 661.6925823256286, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.inplace.cons]/2", "content": "After construction of inplace_stop_source, stop_requested() is false.", "function": "std::inplace_stop_source::inplace_stop_source"}, {"id": "cpp20_inplace_stop_source_stop_possible_always_true_d4a2b7f1", "label": "cpp20_inplace_stop_source_stop_possible_", "x": 32.0753366777074, "y": -521.827526279973, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.inplace.general]/1", "content": "inplace_stop_source::stop_possible() always returns true.", "function": "std::inplace_stop_source::stop_possible"}, {"id": "cpp20_inplace_stop_source_get_token_association_c3f1a6e9", "label": "cpp20_inplace_stop_source_get_token_asso", "x": 281.4613271023258, "y": 488.2095520957376, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.inplace.mem]/1", "content": "inplace_stop_source::get_token() returns a new associated inplace_stop_token object whose stop-source member equals this.", "function": "std::inplace_stop_source::get_token"}, {"id": "cpp20_inplace_stop_source_request_stop_postcond_e5b3c8a2", "label": "cpp20_inplace_stop_source_request_stop_p", "x": -886.0039256696016, "y": 272.1714591520758, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.inplace.mem]/4", "content": "After inplace_stop_source::request_stop() is called, stop_requested() is true.", "function": "std::inplace_stop_source::request_stop"}, {"id": "cpp20_stop_source_get_token_disengaged_a4f7c2e8", "label": "cpp20_stop_source_get_token_disengaged_a", "x": -579.6911623774479, "y": 450.7701492987642, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.mem]/2", "content": "stop_source::get_token() returns stop_token() if stop_possible() is false.", "function": "std::stop_source::get_token"}, {"id": "cpp20_stop_source_stop_possible_definition_b5e8d3f1", "label": "cpp20_stop_source_stop_possible_definiti", "x": -350.537391668751, "y": -373.06274086545295, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stopsource.mem]/3", "content": "stop_source::stop_possible() returns true if and only if stop-state is not nullptr.", "function": "std::stop_source::stop_possible"}, {"id": "cpp20_stopsource_concepts_disengaged_get_token_f9d3a7e5", "label": "cpp20_stopsource_concepts_disengaged_get", "x": 468.37265274845754, "y": 215.77730330831244, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/10", "content": "If stoppable-source object t is disengaged, t.get_token() shall return a disengaged stop token.", "function": ""}, {"id": "cpp20_stopsource_concepts_callback_registration_synchronizes_c3a1d6e9", "label": "cpp20_stopsource_concepts_callback_regis", "x": -703.2627128102795, "y": 468.45339520359687, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/11", "content": "Registration of a callback synchronizes with the invocation of that callback.", "function": ""}, {"id": "cpp20_stopsource_concepts_no_data_races_a1e8b4f9", "label": "cpp20_stopsource_concepts_no_data_races_", "x": -666.9366887373077, "y": 2.3281675123652943, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/11", "content": "Calls to the member functions request_stop, stop_requested, and stop_possible and similarly named member functions on associated stoppable_token objects do not introduce data races.", "function": ""}, {"id": "cpp20_stopsource_concepts_request_stop_synchronizes_b2f9c5a8", "label": "cpp20_stopsource_concepts_request_stop_s", "x": -366.19720967957073, "y": -728.9083378008212, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/11", "content": "A call to request_stop that returns true synchronizes with a call to stop_requested on an associated stoppable_token or stoppable-source object that returns true.", "function": ""}, {"id": "cpp20_stopsource_concepts_disengaged_request_stop_d4b2e7f1", "label": "cpp20_stopsource_concepts_disengaged_req", "x": 167.77655444941078, "y": -920.2457502746981, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/12", "content": "If the stoppable-source is disengaged, request_stop shall have no effect and return false.", "function": ""}, {"id": "cpp20_stopsource_concepts_request_stop_atomic_e5c3f8a2", "label": "cpp20_stopsource_concepts_request_stop_a", "x": 594.9428656168483, "y": -389.04538964460517, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/12", "content": "A stop request operation's determination of whether a stop request has been made and the making of the stop request shall happen atomically, as-if by a read-modify-write operation.", "function": ""}, {"id": "cpp20_stopsource_concepts_request_stop_postcond_f6d4a9b3", "label": "cpp20_stopsource_concepts_request_stop_p", "x": -1000.0, "y": 61.75593309887559, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/12", "content": "After a call to request_stop, either a call to stop_possible shall return false or a call to stop_requested shall return true.", "function": ""}, {"id": "cpp20_stoptoken_concepts_callback_terminate_on_exception_c9e5a2f7", "label": "cpp20_stoptoken_concepts_callback_termin", "x": -723.0273461066097, "y": 215.90770852191426, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/12", "content": "If a registered callback invocation exits via an exception during a stop request operation, std::terminate shall be invoked.", "function": ""}, {"id": "cpp20_stoptoken_concepts_stoppable_callback_registration_precond_a7f3e2d1", "label": "cpp20_stoptoken_concepts_stoppable_callb", "x": 320.1284212251225, "y": -883.5346684561996, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/3.2.1", "content": "If t.stop_possible() is true during stoppable callback registration, callback_fn must be successfully initialized from init before the callback can be registered.", "function": ""}, {"id": "cpp20_stoptoken_concepts_callback_registration_throw_constraint_b8d4f1a3", "label": "cpp20_stoptoken_concepts_callback_regist", "x": 481.3586387856336, "y": -879.567215203992, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/3.2.1.2", "content": "During stoppable callback registration, if t.stop_possible() is true, construction of scb shall only throw exceptions thrown by the initialization of callback_fn from init.", "function": ""}, {"id": "cpp20_stoptoken_concepts_deregistration_blocking_precond_d1a7b3e8", "label": "cpp20_stoptoken_concepts_deregistration_", "x": -532.8528591983522, "y": 496.6552856856646, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/3.3.3", "content": "If callback_fn is concurrently executing on another thread during stoppable callback deregistration, the deregistration shall block until callback_fn returns, such that the return strongly happens before the destruction of callback_fn.", "function": ""}, {"id": "cpp20_stoptoken_concepts_deregistration_no_self_block_e2f8c4d9", "label": "cpp20_stoptoken_concepts_deregistration_", "x": -256.0583551798844, "y": -815.928100187727, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/3.3.4", "content": "If callback_fn is executing on the current thread during stoppable callback deregistration, the destructor shall not block waiting for the return from the invocation of callback_fn.", "function": ""}, {"id": "cpp20_stoptoken_concepts_deregistration_no_cross_block_f3a9d5e1", "label": "cpp20_stoptoken_concepts_deregistration_", "x": -347.46896239680956, "y": -608.0161390259715, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/3.3.5", "content": "A stoppable callback deregistration shall not block on the completion of the invocation of some other callback registered with the same logical stop state.", "function": ""}, {"id": "cpp20_stoptoken_concepts_stop_possible_propagation_a4e7b2f8", "label": "cpp20_stoptoken_concepts_stop_possible_p", "x": 722.5884570203768, "y": -325.44029112447726, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/7.1", "content": "Any evaluation of u.stop_possible() or u.stop_requested() that happens after an evaluation of t.stop_possible() that is false must also be false, where u and t reference the same stop state.", "function": ""}, {"id": "cpp20_stoptoken_concepts_stop_requested_propagation_b5f8c3a9", "label": "cpp20_stoptoken_concepts_stop_requested_", "x": 482.7824708052636, "y": 736.0942690198555, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/7.2", "content": "Any evaluation of u.stop_possible() or u.stop_requested() that happens after an evaluation of t.stop_requested() that is true must also be true, where u and t reference the same stop state.", "function": ""}, {"id": "cpp20_stoptoken_concepts_disengaged_stop_possible_false_c6a9d4e2", "label": "cpp20_stoptoken_concepts_disengaged_stop", "x": -81.25004410599759, "y": 862.285611356164, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/7.4", "content": "If stoppable_token object t is disengaged, evaluations of t.stop_possible() and t.stop_requested() are false.", "function": ""}, {"id": "cpp20_stoptoken_concepts_equality_semantics_d7b1e5f3", "label": "cpp20_stoptoken_concepts_equality_semant", "x": -159.09044023397806, "y": 944.1946734373662, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/7.5", "content": "If t and u reference the same stop state, or if both t and u are disengaged, t==u is true; otherwise, it is false.", "function": ""}, {"id": "cpp20_stopsource_concepts_disengaged_behavior_e8c2f6a4", "label": "cpp20_stopsource_concepts_disengaged_beh", "x": -842.527323161342, "y": 305.4216876612265, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.concepts]/9", "content": "If stoppable-source object s is disengaged, s.stop_possible() and s.stop_requested() shall be false.", "function": ""}, {"id": "cpp20_stop_token_disengaged_definition_a7e5c1f9", "label": "cpp20_stop_token_disengaged_definition_a", "x": 18.68203194179572, "y": -572.2312908271572, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.general]/2", "content": "A stop_token object is disengaged when its exposition-only stop-state member is empty.", "function": ""}, {"id": "cpp20_inplace_stop_token_stop_requested_ub_after_dtor_f9c3a7e5", "label": "cpp20_inplace_stop_token_stop_requested_", "x": 678.3564179259884, "y": 179.02320333569185, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.inplace.mem]/3", "content": "The behavior of inplace_stop_token::stop_requested() is undefined unless the call strongly happens before the start of the destructor of the associated inplace_stop_source object.", "function": "std::inplace_stop_token::stop_requested"}, {"id": "cpp20_inplace_stop_token_stop_possible_impl_defined_a1d8e4f9", "label": "cpp20_inplace_stop_token_stop_possible_i", "x": -868.8627573493426, "y": -462.81246107574657, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.inplace.mem]/5", "content": "The behavior of inplace_stop_token::stop_possible() is implementation-defined unless the call strongly happens before the end of the storage duration of the associated inplace_stop_source object.", "function": "std::inplace_stop_token::stop_possible"}, {"id": "cpp20_stop_token_stop_requested_disengaged_b8f6d2a1", "label": "cpp20_stop_token_stop_requested_disengag", "x": 514.7229742493118, "y": 470.9637230436472, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.mem]/2", "content": "stop_token::stop_requested() returns false if the token is disengaged.", "function": "std::stop_token::stop_requested"}, {"id": "cpp20_stop_token_stop_possible_no_source_c9a7e3d2", "label": "cpp20_stop_token_stop_possible_no_source", "x": 886.3865284128212, "y": 395.34596002854505, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.mem]/3", "content": "stop_token::stop_possible() returns false if the token is disengaged or if a stop request was not made and there are no associated stop_source objects.", "function": "std::stop_token::stop_possible"}, {"id": "cpp20_never_stop_token_stop_possible_always_false_e8b2f6a4", "label": "cpp20_never_stop_token_stop_possible_alw", "x": 900.5504617028186, "y": 328.9341087870341, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.never]/1", "content": "never_stop_token::stop_possible() always returns false.", "function": "std::never_stop_token::stop_possible"}, {"id": "cpp20_never_stop_token_stop_requested_always_false_d7a1e5f3", "label": "cpp20_never_stop_token_stop_requested_al", "x": -350.7726002397605, "y": -761.498528780671, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[stoptoken.never]/1", "content": "never_stop_token::stop_requested() always returns false.", "function": "std::never_stop_token::stop_requested"}, {"id": "cpp20_thread_condition_condvar_wait_relock_fail_terminate_c1d2e3f4", "label": "cpp20_thread_condition_condvar_wait_relo", "x": 153.97038519360896, "y": -94.40543123727109, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/11", "content": "If wait() fails to meet the postcondition (e.g., re-locking mutex throws), terminate() is invoked.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8", "label": "cpp20_thread_condition_condvar_wait_pred", "x": 130.46016094144434, "y": 56.64097926037961, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/12", "content": "Calling wait() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_condvar_wait_pred_terminate_e9f0a1b2", "label": "cpp20_thread_condition_condvar_wait_pred", "x": 162.74641553980226, "y": -122.64597312938271, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/16", "content": "If wait() with predicate fails to meet the postcondition, terminate() is invoked.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6", "label": "cpp20_thread_condition_condvar_wait_unti", "x": 132.76585891406947, "y": 47.85794192637402, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/17", "content": "Calling wait_until() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.", "function": "std::condition_variable::wait_until"}, {"id": "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0", "label": "cpp20_thread_condition_condvar_wait_unti", "x": 41.63260694378043, "y": 22.51845870554175, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/18.4", "content": "If wait_until() exits via an exception, lock.lock() is called prior to exiting the function.", "function": "std::condition_variable::wait_until"}, {"id": "cpp20_thread_condition_condvar_wait_until_terminate_e1f2a3b4", "label": "cpp20_thread_condition_condvar_wait_unti", "x": 139.68118941636848, "y": -108.53246442427395, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/22", "content": "If wait_until() fails to meet the postcondition, terminate() is invoked.", "function": "std::condition_variable::wait_until"}, {"id": "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8", "label": "cpp20_thread_condition_condvar_wait_for_", "x": 131.19627213963983, "y": 33.463227696148, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/23", "content": "Calling wait_for() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.", "function": "std::condition_variable::wait_for"}, {"id": "cpp20_thread_condition_condvar_wait_for_terminate_a9b0c1d2", "label": "cpp20_thread_condition_condvar_wait_for_", "x": 149.95131514429818, "y": -134.14803778093554, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/28", "content": "If wait_for() fails to meet the postcondition, terminate is invoked.", "function": "std::condition_variable::wait_for"}, {"id": "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6", "label": "cpp20_thread_condition_condvar_wait_unti", "x": 117.97785702316452, "y": 35.4378709338224, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/29", "content": "Calling wait_until() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.", "function": "std::condition_variable::wait_until"}, {"id": "cpp20_thread_condition_condvar_wait_until_pred_terminate_c7d8e9f0", "label": "cpp20_thread_condition_condvar_wait_unti", "x": 167.06630074747835, "y": -67.12265843870301, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/34", "content": "If wait_until() with predicate fails to meet the postcondition, terminate() is invoked.", "function": "std::condition_variable::wait_until"}, {"id": "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4", "label": "cpp20_thread_condition_condvar_wait_for_", "x": 115.49116724072272, "y": 21.20189680273998, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/35", "content": "Calling wait_for() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.", "function": "std::condition_variable::wait_for"}, {"id": "cpp20_thread_condition_condvar_dtor_precond_no_blocked_a1b2c3d4", "label": "cpp20_thread_condition_condvar_dtor_prec", "x": 184.5190456895525, "y": 168.86632871867752, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/4", "content": "Destroying a condition_variable requires that no thread is blocked on it.", "function": "std::condition_variable::~condition_variable"}, {"id": "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8", "label": "cpp20_thread_condition_condvar_wait_afte", "x": 31.979334191918365, "y": 123.46856884039954, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/4", "content": "Undefined behavior ensues if a thread waits on a condition_variable once the destructor has been started.", "function": "std::condition_variable::~condition_variable"}, {"id": "cpp20_thread_condition_condvar_wait_for_pred_terminate_e5f6a7b8", "label": "cpp20_thread_condition_condvar_wait_for_", "x": 133.64652974743402, "y": -111.70187689723173, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/41", "content": "If wait_for() with predicate fails to meet the postcondition, terminate() is invoked.", "function": "std::condition_variable::wait_for"}, {"id": "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2", "label": "cpp20_thread_condition_condvar_wait_prec", "x": 109.16632422574267, "y": 25.811373256914052, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/7", "content": "Calling wait() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6", "label": "cpp20_thread_condition_condvar_wait_prec", "x": 150.1365563721345, "y": 19.182190129322382, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/7", "content": "When multiple threads wait on a condition_variable, either no other thread is waiting or all waiting threads must use lock arguments where lock.mutex() returns the same value.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_spurious_wakeup_e7f8a9b0", "label": "cpp20_thread_condition_spurious_wakeup_e", "x": 155.48591714052094, "y": -102.734660062299, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/8.3", "content": "A condition_variable wait function may unblock spuriously (without notification or timeout).", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0", "label": "cpp20_thread_condition_condvar_wait_post", "x": 136.04823209400587, "y": 17.598676439275916, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvar]/9", "content": "After wait() returns, lock.owns_lock() is true and lock.mutex() is locked by the calling thread.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_condvarany_lock_requirement_e7f8a9b0", "label": "cpp20_thread_condition_condvarany_lock_r", "x": -195.15975206102826, "y": 106.4538058151308, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvarany.general]/1", "content": "Template arguments for Lock in condition_variable_any shall meet the Cpp17BasicLockable requirements.", "function": "std::condition_variable_any"}, {"id": "cpp20_thread_condition_condvarany_dtor_precond_no_blocked_c9d0e1f2", "label": "cpp20_thread_condition_condvarany_dtor_p", "x": 172.35483710644553, "y": 169.6034131996187, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvarany.general]/4", "content": "Destroying a condition_variable_any requires that no thread is blocked on it.", "function": "std::condition_variable_any::~condition_variable_any"}, {"id": "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6", "label": "cpp20_thread_condition_condvarany_wait_a", "x": 38.44110064441329, "y": 127.03013893133605, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.condvarany.general]/4", "content": "Undefined behavior ensues if a thread waits on a condition_variable_any once the destructor has been started.", "function": "std::condition_variable_any::~condition_variable_any"}, {"id": "cpp20_thread_condition_concurrent_permitted_c1d2e3f4", "label": "cpp20_thread_condition_concurrent_permit", "x": -206.81110826075815, "y": -977.2340235453023, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.general]/2", "content": "Condition variables permit concurrent invocation of wait, wait_for, wait_until, notify_one and notify_all member functions.", "function": "std::condition_variable"}, {"id": "cpp20_thread_condition_atomic_notify_c9d0e1f2", "label": "cpp20_thread_condition_atomic_notify_c9d", "x": -309.7596943002825, "y": 174.85011321587962, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.general]/3", "content": "The executions of notify_one and notify_all are atomic.", "function": "std::condition_variable::notify_one"}, {"id": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "label": "cpp20_thread_condition_wait_three_atomic", "x": -123.4043065754168, "y": 70.88699567873915, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.general]/3", "content": "The executions of wait, wait_for, and wait_until are performed in three atomic parts: (1) release of mutex and entry into waiting state, (2) unblocking of wait, and (3) reacquisition of lock.", "function": "std::condition_variable::wait"}, {"id": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "label": "cpp20_thread_condition_ctor_dtor_no_sync", "x": -127.77982558324503, "y": 99.64575270139648, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.general]/5", "content": "Condition variable construction and destruction need not be synchronized.", "function": "std::condition_variable"}, {"id": "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0", "label": "cpp20_thread_condition_notify_all_at_thr", "x": 132.01856386492256, "y": 30.194336077144463, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.nonmember]/1", "content": "notify_all_at_thread_exit() requires lk to be locked by the calling thread.", "function": "std::notify_all_at_thread_exit"}, {"id": "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4", "label": "cpp20_thread_condition_notify_all_at_thr", "x": 154.90550986873183, "y": 20.815025139142083, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.nonmember]/1", "content": "notify_all_at_thread_exit() requires either no other thread waiting on cond, or lk.mutex() returns the same value for all concurrently waiting threads.", "function": "std::notify_all_at_thread_exit"}, {"id": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "label": "cpp20_thread_condition_notify_all_at_thr", "x": 45.268807448092616, "y": 62.487575076072446, "size": 7.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condition.nonmember]/3", "content": "The implied lk.unlock() call from notify_all_at_thread_exit is sequenced after the destruction of all objects with thread storage duration associated with the current thread.", "function": "std::notify_all_at_thread_exit"}, {"id": "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2", "label": "cpp20_thread_condition_condvarany_intwai", "x": 144.6324666581473, "y": 40.074412356210075, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.intwait]/10", "content": "After interruptible wait_until() returns on condition_variable_any, lock is locked by the calling thread.", "function": "std::condition_variable_any::wait_until"}, {"id": "cpp20_thread_condition_condvarany_intwait_until_terminate_e3f4a5b6", "label": "cpp20_thread_condition_condvarany_intwai", "x": 163.64557062353802, "y": -106.83549283587348, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.intwait]/12", "content": "If interruptible wait_until() on condition_variable_any fails to meet the postcondition, terminate is called.", "function": "std::condition_variable_any::wait_until"}, {"id": "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4", "label": "cpp20_thread_condition_condvarany_intwai", "x": 122.50879071698702, "y": 14.828500807731189, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.intwait]/4", "content": "After interruptible wait() returns on condition_variable_any, lock is locked by the calling thread.", "function": "std::condition_variable_any::wait"}, {"id": "cpp20_thread_condition_condvarany_intwait_terminate_c5d6e7f8", "label": "cpp20_thread_condition_condvarany_intwai", "x": 165.14695148016372, "y": -119.15789071440234, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.intwait]/6", "content": "If interruptible wait() on condition_variable_any fails to meet the postcondition, terminate is called.", "function": "std::condition_variable_any::wait"}, {"id": "cpp20_thread_condition_condvarany_wait_until_terminate_c3d4e5f6", "label": "cpp20_thread_condition_condvarany_wait_u", "x": 99.59306471057175, "y": -170.05509008374744, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.wait]/10", "content": "If wait_until() on condition_variable_any fails to meet the postcondition, terminate() is invoked.", "function": "std::condition_variable_any::wait_until"}, {"id": "cpp20_thread_condition_condvarany_wait_for_terminate_a7b8c9d0", "label": "cpp20_thread_condition_condvarany_wait_f", "x": 162.5560702982286, "y": -74.4974258864453, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.wait]/15", "content": "If wait_for() on condition_variable_any fails to meet the postcondition, terminate is invoked.", "function": "std::condition_variable_any::wait_for"}, {"id": "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4", "label": "cpp20_thread_condition_condvarany_wait_p", "x": 129.68324715071108, "y": 47.36577618152993, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.wait]/2", "content": "After wait() returns on condition_variable_any, lock is locked by the calling thread.", "function": "std::condition_variable_any::wait"}, {"id": "cpp20_thread_condition_condvarany_wait_relock_fail_terminate_a5b6c7d8", "label": "cpp20_thread_condition_condvarany_wait_r", "x": 118.09207578439417, "y": -156.46737963517558, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.wait]/4", "content": "If wait() on condition_variable_any fails to meet the postcondition, terminate() is invoked.", "function": "std::condition_variable_any::wait"}, {"id": "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2", "label": "cpp20_thread_condition_condvarany_wait_u", "x": 43.33970714531049, "y": 18.10652805403415, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.condvarany.wait]/6.4", "content": "If wait_until() on condition_variable_any exits via an exception, lock.lock() is called prior to exiting the function.", "function": "std::condition_variable_any::wait_until"}, {"id": "cpp20_jthread_cons_move_postcond_ssource_moved_b3c4d5e6", "label": "cpp20_jthread_cons_move_postcond_ssource", "x": 220.288852038293, "y": 946.5779191351947, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/10", "content": "After jthread move construction, ssource has the value of x.ssource prior to construction", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_move_postcond_this_id_from_x_d9e0f1a2", "label": "cpp20_jthread_cons_move_postcond_this_id", "x": 546.4189773326826, "y": -827.911547993094, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/10", "content": "After jthread move construction, get_id() returns the value of x.get_id() prior to construction", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_move_postcond_x_id_default_f5a6b7c8", "label": "cpp20_jthread_cons_move_postcond_x_id_de", "x": 793.2459900704542, "y": 426.37374950782504, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/10", "content": "After jthread move construction, x.get_id() == id() is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_move_postcond_x_stop_not_possible_a7b8c9d0", "label": "cpp20_jthread_cons_move_postcond_x_stop_", "x": 703.7650669949778, "y": -140.43775228456556, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/10", "content": "After jthread move construction, x.ssource.stop_possible() is false", "function": "jthread::jthread"}, {"id": "cpp20_jthread_dtor_effect_request_stop_join_e1f2a3b4", "label": "cpp20_jthread_dtor_effect_request_stop_j", "x": -292.5276541827728, "y": -564.7455304717062, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/11", "content": "jthread destructor calls request_stop() and then join() if joinable() is true", "function": "jthread::~jthread"}, {"id": "cpp20_jthread_move_assign_effect_request_stop_join_a9b0c1d2", "label": "cpp20_jthread_move_assign_effect_request", "x": -242.14202888642424, "y": 80.08212659096706, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/12", "content": "jthread move assignment calls request_stop() and join() if &x != this and joinable() is true", "function": "jthread::operator="}, {"id": "cpp20_jthread_move_assign_effect_self_no_effect_c5d6e7f8", "label": "cpp20_jthread_move_assign_effect_self_no", "x": -241.54998345666343, "y": 83.24511644168633, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/12", "content": "jthread move assignment has no effects if &x == this is true", "function": "jthread::operator="}, {"id": "cpp20_jthread_move_assign_postcond_id_from_x_e3f4a5b6", "label": "cpp20_jthread_move_assign_postcond_id_fr", "x": -294.674595693544, "y": 22.56184915024298, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/13", "content": "After jthread move assignment, get_id() returns the value of x.get_id() prior to assignment", "function": "jthread::operator="}, {"id": "cpp20_jthread_move_assign_postcond_ssource_from_x_c7d8e9f0", "label": "cpp20_jthread_move_assign_postcond_ssour", "x": -248.01487518711136, "y": 55.734459972495266, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/13", "content": "After jthread move assignment, ssource has the value of x.ssource prior to assignment", "function": "jthread::operator="}, {"id": "cpp20_jthread_cons_default_postcond_no_thread_a1b2c3d4", "label": "cpp20_jthread_cons_default_postcond_no_t", "x": 834.3930019962962, "y": 431.6603556682966, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/2", "content": "Default-constructed jthread does not represent a thread of execution: get_id() == id() is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_default_postcond_stop_not_possible_e5f6a7b8", "label": "cpp20_jthread_cons_default_postcond_stop", "x": 993.0767492542298, "y": 69.89627683212731, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/2", "content": "Default-constructed jthread has no stop source: ssource.stop_possible() is false", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_constraint_not_jthread_c9d0e1f2", "label": "cpp20_jthread_cons_f_constraint_not_jthr", "x": 254.88395638404776, "y": -78.8054078632953, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/3", "content": "jthread template constructor requires remove_cvref_t<F> is not the same type as jthread", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_mandate_f_constructible_a3b4c5d6", "label": "cpp20_jthread_cons_f_mandate_f_construct", "x": 270.7534219503633, "y": -84.01836461518255, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/4.1", "content": "jthread template constructor mandates is_constructible_v<decay_t<F>, F> is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_mandate_args_constructible_b7c8d9e0", "label": "cpp20_jthread_cons_f_mandate_args_constr", "x": 261.0093349422435, "y": -88.48606539901145, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/4.2", "content": "jthread template constructor mandates (is_constructible_v<decay_t<Args>, Args> && ...) is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_mandate_invocable_f1a2b3c4", "label": "cpp20_jthread_cons_f_mandate_invocable_f", "x": 283.2969072953078, "y": -82.58994696147116, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/4.3", "content": "jthread template constructor mandates is_invocable_v<decay_t<F>, decay_t<Args>...> || is_invocable_v<decay_t<F>, stop_token, decay_t<Args>...> is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_effect_terminate_on_exception_d5e6f7a8", "label": "cpp20_jthread_cons_f_effect_terminate_on", "x": 278.3661079771134, "y": -386.26885079815884, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/5", "content": "If the invoke expression in jthread constructor exits via an exception, terminate is called", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_postcond_id_not_default_e9f0a1b2", "label": "cpp20_jthread_cons_f_postcond_id_not_def", "x": 705.8183519703821, "y": 282.4631075237426, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/7", "content": "After successful jthread(F&&, Args&&...) construction, get_id() != id() is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_postcond_represents_thread_a7b8c9d0", "label": "cpp20_jthread_cons_f_postcond_represents", "x": -305.45173137223713, "y": 533.769846184471, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/7", "content": "After successful jthread(F&&, Args&&...) construction, *this represents the newly started thread", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_postcond_stop_possible_c3d4e5f6", "label": "cpp20_jthread_cons_f_postcond_stop_possi", "x": -584.3884473477012, "y": -397.8326129744491, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/7", "content": "After successful jthread(F&&, Args&&...) construction, ssource.stop_possible() is true", "function": "jthread::jthread"}, {"id": "cpp20_jthread_cons_f_throws_system_error_b1c2d3e4", "label": "cpp20_jthread_cons_f_throws_system_error", "x": 276.88720545245434, "y": -381.0788408078045, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.cons]/8", "content": "jthread(F&&, Args&&...) throws system_error if unable to start the new thread", "function": "jthread::jthread"}, {"id": "cpp20_jthread_detach_throws_no_such_process_a3b4c5d6", "label": "cpp20_jthread_detach_throws_no_such_proc", "x": 353.6343394903448, "y": -476.8208639750511, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/11.1", "content": "jthread::detach() throws system_error with no_such_process if the thread is not valid", "function": "jthread::detach"}, {"id": "cpp20_jthread_detach_throws_invalid_argument_b7c8d9e0", "label": "cpp20_jthread_detach_throws_invalid_argu", "x": 269.79028694483236, "y": -405.8531580495926, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/11.2", "content": "jthread::detach() throws system_error with invalid_argument if the thread is not joinable", "function": "jthread::detach"}, {"id": "cpp20_jthread_get_id_returns_default_if_no_thread_f1a2b3c4", "label": "cpp20_jthread_get_id_returns_default_if_", "x": -496.36888905344813, "y": -863.2267089423442, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/12", "content": "jthread::get_id() returns a default constructed id object if *this does not represent a thread", "function": "jthread::get_id"}, {"id": "cpp20_jthread_get_id_returns_thread_id_d5e6f7a8", "label": "cpp20_jthread_get_id_returns_thread_id_d", "x": 499.09580207586123, "y": -249.26835845051318, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/12", "content": "jthread::get_id() returns this_thread::get_id() for the thread of execution represented by *this", "function": "jthread::get_id"}, {"id": "cpp20_jthread_joinable_returns_id_not_default_a1b2c3d4", "label": "cpp20_jthread_joinable_returns_id_not_de", "x": -499.17210699166844, "y": 837.305826612649, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/2", "content": "jthread::joinable() returns get_id() != id()", "function": "jthread::joinable"}, {"id": "cpp20_jthread_join_postcond_id_default_f9a0b1c2", "label": "cpp20_jthread_join_postcond_id_default_f", "x": 268.2368773966563, "y": -485.9710471574501, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/5", "content": "After jthread::join() returns, get_id() == id() is true", "function": "jthread::join"}, {"id": "cpp20_jthread_join_postcond_thread_completed_b5c6d7e8", "label": "cpp20_jthread_join_postcond_thread_compl", "x": 10.993912920595232, "y": 613.432806453797, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/5", "content": "After jthread::join() returns, the thread represented by *this has completed", "function": "jthread::join"}, {"id": "cpp20_jthread_join_throws_deadlock_detected_d3e4f5a6", "label": "cpp20_jthread_join_throws_deadlock_detec", "x": 303.91602130787504, "y": -435.58163021733975, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/7.1", "content": "jthread::join() throws system_error with resource_deadlock_would_occur if deadlock is detected", "function": "jthread::join"}, {"id": "cpp20_jthread_join_throws_self_join_b7c8d9e0", "label": "cpp20_jthread_join_throws_self_join_b7c8", "x": 249.41636838243377, "y": -373.23721984341324, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/7.1", "content": "jthread::join() throws system_error with resource_deadlock_would_occur if get_id() == this_thread::get_id()", "function": "jthread::join"}, {"id": "cpp20_jthread_join_throws_no_such_process_a1b2c3d4", "label": "cpp20_jthread_join_throws_no_such_proces", "x": 276.68044799254915, "y": -402.0794796302089, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/7.2", "content": "jthread::join() throws system_error with no_such_process if the thread is not valid", "function": "jthread::join"}, {"id": "cpp20_jthread_join_throws_invalid_argument_e5f6a7b8", "label": "cpp20_jthread_join_throws_invalid_argume", "x": 312.8289554206091, "y": -417.3965290738229, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/7.3", "content": "jthread::join() throws system_error with invalid_argument if the thread is not joinable", "function": "jthread::join"}, {"id": "cpp20_jthread_detach_postcond_id_default_c9d0e1f2", "label": "cpp20_jthread_detach_postcond_id_default", "x": -82.77489690609914, "y": -736.8259096076889, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.mem]/9", "content": "After jthread::detach() returns, get_id() == id() is true", "function": "jthread::detach"}, {"id": "cpp20_jthread_swap_friend_equivalent_member_a1b2c3d4", "label": "cpp20_jthread_swap_friend_equivalent_mem", "x": -829.261280615197, "y": 509.8904812926781, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.special]/1", "content": "Free function swap(jthread&, jthread&) is equivalent to x.swap(y)", "function": "swap"}, {"id": "cpp20_jthread_hardware_concurrency_delegates_thread_b5c6d7e8", "label": "cpp20_jthread_hardware_concurrency_deleg", "x": 897.4896723520015, "y": 423.2874295290648, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.static]/1", "content": "jthread::hardware_concurrency() returns thread::hardware_concurrency()", "function": "jthread::hardware_concurrency"}, {"id": "cpp20_jthread_get_stop_source_returns_ssource_a9b0c1d2", "label": "cpp20_jthread_get_stop_source_returns_ss", "x": 715.5265410888439, "y": -458.0623395109225, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.stop]/1", "content": "jthread::get_stop_source() returns ssource", "function": "jthread::get_stop_source"}, {"id": "cpp20_jthread_get_stop_token_returns_ssource_token_e3f4a5b6", "label": "cpp20_jthread_get_stop_token_returns_sso", "x": 837.6555854489861, "y": -453.30309604739887, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.stop]/2", "content": "jthread::get_stop_token() returns ssource.get_token()", "function": "jthread::get_stop_token"}, {"id": "cpp20_jthread_request_stop_returns_ssource_request_c7d8e9f0", "label": "cpp20_jthread_request_stop_returns_ssour", "x": 668.0150761438045, "y": 739.5565289906449, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.jthread.stop]/3", "content": "jthread::request_stop() returns ssource.request_stop()", "function": "jthread::request_stop"}, {"id": "cpp20_thread_move_assign_joinable_terminate_d5f9a4b8", "label": "cpp20_thread_move_assign_joinable_termin", "x": 302.38479287826635, "y": 942.4695623898864, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.assign]/1", "content": "If joinable() is true when thread move assignment operator is called, terminate is invoked.", "function": "std::thread::operator="}, {"id": "cpp20_thread_no_represent_after_detach_f3a8d1c6", "label": "cpp20_thread_no_represent_after_detach_f", "x": 168.56439260767374, "y": -653.1116865775376, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.class.general]/1", "content": "A thread object does not represent a thread of execution after a successful call to detach.", "function": "std::thread::detach"}, {"id": "cpp20_thread_no_represent_after_join_b9e4f7a2", "label": "cpp20_thread_no_represent_after_join_b9e", "x": -233.6650085925282, "y": 471.6723761349115, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.class.general]/1", "content": "A thread object does not represent a thread of execution after a successful call to join.", "function": "std::thread::join"}, {"id": "cpp20_thread_no_represent_after_moved_from_e7c2a9f5", "label": "cpp20_thread_no_represent_after_moved_fr", "x": -875.8981797953072, "y": 197.5766933085827, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.class.general]/1", "content": "A thread object does not represent a thread of execution after being moved from.", "function": ""}, {"id": "cpp20_thread_unique_representation_c5d9a3e8", "label": "cpp20_thread_unique_representation_c5d9a", "x": 892.2035037707258, "y": -445.20866472840754, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.class.general]/1", "content": "No two thread objects simultaneously represent the same thread of execution.", "function": ""}, {"id": "cpp20_thread_default_ctor_no_execution_b8d2f4a6", "label": "cpp20_thread_default_ctor_no_execution_b", "x": 478.20656010692403, "y": 762.7800898382674, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.constr]/1", "content": "After default construction, a thread object does not represent a thread of execution.", "function": "std::thread::thread"}, {"id": "cpp20_thread_default_ctor_postcond_id_e7a9c3b5", "label": "cpp20_thread_default_ctor_postcond_id_e7", "x": 695.5052192039107, "y": 718.2866413180393, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.constr]/2", "content": "After default construction, get_id() returns a default-constructed id.", "function": "std::thread::thread"}, {"id": "cpp20_thread_template_ctor_exception_in_constructing_thread_f4b8d1e9", "label": "cpp20_thread_template_ctor_exception_in_", "x": 45.5927541047842, "y": 969.2507297154606, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.constr]/5", "content": "Exceptions not thrown from the invocation of the copy of f in thread constructor are thrown in the constructing thread, not the new thread.", "function": "std::thread::thread"}, {"id": "cpp20_thread_template_ctor_uncaught_exception_terminate_a2c6e8f1", "label": "cpp20_thread_template_ctor_uncaught_exce", "x": 486.35616688252844, "y": -652.7808771829672, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.constr]/5", "content": "If the invocation of invoke in a new thread terminates with an uncaught exception, terminate is invoked.", "function": "std::thread::thread"}, {"id": "cpp20_thread_template_ctor_synchronizes_with_invocation_d7b4f9a3", "label": "cpp20_thread_template_ctor_synchronizes_", "x": -20.161796999457444, "y": 647.258774035446, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.constr]/6", "content": "The completion of the invocation of the thread constructor synchronizes with the beginning of the invocation of the copy of f.", "function": "std::thread::thread"}, {"id": "cpp20_thread_template_ctor_postcond_represents_new_thread_a4f8b2d7", "label": "cpp20_thread_template_ctor_postcond_repr", "x": -618.3082159497612, "y": 316.3284947282016, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.constr]/7", "content": "After successful template constructor, *this represents the newly started thread.", "function": "std::thread::thread"}, {"id": "cpp20_thread_destructor_joinable_terminate_b9e3a7c2", "label": "cpp20_thread_destructor_joinable_termina", "x": 327.10957162713845, "y": -737.276265397342, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.destr]/1", "content": "If joinable() is true when thread destructor is called, terminate is invoked.", "function": "std::thread::~thread"}, {"id": "cpp20_thread_id_not_equal_non_thread_d4c8a1f6", "label": "cpp20_thread_id_not_equal_non_thread_d4c", "x": 116.17512444422532, "y": 687.0811712674505, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.id]/1", "content": "A thread::id for a thread of execution is not equal to the thread::id of any thread object that does not represent threads of execution.", "function": ""}, {"id": "cpp20_thread_id_unique_per_thread_f7a3e9b2", "label": "cpp20_thread_id_unique_per_thread_f7a3e9", "x": 35.15953260680757, "y": -963.6255916909656, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.id]/1", "content": "Each thread of execution has an associated thread::id object that is not equal to the thread::id object of any other thread of execution.", "function": "std::thread::get_id"}, {"id": "cpp20_thread_id_equality_same_representation_a3f7b9d1", "label": "cpp20_thread_id_equality_same_representa", "x": -976.6579003534819, "y": -202.45419567400174, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.id]/2", "content": "Two thread::id objects have the same text representation if and only if they are equal.", "function": "std::operator=="}, {"id": "cpp20_thread_id_inequality_distinct_representation_c1e5f8a4", "label": "cpp20_thread_id_inequality_distinct_repr", "x": 800.052881314612, "y": -417.3974888682978, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.id]/2", "content": "Two thread::id objects have distinct text representations if and only if they are not equal.", "function": ""}, {"id": "cpp20_thread_id_reuse_terminated_e9b2c5a7", "label": "cpp20_thread_id_reuse_terminated_e9b2c5a", "x": 289.7216192934788, "y": -675.8747961565016, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.id]/3", "content": "The library may reuse the value of a thread::id of a terminated thread that can no longer be joined.", "function": ""}, {"id": "cpp20_thread_detach_no_such_process_f9b5e2a8", "label": "cpp20_thread_detach_no_such_process_f9b5", "x": -297.53143806529835, "y": 753.8727543618802, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/11.1", "content": "Calling detach() on a thread that is not valid results in no_such_process error.", "function": "std::thread::detach"}, {"id": "cpp20_thread_detach_not_joinable_invalid_argument_c3d7f1a9", "label": "cpp20_thread_detach_not_joinable_invalid", "x": 381.5139882838531, "y": -812.5872274646645, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/11.2", "content": "Calling detach() on a thread that is not joinable results in invalid_argument error.", "function": "std::thread::detach"}, {"id": "cpp20_thread_joinable_definition_b2e6a8d4", "label": "cpp20_thread_joinable_definition_b2e6a8d", "x": -40.368091399062244, "y": -974.4452560705676, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/2", "content": "A thread is joinable if and only if get_id() != id().", "function": "std::thread::joinable"}, {"id": "cpp20_thread_join_synchronizes_with_completion_e2a7c9f4", "label": "cpp20_thread_join_synchronizes_with_comp", "x": 22.314085570882888, "y": 592.0070002484223, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/4", "content": "The completion of the thread represented by *this synchronizes with the corresponding successful join() return.", "function": "std::thread::join"}, {"id": "cpp20_thread_join_postcond_not_joinable_a9f4c7e2", "label": "cpp20_thread_join_postcond_not_joinable_", "x": -757.3701793570432, "y": -395.07615202930526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/5", "content": "After successful join(), get_id() == id(), making the thread not joinable.", "function": "std::thread::join"}, {"id": "cpp20_thread_join_deadlock_self_join_c8a2f5e7", "label": "cpp20_thread_join_deadlock_self_join_c8a", "x": -141.42355316449726, "y": 887.3599587834966, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/7.1", "content": "Calling join() when get_id() == this_thread::get_id() results in resource_deadlock_would_occur error.", "function": "std::thread::join"}, {"id": "cpp20_thread_join_no_such_process_a7d3b9f2", "label": "cpp20_thread_join_no_such_process_a7d3b9", "x": 758.3422133313405, "y": -645.7712251454965, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/7.2", "content": "Calling join() on a thread that is not valid results in no_such_process error.", "function": "std::thread::join"}, {"id": "cpp20_thread_join_not_joinable_invalid_argument_e4c8a1d6", "label": "cpp20_thread_join_not_joinable_invalid_a", "x": 649.6731640518246, "y": -279.23490264088883, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/7.3", "content": "Calling join() on a thread that is not joinable results in invalid_argument error.", "function": "std::thread::join"}, {"id": "cpp20_thread_detach_postcond_not_joinable_d8b3f6a1", "label": "cpp20_thread_detach_postcond_not_joinabl", "x": -202.66599985190098, "y": 621.6822907874821, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[thread.thread.member]/9", "content": "After successful detach(), get_id() == id(), making the thread not joinable.", "function": "std::thread::detach"}, {"id": "cpp20_time_cal_day_ctor_truncation_f4a8b2c1", "label": "cpp20_time_cal_day_ctor_truncation_f4a8b", "x": 652.5569845553454, "y": 703.971039921834, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.day.members]/1", "content": "Constructing day with unsigned value d outside range [0,255] results in unspecified value held in internal storage", "function": "std::chrono::day::day"}, {"id": "cpp20_time_cal_day_ok_range_a5f7c3d1", "label": "cpp20_time_cal_day_ok_range_a5f7c3d1", "x": 279.40186913404216, "y": -531.8389507798403, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.day.members]/15", "content": "day::ok() returns true if and only if the internal value d_ is in range [1,31]", "function": "std::chrono::day::ok"}, {"id": "cpp20_time_cal_month_day_ok_constraint_e2f3a4b5", "label": "cpp20_time_cal_month_day_ok_constraint_e", "x": 607.5125342125098, "y": -493.3505310972419, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.md.members]/4", "content": "month_day::ok() returns true only if m_.ok() is true, 1d <= d_, and d_ does not exceed days in month m_ (29 for February)", "function": "std::chrono::month_day::ok"}, {"id": "cpp20_time_cal_month_day_ok_february_assumption_f3a4b5c6", "label": "cpp20_time_cal_month_day_ok_february_ass", "x": 231.0747434700588, "y": -529.4091454331832, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.md.members]/4", "content": "month_day::ok() assumes February has 29 days for validation purposes", "function": "std::chrono::month_day::ok"}, {"id": "cpp20_time_cal_month_ctor_truncation_b7c8d9e0", "label": "cpp20_time_cal_month_ctor_truncation_b7c", "x": 377.53593710639717, "y": -615.7799497936647, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.month.members]/1", "content": "Constructing month with unsigned value m outside range [0,255] results in unspecified value held in internal storage", "function": "std::chrono::month::month"}, {"id": "cpp20_time_cal_month_ok_range_c8d9e0f1", "label": "cpp20_time_cal_month_ok_range_c8d9e0f1", "x": -449.2966069691368, "y": 817.5549922335732, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.month.members]/15", "content": "month::ok() returns true if and only if the internal value m_ is in range [1,12]", "function": "std::chrono::month::ok"}, {"id": "cpp20_time_cal_month_add_euclidean_d9e0f1a2", "label": "cpp20_time_cal_month_add_euclidean_d9e0f", "x": -821.4339654872689, "y": 61.82080834779636, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.month.nonmembers]/3", "content": "month addition uses Euclidean division modulo 12, always producing result in range [1,12] even if !x.ok()", "function": "std::chrono::operator+"}, {"id": "cpp20_time_cal_month_subtract_result_range_e0f1a2b3", "label": "cpp20_time_cal_month_subtract_result_ran", "x": -388.2969111814912, "y": -841.0040259222037, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.month.nonmembers]/6", "content": "month subtraction when both operands satisfy ok() returns value m in range [months{0}, months{11}] satisfying y + m == x", "function": "std::chrono::operator-"}, {"id": "cpp20_time_cal_month_subtract_unspecified_f1a2b3c4", "label": "cpp20_time_cal_month_subtract_unspecifie", "x": -818.3060176759097, "y": -469.6008141497878, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.month.nonmembers]/6", "content": "month subtraction when !x.ok() || !y.ok() returns unspecified value", "function": "std::chrono::operator-"}, {"id": "cpp20_time_cal_weekday_ctor_seven_normalization_d5e6f7a8", "label": "cpp20_time_cal_weekday_ctor_seven_normal", "x": 757.8838401620438, "y": -379.8330985832526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wd.members]/1", "content": "Constructing weekday with unsigned value 7 normalizes to 0 (Sunday); values outside [0,255] result in unspecified storage", "function": "std::chrono::weekday::weekday"}, {"id": "cpp20_time_cal_weekday_ok_range_e6f7a8b9", "label": "cpp20_time_cal_weekday_ok_range_e6f7a8b9", "x": 943.2905541583236, "y": 159.18590162495232, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wd.members]/20", "content": "weekday::ok() returns true if and only if wd_ is in range [0,6]", "function": "std::chrono::weekday::ok"}, {"id": "cpp20_time_cal_weekday_add_euclidean_f7a8b9c0", "label": "cpp20_time_cal_weekday_add_euclidean_f7a", "x": -299.3308819835681, "y": 428.51706891714883, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wd.nonmembers]/2", "content": "weekday addition uses Euclidean division modulo 7, always producing result in range [0,6] even if !x.ok()", "function": "std::chrono::operator+"}, {"id": "cpp20_time_cal_weekday_subtract_result_range_a8b9c0d1", "label": "cpp20_time_cal_weekday_subtract_result_r", "x": 28.250939322863847, "y": 698.6272776655703, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wd.nonmembers]/5", "content": "weekday subtraction when both operands satisfy ok() returns value d in range [days{0}, days{6}] satisfying y + d == x", "function": "std::chrono::operator-"}, {"id": "cpp20_time_cal_weekday_subtract_unspecified_b9c0d1e2", "label": "cpp20_time_cal_weekday_subtract_unspecif", "x": -563.3104074280931, "y": -379.9128366806563, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wd.nonmembers]/5", "content": "weekday subtraction when !x.ok() || !y.ok() returns unspecified value", "function": "std::chrono::operator-"}, {"id": "cpp20_time_cal_weekday_indexed_ctor_unspecified_c0d1e2f3", "label": "cpp20_time_cal_weekday_indexed_ctor_unsp", "x": 622.4839182031008, "y": 735.0258299422778, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wdidx.members]/1", "content": "Constructing weekday_indexed with !wd.ok() or index not in [0,7] results in unspecified values held", "function": "std::chrono::weekday_indexed::weekday_indexed"}, {"id": "cpp20_time_cal_weekday_indexed_ok_range_d1e2f3a4", "label": "cpp20_time_cal_weekday_indexed_ok_range_", "x": 808.8083802878042, "y": -158.18737640752997, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.wdidx.members]/4", "content": "weekday_indexed::ok() returns true if and only if wd_.ok() and index_ is in range [1,5]", "function": "std::chrono::weekday_indexed::ok"}, {"id": "cpp20_time_cal_year_ctor_truncation_a2b3c4d5", "label": "cpp20_time_cal_year_ctor_truncation_a2b3", "x": 709.5114207211446, "y": -84.8437175680815, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.year.members]/1", "content": "Constructing year with int value y outside range [-32767,32767] results in unspecified value held in internal storage", "function": "std::chrono::year::year"}, {"id": "cpp20_time_cal_year_is_leap_formula_c4d5e6f7", "label": "cpp20_time_cal_year_is_leap_formula_c4d5", "x": 13.911091172188039, "y": -759.8195862205012, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.year.members]/16", "content": "year::is_leap() returns true if year is divisible by 4 and either not divisible by 100 or divisible by 400", "function": "std::chrono::year::is_leap"}, {"id": "cpp20_time_cal_year_ok_range_b3c4d5e6", "label": "cpp20_time_cal_year_ok_range_b3c4d5e6", "x": 169.3740054650276, "y": -743.6536873508047, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.year.members]/18", "content": "year::ok() returns true if and only if y_ is in range [min().y_, max().y_] which is [-32767, 32767]", "function": "std::chrono::year::ok"}, {"id": "cpp20_time_cal_ym_add_months_constraint_c6d7e8f9", "label": "cpp20_time_cal_ym_add_months_constraint_", "x": -273.7790228585271, "y": 783.9300417602726, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.ym.members]/4", "content": "year_month::operator+=(months) requires months parameter's implicit conversion to years be worse than to months", "function": "std::chrono::year_month::operator+="}, {"id": "cpp20_time_cal_ym_add_months_result_ok_d7e8f9a0", "label": "cpp20_time_cal_ym_add_months_result_ok_d", "x": -494.1188236156707, "y": -744.8784966855554, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.ym.nonmembers]/4", "content": "year_month operator+(ym, months dm) returns year_month value z such that z.ok() && z - ym == dm", "function": "std::chrono::operator+"}, {"id": "cpp20_time_cal_ym_add_months_complexity_e8f9a0b1", "label": "cpp20_time_cal_ym_add_months_complexity_", "x": -726.7664713124872, "y": 822.3736151868025, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.ym.nonmembers]/5", "content": "year_month operator+(ym, months dm) has O(1) complexity with respect to dm value", "function": "std::chrono::operator+"}, {"id": "cpp20_time_cal_ymd_sys_days_unspecified_not_ok_b5c6d7e8", "label": "cpp20_time_cal_ymd_sys_days_unspecified_", "x": 124.59999328749187, "y": -534.309687030533, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.ymd.members]/19", "content": "Converting year_month_day to sys_days when !ok() but y_.ok() && m_.ok() returns sys_days{y_/m_/1d} + (d_ - 1d); otherwise unspecified", "function": "std::chrono::year_month_day::operator sys_days"}, {"id": "cpp20_time_cal_ymd_sys_days_ok_roundtrip_a4b5c6d7", "label": "cpp20_time_cal_ymd_sys_days_ok_roundtrip", "x": 548.5689906669816, "y": 656.2690811210003, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.ymd.members]/4", "content": "For any year_month_day ymd where ymd.ok() is true, the round-trip ymd == year_month_day{sys_days{ymd}} is true", "function": "std::chrono::year_month_day::year_month_day"}, {"id": "cpp20_time_cal_ymd_add_months_constraint_f9a0b1c2", "label": "cpp20_time_cal_ymd_add_months_constraint", "x": -375.65559532734176, "y": 528.9239286058786, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.cal.ymd.members]/6", "content": "year_month_day::operator+=(months) requires months parameter's implicit conversion to years be worse than to months", "function": "std::chrono::year_month_day::operator+="}, {"id": "cpp20_time_duration_abs_constraint_3e7a9c42", "label": "cpp20_time_duration_abs_constraint_3e7a9", "x": 600.0825227138293, "y": 367.90108797072173, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.alg]/1", "content": "abs(duration<Rep, Period> d) requires numeric_limits<Rep>::is_signed is true.", "function": "std::chrono::abs"}, {"id": "cpp20_time_duration_abs_postcond_5b8c2f91", "label": "cpp20_time_duration_abs_postcond_5b8c2f9", "x": -571.0713939130886, "y": 649.2845872272776, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.alg]/2", "content": "abs(d) returns d if d >= d.zero(), otherwise returns -d.", "function": "std::chrono::abs"}, {"id": "cpp20_time_duration_cast_constraint_2d4e8c71", "label": "cpp20_time_duration_cast_constraint_2d4e", "x": 136.81967552680598, "y": -669.9355346541133, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/1", "content": "duration_cast<ToDuration> requires ToDuration is a specialization of duration.", "function": "std::chrono::duration_cast"}, {"id": "cpp20_time_duration_floor_constraint_6f3a9e82", "label": "cpp20_time_duration_floor_constraint_6f3", "x": -45.41275606287032, "y": -943.3751794924377, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/4", "content": "floor<ToDuration> requires ToDuration is a specialization of duration.", "function": "std::chrono::floor"}, {"id": "cpp20_time_duration_floor_postcond_greatest_2e8a5d93", "label": "cpp20_time_duration_floor_postcond_great", "x": -748.9170774290304, "y": 432.07600107540844, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/5", "content": "floor<ToDuration>(d) returns the greatest result t representable in ToDuration for which t <= d.", "function": "std::chrono::floor"}, {"id": "cpp20_time_duration_ceil_constraint_7a2b5d93", "label": "cpp20_time_duration_ceil_constraint_7a2b", "x": -993.9576236753842, "y": -108.51628905414049, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/6", "content": "ceil<ToDuration> requires ToDuration is a specialization of duration.", "function": "std::chrono::ceil"}, {"id": "cpp20_time_duration_ceil_postcond_least_7c3f9a42", "label": "cpp20_time_duration_ceil_postcond_least_", "x": 48.13293937071176, "y": -925.3219545211368, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/7", "content": "ceil<ToDuration>(d) returns the least result t representable in ToDuration for which t >= d.", "function": "std::chrono::ceil"}, {"id": "cpp20_time_duration_round_constraint_4c8e1f72", "label": "cpp20_time_duration_round_constraint_4c8", "x": 894.7561037500683, "y": -401.8581612618052, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/8", "content": "round<ToDuration> requires ToDuration is a specialization of duration and treat_as_floating_point_v<typename ToDuration::rep> is false.", "function": "std::chrono::round"}, {"id": "cpp20_time_duration_round_postcond_closest_9a4e7b82", "label": "cpp20_time_duration_round_postcond_close", "x": -450.92939752159964, "y": -514.7525450245145, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cast]/9", "content": "round<ToDuration>(d) returns the value of ToDuration that is closest to d. If there are two closest values, then return the value t for which t % 2 == 0.", "function": "std::chrono::round"}, {"id": "cpp20_time_duration_spaceship_constraint_9c6f4d81", "label": "cpp20_time_duration_spaceship_constraint", "x": -348.6084440345206, "y": -929.4184177521314, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.comparisons]/7", "content": "operator<=>(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs) requires three_way_comparable<typename CT::rep>.", "function": "std::chrono::operator<=>"}, {"id": "cpp20_time_duration_cons_rep2_constraint_3f7b9d21", "label": "cpp20_time_duration_cons_rep2_constraint", "x": 348.5938672677309, "y": 899.988353834533, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cons]/1", "content": "duration(const Rep2& r) requires is_convertible_v<const Rep2&, rep> is true and either treat_as_floating_point_v<rep> is true or treat_as_floating_point_v<Rep2> is false.", "function": "std::chrono::duration::duration"}, {"id": "cpp20_time_duration_cons_duration_constraint_8e4c2a61", "label": "cpp20_time_duration_cons_duration_constr", "x": -558.4993431978745, "y": 417.1920783943427, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cons]/3", "content": "duration(const duration<Rep2, Period2>& d) requires is_convertible_v<const Rep2&, rep> is true, ratio_divide<Period2::type, period> is valid, and either treat_as_floating_point_v<rep> is true or (ratio_divide<Period2, period>::den is 1 and treat_as_floating_point_v<Rep2> is false).", "function": "std::chrono::duration::duration"}, {"id": "cpp20_time_duration_cons_truncation_prevention_4f9b7e31", "label": "cpp20_time_duration_cons_truncation_prev", "x": 450.5327535347668, "y": 698.2629321706561, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.cons]/3", "content": "The duration constructor from duration<Rep2, Period2> prevents implicit truncation errors when converting between integral-based duration types by requiring ratio_divide<Period2, period>::den is 1 when both are integral.", "function": "std::chrono::duration::duration"}, {"id": "cpp20_time_duration_rep_arithmetic_6d8a3e92", "label": "cpp20_time_duration_rep_arithmetic_6d8a3", "x": -156.10544108456446, "y": -612.7142115292094, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.general]/2", "content": "Rep shall be an arithmetic type or a class emulating an arithmetic type.", "function": ""}, {"id": "cpp20_time_duration_rep_not_duration_8a3f2d91", "label": "cpp20_time_duration_rep_not_duration_8a3", "x": -397.5225117812454, "y": 554.8431126044818, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.general]/2", "content": "If duration is instantiated with a duration type as the argument for the template parameter Rep, the program is ill-formed.", "function": ""}, {"id": "cpp20_time_duration_period_must_be_ratio_7b4e1c82", "label": "cpp20_time_duration_period_must_be_ratio", "x": 601.6297963200198, "y": -575.0511795900536, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.general]/3", "content": "If Period is not a specialization of ratio, the program is ill-formed.", "function": ""}, {"id": "cpp20_time_duration_period_num_positive_9c2d5f73", "label": "cpp20_time_duration_period_num_positive_", "x": -173.85767674408368, "y": 857.6942742559573, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.general]/3", "content": "If Period::num is not positive, the program is ill-formed.", "function": ""}, {"id": "cpp20_time_duration_exceptions_from_rep_8b3d0e95", "label": "cpp20_time_duration_exceptions_from_rep_", "x": 336.8563777900317, "y": -501.4074123579479, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.general]/4", "content": "Members of duration do not throw exceptions other than those thrown by the indicated operations on their representations.", "function": ""}, {"id": "cpp20_time_duration_copy_ctor_constexpr_7a2c9f84", "label": "cpp20_time_duration_copy_ctor_constexpr_", "x": 649.8351743127753, "y": -243.1864140964651, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.general]/5", "content": "The defaulted copy constructor of duration shall be a constexpr function if and only if the required initialization of the member rep_ for copy would be constexpr-suitable.", "function": ""}, {"id": "cpp20_time_duration_from_stream_parse_failure_9c4e1f06", "label": "cpp20_time_duration_from_stream_parse_fa", "x": 240.87707666407394, "y": 541.3751957308167, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.io]/3", "content": "In from_stream, if the parse fails to decode a valid duration, is.setstate(ios_base::failbit) is called and d is not modified.", "function": "std::chrono::from_stream"}, {"id": "cpp20_time_duration_operator_us_int_postcond_5e0a7c94", "label": "cpp20_time_duration_operator_us_int_post", "x": -865.3319689031907, "y": 120.83541473758483, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/10", "content": "operator\"\"us(unsigned long long usec) returns a duration literal representing usec microseconds.", "function": "std::chrono::operator\"\"us"}, {"id": "cpp20_time_duration_operator_ns_int_postcond_6f1b8d05", "label": "cpp20_time_duration_operator_ns_int_post", "x": 428.6342260667641, "y": -677.8266178837576, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/11", "content": "operator\"\"ns(unsigned long long nsec) returns a duration literal representing nsec nanoseconds.", "function": "std::chrono::operator\"\"ns"}, {"id": "cpp20_time_duration_literal_overflow_9b5d2e83", "label": "cpp20_time_duration_literal_overflow_9b5", "x": 696.4459455410223, "y": 214.82430660328978, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/3", "content": "If any duration literal suffix (h, min, s, ms, us, ns) is applied to an integer-literal and the resulting chrono::duration value cannot be represented in the result type because of overflow, the program is ill-formed.", "function": ""}, {"id": "cpp20_time_duration_operator_h_int_postcond_1a9c6e82", "label": "cpp20_time_duration_operator_h_int_postc", "x": 673.2823707875829, "y": -721.6611443811561, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/5", "content": "operator\"\"h(unsigned long long hours) returns a duration literal representing hours hours.", "function": "std::chrono::operator\"\"h"}, {"id": "cpp20_time_duration_operator_min_int_postcond_2b7d4f91", "label": "cpp20_time_duration_operator_min_int_pos", "x": -609.4880930889728, "y": 274.05183771174086, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/6", "content": "operator\"\"min(unsigned long long minutes) returns a duration literal representing minutes minutes.", "function": "std::chrono::operator\"\"min"}, {"id": "cpp20_time_duration_operator_s_int_postcond_3c8e5a72", "label": "cpp20_time_duration_operator_s_int_postc", "x": -484.2239311799943, "y": 516.1052832234997, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/7", "content": "operator\"\"s(unsigned long long sec) returns a duration literal representing sec seconds.", "function": "std::chrono::operator\"\"s"}, {"id": "cpp20_time_duration_operator_ms_int_postcond_4d9f6b83", "label": "cpp20_time_duration_operator_ms_int_post", "x": 445.75360971209994, "y": -780.1854694726823, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.literals]/9", "content": "operator\"\"ms(unsigned long long msec) returns a duration literal representing msec milliseconds.", "function": "std::chrono::operator\"\"ms"}, {"id": "cpp20_time_duration_operator_mod_rep2_constraint_8a5e2c73", "label": "cpp20_time_duration_operator_mod_rep2_co", "x": 432.432956909241, "y": 316.5410101865813, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.nonmember]/12", "content": "operator%(const duration<Rep1, Period>& d, const Rep2& s) requires is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true and Rep2 is not a specialization of duration.", "function": "std::chrono::operator%"}, {"id": "cpp20_time_duration_operator_mult_rep2_constraint_5d8f3a91", "label": "cpp20_time_duration_operator_mult_rep2_c", "x": -189.63975030567414, "y": 920.1758511134376, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.nonmember]/4", "content": "operator*(const duration<Rep1, Period>& d, const Rep2& s) requires is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true.", "function": "std::chrono::operator*"}, {"id": "cpp20_time_duration_operator_mult_rep1_constraint_6c2e9f84", "label": "cpp20_time_duration_operator_mult_rep1_c", "x": 708.6178388600091, "y": 369.18397298205497, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.nonmember]/6", "content": "operator*(const Rep1& s, const duration<Rep2, Period>& d) requires is_convertible_v<const Rep1&, common_type_t<Rep1, Rep2>> is true.", "function": "std::chrono::operator*"}, {"id": "cpp20_time_duration_operator_div_rep2_constraint_7b4d1a92", "label": "cpp20_time_duration_operator_div_rep2_co", "x": 625.276620663808, "y": -130.19742205649894, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.nonmember]/8", "content": "operator/(const duration<Rep1, Period>& d, const Rep2& s) requires is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true and Rep2 is not a specialization of duration.", "function": "std::chrono::operator/"}, {"id": "cpp20_time_duration_count_returns_rep_5a9f7b32", "label": "cpp20_time_duration_count_returns_rep_5a", "x": 821.935942512473, "y": 336.4492210983704, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.observer]/1", "content": "count() returns the internal representation rep_.", "function": "std::chrono::duration::count"}, {"id": "cpp20_time_duration_zero_postcond_3d7f9a21", "label": "cpp20_time_duration_zero_postcond_3d7f9a", "x": 418.50068848008954, "y": 731.69448527256, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.special]/1", "content": "duration::zero() returns duration(duration_values<rep>::zero()).", "function": "std::chrono::duration::zero"}, {"id": "cpp20_time_duration_min_postcond_6e4a8c72", "label": "cpp20_time_duration_min_postcond_6e4a8c7", "x": -439.580346880291, "y": 644.2076164767537, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.special]/2", "content": "duration::min() returns duration(duration_values<rep>::min()).", "function": "std::chrono::duration::min"}, {"id": "cpp20_time_duration_max_postcond_8f2b5d93", "label": "cpp20_time_duration_max_postcond_8f2b5d9", "x": -652.1860710451472, "y": -340.1662466130109, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.duration.special]/3", "content": "duration::max() returns duration(duration_values<rep>::max()).", "function": "std::chrono::duration::max"}, {"id": "cpp20_time_point_arithmetic_pre_increment_5a9c3e7d", "label": "cpp20_time_point_arithmetic_pre_incremen", "x": -229.6646268447772, "y": 954.6848338876479, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.arithmetic]/1-2", "content": "Pre-increment operator++ increments d_ and returns *this.", "function": "std::chrono::time_point::operator++"}, {"id": "cpp20_time_point_arithmetic_post_increment_7f1d8b2c", "label": "cpp20_time_point_arithmetic_post_increme", "x": 784.3744849505571, "y": 328.2916883475904, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.arithmetic]/3", "content": "Post-increment operator++(int) returns time_point{d_++}.", "function": "std::chrono::time_point::operator++"}, {"id": "cpp20_time_point_arithmetic_pre_decrement_2e6a9f4b", "label": "cpp20_time_point_arithmetic_pre_decremen", "x": 608.272162232139, "y": 190.04416677637312, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.arithmetic]/4-5", "content": "Pre-decrement operator-- decrements d_ and returns *this.", "function": "std::chrono::time_point::operator--"}, {"id": "cpp20_time_point_arithmetic_post_decrement_8c3d5a1f", "label": "cpp20_time_point_arithmetic_post_decreme", "x": 928.9699171268649, "y": 8.765294575221576, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.arithmetic]/6", "content": "Post-decrement operator--(int) returns time_point{d_--}.", "function": "std::chrono::time_point::operator--"}, {"id": "cpp20_time_point_arithmetic_plus_assign_4b8e2d9a", "label": "cpp20_time_point_arithmetic_plus_assign_", "x": -216.2362203118075, "y": -745.8205516328712, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.arithmetic]/7-8", "content": "operator+=(d) adds d to d_ and returns *this.", "function": "std::chrono::time_point::operator+="}, {"id": "cpp20_time_point_arithmetic_minus_assign_9f3c7e1d", "label": "cpp20_time_point_arithmetic_minus_assign", "x": 570.2654933271091, "y": 483.5612170596278, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.arithmetic]/9-10", "content": "operator-=(d) subtracts d from d_ and returns *this.", "function": "std::chrono::time_point::operator-="}, {"id": "cpp20_time_point_cast_constraint_duration_specialization_8a4f2e6c", "label": "cpp20_time_point_cast_constraint_duratio", "x": -146.23852821232737, "y": -968.8307271994155, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/1", "content": "time_point_cast requires ToDuration to be a specialization of duration.", "function": "std::chrono::time_point_cast"}, {"id": "cpp20_time_point_cast_effect_duration_cast_3c9e5a1d", "label": "cpp20_time_point_cast_effect_duration_ca", "x": 491.44568685160624, "y": -851.4310980892666, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/2", "content": "time_point_cast returns time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch())).", "function": "std::chrono::time_point_cast"}, {"id": "cpp20_time_point_floor_constraint_duration_specialization_7e2a9f4b", "label": "cpp20_time_point_floor_constraint_durati", "x": 291.16232089106717, "y": 915.1116461518793, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/3", "content": "floor requires ToDuration to be a specialization of duration.", "function": "std::chrono::floor"}, {"id": "cpp20_time_point_floor_effect_5d8c1f3a", "label": "cpp20_time_point_floor_effect_5d8c1f3a", "x": -87.9855945411399, "y": -713.986945408163, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/4", "content": "floor returns time_point<Clock, ToDuration>(floor<ToDuration>(tp.time_since_epoch())).", "function": "std::chrono::floor"}, {"id": "cpp20_time_point_ceil_constraint_duration_specialization_9b3e6d2f", "label": "cpp20_time_point_ceil_constraint_duratio", "x": 388.35951861056583, "y": 659.3131339949219, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/5", "content": "ceil requires ToDuration to be a specialization of duration.", "function": "std::chrono::ceil"}, {"id": "cpp20_time_point_ceil_effect_4a7e2c8d", "label": "cpp20_time_point_ceil_effect_4a7e2c8d", "x": 81.23059932950451, "y": 923.9938154715156, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/6", "content": "ceil returns time_point<Clock, ToDuration>(ceil<ToDuration>(tp.time_since_epoch())).", "function": "std::chrono::ceil"}, {"id": "cpp20_time_point_round_constraint_duration_specialization_6f1d9a3e", "label": "cpp20_time_point_round_constraint_durati", "x": -935.2388018283639, "y": 54.41923419965299, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/7", "content": "round requires ToDuration to be a specialization of duration.", "function": "std::chrono::round"}, {"id": "cpp20_time_point_round_constraint_integral_rep_2c5e8f4a", "label": "cpp20_time_point_round_constraint_integr", "x": 387.4447610362747, "y": 739.7280991764324, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/7", "content": "round requires treat_as_floating_point_v<typename ToDuration::rep> to be false.", "function": "std::chrono::round"}, {"id": "cpp20_time_point_round_effect_8d3a7f1c", "label": "cpp20_time_point_round_effect_8d3a7f1c", "x": -603.9997185229395, "y": 576.0940438524963, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cast]/8", "content": "round returns time_point<Clock, ToDuration>(round<ToDuration>(tp.time_since_epoch())).", "function": "std::chrono::round"}, {"id": "cpp20_time_point_comparisons_equal_9a3e7c1f", "label": "cpp20_time_point_comparisons_equal_9a3e7", "x": 304.29368712083027, "y": -476.9583050894316, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.comparisons]/1", "content": "operator==(time_point, time_point) returns lhs.time_since_epoch() == rhs.time_since_epoch().", "function": "std::chrono::operator=="}, {"id": "cpp20_time_point_comparisons_less_4e8b2d5a", "label": "cpp20_time_point_comparisons_less_4e8b2d", "x": -635.1345841952839, "y": 612.8559703695546, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.comparisons]/2", "content": "operator<(time_point, time_point) returns lhs.time_since_epoch() < rhs.time_since_epoch().", "function": "std::chrono::operator<"}, {"id": "cpp20_time_point_comparisons_greater_7c1f9a3e", "label": "cpp20_time_point_comparisons_greater_7c1", "x": -692.0376380795498, "y": -389.0838552680405, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.comparisons]/3", "content": "operator>(time_point, time_point) returns rhs < lhs.", "function": "std::chrono::operator>"}, {"id": "cpp20_time_point_comparisons_less_equal_2d5a8e4b", "label": "cpp20_time_point_comparisons_less_equal_", "x": -352.93463464197316, "y": 779.147067861728, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.comparisons]/4", "content": "operator<=(time_point, time_point) returns !(rhs < lhs).", "function": "std::chrono::operator<="}, {"id": "cpp20_time_point_comparisons_greater_equal_6f9c3a7d", "label": "cpp20_time_point_comparisons_greater_equ", "x": 370.8064710061755, "y": 616.4355089755622, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.comparisons]/5", "content": "operator>=(time_point, time_point) returns !(lhs < rhs).", "function": "std::chrono::operator>="}, {"id": "cpp20_time_point_comparisons_three_way_1e7d4b9f", "label": "cpp20_time_point_comparisons_three_way_1", "x": -634.0835462396095, "y": 266.3928120629195, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.comparisons]/6", "content": "operator<=>(time_point, time_point) returns lhs.time_since_epoch() <=> rhs.time_since_epoch() when Duration2 is three_way_comparable_with Duration1.", "function": "std::chrono::operator<=>"}, {"id": "cpp20_time_point_cons_default_effect_epoch_4b9d2f1a", "label": "cpp20_time_point_cons_default_effect_epo", "x": 123.76707034176857, "y": 765.2680716454771, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cons]/1", "content": "Default constructor initializes d_ with duration::zero(), representing the epoch.", "function": "std::chrono::time_point::time_point"}, {"id": "cpp20_time_point_cons_duration_effect_epoch_plus_d_8c4e7a1b", "label": "cpp20_time_point_cons_duration_effect_ep", "x": 552.206204641381, "y": -800.8586265876993, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cons]/2", "content": "Explicit constructor from duration d initializes d_ with d, representing epoch + d.", "function": "std::chrono::time_point::time_point"}, {"id": "cpp20_time_point_cons_conversion_constraint_9f2a5d3c", "label": "cpp20_time_point_cons_conversion_constra", "x": 254.95065907811738, "y": -925.1013098027099, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cons]/3", "content": "Converting constructor from time_point<clock, Duration2> requires is_convertible_v<Duration2, duration> to be true.", "function": "std::chrono::time_point::time_point"}, {"id": "cpp20_time_point_cons_conversion_effect_1e8b4c9f", "label": "cpp20_time_point_cons_conversion_effect_", "x": 158.12285070679332, "y": -621.3249578303784, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.cons]/4", "content": "Converting constructor initializes d_ with t.time_since_epoch().", "function": "std::chrono::time_point::time_point"}, {"id": "cpp20_time_point_general_duration_specialization_7a3f8c2e", "label": "cpp20_time_point_general_duration_specia", "x": -517.5351492649993, "y": -413.4978932763854, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.general]/1", "content": "If Duration template parameter is not a specialization of std::chrono::duration, the program is ill-formed.", "function": ""}, {"id": "cpp20_time_point_nonmember_add_duration_3e8d1c5f", "label": "cpp20_time_point_nonmember_add_duration_", "x": 366.22884889451194, "y": -516.9807227522267, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.nonmember]/1", "content": "operator+(time_point, duration) returns CT(lhs.time_since_epoch() + rhs) where CT is time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>.", "function": "std::chrono::operator+"}, {"id": "cpp20_time_point_nonmember_add_commutative_7b4f2a9e", "label": "cpp20_time_point_nonmember_add_commutati", "x": 611.3779972156893, "y": -266.00032292252996, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.nonmember]/2", "content": "operator+(duration, time_point) returns rhs + lhs, providing commutative addition.", "function": "std::chrono::operator+"}, {"id": "cpp20_time_point_nonmember_subtract_duration_5c9a3f7d", "label": "cpp20_time_point_nonmember_subtract_dura", "x": -825.0119682828849, "y": 422.7253982619222, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.nonmember]/3", "content": "operator-(time_point, duration) returns CT(lhs.time_since_epoch() - rhs) where CT is time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>.", "function": "std::chrono::operator-"}, {"id": "cpp20_time_point_nonmember_subtract_time_points_2f6d8e1a", "label": "cpp20_time_point_nonmember_subtract_time", "x": -620.0706628957447, "y": -190.77555145192042, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.nonmember]/4", "content": "operator-(time_point, time_point) returns lhs.time_since_epoch() - rhs.time_since_epoch() as common_type_t<Duration1, Duration2>.", "function": "std::chrono::operator-"}, {"id": "cpp20_time_point_observer_time_since_epoch_3d7f2a8e", "label": "cpp20_time_point_observer_time_since_epo", "x": 484.46481939417885, "y": -421.33868575026526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.observer]/1", "content": "time_since_epoch() returns d_, the duration since epoch.", "function": "std::chrono::time_point::time_since_epoch"}, {"id": "cpp20_time_point_special_min_6d2f9a5c", "label": "cpp20_time_point_special_min_6d2f9a5c", "x": -897.6369585329755, "y": -193.2044992894597, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.special]/1", "content": "min() returns time_point(duration::min()), representing the minimum representable time_point.", "function": "std::chrono::time_point::min"}, {"id": "cpp20_time_point_special_max_1a7e4b8f", "label": "cpp20_time_point_special_max_1a7e4b8f", "x": 906.6941265724319, "y": 241.49929344561463, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[time.point.special]/2", "content": "max() returns time_point(duration::max()), representing the maximum representable time_point.", "function": "std::chrono::time_point::max"}, {"id": "cpp20_transform_exclusive_scan_mandate_e7f2b0c5", "label": "cpp20_transform_exclusive_scan_mandate_e", "x": 459.09230140575073, "y": 431.3133027370093, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.exclusive.scan]/1", "content": "All of binary_op(init, init), binary_op(init, unary_op(*first)), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T.", "function": "std::transform_exclusive_scan"}, {"id": "cpp20_transform_exclusive_scan_precond_movable_f8a3c1d6", "label": "cpp20_transform_exclusive_scan_precond_m", "x": -720.5236257810136, "y": -166.1387977397109, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.exclusive.scan]/2", "content": "Type T must meet Cpp17MoveConstructible requirements for std::transform_exclusive_scan.", "function": "std::transform_exclusive_scan"}, {"id": "cpp20_transform_exclusive_scan_precond_no_invalidate_a9b4d2e7", "label": "cpp20_transform_exclusive_scan_precond_n", "x": 412.71887945581165, "y": -790.4722552490259, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.exclusive.scan]/2", "content": "Neither unary_op nor binary_op may invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)].", "function": "std::transform_exclusive_scan"}, {"id": "cpp20_transform_inclusive_scan_mandate_b0c5e3f8", "label": "cpp20_transform_inclusive_scan_mandate_b", "x": -522.8073015901516, "y": -511.05426297617834, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.inclusive.scan]/2", "content": "If init is provided, all of binary_op(init, init), binary_op(init, unary_op(*first)), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T; otherwise, binary_op(unary_op(*first), unary_op(*first)) must be convertible to U.", "function": "std::transform_inclusive_scan"}, {"id": "cpp20_transform_inclusive_scan_precond_movable_c1d6f4a9", "label": "cpp20_transform_inclusive_scan_precond_m", "x": -95.88512098852351, "y": 969.1721490364105, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.inclusive.scan]/3", "content": "If init is provided, T must meet Cpp17MoveConstructible requirements; otherwise, U must meet Cpp17MoveConstructible requirements.", "function": "std::transform_inclusive_scan"}, {"id": "cpp20_transform_inclusive_scan_precond_no_invalidate_d2e7a5b0", "label": "cpp20_transform_inclusive_scan_precond_n", "x": -864.7199346275806, "y": 89.48614173639041, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.inclusive.scan]/3", "content": "Neither unary_op nor binary_op may invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)].", "function": "std::transform_inclusive_scan"}, {"id": "cpp20_transform_reduce_mandate_convertible_b2c7e5f0", "label": "cpp20_transform_reduce_mandate_convertib", "x": -439.0691190736172, "y": 853.2757860028227, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.reduce]/3", "content": "All of binary_op1(init, init), binary_op1(init, binary_op2(*first1, *first2)), binary_op1(binary_op2(*first1, *first2), init), and binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2)) must be convertible to T.", "function": "std::transform_reduce"}, {"id": "cpp20_transform_reduce_precond_no_invalidate_d4e9a7b2", "label": "cpp20_transform_reduce_precond_no_invali", "x": -797.3261284981653, "y": -142.94852486452487, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.reduce]/4", "content": "Neither binary_op1 nor binary_op2 may invalidate subranges or modify elements in the ranges [first1, last1] and [first2, first2+(last1-first1)].", "function": "std::transform_reduce"}, {"id": "cpp20_transform_reduce_precond_t_movable_c3d8f6a1", "label": "cpp20_transform_reduce_precond_t_movable", "x": 539.6795008065013, "y": 449.2762673233435, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.reduce]/4", "content": "Type T must meet Cpp17MoveConstructible requirements for std::transform_reduce.", "function": "std::transform_reduce"}, {"id": "cpp20_transform_reduce_unary_mandate_e5f0b8c3", "label": "cpp20_transform_reduce_unary_mandate_e5f", "x": -230.9258411489544, "y": -552.9985371201192, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.reduce]/7", "content": "All of binary_op(init, init), binary_op(init, unary_op(*first)), binary_op(unary_op(*first), init), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T.", "function": "std::transform_reduce"}, {"id": "cpp20_transform_reduce_unary_precond_no_invalidate_f6a1c9d4", "label": "cpp20_transform_reduce_unary_precond_no_", "x": -264.91473389579403, "y": -651.8626082914374, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[transform.reduce]/8", "content": "Neither unary_op nor binary_op may invalidate subranges or modify elements in the range [first, last].", "function": "std::transform_reduce"}, {"id": "cpp20_hash_constraint_type_enabled_a9b0c1d2", "label": "cpp20_hash_constraint_type_enabled_a9b0c", "x": -695.6287066611874, "y": -91.53279241784342, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[unord.hash]", "content": "std::hash is enabled only for specific types; for types where hash is not explicitly enabled, the specialization is disabled.", "function": "std::hash"}, {"id": "cpp20_get_deleter_validity_lifetime_9a0b1c2d", "label": "cpp20_get_deleter_validity_lifetime_9a0b", "x": 13.97872254306099, "y": -106.43449582690954, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.getdeleter]/1", "content": "The pointer returned by get_deleter remains valid as long as there exists a shared_ptr instance that owns the deleter.", "function": "std::get_deleter"}, {"id": "cpp20_static_pointer_cast_mandates_9e0f1a2b", "label": "cpp20_static_pointer_cast_mandates_9e0f1", "x": -7.218681466900439, "y": -113.79661970548308, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.cast]/1", "content": "static_pointer_cast mandates: The expression static_cast<T*>((U*)nullptr) must be well-formed.", "function": "std::static_pointer_cast"}, {"id": "cpp20_reinterpret_pointer_cast_mandates_1e2f3a4b", "label": "cpp20_reinterpret_pointer_cast_mandates_", "x": -12.285204975748844, "y": -128.41480122812902, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.cast]/11", "content": "reinterpret_pointer_cast mandates: The expression reinterpret_cast<T*>((U*)nullptr) must be well-formed.", "function": "std::reinterpret_pointer_cast"}, {"id": "cpp20_shared_ptr_cast_double_delete_ub_5c6d7e8f", "label": "cpp20_shared_ptr_cast_double_delete_ub_5", "x": -600.721971466233, "y": 731.8093586319352, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.cast]/3", "content": "Creating shared_ptr via direct cast like shared_ptr<T>(static_cast<T*>(r.get())) can result in undefined behavior by attempting to delete the same object twice.", "function": ""}, {"id": "cpp20_dynamic_pointer_cast_mandates_3c4d5e6f", "label": "cpp20_dynamic_pointer_cast_mandates_3c4d", "x": 4.074431848630206, "y": -129.2233296965181, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.cast]/4", "content": "dynamic_pointer_cast mandates: dynamic_cast<T*>((U*)nullptr) and dynamic_cast<typename shared_ptr<T>::element_type*>(r.get()) must be well-formed.", "function": "std::dynamic_pointer_cast"}, {"id": "cpp20_dynamic_pointer_cast_precondition_wellformed_5a6b7c8d", "label": "cpp20_dynamic_pointer_cast_precondition_", "x": 168.7267780461072, "y": -86.48861464691402, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.cast]/5", "content": "dynamic_pointer_cast precondition: the expression dynamic_cast<typename shared_ptr<T>::element_type*>(r.get()) must have well-defined behavior.", "function": "std::dynamic_pointer_cast"}, {"id": "cpp20_const_pointer_cast_mandates_7a8b9c0d", "label": "cpp20_const_pointer_cast_mandates_7a8b9c", "x": -45.3207566663867, "y": -72.29667787036544, "size": 7.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.cast]/8", "content": "const_pointer_cast mandates: The expression const_cast<T*>((U*)nullptr) must be well-formed.", "function": "std::const_pointer_cast"}, {"id": "cpp20_shared_ptr_enable_shared_from_this_concurrency_3a4b5c6d", "label": "cpp20_shared_ptr_enable_shared_from_this", "x": -291.4992991886857, "y": 221.1319795495752, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/1", "content": "The assignment to the weak_this member when enabling shared_from_this is not atomic and conflicts with any potentially concurrent access to the same object.", "function": ""}, {"id": "cpp20_shared_ptr_ctor_allocator_precondition_3c4d5e6f", "label": "cpp20_shared_ptr_ctor_allocator_precondi", "x": -66.89284139164585, "y": -13.317052112948438, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/10", "content": "Allocator A must meet the Cpp17Allocator requirements when constructing shared_ptr with allocator.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_deleter_precondition_move_5a6b7c8d", "label": "cpp20_shared_ptr_ctor_deleter_preconditi", "x": -44.6671370496519, "y": -44.38561703726855, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/10", "content": "Construction of d and a deleter of type D initialized with std::move(d) must not throw exceptions.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_deleter_precondition_wellformed_9e0f1a2b", "label": "cpp20_shared_ptr_ctor_deleter_preconditi", "x": -207.48947147099247, "y": -69.14948459813911, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/10", "content": "The expression d(p) must have well-defined behavior and not throw exceptions.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_aliasing_ctor_dangling_pointer_3e4f5a6b", "label": "cpp20_shared_ptr_aliasing_ctor_dangling_", "x": -0.6098197798544147, "y": -57.56786969703415, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/16", "content": "Using the aliasing constructor shared_ptr(r, p) leads to a dangling pointer unless p remains valid at least until the ownership group of r is destroyed.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_compatible_pointer_constraint_9c0d1e2f", "label": "cpp20_shared_ptr_ctor_compatible_pointer", "x": 71.62478696295514, "y": -26.27706468265853, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/18", "content": "Copy and move constructors from shared_ptr<Y> require Y* to be compatible with T*.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_weak_ptr_compatible_constraint_3a4b5c6d", "label": "cpp20_shared_ptr_ctor_weak_ptr_compatibl", "x": 53.53710074179895, "y": -42.7385110536769, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/24", "content": "Constructing shared_ptr from weak_ptr<Y> requires Y* to be compatible with T*.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_weak_ptr_throws_bad_weak_ptr_7a8b9c0d", "label": "cpp20_shared_ptr_ctor_weak_ptr_throws_ba", "x": 53.55597909568206, "y": -51.14476736843727, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/27", "content": "Constructing shared_ptr from expired weak_ptr throws bad_weak_ptr.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_unique_ptr_constraints_7e8f9a0b", "label": "cpp20_shared_ptr_ctor_unique_ptr_constra", "x": 6.312746973729552, "y": -39.30393806585537, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/28", "content": "Constructing shared_ptr from unique_ptr<Y, D> requires Y* compatible with T* and unique_ptr<Y, D>::pointer convertible to element_type*.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_constraints_array_type_7c8d9e0f", "label": "cpp20_shared_ptr_ctor_constraints_array_", "x": -179.41406317581462, "y": -54.9035594181983, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/3", "content": "When T is an array type, shared_ptr(Y* p) requires delete[] p to be well-formed and proper pointer convertibility.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_constraints_non_array_type_1a2b3c4d", "label": "cpp20_shared_ptr_ctor_constraints_non_ar", "x": -150.85614385420547, "y": -41.56157754366382, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/3", "content": "When T is not an array type, shared_ptr(Y* p) requires delete p to be well-formed and Y* convertible to T*.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_pointer_mandates_complete_7e8f9a0b", "label": "cpp20_shared_ptr_ctor_pointer_mandates_c", "x": -60.90303816122518, "y": -15.720646331937473, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/4", "content": "The constructor shared_ptr(Y* p) mandates that Y is a complete type.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_pointer_precondition_delete_c1d2e3f4", "label": "cpp20_shared_ptr_ctor_pointer_preconditi", "x": -173.94296242786766, "y": -28.926198308463906, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/5", "content": "The expression delete[] p (when T is array type) or delete p (when T is not array type) must have well-defined behavior and not throw exceptions.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_shared_ptr_ctor_deleter_constraints_5e6f7a8b", "label": "cpp20_shared_ptr_ctor_deleter_constraint", "x": -78.23485522531524, "y": -20.254381935904377, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.const]/9", "content": "shared_ptr deleter constructors require is_move_constructible_v<D> to be true and d(p) to be well-formed.", "function": "std::shared_ptr::shared_ptr"}, {"id": "cpp20_make_shared_unbounded_array_constraint_5a6b7c8d", "label": "cpp20_make_shared_unbounded_array_constr", "x": -198.782128774476, "y": -37.21858528643661, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/12", "content": "make_shared<T>(size_t N) requires T is an array of unknown bound (U[]).", "function": "std::make_shared"}, {"id": "cpp20_make_shared_bounded_array_constraint_9e0f1a2b", "label": "cpp20_make_shared_bounded_array_constrai", "x": -177.43712938897943, "y": -72.91121345378421, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/15", "content": "make_shared<T>() with no size argument requires T is an array of known bound (U[N]).", "function": "std::make_shared"}, {"id": "cpp20_make_shared_allocator_precondition_9c0d1e2f", "label": "cpp20_make_shared_allocator_precondition", "x": 162.4592321699022, "y": -55.722584546439336, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/2", "content": "Allocator A must meet Cpp17Allocator requirements for allocate_shared and allocate_shared_for_overwrite.", "function": "std::allocate_shared"}, {"id": "cpp20_make_shared_for_overwrite_constraint_3c4d5e6f", "label": "cpp20_make_shared_for_overwrite_constrai", "x": -207.95350903682998, "y": -16.20138133829426, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/24", "content": "make_shared_for_overwrite<T>() requires T is not an array of unknown bound.", "function": "std::make_shared_for_overwrite"}, {"id": "cpp20_make_shared_for_overwrite_unbounded_constraint_7a8b9c0d", "label": "cpp20_make_shared_for_overwrite_unbounde", "x": -198.47399604045313, "y": -58.106116182800534, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/27", "content": "make_shared_for_overwrite<T>(size_t N) requires T is an array of unknown bound.", "function": "std::make_shared_for_overwrite"}, {"id": "cpp20_make_shared_exception_safety_3a4b5c6d", "label": "cpp20_make_shared_exception_safety_3a4b5", "x": 26.5498198182529, "y": 7.800841666963262, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/3", "content": "If an exception is thrown during make_shared/allocate_shared, the functions have no effect.", "function": "std::make_shared"}, {"id": "cpp20_make_shared_postcondition_non_null_7e8f9a0b", "label": "cpp20_make_shared_postcondition_non_null", "x": 0.4564012444806122, "y": -120.69729953894102, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/4", "content": "make_shared and allocate_shared postcondition: r.get() != nullptr && r.use_count() == 1.", "function": "std::make_shared"}, {"id": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "label": "cpp20_make_shared_array_reverse_destruct", "x": -75.33604886550431, "y": -26.242234900445908, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/7.10", "content": "When lifetime ends or initialization throws, initialized array elements are destroyed in reverse order of their original construction.", "function": "std::make_shared"}, {"id": "cpp20_make_shared_non_array_constraint_1c2d3e4f", "label": "cpp20_make_shared_non_array_constraint_1", "x": -43.059713820584726, "y": -60.90131235613111, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.create]/8", "content": "make_shared<T>(Args&&...) and allocate_shared<T>(a, Args&&...) require T is not an array type.", "function": "std::make_shared"}, {"id": "cpp20_shared_ptr_data_race_member_access_a1b2c3d4", "label": "cpp20_shared_ptr_data_race_member_access", "x": 334.77988856206764, "y": -823.2798621813096, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.general]/5", "content": "For purposes of determining data races, shared_ptr member functions access and modify only the shared_ptr and weak_ptr objects themselves, not objects they refer to.", "function": ""}, {"id": "cpp20_shared_ptr_use_count_no_data_race_reflect_e5f6a7b8", "label": "cpp20_shared_ptr_use_count_no_data_race_", "x": -502.4936036393656, "y": 700.4785865759483, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.general]/5", "content": "Changes in use_count() do not reflect modifications that can introduce data races.", "function": ""}, {"id": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "label": "cpp20_shared_ptr_compatible_pointer_defi", "x": -102.12780193059471, "y": -53.722316318223335, "size": 18, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.general]/6", "content": "A pointer type Y* is compatible with a pointer type T* when either Y* is convertible to T* or Y is U[N] and T is cv U[].", "function": ""}, {"id": "cpp20_shared_ptr_use_count_no_synchronization_1a2b3c4d", "label": "cpp20_shared_ptr_use_count_no_synchroniz", "x": -315.92615478979315, "y": 210.29554449311024, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/13", "content": "use_count() has no synchronization, meaning multiple threads can affect the result and it is approximate.", "function": "std::shared_ptr::use_count"}, {"id": "cpp20_shared_ptr_use_count_one_no_completion_guarantee_5e6f7a8b", "label": "cpp20_shared_ptr_use_count_one_no_comple", "x": -444.7214550583427, "y": -565.0568030048526, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/17", "content": "use_count() == 1 does not imply that accesses through a previously destroyed shared_ptr have completed.", "function": "std::shared_ptr::use_count"}, {"id": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "label": "cpp20_shared_ptr_operator_deref_precondi", "x": -32.790182490935265, "y": -95.99082309600055, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/2", "content": "Calling operator* on shared_ptr requires get() != nullptr.", "function": "std::shared_ptr::operator*"}, {"id": "cpp20_shared_ptr_operator_arrow_precondition_5c6d7e8f", "label": "cpp20_shared_ptr_operator_arrow_precondi", "x": -108.72422483093766, "y": -95.48502717800362, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/5", "content": "Calling operator-> on shared_ptr requires get() != nullptr.", "function": "std::shared_ptr::operator->"}, {"id": "cpp20_shared_ptr_operator_subscript_precondition_null_9a0b1c2d", "label": "cpp20_shared_ptr_operator_subscript_prec", "x": 2.337522719969152, "y": -126.4434787153673, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/8", "content": "Calling operator[] on shared_ptr requires get() != nullptr.", "function": "std::shared_ptr::operator[]"}, {"id": "cpp20_shared_ptr_operator_subscript_hardened_bounds_7c8d9e0f", "label": "cpp20_shared_ptr_operator_subscript_hard", "x": 69.59075673645282, "y": -141.5328444198085, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/9", "content": "Hardened precondition: When T is U[N], operator[] index i must be < N.", "function": "std::shared_ptr::operator[]"}, {"id": "cpp20_shared_ptr_operator_subscript_hardened_nonneg_3e4f5a6b", "label": "cpp20_shared_ptr_operator_subscript_hard", "x": 69.13711074565408, "y": -126.04205944976339, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.shared.obs]/9", "content": "Hardened precondition: operator[] index i must be >= 0.", "function": "std::shared_ptr::operator[]"}, {"id": "cpp20_weak_ptr_assignment_copy_effect_b9d3f7e2", "label": "cpp20_weak_ptr_assignment_copy_effect_b9", "x": 86.12696919888404, "y": -145.52274282850343, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.assign]/1", "content": "Copy assignment operators are equivalent to weak_ptr(r).swap(*this).", "function": "std::weak_ptr::operator="}, {"id": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3", "label": "cpp20_weak_ptr_assignment_move_effect_c0", "x": 74.30010350290888, "y": -85.35005160007773, "size": 7.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.assign]/4", "content": "Move assignment operators are equivalent to weak_ptr(std::move(r)).swap(*this).", "function": "std::weak_ptr::operator="}, {"id": "cpp20_weak_ptr_default_ctor_empty_postcondition_c8e5a2d9", "label": "cpp20_weak_ptr_default_ctor_empty_postco", "x": -59.033192480099885, "y": -12.238090918001637, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.const]/1-2", "content": "Default constructed weak_ptr is empty and stores a null pointer value with use_count() == 0.", "function": "std::weak_ptr::weak_ptr"}, {"id": "cpp20_weak_ptr_copy_ctor_constraint_compatible_d3f7b1a6", "label": "cpp20_weak_ptr_copy_ctor_constraint_comp", "x": 71.51763297498412, "y": -37.914012219523364, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.const]/3", "content": "For weak_ptr copy constructors from weak_ptr<Y> or shared_ptr<Y>, Y* must be compatible with T*.", "function": "std::weak_ptr::weak_ptr"}, {"id": "cpp20_weak_ptr_copy_ctor_shared_ptr_constraint_e4a8c2b7", "label": "cpp20_weak_ptr_copy_ctor_shared_ptr_cons", "x": 32.59003342367759, "y": -66.24049908002362, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.const]/3", "content": "For weak_ptr constructor from shared_ptr<Y>, Y* must be compatible with T*.", "function": "std::weak_ptr::weak_ptr"}, {"id": "cpp20_weak_ptr_copy_ctor_postcondition_use_count_f5b9d3c8", "label": "cpp20_weak_ptr_copy_ctor_postcondition_u", "x": 56.41564608821637, "y": -11.091280925316557, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.const]/5", "content": "After copy construction from r, use_count() equals r.use_count().", "function": "std::weak_ptr::weak_ptr"}, {"id": "cpp20_weak_ptr_move_ctor_constraint_compatible_a6c0e4d9", "label": "cpp20_weak_ptr_move_ctor_constraint_comp", "x": 68.57350387963794, "y": -24.548822121438143, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.const]/6", "content": "For weak_ptr move constructor from weak_ptr<Y>&&, Y* must be compatible with T*.", "function": "std::weak_ptr::weak_ptr"}, {"id": "cpp20_weak_ptr_move_ctor_postcondition_b7d1f5e0", "label": "cpp20_weak_ptr_move_ctor_postcondition_b", "x": 2.587473016215223, "y": -71.65409788590341, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.const]/8", "content": "After move construction from r, *this contains the old value of r, and r is empty with null pointer and use_count() == 0.", "function": "std::weak_ptr::weak_ptr"}, {"id": "cpp20_weak_ptr_destructor_no_effect_on_object_c8e2a6f1", "label": "cpp20_weak_ptr_destructor_no_effect_on_o", "x": -124.32339348526486, "y": 59.61759371187393, "size": 4.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.dest]/1", "content": "The weak_ptr destructor destroys the weak_ptr object but has no effect on the object its stored pointer points to.", "function": "std::weak_ptr::~weak_ptr"}, {"id": "cpp20_weak_ptr_deduction_guide_from_shared_ptr_e2a6c0b5", "label": "cpp20_weak_ptr_deduction_guide_from_shar", "x": 282.21196913621856, "y": -619.7348787599752, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.general]/1", "content": "weak_ptr has a deduction guide that deduces weak_ptr<T> from shared_ptr<T>.", "function": ""}, {"id": "cpp20_weak_ptr_copy_constructible_requirement_b2d4e6f1", "label": "cpp20_weak_ptr_copy_constructible_requir", "x": 613.9104879576308, "y": -206.9300045830547, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.general]/2", "content": "Specializations of weak_ptr shall be Cpp17CopyConstructible and Cpp17CopyAssignable, allowing their use in standard containers.", "function": ""}, {"id": "cpp20_weak_ptr_general_incomplete_type_allowed_a7c3f8e2", "label": "cpp20_weak_ptr_general_incomplete_type_a", "x": -187.49804139788992, "y": 46.680885230150295, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.general]/2", "content": "The template parameter T of weak_ptr may be an incomplete type.", "function": ""}, {"id": "cpp20_weak_ptr_swap_exchanges_contents_f7b1d5c0", "label": "cpp20_weak_ptr_swap_exchanges_contents_f", "x": 154.78408311025046, "y": -88.50654106630948, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.mod]/1", "content": "swap() exchanges the contents of *this and r.", "function": "std::weak_ptr::swap"}, {"id": "cpp20_weak_ptr_reset_makes_empty_a8c2e6d1", "label": "cpp20_weak_ptr_reset_makes_empty_a8c2e6d", "x": 708.1597786422903, "y": -351.5097793323281, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.mod]/2", "content": "reset() is equivalent to weak_ptr().swap(*this), making *this empty.", "function": "std::weak_ptr::reset"}, {"id": "cpp20_weak_ptr_use_count_empty_returns_zero_d9f3b7a2", "label": "cpp20_weak_ptr_use_count_empty_returns_z", "x": -12.229311624610755, "y": -975.3026874171679, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/1", "content": "use_count() returns 0 if the weak_ptr is empty; otherwise returns the number of shared_ptr instances that share ownership.", "function": "std::weak_ptr::use_count"}, {"id": "cpp20_weak_ptr_expired_definition_e0a4c8b3", "label": "cpp20_weak_ptr_expired_definition_e0a4c8", "x": -636.7631954498665, "y": -15.282241460955138, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/2", "content": "expired() returns true if and only if use_count() == 0.", "function": "std::weak_ptr::expired"}, {"id": "cpp20_weak_ptr_lock_atomic_operation_f1b5d9c4", "label": "cpp20_weak_ptr_lock_atomic_operation_f1b", "x": -919.3555417908343, "y": 20.449347770280944, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/3", "content": "lock() returns an empty shared_ptr if expired(), otherwise returns shared_ptr(*this), executed atomically.", "function": "std::weak_ptr::lock"}, {"id": "cpp20_weak_ptr_owner_before_strict_weak_ordering_a2c6e0d5", "label": "cpp20_weak_ptr_owner_before_strict_weak_", "x": 78.14713387454711, "y": -143.32964019960696, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/4.1", "content": "owner_before defines a strict weak ordering as defined in [alg.sorting].", "function": "std::weak_ptr::owner_before"}, {"id": "cpp20_weak_ptr_owner_before_owner_equal_relation_b3d7f1e6", "label": "cpp20_weak_ptr_owner_before_owner_equal_", "x": 157.25428065218225, "y": -124.72083294503398, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/4.2", "content": "!owner_before(b) && !b.owner_before(*this) is true if and only if owner_equal(b) is true.", "function": "std::weak_ptr::owner_before"}, {"id": "cpp20_weak_ptr_owner_hash_consistency_c4e8a2f7", "label": "cpp20_weak_ptr_owner_hash_consistency_c4", "x": 373.2051252200532, "y": -574.9206282401578, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/5", "content": "owner_hash returns a value such that for any object x where owner_equal(x) is true, owner_hash() == x.owner_hash() is true.", "function": "std::weak_ptr::owner_hash"}, {"id": "cpp20_weak_ptr_owner_equal_shared_ownership_d5f9b3a8", "label": "cpp20_weak_ptr_owner_equal_shared_owners", "x": 151.1397415789062, "y": -144.9598246975337, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/6", "content": "owner_equal returns true if and only if *this and b share ownership or are both empty; otherwise returns false.", "function": "std::weak_ptr::owner_equal"}, {"id": "cpp20_weak_ptr_owner_equal_equivalence_relation_e6a0c4b9", "label": "cpp20_weak_ptr_owner_equal_equivalence_r", "x": 153.11052814635167, "y": -110.86741306325663, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.obs]/7", "content": "owner_equal is an equivalence relation.", "function": "std::weak_ptr::owner_equal"}, {"id": "cpp20_weak_ptr_free_swap_equivalent_d1f5b9a4", "label": "cpp20_weak_ptr_free_swap_equivalent_d1f5", "x": 172.76281288164955, "y": -52.16038796011641, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[util.smartptr.weak.spec]/1", "content": "The free function swap(a, b) is equivalent to a.swap(b).", "function": "std::swap"}, {"id": "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2", "label": "cpp20_utility_swap_constraint_move_assig", "x": -25.654911506789016, "y": 22.5043358764316, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/1", "content": "The template std::swap(T&, T&) requires is_move_assignable_v<T> to be true.", "function": "std::swap"}, {"id": "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1", "label": "cpp20_utility_swap_constraint_move_const", "x": -41.98909204401953, "y": -7.729005681862652, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/1", "content": "The template std::swap(T&, T&) requires is_move_constructible_v<T> to be true.", "function": "std::swap"}, {"id": "cpp20_utility_swap_precond_cpp17moveassignable_f6g0h4i8", "label": "cpp20_utility_swap_precond_cpp17moveassi", "x": 133.59968847898566, "y": -132.69164633214706, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/2", "content": "Calling std::swap(T&, T&) requires that type T meets the Cpp17MoveAssignable requirements.", "function": "std::swap"}, {"id": "cpp20_utility_swap_precond_cpp17moveconstructible_b5c9d3e7", "label": "cpp20_utility_swap_precond_cpp17movecons", "x": 177.39002303336196, "y": -109.75712044742434, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/2", "content": "Calling std::swap(T&, T&) requires that type T meets the Cpp17MoveConstructible requirements.", "function": "std::swap"}, {"id": "cpp20_utility_swap_effect_exchange_values_c7d1e5f9", "label": "cpp20_utility_swap_effect_exchange_value", "x": 136.48388627183166, "y": -143.14783002590428, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/3", "content": "std::swap(T&, T&) exchanges the values stored in the two locations.", "function": "std::swap"}, {"id": "cpp20_utility_swap_noexcept_spec_g8h2i6j0", "label": "cpp20_utility_swap_noexcept_spec_g8h2i6j", "x": 137.73065476595983, "y": -90.68971216955188, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/4", "content": "The noexcept specification of std::swap(T&, T&) is equivalent to is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>.", "function": "std::swap"}, {"id": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "label": "cpp20_utility_swap_array_constraint_swap", "x": -29.036829940558594, "y": -101.52708492815198, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/5", "content": "The array overload of std::swap requires is_swappable_v<T> to be true.", "function": "std::swap"}, {"id": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "label": "cpp20_utility_swap_array_noexcept_spec_w", "x": 115.6108029172254, "y": -69.8878124512288, "size": 8.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/5", "content": "The noexcept specification of std::swap for arrays is is_nothrow_swappable_v<T>.", "function": "std::swap"}, {"id": "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2", "label": "cpp20_utility_swap_array_precond_element", "x": -48.65992635313708, "y": -173.2933668640598, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/6", "content": "Calling std::swap on arrays requires that a[i] is swappable with b[i] for all i in the range [0, N).", "function": "std::swap"}, {"id": "cpp20_utility_swap_array_effect_swap_ranges_s1t5u9v3", "label": "cpp20_utility_swap_array_effect_swap_ran", "x": 136.92935755593913, "y": -77.59715689696634, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[utility.swap]/7", "content": "std::swap on arrays has the effect of calling swap_ranges(a, a+N, b).", "function": "std::swap"}, {"id": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "label": "cpp20_variant_move_assign_exception_valu", "x": 35.89900586007957, "y": -2.288198539334881, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.assign]/10.1", "content": "If an exception is thrown during the call to Tj's move construction in move assignment, the variant will hold no value.", "function": "std::variant::operator="}, {"id": "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4", "label": "cpp20_variant_assign_converting_ambiguou", "x": 28.519129585103567, "y": -141.77047035193868, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.assign]/12.3", "content": "Converting assignment is ill-formed if the expression FUN(forward<T>(t)) is not well-formed (e.g., ambiguous overload).", "function": "std::variant::operator="}, {"id": "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4", "label": "cpp20_variant_converting_assign_exceptio", "x": 5.202166582167064, "y": 15.158288871954651, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.assign]/16.2", "content": "If an exception is thrown during the initialization of the contained value in converting assignment, the variant object is permitted to not hold a value.", "function": "std::variant::operator="}, {"id": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "label": "cpp20_variant_copy_assign_deleted_condit", "x": 12.068850003893639, "y": -52.03354736196638, "size": 7.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.assign]/5", "content": "The copy assignment operator is defined as deleted unless is_copy_constructible_v<Ti> && is_copy_assignable_v<Ti> is true for all i.", "function": "std::variant::operator="}, {"id": "cpp20_variant_bad_variant_access_u1v2w3x4", "label": "cpp20_variant_bad_variant_access_u1v2w3x", "x": 232.43059213019188, "y": -142.21095392627652, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.bad.access]/1", "content": "Objects of type bad_variant_access are thrown to report invalid accesses to the value of a variant object.", "function": ""}, {"id": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "label": "cpp20_variant_ctor_converting_ambiguous_", "x": 18.107027401779785, "y": -76.99605464273321, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.ctor]/15.5", "content": "Converting constructor is ill-formed if the expression FUN(forward<T>(t)) is not well-formed (e.g., ambiguous overload).", "function": "std::variant::variant"}, {"id": "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2", "label": "cpp20_variant_ctor_in_place_type_unique_", "x": 46.36989265087954, "y": -6.632939597118714, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.ctor]/20", "content": "Constructor with in_place_type_t<T> requires exactly one occurrence of T in Types.", "function": "std::variant::variant"}, {"id": "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6", "label": "cpp20_variant_ctor_in_place_index_bound_", "x": 60.516411702031824, "y": -17.61118365657177, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.ctor]/30", "content": "Constructor with in_place_index_t<I> requires I to be less than sizeof...(Types).", "function": "std::variant::variant"}, {"id": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "label": "cpp20_variant_copy_ctor_deleted_conditio", "x": 17.39037927162258, "y": -52.520009249486414, "size": 6.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.ctor]/9", "content": "The copy constructor is defined as deleted unless is_copy_constructible_v<Ti> is true for all i.", "function": "std::variant::variant"}, {"id": "cpp20_variant_dtor_destroys_value_i3j4k5l6", "label": "cpp20_variant_dtor_destroys_value_i3j4k5", "x": -144.0847061043987, "y": 151.6940670411426, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.dtor]/1", "content": "The variant destructor destroys the currently contained value if valueless_by_exception() is false.", "function": "std::variant::~variant"}, {"id": "cpp20_variant_holds_alternative_mandates_k7l8m9n0", "label": "cpp20_variant_holds_alternative_mandates", "x": 165.48845615617157, "y": -77.87259535946542, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/1", "content": "holds_alternative<T> mandates that the type T occurs exactly once in Types.", "function": "std::holds_alternative"}, {"id": "cpp20_variant_get_if_mandates_index_s7t8u9v0", "label": "cpp20_variant_get_if_mandates_index_s7t8", "x": -222.01827609625943, "y": -88.03776457037354, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/10", "content": "get_if<I> mandates that I is less than sizeof...(Types).", "function": "std::get_if"}, {"id": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6", "label": "cpp20_variant_get_if_returns_nullptr_o3p", "x": -62.97474792834348, "y": -118.28807575826812, "size": 9.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/11", "content": "get_if returns nullptr if v is nullptr or if v->index() != I.", "function": "std::get_if"}, {"id": "cpp20_variant_get_if_type_mandates_unique_w1x2y3z4", "label": "cpp20_variant_get_if_type_mandates_uniqu", "x": -241.86776331969926, "y": -49.59034716884645, "size": 3.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/12", "content": "get_if<T> mandates that the type T occurs exactly once in Types.", "function": "std::get_if"}, {"id": "cpp20_variant_get_index_precondition_m3n4o5p6", "label": "cpp20_variant_get_index_precondition_m3n", "x": 103.4935629742023, "y": -162.03716268992662, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/4", "content": "Calling GET<I>(v) requires that v.index() is I.", "function": "GET"}, {"id": "cpp20_variant_get_index_mandates_c9d0e1f2", "label": "cpp20_variant_get_index_mandates_c9d0e1f", "x": 172.58064923196923, "y": -121.64660997492388, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/6", "content": "std::get<I> mandates that I is less than sizeof...(Types).", "function": "std::get"}, {"id": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0", "label": "cpp20_variant_get_throws_bad_variant_acc", "x": 172.6678275609614, "y": -119.19587782614248, "size": 6.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/7", "content": "Calling std::get<I>(v) throws bad_variant_access if v.index() is not I.", "function": "std::get"}, {"id": "cpp20_variant_get_type_mandates_unique_g3h4i5j6", "label": "cpp20_variant_get_type_mandates_unique_g", "x": 140.42996131126188, "y": -105.42789805598034, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/8", "content": "std::get<T> mandates that the type T occurs exactly once in Types.", "function": "std::get"}, {"id": "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8", "label": "cpp20_variant_get_type_throws_bad_varian", "x": 162.14024332412794, "y": -131.52334981635067, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.get]/9", "content": "Calling std::get<T>(v) throws bad_variant_access if v does not hold a value of type T.", "function": "std::get"}, {"id": "cpp20_variant_hash_enabled_condition_e9f0g1h2", "label": "cpp20_variant_hash_enabled_condition_e9f", "x": -407.23589297433995, "y": 872.7344207732779, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.hash]/1", "content": "The specialization hash<variant<Types...>> is enabled if and only if every specialization in hash<remove_const_t<Types>>... is enabled.", "function": ""}, {"id": "cpp20_variant_alternative_mandates_o1p2q3r4", "label": "cpp20_variant_alternative_mandates_o1p2q", "x": 475.7817369629871, "y": 301.91355611548994, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.helper]/4", "content": "variant_alternative<I, variant<Types...>>::type mandates that I is less than sizeof...(Types).", "function": ""}, {"id": "cpp20_variant_emplace_type_unique_a5b6c7d8", "label": "cpp20_variant_emplace_type_unique_a5b6c7", "x": 119.9360924821521, "y": -137.90196470679027, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.mod]/1", "content": "emplace<T>(...) requires T to occur exactly once in Types.", "function": "std::variant::emplace"}, {"id": "cpp20_variant_emplace_valueless_w9x0y1z2", "label": "cpp20_variant_emplace_valueless_w9x0y1z2", "x": 26.72600366140446, "y": 4.50642782987921, "size": 5.5, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.mod]/11", "content": "If an exception is thrown during the initialization of the contained value in emplace, the variant is permitted to not hold a value (become valueless_by_exception).", "function": "std::variant::emplace"}, {"id": "cpp20_variant_emplace_mandates_s5t6u7v8", "label": "cpp20_variant_emplace_mandates_s5t6u7v8", "x": 138.17735196301132, "y": -120.80624781191752, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.mod]/5", "content": "emplace<I>(...) mandates that I is less than sizeof...(Types).", "function": "std::variant::emplace"}, {"id": "cpp20_variant_spaceship_valueless_ordering_c3d4e5f6", "label": "cpp20_variant_spaceship_valueless_orderi", "x": 146.77178355210654, "y": -120.616460771178, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.relops]/13", "content": "In three-way comparison, two valueless variants yield strong_ordering::equal, valueless < non-valueless yields strong_ordering::less, non-valueless > valueless yields strong_ordering::greater.", "function": "operator<=>"}, {"id": "cpp20_variant_relops_valueless_equal_u5v6w7x8", "label": "cpp20_variant_relops_valueless_equal_u5v", "x": 151.58756847729404, "y": -106.09797687882572, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.relops]/2", "content": "Two valueless variants compare equal.", "function": "operator=="}, {"id": "cpp20_variant_relops_valueless_less_y9z0a1b2", "label": "cpp20_variant_relops_valueless_less_y9z0", "x": 141.78869914932633, "y": -135.78271406986948, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.relops]/6", "content": "A valueless variant is less than a non-valueless variant.", "function": "operator<"}, {"id": "cpp20_variant_swap_specialized_constraints_o5p6q7r8", "label": "cpp20_variant_swap_specialized_constrain", "x": 145.39325351927, "y": -123.51496500435299, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.specalg]/1", "content": "The specialized swap for variant requires is_move_constructible_v<Ti> && is_swappable_v<Ti> is true for all i.", "function": "std::swap"}, {"id": "cpp20_variant_valueless_by_exception_k9l0m1n2", "label": "cpp20_variant_valueless_by_exception_k9l", "x": -294.4063164755519, "y": -735.4315710298216, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.status]/1", "content": "valueless_by_exception() returns false if and only if the variant holds a value.", "function": "std::variant::valueless_by_exception"}, {"id": "cpp20_variant_index_valueless_returns_npos_g5h6i7j8", "label": "cpp20_variant_index_valueless_returns_np", "x": 387.2676675008074, "y": -650.0488326142081, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.status]/3", "content": "If valueless_by_exception() is true, index() returns variant_npos.", "function": "std::variant::index"}, {"id": "cpp20_variant_swap_mandates_move_constructible_e7f8g9h0", "label": "cpp20_variant_swap_mandates_move_constru", "x": 177.80427439315443, "y": -69.38518136599528, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.swap]/1", "content": "variant::swap mandates that is_move_constructible_v<Ti> is true for all i.", "function": "std::variant::swap"}, {"id": "cpp20_variant_swap_precondition_swappable_a3b4c5d6", "label": "cpp20_variant_swap_precondition_swappabl", "x": 84.47804501841085, "y": -169.56411609087917, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.swap]/2", "content": "Each Ti must meet the Cpp17Swappable requirements for variant::swap.", "function": "std::variant::swap"}, {"id": "cpp20_variant_types_destructible_i9j0k1l2", "label": "cpp20_variant_types_destructible_i9j0k1l", "x": -66.42648430314757, "y": -990.2136639495641, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.variant.general]/2", "content": "All types in the variant Types parameter pack shall meet the Cpp17Destructible requirements.", "function": ""}, {"id": "cpp20_variant_no_args_illformed_a1b2c3d4", "label": "cpp20_variant_no_args_illformed_a1b2c3d4", "x": -192.57722165951793, "y": 106.07619724791127, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.variant.general]/3", "content": "A program that instantiates the definition of variant with no template arguments is ill-formed.", "function": ""}, {"id": "cpp20_variant_explicit_specialization_illformed_e5f6g7h8", "label": "cpp20_variant_explicit_specialization_il", "x": -143.31393343558497, "y": 504.5204878970154, "size": 3.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.variant.general]/4", "content": "If a program declares an explicit or partial specialization of variant, the program is ill-formed, no diagnostic required.", "function": ""}, {"id": "cpp20_variant_visit_mandates_valid_expression_m5n6o7p8", "label": "cpp20_variant_visit_mandates_valid_expre", "x": 179.61609419820778, "y": -73.6399897227054, "size": 4.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.visit]/5", "content": "For each valid pack m, e(m) must be a valid expression and all such expressions must be of the same type and value category.", "function": "std::visit"}, {"id": "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4", "label": "cpp20_variant_visit_throws_bad_variant_a", "x": 160.90797766263344, "y": -132.98429964406168, "size": 5.0, "color": "#0984e3", "layer": "cpp20_stdlib", "module": "[variant.visit]/7", "content": "std::visit throws bad_variant_access if any variant argument is valueless_by_exception.", "function": "std::visit"}, {"id": "ILP_ALWAYS_INLINE.expansion", "label": "ILP_ALWAYS_INLINE.expansion", "x": 617.6820244424086, "y": 64.4926113866174, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_ALWAYS_INLINE expands to the 'inline' keyword, suggesting inline expansion to the compiler", "function": "ILP_ALWAYS_INLINE"}, {"id": "ILP_ALWAYS_INLINE.odr_implication", "label": "ILP_ALWAYS_INLINE.odr_implication", "x": 624.9603119652432, "y": 587.4689779982135, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Functions declared with ILP_ALWAYS_INLINE follow ODR (One Definition Rule) relaxation for inline functions, allowing identical definitions in multiple translation units", "function": "ILP_ALWAYS_INLINE"}, {"id": "ILP_ALWAYS_INLINE.semantic_note", "label": "ILP_ALWAYS_INLINE.semantic_note", "x": 787.7476097436164, "y": -37.08364072011694, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Despite the name 'ALWAYS_INLINE', this macro only provides an inline hint to the compiler, not a guarantee of inlining; compiler may still choose not to inline", "function": "ILP_ALWAYS_INLINE"}, {"id": "ILP_ALWAYS_INLINE.usage_constraint", "label": "ILP_ALWAYS_INLINE.usage_constraint", "x": -332.49382826305407, "y": 648.8435391940236, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_ALWAYS_INLINE must be used in a context where the 'inline' keyword is valid (function definitions, variable declarations in C++17+)", "function": "ILP_ALWAYS_INLINE"}, {"id": "ILP_END_RETURN_macro_empty_expansion", "label": "ILP_END_RETURN_macro_empty_expansion", "x": -63.3002196726257, "y": -761.4885149658193, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END_RETURN expands to empty text, producing no tokens in the preprocessing output", "function": "ILP_END_RETURN"}, {"id": "ILP_END_RETURN_macro_marker_semantics", "label": "ILP_END_RETURN_macro_marker_semantics", "x": 585.9625045711035, "y": 662.4351902299242, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END_RETURN serves as a syntactic marker in macro-based control flow, paired with ILP_FOR* opening macros. It must be used (instead of ILP_END) when ILP_RETURN is used anywhere in the loop body to return from the enclosing function.", "function": "ILP_END_RETURN"}, {"id": "ILP_END_RETURN_macro_no_side_effects", "label": "ILP_END_RETURN_macro_no_side_effects", "x": -25.485915688872236, "y": -879.0772066759866, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Expansion of ILP_END_RETURN produces no side effects, no code generation, and does not affect program semantics beyond its removal", "function": "ILP_END_RETURN"}, {"id": "ILP_END_RETURN_macro_statement_context", "label": "ILP_END_RETURN_macro_statement_context", "x": -178.7842766644216, "y": 700.5798143323084, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END_RETURN should only be used in contexts where an empty statement or removal of text is syntactically valid", "function": "ILP_END_RETURN"}, {"id": "check_sum_overflow_anti_pattern_size_mismatch_g3h4i5j6", "label": "check_sum_overflow_anti_pattern_size_mis", "x": 740.8029159061915, "y": -481.13657440652446, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using an accumulator type AccumT with sizeof(AccumT) < sizeof(ElemT) when both are integral types creates overflow risk during accumulation, as the accumulator cannot represent the full range of element values.", "function": "check_sum_overflow"}, {"id": "check_sum_overflow_complexity_constant_p1q2r3s4", "label": "check_sum_overflow_complexity_constant_p", "x": -793.5789398964846, "y": 533.0424250139644, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity: O(1) - compile-time only evaluation with no runtime cost. Space complexity: O(1) - no additional memory allocated.", "function": "check_sum_overflow"}, {"id": "check_sum_overflow_constraint_type_safety_c9d0e1f2", "label": "check_sum_overflow_constraint_type_safet", "x": -488.5036850302881, "y": 207.978221686039, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The function only performs overflow checking when both AccumT and ElemT satisfy std::integral<T>. For non-integral types (e.g., floating-point), the function is a no-op and performs no checks.", "function": "check_sum_overflow"}, {"id": "check_sum_overflow_effect_diagnostic_emission_a1b2c3d4", "label": "check_sum_overflow_effect_diagnostic_emi", "x": 741.8007745000575, "y": -619.658391471997, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "At compile-time, if both AccumT and ElemT are integral types and sizeof(AccumT) < sizeof(ElemT), the function invokes warn_accumulator_overflow<AccumT, ElemT>() to emit a diagnostic about potential overflow risk.", "function": "check_sum_overflow"}, {"id": "check_sum_overflow_exception_noexcept_t5u6v7w8", "label": "check_sum_overflow_exception_noexcept_t5", "x": 336.7297036745461, "y": -443.70068807997654, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "The function is constexpr and performs compile-time checks only. It cannot throw exceptions at runtime and is implicitly noexcept.", "function": "check_sum_overflow"}, {"id": "check_sum_overflow_postcondition_warning_issued_e5f6a7b8", "label": "check_sum_overflow_postcondition_warning", "x": -217.5399440301619, "y": 699.0381279710512, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After execution, if the conditions std::integral<AccumT> && std::integral<ElemT> && sizeof(AccumT) < sizeof(ElemT) are met, a warning has been issued to alert the developer of potential accumulator overflow.", "function": "check_sum_overflow"}, {"id": "check_sum_overflow_precondition_none_k7l8m9n0", "label": "check_sum_overflow_precondition_none_k7l", "x": -90.76064565706707, "y": 992.6672994694693, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "No runtime preconditions required. The function is constexpr and performs compile-time checks only based on template parameters AccumT and ElemT.", "function": "check_sum_overflow"}, {"id": "ctrl_r_conversion_operator_anti_pattern_use_after_move_143", "label": "ctrl_r_conversion_operator_anti_pattern_", "x": -12.995316136335406, "y": 99.66328750754862, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Do not use the object after invoking this rvalue conversion operator - member s may be in moved-from state", "function": "R"}, {"id": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2", "label": "ctrl_r_conversion_operator_anti_pattern_", "x": 48.94626369396641, "y": 121.09076642854168, "size": 17.5, "color": "#26de81", "layer": "library", "module": "", "content": "Do not use the object after invoking this rvalue conversion operator. Since it requires && (rvalue reference), the object is moved-from after the conversion and further use may lead to undefined behavior.", "function": "R"}, {"id": "ctrl_r_conversion_operator_complexity_constant_b7e2f9a1", "label": "ctrl_r_conversion_operator_complexity_co", "x": -103.40924603377837, "y": -880.9125752816209, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) for the conversion operator itself, plus the complexity of s.extract<R>(). Space complexity is O(1) excluding the returned object.", "function": "R"}, {"id": "ctrl_r_conversion_operator_constraint_type_convertible_e8f3a1d2", "label": "ctrl_r_conversion_operator_constraint_ty", "x": -558.9314562394637, "y": -117.62186744874967, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type R must be the exact type that s.extract<R>() returns or implicitly convertible to it. The conversion operator enables implicit conversion from the enclosing class to type R.", "function": "R"}, {"id": "ctrl_r_conversion_operator_constraint_type_r_143", "label": "ctrl_r_conversion_operator_constraint_ty", "x": 564.9934839068225, "y": 408.0219214041437, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter R must be a complete type that is compatible with the extract<R>() method's return type", "function": "R"}, {"id": "ctrl_r_conversion_operator_effect_move_semantics_143", "label": "ctrl_r_conversion_operator_effect_move_s", "x": 69.6393160150368, "y": 120.36707209691298, "size": 17.0, "color": "#26de81", "layer": "library", "module": "", "content": "Invokes s.template extract<R>() which may consume/move resources from member s due to rvalue context", "function": "R"}, {"id": "ctrl_r_conversion_operator_effect_move_semantics_d5a7b3c9", "label": "ctrl_r_conversion_operator_effect_move_s", "x": -658.4156328885723, "y": 353.8146931625791, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Invokes s.template extract<R>() with move semantics (&&). After this operation, the object should be treated as moved-from and 's' may be in a valid but unspecified state.", "function": "R"}, {"id": "ctrl_r_conversion_operator_exception_extract_propagation_143", "label": "ctrl_r_conversion_operator_exception_ext", "x": 13.468411541463844, "y": -976.0119692228847, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any exception thrown by s.template extract<R>() will propagate to the caller - no exception handling in conversion operator", "function": "R"}, {"id": "ctrl_r_conversion_operator_exception_propagates_extract_f2c8e1a4", "label": "ctrl_r_conversion_operator_exception_pro", "x": 588.1701058870214, "y": 539.1057830860581, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any exception thrown by s.extract<R>() will propagate to the caller. The conversion operator provides no exception handling, so exception safety depends entirely on extract<R>() implementation.", "function": "R"}, {"id": "ctrl_r_conversion_operator_postcondition_return_type_143", "label": "ctrl_r_conversion_operator_postcondition", "x": 87.12143223625166, "y": -916.4027329392347, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns an object of type R obtained by calling s.template extract<R>(), where the returned value is the result of the extraction operation", "function": "R"}, {"id": "ctrl_r_conversion_operator_postcondition_returns_r_a1f8c2e7", "label": "ctrl_r_conversion_operator_postcondition", "x": 680.1806381024533, "y": 170.58709164481834, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns an object of type R obtained by calling s.extract<R>(). The returned value is exactly the result of the extraction operation on 's'.", "function": "R"}, {"id": "ctrl_r_conversion_operator_precondition_extract_valid_143", "label": "ctrl_r_conversion_operator_precondition_", "x": 554.0702628121265, "y": 510.52356679751375, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type R must be a valid template argument for the extract method and member s must support extraction to type R", "function": "R"}, {"id": "ctrl_r_conversion_operator_precondition_extract_valid_c4f1a8e3", "label": "ctrl_r_conversion_operator_precondition_", "x": 747.7699554435904, "y": 24.711007807788487, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter R must be a valid type for which s.extract<R>() is defined. The member object 's' must have a template method extract that can be instantiated with type R.", "function": "R"}, {"id": "ctrl_r_conversion_operator_precondition_extractable_data_8c3d4f92", "label": "ctrl_r_conversion_operator_precondition_", "x": -770.0276323113308, "y": 292.6322701130343, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The member object 's' must contain data that can be extracted as type R. The extract operation must be semantically valid for the current state of 's'.", "function": "R"}, {"id": "ctrl_r_conversion_operator_precondition_rvalue_143", "label": "ctrl_r_conversion_operator_precondition_", "x": -137.23831112309273, "y": 53.8999120688827, "size": 8.5, "color": "#26de81", "layer": "library", "module": "", "content": "This conversion operator requires rvalue reference (&&) semantics - object must be an expiring value or moved-from state", "function": "R"}, {"id": "ctrl_r_conversion_operator_precondition_rvalue_ref_b2e9f7d1", "label": "ctrl_r_conversion_operator_precondition_", "x": 102.49655803015489, "y": -76.73041843414391, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "This conversion operator requires the object to be an rvalue reference (&&). The object must be in a movable state and should not be used after this conversion.", "function": "R"}, {"id": "extract_anti_pattern_double_extract_h1c2d3e4", "label": "extract_anti_pattern_double_extract_h1c2", "x": 792.8523522963152, "y": 385.5475344276185, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not call extract() multiple times on the same buffer without reconstructing the object, as the first call may move/destroy the object", "function": "extract"}, {"id": "extract_anti_pattern_double_extraction_a4d7b9c3", "label": "extract_anti_pattern_double_extraction_a", "x": 826.1262296266237, "y": 404.04813916870745, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not call extract() multiple times on the same buffer without reconstructing the object, as the first call may move from the object leaving it in a valid but unspecified state", "function": "extract"}, {"id": "extract_complexity_constant_time_b5e2f8a9", "label": "extract_complexity_constant_time_b5e2f8a", "x": 301.31913243526554, "y": 504.27169203537, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "O(1) time and space complexity - performs only pointer casts and dereference operations", "function": "extract"}, {"id": "extract_complexity_constant_time_i0d1e2f3", "label": "extract_complexity_constant_time_i0d1e2f", "x": 860.2958203508377, "y": 156.79356130174455, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "extract() operates in O(1) constant time - performs only pointer operations and casts without iteration", "function": "extract"}, {"id": "extract_constraint_type_r_moveable_f6c8d2e4", "label": "extract_constraint_type_r_moveable_f6c8d", "x": 79.08968556141322, "y": 38.94451170521289, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Type R must be move-constructible or move-assignable for the rvalue reference return to be useful", "function": "extract"}, {"id": "extract_constraint_type_r_must_match_buffer_g2b3c4d5", "label": "extract_constraint_type_r_must_match_buf", "x": -70.18560393702582, "y": 624.9967728516799, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter R must match the actual type of the object stored in buffer (or a cv-qualified variant) to avoid type punning undefined behavior", "function": "extract"}, {"id": "extract_effect_launder_bypass_optimization_d2e8f4a6", "label": "extract_effect_launder_bypass_optimizati", "x": -431.6222059652792, "y": -616.0290946818635, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "std::launder obtains a pointer to the object at buffer storage, bypassing compiler optimizations that assume no object exists there", "function": "extract"}, {"id": "extract_effect_launder_pointer_optimization_e4f5a6b7", "label": "extract_effect_launder_pointer_optimizat", "x": -376.24421711993955, "y": -605.0566403215995, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "std::launder provides pointer optimization transparency, ensuring the returned pointer refers to the actual object at the storage location even after transparent replacement", "function": "extract"}, {"id": "extract_effect_perfect_forward_rvalue_c7b4d9e2", "label": "extract_effect_perfect_forward_rvalue_c7", "x": -419.0094521104418, "y": -131.11760007587964, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "static_cast<R&&> performs perfect forwarding to preserve the value category as an rvalue reference, enabling move semantics", "function": "extract"}, {"id": "extract_effect_perfect_forward_rvalue_d5e6f7a8", "label": "extract_effect_perfect_forward_rvalue_d5", "x": 854.9884231002494, "y": 16.970085014987546, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns the object at buffer as an rvalue reference R&&, performing perfect forwarding that preserves value category", "function": "extract"}, {"id": "extract_effect_reinterpret_cast_type_punning_d8b3e5c7", "label": "extract_effect_reinterpret_cast_type_pun", "x": -540.3532219149569, "y": -738.1363632964012, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "reinterpret_cast<R*>(buffer) reinterprets the buffer bytes as a pointer to type R without type conversion, providing type punning mechanism", "function": "extract"}, {"id": "extract_postcond_returns_rvalue_ref_e9a3f5b7", "label": "extract_postcond_returns_rvalue_ref_e9a3", "x": 560.3174072536483, "y": -320.9009322790873, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns an rvalue reference to the object of type R stored in buffer, enabling move operations", "function": "extract"}, {"id": "extract_postcond_returns_rvalue_ref_f3a4b5c6", "label": "extract_postcond_returns_rvalue_ref_f3a4", "x": 732.8012167772084, "y": 338.9784408492622, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns an rvalue reference to the object of type R stored in buffer, enabling move semantics", "function": "extract"}, {"id": "extract_precond_buffer_alignment_a9b4c3d2", "label": "extract_precond_buffer_alignment_a9b4c3d", "x": 619.0498964435601, "y": -451.3186611224951, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "buffer must be properly aligned for type R when reinterpret_cast is performed", "function": "extract"}, {"id": "extract_precond_buffer_alignment_e3d9a1f5", "label": "extract_precond_buffer_alignment_e3d9a1f", "x": -135.38662029305783, "y": -328.0208522517218, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "buffer must be properly aligned for type R to satisfy reinterpret_cast requirements", "function": "extract"}, {"id": "extract_precond_buffer_non_null_b7c8d9e0", "label": "extract_precond_buffer_non_null_b7c8d9e0", "x": -127.87334923402697, "y": -496.4897951102615, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "buffer must not be a null pointer when dereferenced through std::launder", "function": "extract"}, {"id": "extract_precond_buffer_not_const_e7a9c4d2", "label": "extract_precond_buffer_not_const_e7a9c4d", "x": -390.40780908810086, "y": -561.2597609291064, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If R is non-const, buffer must point to non-const storage to avoid const-correctness violation", "function": "extract"}, {"id": "extract_precond_buffer_not_deallocated_j9e8f7a6", "label": "extract_precond_buffer_not_deallocated_j", "x": -650.3740846626681, "y": 399.02260332914864, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The storage pointed to by buffer must not have been deallocated or released before extraction", "function": "extract"}, {"id": "extract_precond_buffer_valid_storage_a8f3d2e1", "label": "extract_precond_buffer_valid_storage_a8f", "x": 546.7029213152399, "y": -75.9643524847966, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "buffer must point to storage that contains a valid object of type R or cv-qualified variant before extraction", "function": "extract"}, {"id": "extract_precond_buffer_valid_storage_f4a7b2c9", "label": "extract_precond_buffer_valid_storage_f4a", "x": -554.2717312550594, "y": 446.229164382052, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "buffer must point to storage containing a valid object of type R before extract() is called", "function": "extract"}, {"id": "extract_precond_object_lifetime_started_b8c2d4e6", "label": "extract_precond_object_lifetime_started_", "x": 687.3569829025248, "y": 191.37790134087803, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "The object of type R at buffer location must have its lifetime already started before dereferencing", "function": "extract"}, {"id": "extract_precond_object_lifetime_started_c6d7e8f9", "label": "extract_precond_object_lifetime_started_", "x": 510.79330378738797, "y": -615.677676917102, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The object of type R at buffer location must have its lifetime started before extraction", "function": "extract"}, {"id": "extract_precond_pointer_non_null_a5f7c3d1", "label": "extract_precond_pointer_non_null_a5f7c3d", "x": -236.96136570936247, "y": -357.847190131599, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "buffer must not be null when reinterpret_cast and dereferenced through std::launder", "function": "extract"}, {"id": "for_loop_auto_complexity_delegates_complexity_i9j0k1l2", "label": "for_loop_auto_complexity_delegates_compl", "x": -191.32093599546604, "y": 214.18840584848084, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Complexity: Time and space complexity is identical to for_loop<optimal_N<LT, ElementT>>, as this function is a zero-overhead delegation wrapper that only performs compile-time template parameter computation", "function": "for_loop_auto"}, {"id": "for_loop_auto_constraint_body_callable_c3d4e5f6", "label": "for_loop_auto_constraint_body_callable_c", "x": -888.9139639782201, "y": -410.03641262000804, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Constraint: body must be a callable object compatible with the signature expected by for_loop<optimal_N<LT, ElementT>>, accepting loop iteration parameters", "function": "for_loop_auto"}, {"id": "for_loop_auto_constraint_optimal_n_valid_b2c3d4e5", "label": "for_loop_auto_constraint_optimal_n_valid", "x": -172.1409144606079, "y": 209.81600939383046, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Constraint: optimal_N<LT, ElementT> must resolve to a valid positive compile-time constant usable as a template parameter for for_loop instantiation", "function": "for_loop_auto"}, {"id": "for_loop_auto_constraint_type_compatibility_g7h8i9j0", "label": "for_loop_auto_constraint_type_compatibil", "x": -660.6277765795916, "y": 127.46743796005032, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Constraint: Type parameters T, F, R, LT, and ElementT must be compatible such that T is suitable for loop iteration according to LT, and ElementT correctly describes the element type for optimal_N computation", "function": "for_loop_auto"}, {"id": "for_loop_auto_effect_delegates_to_for_loop_d4e5f6g7", "label": "for_loop_auto_effect_delegates_to_for_lo", "x": -910.6675005631283, "y": 278.1824402422148, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Effect: Delegates execution to for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)), automatically determining optimal iteration unrolling factor N based on loop type LT and element type ElementT", "function": "for_loop_auto"}, {"id": "for_loop_auto_effect_perfect_forwarding_e5f6g7h8", "label": "for_loop_auto_effect_perfect_forwarding_", "x": 93.78012460355379, "y": 143.3984196209793, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Effect: Uses std::forward<F>(body) to preserve the value category of body parameter, enabling perfect forwarding of both lvalue and rvalue callable objects without unnecessary copies", "function": "for_loop_auto"}, {"id": "for_loop_auto_exception_propagates_from_delegate_h8i9j0k1", "label": "for_loop_auto_exception_propagates_from_", "x": 788.2632700658214, "y": -310.1257588542035, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Exception: Any exception thrown by for_loop<optimal_N<LT, ElementT>> or std::forward<F> is propagated to the caller without modification", "function": "for_loop_auto"}, {"id": "for_loop_auto_postcond_returns_for_result_f6g7h8i9", "label": "for_loop_auto_postcond_returns_for_resul", "x": 571.5332179070281, "y": 817.745389522336, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Postcondition: Returns a ForResult object containing the result of loop execution, semantically equivalent to the result returned by for_loop<optimal_N<LT, ElementT>>(start, end, body)", "function": "for_loop_auto"}, {"id": "for_loop_auto_precond_valid_range_a1b2c3d4", "label": "for_loop_auto_precond_valid_range_a1b2c3", "x": -56.220302574586675, "y": 300.6499674270635, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Precondition: start and end must form a valid range according to loop type LT, satisfying the preconditions of the delegated for_loop<optimal_N<LT, ElementT>> function", "function": "for_loop_auto"}, {"id": "for_loop_complexity_linear_iterations_i9j0k1l2", "label": "for_loop_complexity_linear_iterations_i9", "x": -687.8119585361251, "y": 179.32908604295073, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O((end - start) * complexity(body)), where each iteration from start to end invokes body once", "function": "for_loop"}, {"id": "for_loop_constraint_type_t_comparable_h8i9j0k1", "label": "for_loop_constraint_type_t_comparable_h8", "x": 32.898071896651665, "y": 309.5504670681021, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type T must support comparison operators (<, <=, >, >=) for range validation and iteration", "function": "for_loop"}, {"id": "for_loop_effect_delegates_to_impl_d4e5f6a7", "label": "for_loop_effect_delegates_to_impl_d4e5f6", "x": 953.1916352954368, "y": -269.12724326633156, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates all iteration logic to detail::for_loop_untyped_impl<N> with perfect forwarding of body parameter", "function": "for_loop"}, {"id": "for_loop_effect_perfect_forward_body_e5f6g7h8", "label": "for_loop_effect_perfect_forward_body_e5f", "x": 125.6260233930738, "y": 144.31059065873745, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Uses std::forward<F> to preserve the value category of body, enabling move semantics for rvalue references and maintaining lvalue references", "function": "for_loop"}, {"id": "for_loop_effect_unroll_optimization_g7h8i9j0", "label": "for_loop_effect_unroll_optimization_g7h8", "x": 503.39826740464116, "y": 856.389098049437, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop unrolling by factor N enables instruction-level parallelism by processing iterations in blocks of N", "function": "for_loop"}, {"id": "for_loop_postcond_returns_for_result_f6g7h8i9", "label": "for_loop_postcond_returns_for_result_f6g", "x": -354.63338752828975, "y": -891.1913712287336, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns ForResult object indicating loop completion status; if all iterations complete successfully, return_set is false and storage is default-constructed", "function": "for_loop"}, {"id": "for_loop_precond_body_callable_b2c3d4e5", "label": "for_loop_precond_body_callable_b2c3d4e5", "x": -108.17605272114767, "y": -797.6762242799691, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "body must be a valid callable object that can be invoked with loop iteration parameters", "function": "for_loop"}, {"id": "for_loop_precond_n_positive_c3d4e5f6", "label": "for_loop_precond_n_positive_c3d4e5f6", "x": -947.8257405295243, "y": -193.70792762068538, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be a positive integer >= 1 for loop unrolling factor", "function": "for_loop"}, {"id": "for_loop_precond_valid_range_a1b2c3d4", "label": "for_loop_precond_valid_range_a1b2c3d4", "x": 14.991625340124466, "y": 321.8323399769165, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "start and end must form a valid range for the loop type, with start <= end for forward iteration", "function": "for_loop"}, {"id": "for_loop_range_anti_pattern_pass_by_value_o6p7q8r9", "label": "for_loop_range_anti_pattern_pass_by_valu", "x": -488.8070333518804, "y": 436.10240795576317, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not explicitly move or copy arguments when calling this function; use direct pass-through to preserve value category and enable perfect forwarding", "function": "for_loop_range"}, {"id": "for_loop_range_auto_complexity_depends_on_impl_1f3a7c8d", "label": "for_loop_range_auto_complexity_depends_o", "x": 20.60681922253284, "y": 361.6832136211031, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) for the wrapper itself (just forwarding), plus the complexity of for_loop_range<optimal_N<LT, ElementT>> which depends on range size and body complexity. Space complexity is O(1) excluding the delegated call.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_constraint_optimal_n_valid_9c2d5a7e", "label": "for_loop_range_auto_constraint_optimal_n", "x": -204.41344164310166, "y": 196.787167582311, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter optimal_N<LT, ElementT> must resolve to a valid compile-time constant greater than zero, representing the instruction-level parallelism factor for loop unrolling.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_effect_delegates_to_impl_3c8b5d2a", "label": "for_loop_range_auto_effect_delegates_to_", "x": 415.6787337684889, "y": -864.8360847153676, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates execution to for_loop_range<optimal_N<LT, ElementT>> with perfectly forwarded parameters, automatically determining the optimal ILP unrolling factor based on loop type LT and element type ElementT.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_effect_perfect_forward_body_4d7f8a1e", "label": "for_loop_range_auto_effect_perfect_forwa", "x": 146.53192987699416, "y": 99.34962595443935, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the body parameter using std::forward<F>, preserving its value category to enable move semantics for rvalue callables and avoid unnecessary copies.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c", "label": "for_loop_range_auto_effect_perfect_forwa", "x": 53.99864516916752, "y": 172.60893300633703, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the range parameter using std::forward<Range>, preserving its value category: rvalue ranges are moved, lvalue ranges are copied or referenced.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_exception_propagates_from_impl_2b6d9e4f", "label": "for_loop_range_auto_exception_propagates", "x": 23.64317147803103, "y": 322.0073669884265, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any exceptions thrown by for_loop_range<optimal_N<LT, ElementT>>, range operations (begin/end), or body invocations are propagated to the caller without modification.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_postcond_returns_for_result_5a9e2c7b", "label": "for_loop_range_auto_postcond_returns_for", "x": 120.40211419570483, "y": 951.6663644589538, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns a ForResult object containing the result of the loop execution, semantically equivalent to the result returned by for_loop_range<optimal_N<LT, ElementT>> with the same parameters.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_precond_body_callable_7b4e1c8f", "label": "for_loop_range_auto_precond_body_callabl", "x": -91.76399313941457, "y": 207.86920378490666, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter must be a callable object (function, lambda, functor) that can be invoked with elements from the range, compatible with the for_loop_range template's requirements.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_auto_precond_range_valid_8a3f2e9d", "label": "for_loop_range_auto_precond_range_valid_", "x": -93.67183774125454, "y": 217.3157223690036, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter must be a valid range type supporting std::forward<Range>, with valid begin() and end() iterators that satisfy the requirements of the underlying for_loop_range template.", "function": "for_loop_range_auto"}, {"id": "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6", "label": "for_loop_range_constraint_rvalue_ref_par", "x": 56.734240948179625, "y": 173.4125857693786, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Both Range and F parameters are forwarding references (Range&& and F&&), accepting both lvalue and rvalue arguments with perfect forwarding semantics", "function": "for_loop_range"}, {"id": "for_loop_range_constraint_template_n_compile_time_g0h1i2j3", "label": "for_loop_range_constraint_template_n_com", "x": -189.60188816315085, "y": 376.23948736288503, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be a compile-time constant value specifying loop parallelization or unrolling factor", "function": "for_loop_range"}, {"id": "for_loop_range_effect_delegates_to_impl_y3z4a5b6", "label": "for_loop_range_effect_delegates_to_impl_", "x": -3.705402518267368, "y": 342.7435156997222, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates execution to detail::for_loop_range_untyped_impl<N> which performs the actual iteration over the range, invoking body for each element", "function": "for_loop_range"}, {"id": "for_loop_range_effect_perfect_forward_body_u0v1w2x3", "label": "for_loop_range_effect_perfect_forward_bo", "x": 103.8406709262271, "y": 133.14495381484758, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the body parameter using std::forward<F>, preserving its value category to enable move semantics for rvalue callables and avoid unnecessary copies", "function": "for_loop_range"}, {"id": "for_loop_range_effect_perfect_forward_range_q7r8s9t0", "label": "for_loop_range_effect_perfect_forward_ra", "x": 48.70916194254217, "y": 179.45421267976573, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the range parameter using std::forward<Range>, preserving its value category (lvalue ranges are preserved as lvalue references, rvalue ranges are moved)", "function": "for_loop_range"}, {"id": "for_loop_range_impl_anti_pattern_large_N_warning_b1c2d3e4", "label": "for_loop_range_impl_anti_pattern_large_N", "x": 655.5497805628654, "y": 433.42408322760986, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8", "label": "for_loop_range_impl_anti_pattern_non_ran", "x": 216.5016054761087, "y": 135.43088394524375, "size": 8.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not use with ranges whose iterators are not random access (e.g., std::list, forward_list); subscript operator it[i] required", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_complexity_space_constant_c7d8e9f0", "label": "for_loop_range_impl_complexity_space_con", "x": 86.73025948723233, "y": 326.76992702010995, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity is O(1) for local variables (it, size, i, j, ctrl); does not depend on range size", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_complexity_time_linear_a3b4c5d6", "label": "for_loop_range_impl_complexity_time_line", "x": 113.73364834666437, "y": 348.1305714283628, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(size) where size = std::ranges::size(range), with each element processed exactly once (or until ctrl.ok becomes false)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "label": "for_loop_range_impl_constraint_array_acc", "x": -126.29418541922855, "y": -27.003492746039537, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i + j] requires i + j < size, guaranteed by loop guards (i + N <= size && j < N)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_no_ctrl_c3d4e5f6", "label": "for_loop_range_impl_constraint_array_acc", "x": -36.819285894537536, "y": 621.2182761958708, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i + j] in else branch requires i + j < size, guaranteed by loop guards (i + N <= size && j < N)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_constraint_array_access_bounds_remainder_loop_a7b8c9d0", "label": "for_loop_range_impl_constraint_array_acc", "x": -213.80347999569142, "y": -72.4605713412954, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i] in remainder loop requires i < size, guaranteed by loop guard (i < size)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_constraint_array_access_bounds_remainder_loop_no_ctrl_e1f2a3b4", "label": "for_loop_range_impl_constraint_array_acc", "x": -386.8611149380332, "y": -701.3690399741155, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i] in else branch remainder loop requires i < size, guaranteed by loop guard (i < size)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8", "label": "for_loop_range_impl_constraint_body_lval", "x": 85.44803343508958, "y": 113.16352809230594, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter accepts both lvalue and rvalue callable objects via forwarding reference F&&, enabling move semantics for temporary functors", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "label": "for_loop_range_impl_constraint_range_lva", "x": 25.70927168730924, "y": 29.674352412866327, "size": 7.0, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter accepts both lvalue and rvalue references via forwarding reference Range&&, enabling use with temporary and named ranges", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_body_invocation_unrolled_d3e4f5a6", "label": "for_loop_range_impl_effect_body_invocati", "x": -135.86691120287895, "y": 586.8994827592413, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body is invoked exactly size times, in N-element unrolled chunks followed by remainder elements, with elements it[0], it[1], ..., it[size-1]", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_early_termination_ctrl_ok_b7c8d9e0", "label": "for_loop_range_impl_effect_early_termina", "x": 623.4528792732946, "y": -594.6018313093417, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When has_ctrl is true, loop terminates early if ctrl.ok becomes false, potentially invoking body fewer than size times", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8", "label": "for_loop_range_impl_effect_forwards_body", "x": 80.72989756948976, "y": 73.24758325779047, "size": 6.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards body functor parameter preserving its value category through F&& forwarding reference", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2", "label": "for_loop_range_impl_effect_forwards_rang", "x": 53.35727465564514, "y": 84.20403833265817, "size": 8.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards range parameter preserving its value category (lvalue/rvalue) through Range&& forwarding reference", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_range_single_evaluation_f9a0b1c2", "label": "for_loop_range_impl_effect_range_single_", "x": 93.79422542856825, "y": 313.3022904776947, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range expression is evaluated exactly once at function entry via std::ranges::begin() and std::ranges::size()", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_unrolling_optimization_b9c0d1e2", "label": "for_loop_range_impl_effect_unrolling_opt", "x": 933.5300009897862, "y": 47.4425217835191, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop is unrolled by factor N, processing N consecutive elements in inner loop before advancing by N, potentially improving instruction-level parallelism", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_effect_validate_unroll_factor_first_b5c6d7e8", "label": "for_loop_range_impl_effect_validate_unro", "x": -64.09772072877209, "y": -553.6743798953261, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Validates unroll factor N at compile-time as first operation before any loop execution", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_exception_body_propagates_a9b0c1d2", "label": "for_loop_range_impl_exception_body_propa", "x": -796.4838503551913, "y": 132.08713729931262, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body throws exception E during invocation, exception propagates immediately and remaining iterations are not executed", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_exception_ranges_begin_propagates_f3a4b5c6", "label": "for_loop_range_impl_exception_ranges_beg", "x": 85.52283761016562, "y": 275.9277848109333, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "If std::ranges::begin(range) throws exception E, exception propagates before loop execution", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_exception_ranges_size_propagates_d7e8f9a0", "label": "for_loop_range_impl_exception_ranges_siz", "x": 102.93725414048629, "y": 299.1589974081804, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "If std::ranges::size(range) throws exception E, exception propagates before loop execution", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_exception_validate_propagates_c5d6e7f8", "label": "for_loop_range_impl_exception_validate_p", "x": -175.87689593860551, "y": -898.7470010141894, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If validate_unroll_factor<N>() throws or fails compilation, exception/error propagates before any loop execution or body invocation", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_invariant_ctrl_state_monotonic_d9e0f1a2", "label": "for_loop_range_impl_invariant_ctrl_state", "x": -953.2216682399671, "y": -103.68275096316553, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When has_ctrl is true, ctrl.ok can only transition from true to false, never back to true (monotonic)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_invariant_index_alignment_unrolled_f7a8b9c0", "label": "for_loop_range_impl_invariant_index_alig", "x": -852.0191245310191, "y": 164.80120125934462, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "In unrolled loop, i is always aligned to N-element boundary: i % N == 0", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_invariant_index_bounds_i_c1d2e3f4", "label": "for_loop_range_impl_invariant_index_boun", "x": 665.5558691997945, "y": 628.7309893566902, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop invariant: 0 <= i <= size throughout all loop iterations", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_postcond_all_elements_processed_b3c4d5e6", "label": "for_loop_range_impl_postcond_all_element", "x": 354.8285917333941, "y": -669.8482744094155, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If ctrl.ok remains true (or has_ctrl is false), body has been invoked exactly size times with it[0] through it[size-1]", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_postcond_final_index_value_e1f2a3b4", "label": "for_loop_range_impl_postcond_final_index", "x": 619.8813160768289, "y": 661.5361654610448, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After function returns, i == size (if ctrl.ok remains true or has_ctrl is false)", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_postcond_partial_processing_ctrl_a7b8c9d0", "label": "for_loop_range_impl_postcond_partial_pro", "x": -618.6956514223597, "y": 471.412005365083, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If has_ctrl is true and ctrl.ok becomes false, body has been invoked with it[0] through it[k] for some k < size where ctrl.ok became false", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_precond_body_callable_f0a1b2c3", "label": "for_loop_range_impl_precond_body_callabl", "x": 29.536561234484005, "y": 368.58387132614206, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body must be callable with signature (Ref) or (Ref, LoopCtrl<void>&) where Ref = std::ranges::range_reference_t<Range>", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0", "label": "for_loop_range_impl_precond_iterator_ran", "x": 255.04960623272652, "y": -0.3938685424599643, "size": 12.5, "color": "#26de81", "layer": "library", "module": "", "content": "Iterator returned by std::ranges::begin(range) must support random access (subscript operator it[index])", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_precond_range_valid_b3c4d5e6", "label": "for_loop_range_impl_precond_range_valid_", "x": 28.288879427219552, "y": 257.8187831583005, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Range must be a valid range type satisfying std::ranges::sized_range and std::ranges::random_access_range, providing valid begin() and size() operations", "function": "for_loop_range_impl"}, {"id": "for_loop_range_impl_precond_unroll_factor_valid_a5b6c7d8", "label": "for_loop_range_impl_precond_unroll_facto", "x": 959.3767424679758, "y": 1.0516692426074894, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be >= 1, validated at compile-time by validate_unroll_factor<N>()", "function": "for_loop_range_impl"}, {"id": "for_loop_range_postcond_returns_forresult_c6d7e8f9", "label": "for_loop_range_postcond_returns_forresul", "x": -11.63381059325426, "y": 302.7371720855641, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns ForResult object containing the result of the range-based loop execution from the underlying implementation", "function": "for_loop_range"}, {"id": "for_loop_range_precond_body_invocable_m4n5o6p7", "label": "for_loop_range_precond_body_invocable_m4", "x": -51.37774933752668, "y": 307.74854430724145, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter must be a callable object that can be invoked with elements from the range", "function": "for_loop_range"}, {"id": "for_loop_range_precond_range_has_iterator_i1j2k3l4", "label": "for_loop_range_precond_range_has_iterato", "x": 135.27016100755446, "y": 215.393135422494, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range must provide an iterator satisfying input_or_output_iterator concept for std::ranges::begin(range)", "function": "for_loop_range"}, {"id": "for_loop_range_precond_range_sized_e7f8g9h0", "label": "for_loop_range_precond_range_sized_e7f8g", "x": 15.253606989284236, "y": 324.5382303118439, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter must be a valid sized range satisfying std::ranges::sized_range, providing valid std::ranges::size() and std::ranges::begin() expressions", "function": "for_loop_range"}, {"id": "for_loop_range_ret_simple_constraint_template_param_n_1e8c4f2d", "label": "for_loop_range_ret_simple_constraint_tem", "x": -210.21169419341837, "y": 196.58183926389864, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be a valid compile-time constant suitable for detail::for_loop_range_ret_simple_impl<N>", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_effect_delegates_to_impl_6e3f8a1c", "label": "for_loop_range_ret_simple_effect_delegat", "x": -35.54431738799359, "y": 322.0915326048083, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates to detail::for_loop_range_ret_simple_impl<N> with perfectly forwarded range and body parameters", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_effect_no_side_effects_2a5d9c3e", "label": "for_loop_range_ret_simple_effect_no_side", "x": -694.2095872801082, "y": -58.899731877222905, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This wrapper function has no side effects itself; all effects are delegated to detail::for_loop_range_ret_simple_impl<N>", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_effect_perfect_forward_body_7b2c9d4e", "label": "for_loop_range_ret_simple_effect_perfect", "x": 128.12431365569682, "y": 129.9803868930064, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the body parameter to implementation function, preserving its value category (lvalue vs rvalue) using std::forward<F>", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f", "label": "for_loop_range_ret_simple_effect_perfect", "x": 48.359391822747995, "y": 174.97909534715882, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the range parameter to implementation function, preserving its value category (lvalue vs rvalue) using std::forward<Range>", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_exception_propagates_impl_exceptions_4c7e1f8a", "label": "for_loop_range_ret_simple_exception_prop", "x": 127.284548555733, "y": 317.57770913805507, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Propagates any exceptions thrown by detail::for_loop_range_ret_simple_impl<N>, std::forward, or operations within body callable", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_impl_anti_pattern_excessive_n_p5q6r7s8", "label": "for_loop_range_ret_simple_impl_anti_patt", "x": 947.3126175409286, "y": -78.51655595092167, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_complexity_space_x3y4z5a6", "label": "for_loop_range_ret_simple_impl_complexit", "x": 25.631840706762475, "y": 335.00699062173726, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity is O(N) for temporary storage arrays (matches or results), independent of range size", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_complexity_time_t9u0v1w2", "label": "for_loop_range_ret_simple_impl_complexit", "x": -422.0597116003474, "y": -528.4222749613978, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(size) in worst case (no early return), best case O(1) (immediate match)", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_constraint_array_access_i_d1e2f3g4", "label": "for_loop_range_ret_simple_impl_constrain", "x": -199.50970021640117, "y": -4.386432787926651, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i] in remainder loop requires 0 <= i < size, guaranteed by loop guard i < size", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_constraint_array_access_i_j_z7a8b9c0", "label": "for_loop_range_ret_simple_impl_constrain", "x": -199.38083282316074, "y": 17.44542064265828, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i + j] requires 0 <= i + j < size, guaranteed by loop guard i + N <= size && j < N", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_constraint_matches_bounds_h5i6j7k8", "label": "for_loop_range_ret_simple_impl_constrain", "x": -218.3357688860117, "y": 33.671923011456194, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Array access matches[j] requires 0 <= j < N, guaranteed by loop guard j < N", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_constraint_results_bounds_l9m0n1o2", "label": "for_loop_range_ret_simple_impl_constrain", "x": -209.70538649023243, "y": 22.239229786073942, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Array access results[j] requires 0 <= j < N, guaranteed by loop guard j < N", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_constraint_return_type_convertible_f1g2h3i4", "label": "for_loop_range_ret_simple_impl_constrain", "x": -711.6664916401363, "y": -324.1151012299422, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "All return paths must yield same type R (invoke_result_t matches return type for all branches)", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_constraint_static_cast_valid_b7c8d9e0", "label": "for_loop_range_ret_simple_impl_constrain", "x": 643.0276551166929, "y": -620.6325232422898, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When R is neither bool nor optional, static_cast<R>(end_it) must be well-formed (Sentinel must be convertible to R)", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_early_return_bool_b5c6d7e8", "label": "for_loop_range_ret_simple_impl_effect_ea", "x": 273.3752065995224, "y": 115.30067207014076, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "When R is bool, returns iterator to first element where body returns true, or end_it if none found", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_early_return_optional_f9g0h1i2", "label": "for_loop_range_ret_simple_impl_effect_ea", "x": -584.8595905867327, "y": 215.23221587746576, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When R is optional-like, returns first non-empty optional result from body, or empty R{} if none found", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_early_return_sentinel_j3k4l5m6", "label": "for_loop_range_ret_simple_impl_effect_ea", "x": 539.9861135180445, "y": -670.7641823755886, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When R is neither bool nor optional, returns first result != end_it, or static_cast<R>(end_it) if none found", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_evaluates_range_once_v3w4x5y6", "label": "for_loop_range_ret_simple_impl_effect_ev", "x": 30.174541853212453, "y": 347.8317220638842, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Range expression is evaluated exactly once before loop begins (range-for semantics)", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2", "label": "for_loop_range_ret_simple_impl_effect_fo", "x": 64.7793135242955, "y": 173.35247744683056, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards range parameter preserving value category (rvalue ranges moved, lvalue ranges referenced)", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_ilp_optimization_j5k6l7m8", "label": "for_loop_range_ret_simple_impl_effect_il", "x": -650.2807849881618, "y": -66.20959408401504, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Enables instruction-level parallelism by computing N results before checking any, allowing CPU to execute body calls in parallel", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_move_semantics_n7o8p9q0", "label": "for_loop_range_ret_simple_impl_effect_mo", "x": -874.2909010264016, "y": -41.694728411553506, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns matching result using std::move for efficiency when returning from unrolled batch", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_static_cast_sentinel_r1s2t3u4", "label": "for_loop_range_ret_simple_impl_effect_st", "x": -369.6432113767031, "y": 678.8078185285237, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Performs static_cast<R>(end_it) to convert sentinel to return type R when no match found", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_unrolled_execution_x1y2z3a4", "label": "for_loop_range_ret_simple_impl_effect_un", "x": -903.1154539588102, "y": -112.13580436812973, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Executes body in unrolled batches of N iterations, then handles remainder sequentially", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_effect_validates_n_n5o6p7q8", "label": "for_loop_range_ret_simple_impl_effect_va", "x": -68.75536928338778, "y": 655.6689450788531, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "First operation validates unroll factor N via validate_unroll_factor<N>(), potentially issuing warning if N > 16", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_exception_body_propagates_h7i8j9k0", "label": "for_loop_range_ret_simple_impl_exception", "x": 182.7801791183746, "y": 561.48411401054, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body throws exception E during iteration i, exception propagates immediately without processing remaining elements", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_exception_range_ops_propagate_l1m2n3o4", "label": "for_loop_range_ret_simple_impl_exception", "x": 487.68350792644287, "y": 707.4602351287534, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If std::ranges::begin, end, or size throw exceptions, they propagate before loop execution", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_exception_validate_propagates_d3e4f5g6", "label": "for_loop_range_ret_simple_impl_exception", "x": -579.6268224220139, "y": 150.25403593936028, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If validate_unroll_factor<N>() throws exception E, it propagates before any loop execution", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_invariant_i_bounds_p3q4r5s6", "label": "for_loop_range_ret_simple_impl_invariant", "x": 169.3397431255536, "y": 303.80542922207724, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Loop invariant: at loop entry and after each iteration, 0 <= i <= size && i % N == 0 (for main loop)", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_invariant_j_bounds_t7u8v9w0", "label": "for_loop_range_ret_simple_impl_invariant", "x": 782.6468343243067, "y": -226.16741593743302, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop invariant: inner loop counter j satisfies 0 <= j < N throughout execution", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_invariant_no_overflow_n9o0p1q2", "label": "for_loop_range_ret_simple_impl_invariant", "x": -750.4907699576898, "y": -33.79049725917586, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Addition i + j and i + N cannot overflow: guaranteed by loop guards i + N <= size and j < N", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_postcond_body_invoked_z9a0b1c2", "label": "for_loop_range_ret_simple_impl_postcond_", "x": 662.4302402197313, "y": -49.351489393901716, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body has been invoked for all elements from index 0 to matching index (inclusive), or all elements if no match", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_postcond_result_valid_v5w6x7y8", "label": "for_loop_range_ret_simple_impl_postcond_", "x": -18.981339390929136, "y": 766.7175729907386, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returned value is either a successful match result or a sentinel/empty value indicating no match", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_precond_body_callable_f7g8h9i0", "label": "for_loop_range_ret_simple_impl_precond_b", "x": 35.95746317215473, "y": 326.3729821492195, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body must be callable with signature (range_reference_t<Range>, Sentinel) returning R", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_precond_n_valid_j1k2l3m4", "label": "for_loop_range_ret_simple_impl_precond_n", "x": -267.1653611763836, "y": -552.7070122219253, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be >= 1 (validated by validate_unroll_factor<N>())", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8", "label": "for_loop_range_ret_simple_impl_precond_r", "x": 142.80155255323328, "y": 157.85031426142143, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Iterator returned by std::ranges::begin(range) must support random access (subscript operator it[index])", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_impl_precond_range_valid_a1b2c3d4", "label": "for_loop_range_ret_simple_impl_precond_r", "x": 78.81907817025895, "y": 321.08067908831583, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range must be a valid range type supporting std::ranges::begin, std::ranges::end, and std::ranges::size", "function": "for_loop_range_ret_simple_impl"}, {"id": "for_loop_range_ret_simple_postcond_returns_impl_result_9f4d2e7b", "label": "for_loop_range_ret_simple_postcond_retur", "x": 815.4500479158735, "y": -511.20579247656707, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns the result of detail::for_loop_range_ret_simple_impl<N> without modification; return type is auto-deduced from implementation function", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_precond_body_callable_8d4e2f1a", "label": "for_loop_range_ret_simple_precond_body_c", "x": 39.467762483453456, "y": 312.382345000804, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter must be a callable object that can be invoked with elements from the range", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_ret_simple_precond_range_valid_5a7b3c9d", "label": "for_loop_range_ret_simple_precond_range_", "x": 74.44678875812433, "y": 328.49634716948, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter must satisfy range concept requirements: must have begin() and end() iterators that define a valid range", "function": "for_loop_range_ret_simple"}, {"id": "for_loop_range_typed_anti_pattern_no_guard_f2a3b4c5", "label": "for_loop_range_typed_anti_pattern_no_gua", "x": -687.5336320376118, "y": 143.91768037099737, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not pass temporary ranges that would be destroyed before iteration completes if implementation stores iterators/references", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_auto_complexity_delegates_complexity_c6d7e8f9", "label": "for_loop_range_typed_auto_complexity_del", "x": 1.2859411932683982, "y": 330.0252276177219, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) wrapper overhead plus the complexity of for_loop_range_typed<R, optimal_N<LT, ElementT>>, which depends on range size and body execution time.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_constraint_element_type_compatible_d4e5f6a7", "label": "for_loop_range_typed_auto_constraint_ele", "x": 13.014617722900454, "y": 333.77838739046257, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "ElementT must be the element type of Range and must be compatible with the loop type LT for optimal_N instantiation.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_constraint_optimal_n_valid_c2d3e4f5", "label": "for_loop_range_typed_auto_constraint_opt", "x": -214.24422049107966, "y": 198.91063192943213, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "The template parameter optimal_N<LT, ElementT> must resolve to a valid compile-time constant representing the ILP unrolling factor, compatible with for_loop_range_typed instantiation.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_effect_delegates_to_typed_f2a3b4c5", "label": "for_loop_range_typed_auto_effect_delegat", "x": 10.41488095668099, "y": 321.89909148836966, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates to for_loop_range_typed<R, optimal_N<LT, ElementT>> with automatically determined ILP factor, executing the loop body over the range with the optimal unrolling.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_effect_perfect_forward_body_b9c0d1e2", "label": "for_loop_range_typed_auto_effect_perfect", "x": 128.77469353011998, "y": 109.78517209828703, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the body parameter using std::forward<F>, preserving its value category to enable move semantics for rvalue callables and avoid unnecessary copies.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "label": "for_loop_range_typed_auto_effect_perfect", "x": 56.42006832805487, "y": 177.31633402128173, "size": 6.0, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards the range parameter using std::forward<Range>, preserving its value category (lvalue vs rvalue) to enable move semantics for rvalue ranges.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_exception_propagates_from_delegate_d5e6f7a8", "label": "for_loop_range_typed_auto_exception_prop", "x": -21.727658390601643, "y": 297.0402601464366, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Propagates any exceptions thrown by for_loop_range_typed<R, optimal_N<LT, ElementT>>, including exceptions from range iteration or body invocation.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_postcond_returns_for_result_typed_e3f4a5b6", "label": "for_loop_range_typed_auto_postcond_retur", "x": -210.7489598286121, "y": 669.2427887685365, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns a ForResultTyped<R> object containing the result of the loop execution, equivalent to the result returned by for_loop_range_typed<R, optimal_N<LT, ElementT>>.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_precond_body_callable_e5f6a7b8", "label": "for_loop_range_typed_auto_precond_body_c", "x": -23.403098185054237, "y": 321.7272423906096, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter F must be a callable object (function, lambda, functor) that accepts elements from the range and satisfies the requirements of for_loop_range_typed.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4", "label": "for_loop_range_typed_auto_precond_range_", "x": -8.228535290557323, "y": 278.3753450967265, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Range must be a valid range type that satisfies the requirements of std::forward<Range>, providing valid begin() and end() iterators that can be used with for_loop_range_typed.", "function": "for_loop_range_typed_auto"}, {"id": "for_loop_range_typed_complexity_delegates_impl_a3b4c5d6", "label": "for_loop_range_typed_complexity_delegate", "x": 540.6586741502631, "y": -638.3064570573185, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) for wrapper delegation plus complexity of detail::for_loop_range_typed_impl; space complexity O(1) for forwarding references", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "label": "for_loop_range_typed_constraint_body_rva", "x": 11.493969586597373, "y": -5.077650176684022, "size": 6.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter must be a forwarding reference (F&&) accepting both lvalue and rvalue callables", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_constraint_range_rvalue_ref_c9d0e1f2", "label": "for_loop_range_typed_constraint_range_rv", "x": 34.0115401166265, "y": 196.85622861835068, "size": 5.0, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter must be a forwarding reference (Range&&) accepting both lvalues and rvalues", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_effect_delegates_impl_e5f6a7b8", "label": "for_loop_range_typed_effect_delegates_im", "x": -573.7450463249198, "y": -444.3568392440893, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates all iteration logic to detail::for_loop_range_typed_impl<R, N> with perfectly forwarded parameters", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_effect_perfect_forward_body_a7b8c9d0", "label": "for_loop_range_typed_effect_perfect_forw", "x": 102.78741788943317, "y": 122.71455875224444, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards body parameter preserving value category, enabling move semantics for rvalue callables", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9", "label": "for_loop_range_typed_effect_perfect_forw", "x": 53.29117332039324, "y": 172.3731338644136, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards range parameter preserving value category: rvalue ranges are moved, lvalue ranges are copied/referenced", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_exception_propagates_impl_e1f2a3b4", "label": "for_loop_range_typed_exception_propagate", "x": 51.622139113743884, "y": 327.2538328263958, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Propagates any exceptions thrown by detail::for_loop_range_typed_impl, including exceptions from body invocations or range operations", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_impl_anti_pattern_large_unroll_r3s4t5u6", "label": "for_loop_range_typed_impl_anti_pattern_l", "x": -114.72289665919172, "y": -586.2040789203933, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_complexity_space_constant_z1a2b3c4", "label": "for_loop_range_typed_impl_complexity_spa", "x": -840.9488003957613, "y": -23.43789756750603, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity is O(1) excluding storage in ForCtrlTyped<R> which depends on R", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_complexity_time_linear_v7w8x9y0", "label": "for_loop_range_typed_impl_complexity_tim", "x": 74.12369663709754, "y": 316.36657975504994, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(size) where size = std::ranges::size(range), with constant factor improvement from unrolling", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_constraint_addition_no_overflow_h9i0j1k2", "label": "for_loop_range_typed_impl_constraint_add", "x": -364.2226661763772, "y": -675.9302850492655, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Addition i + j and i + N must not overflow std::size_t (guaranteed by loop guards)", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0", "label": "for_loop_range_typed_impl_constraint_arr", "x": -147.12122623588957, "y": 65.4454483773899, "size": 8.5, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i + j] requires (i + j) < size, protected by loop guards (i + N <= size) && (j < N)", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4", "label": "for_loop_range_typed_impl_constraint_arr", "x": -123.65004823611295, "y": -8.022134524095081, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i] requires i < size, protected by loop guard (i < size)", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_constraint_size_representable_d5e6f7g8", "label": "for_loop_range_typed_impl_constraint_siz", "x": 48.191474425044916, "y": 345.33412103841806, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Range size must be representable as std::size_t without overflow", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_effect_evaluates_range_once_h7i8j9k0", "label": "for_loop_range_typed_impl_effect_evaluat", "x": 18.408873268194835, "y": 277.61948725507773, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range expression is evaluated exactly once via std::ranges::begin and std::ranges::size before loop begins", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8", "label": "for_loop_range_typed_impl_effect_forward", "x": 11.305181307716694, "y": 266.2315278971614, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter is perfectly forwarded preserving its value category (lvalue/rvalue)", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_effect_invokes_body_unrolled_l1m2n3o4", "label": "for_loop_range_typed_impl_effect_invokes", "x": 93.5397496940242, "y": 348.0163789102923, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body is invoked once per element in range with unrolling factor N in inner loop, stopping early if ctrl.ok becomes false", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_effect_validates_unroll_d3e4f5g6", "label": "for_loop_range_typed_impl_effect_validat", "x": 580.4117067731695, "y": -622.0325925991367, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "First operation validates unroll factor N via validate_unroll_factor<N>() before any loop execution", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_exception_body_propagates_j5k6l7m8", "label": "for_loop_range_typed_impl_exception_body", "x": -840.27651099011, "y": -449.63829448790267, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body throws exception E, exception propagates to caller and loop terminates", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_exception_range_ops_propagate_n9o0p1q2", "label": "for_loop_range_typed_impl_exception_rang", "x": -570.3266433988134, "y": 25.79986738828564, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If std::ranges::begin or std::ranges::size throw, exception propagates before any loop execution", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_exception_validate_propagates_f1g2h3i4", "label": "for_loop_range_typed_impl_exception_vali", "x": 193.61939437995875, "y": 869.622027863346, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If validate_unroll_factor<N>() fails (static_assert), compilation fails before runtime", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_invariant_ctrl_consistency_v5w6x7y8", "label": "for_loop_range_typed_impl_invariant_ctrl", "x": -294.09015572483435, "y": 214.40948255094776, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ForCtrlTyped<R> ctrl maintains consistent state: if !ctrl.ok, then ctrl.return_set is true and ctrl.storage contains valid return value", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_invariant_loop_progress_z9a0b1c2", "label": "for_loop_range_typed_impl_invariant_loop", "x": -673.0459016347589, "y": -745.1958342280976, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop index i is monotonically increasing and satisfies 0 <= i <= size throughout execution", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_postcond_all_elements_processed_b7c8d9e0", "label": "for_loop_range_typed_impl_postcond_all_e", "x": 32.24995066118203, "y": 370.91154656361886, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body is invoked exactly once for each element in range [0, size) unless early termination via ctrl.ok", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_postcond_early_return_typed_t9u0v1w2", "label": "for_loop_range_typed_impl_postcond_early", "x": 597.4134515386213, "y": -636.4808101693685, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body sets ctrl.ok to false, function returns ForResultTyped<R>{true, moved ctrl.storage} immediately", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_postcond_normal_completion_x3y4z5a6", "label": "for_loop_range_typed_impl_postcond_norma", "x": -962.772332096248, "y": -60.344753020891396, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If all iterations complete without ctrl.ok becoming false, returns ForResultTyped<R>{false, {}}", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_precond_body_callable_typed_f9g0h1i2", "label": "for_loop_range_typed_impl_precond_body_c", "x": -354.95399381194096, "y": -845.2648418533671, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body must be callable with signature (decltype(it[i]), ForCtrlTyped<R>&)", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8", "label": "for_loop_range_typed_impl_precond_iterat", "x": 209.07925097156846, "y": 134.28509899696928, "size": 9.0, "color": "#26de81", "layer": "library", "module": "", "content": "Iterator returned by std::ranges::begin(range) must support subscript operator (random_access_iterator)", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_precond_range_valid_a1b2c3d4", "label": "for_loop_range_typed_impl_precond_range_", "x": 85.33685837855626, "y": 279.86990201799205, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range must be a valid range type supporting std::ranges::begin and std::ranges::size", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_impl_precond_unroll_factor_valid_j3k4l5m6", "label": "for_loop_range_typed_impl_precond_unroll", "x": -708.0070770042299, "y": -250.46902099327113, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be >= 1 (validated by validate_unroll_factor<N>())", "function": "for_loop_range_typed_impl"}, {"id": "for_loop_range_typed_postcond_returns_typed_result_b8c9d0e1", "label": "for_loop_range_typed_postcond_returns_ty", "x": 21.303559841385045, "y": 335.5852594974855, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns ForResultTyped<R> containing results of all body invocations over the range", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_precond_body_callable_d4e5f6a7", "label": "for_loop_range_typed_precond_body_callab", "x": 434.42046193086185, "y": -743.221032930627, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter must be a callable accepting appropriate iteration parameters and returning type compatible with R", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "label": "for_loop_range_typed_precond_n_valid_off", "x": -140.02762204784116, "y": 82.16373841071078, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be greater than or equal to any internal offset used in implementation", "function": "for_loop_range_typed"}, {"id": "for_loop_range_typed_precond_range_valid_c4d5e6f7", "label": "for_loop_range_typed_precond_range_valid", "x": 19.97650782423959, "y": 348.4064692410303, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Range parameter must be a valid sized range type providing valid begin() and size() operations", "function": "for_loop_range_typed"}, {"id": "for_loop_range_untyped_impl_anti_pattern_large_n_f8a9b0c1", "label": "for_loop_range_untyped_impl_anti_pattern", "x": 835.1880170223278, "y": -198.89742836493232, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using N > 16 without careful consideration; large unroll factors cause code bloat", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_complexity_linear_a9b0c1d2", "label": "for_loop_range_untyped_impl_complexity_l", "x": -81.360159534062, "y": 317.34024711750635, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity: O(size) where size = std::ranges::size(range), with exactly size body invocations (unless early termination)", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_complexity_space_constant_b0c1d2e3", "label": "for_loop_range_untyped_impl_complexity_s", "x": 790.1034723884977, "y": 8.799419619772335, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity: O(1) excluding space used by body callable", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "label": "for_loop_range_untyped_impl_constraint_a", "x": -120.5231552904002, "y": -6.0480668819687216, "size": 18, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i] requires 0 <= i < size, protected by loop guard i < size", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_constraint_array_bounds_unrolled_a7b8c9d0", "label": "for_loop_range_untyped_impl_constraint_a", "x": -190.8178825484324, "y": -957.24758750973, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Array access it[i + j] requires 0 <= i + j < size, protected by loop guards i + N <= size && j < N", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5", "label": "for_loop_range_untyped_impl_constraint_b", "x": 185.45475947786582, "y": 14.283935913143848, "size": 7.5, "color": "#26de81", "layer": "library", "module": "", "content": "F&& is a forwarding reference accepting both lvalue and rvalue callables", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "label": "for_loop_range_untyped_impl_constraint_f", "x": -31.616059736047177, "y": 60.08360995087752, "size": 8.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range&& is a forwarding reference accepting both lvalue and rvalue ranges", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_effect_body_invocations_c9d0e1f2", "label": "for_loop_range_untyped_impl_effect_body_", "x": 362.96761166781846, "y": 523.5386158045845, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body is invoked exactly size times (once per element) unless early return via ctrl.ok == false", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_effect_ctrl_mutation_d0e1f2a3", "label": "for_loop_range_untyped_impl_effect_ctrl_", "x": -347.5142010538475, "y": 730.2895211985251, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ForCtrl object is passed by reference to body, allowing body to signal early termination via ctrl.ok = false", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_effect_range_eval_once_f6a7b8c9", "label": "for_loop_range_untyped_impl_effect_range", "x": 86.85473089197393, "y": 322.11439335015314, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range is evaluated exactly once via std::ranges::begin and std::ranges::size before loop execution", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_effect_storage_move_c5d6e7f8", "label": "for_loop_range_untyped_impl_effect_stora", "x": 542.7227117527775, "y": -476.36361346401867, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "On early return, ctrl.storage is moved into result, leaving ctrl.storage in valid but unspecified state", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_effect_unroll_optimization_e3f4a5b6", "label": "for_loop_range_untyped_impl_effect_unrol", "x": -297.63038567105207, "y": 907.9852005248287, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop is unrolled by factor N: processes N elements per outer iteration where possible, with remainder loop for elements beyond last full unrolled block", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_effect_validate_first_e5f6a7b8", "label": "for_loop_range_untyped_impl_effect_valid", "x": -930.2283825224441, "y": 322.935663082805, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "First operation validates unroll factor N before any loop execution", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_exception_body_propagates_e7f8a9b0", "label": "for_loop_range_untyped_impl_exception_bo", "x": 552.8666800815452, "y": 346.15786934885733, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body throws exception, it propagates immediately to caller", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_exception_validate_propagates_d6e7f8a9", "label": "for_loop_range_untyped_impl_exception_va", "x": 935.0703732868019, "y": -294.85700695545984, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If validate_unroll_factor<N>() throws, exception propagates before any loop execution", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_invariant_loop_bounds_a3b4c5d6", "label": "for_loop_range_untyped_impl_invariant_lo", "x": -230.34383943563503, "y": -837.8938482367914, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop invariant: 0 <= i <= size throughout execution", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_invariant_unrolled_bounds_b4c5d6e7", "label": "for_loop_range_untyped_impl_invariant_un", "x": -72.51350162698286, "y": -679.3131553211603, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "In unrolled loop: i + N <= size at loop entry, ensuring all N iterations are valid", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_postcond_early_return_f2a3b4c5", "label": "for_loop_range_untyped_impl_postcond_ear", "x": -263.1529543988178, "y": 752.3875975601507, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If any body invocation sets ctrl.ok = false, returns ForResult{ctrl.return_set, std::move(ctrl.storage)} immediately", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_postcond_normal_return_e1f2a3b4", "label": "for_loop_range_untyped_impl_postcond_nor", "x": 784.348453758618, "y": -486.10648694415175, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If all body invocations complete with ctrl.ok == true, returns ForResult{false, {}}", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_precond_body_callable_c3d4e5f6", "label": "for_loop_range_untyped_impl_precond_body", "x": -168.05572847221558, "y": 892.1062726851818, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body must be callable with signature (auto&&, ForCtrl&)", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5", "label": "for_loop_range_untyped_impl_precond_iter", "x": 202.54464180431938, "y": 159.64763403458704, "size": 9.5, "color": "#26de81", "layer": "library", "module": "", "content": "Iterator returned by std::ranges::begin(range) must support random access (subscript operator)", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_precond_n_valid_d4e5f6a7", "label": "for_loop_range_untyped_impl_precond_n_va", "x": -751.1231975285019, "y": 209.46040357763854, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be >= 1 (validated at compile-time)", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_range_untyped_impl_precond_range_sized_a1b2c3d4", "label": "for_loop_range_untyped_impl_precond_rang", "x": 51.92441247956868, "y": 367.37305745076077, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Range must satisfy std::ranges::sized_range to support std::ranges::size(range)", "function": "for_loop_range_untyped_impl"}, {"id": "for_loop_typed_auto_complexity_delegates_c9d0e1f2", "label": "for_loop_typed_auto_complexity_delegates", "x": -522.02274722859, "y": 20.19385981190677, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) for this wrapper plus the complexity of for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, body), which depends on (end - start) and body execution cost", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_constraint_f_callable_d4e5f6a7", "label": "for_loop_typed_auto_constraint_f_callabl", "x": -47.5476418285398, "y": 573.9955430622728, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "F must be a callable type (function, lambda, functor) compatible with the signature expected by for_loop_typed", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_constraint_optimal_n_valid_b2c3d4e5", "label": "for_loop_typed_auto_constraint_optimal_n", "x": -202.99665726967766, "y": 205.41244180981695, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "optimal_N<LT, ElementT> must evaluate to a valid positive compile-time constant suitable as template parameter", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_constraint_t_integral_c3d4e5f6", "label": "for_loop_typed_auto_constraint_t_integra", "x": 633.0234751485424, "y": 178.0964065051973, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type T must support loop operations required by LT (comparison, increment) and be compatible with optimal_N instantiation", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_effect_delegates_typed_e5f6a7b8", "label": "for_loop_typed_auto_effect_delegates_typ", "x": 753.1443605211787, "y": 511.0087481447412, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates to for_loop_typed<R, optimal_N<LT, ElementT>> with automatic unroll factor determination, forwarding body with perfect forwarding", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_effect_perfect_forward_f6a7b8c9", "label": "for_loop_typed_auto_effect_perfect_forwa", "x": 126.67795153463378, "y": 122.94911548877401, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Uses std::forward<F>(body) to preserve value category: rvalue references enable move semantics, lvalue references preserve copying semantics", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1", "label": "for_loop_typed_auto_exception_propagates", "x": 300.9962851470173, "y": -430.9188983896994, "size": 8.0, "color": "#26de81", "layer": "library", "module": "", "content": "Propagates any exceptions thrown by for_loop_typed<R, optimal_N<LT, ElementT>> or during body execution", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_postcond_returns_typed_a7b8c9d0", "label": "for_loop_typed_auto_postcond_returns_typ", "x": 529.8378293960695, "y": -305.44140128861727, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Returns ForResultTyped<R> containing the result of the loop execution as determined by for_loop_typed", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_auto_precond_valid_range_a1b2c3d4", "label": "for_loop_typed_auto_precond_valid_range_", "x": 42.25399564319386, "y": 322.38151012588077, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "start and end must form a valid range according to loop type LT semantics (start <= end for forward iteration)", "function": "for_loop_typed_auto"}, {"id": "for_loop_typed_complexity_space_b3c4d5e6", "label": "for_loop_typed_complexity_space_b3c4d5e6", "x": 683.0356310191149, "y": 692.6760198790108, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity is O(1) excluding the space used by body callable and return value storage", "function": "for_loop_typed"}, {"id": "for_loop_typed_complexity_time_b2c3d4e5", "label": "for_loop_typed_complexity_time_b2c3d4e5", "x": -463.4070629598337, "y": 495.2737751656256, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O((end - start) * C) where C is the complexity of body invocation, with constant factor improvement from unrolling by N", "function": "for_loop_typed"}, {"id": "for_loop_typed_constraint_return_type_r_b1c2d3e4", "label": "for_loop_typed_constraint_return_type_r_", "x": -197.47482987366672, "y": 218.7499803543566, "size": 7.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter R must be default-constructible and stored in ForResultTyped<R> for early return values", "function": "for_loop_typed"}, {"id": "for_loop_typed_constraint_template_params_a9b0c1d2", "label": "for_loop_typed_constraint_template_param", "x": -673.958405800942, "y": -361.12290401717587, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be a positive compile-time constant representing the unroll factor", "function": "for_loop_typed"}, {"id": "for_loop_typed_constraint_type_t_requirements_b0c1d2e3", "label": "for_loop_typed_constraint_type_t_require", "x": -90.22800670817774, "y": 767.9825415988727, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type T must support comparison operators (<=), increment (++), and addition (+) for loop iteration", "function": "for_loop_typed"}, {"id": "for_loop_typed_effect_delegates_impl_a4b5c6d7", "label": "for_loop_typed_effect_delegates_impl_a4b", "x": -784.472686473993, "y": 406.6639124175976, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Delegates all iteration logic to for_loop_typed_impl with template parameters R and N, forwarding start, end, and body", "function": "for_loop_typed"}, {"id": "for_loop_typed_effect_perfect_forward_a5b6c7d8", "label": "for_loop_typed_effect_perfect_forward_a5", "x": 126.39325720486748, "y": 115.511119383043, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Perfectly forwards body parameter to preserve its value category (lvalue/rvalue) using std::forward<F>", "function": "for_loop_typed"}, {"id": "for_loop_typed_effect_unroll_optimization_a6b7c8d9", "label": "for_loop_typed_effect_unroll_optimizatio", "x": -47.950506480746455, "y": -629.608210392347, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Invokes body for each value in [start, end) using loop unrolling by factor N for instruction-level parallelism", "function": "for_loop_typed"}, {"id": "for_loop_typed_impl_anti_pattern_large_N_4m5n6o7p", "label": "for_loop_typed_impl_anti_pattern_large_N", "x": 459.42117992026965, "y": -289.5721935528343, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using N > 16; large unroll factors cause code bloat and may reduce performance", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_anti_pattern_narrow_type_8q9r0s1t", "label": "for_loop_typed_impl_anti_pattern_narrow_", "x": -612.3940529360268, "y": -641.738518955545, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using narrow integer types (int8_t, uint8_t) when N is large or range is large; risk of overflow", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_complexity_space_6y7z8a9b", "label": "for_loop_typed_impl_complexity_space_6y7", "x": 78.12266127755412, "y": 867.4651405362687, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity is O(1) for loop state plus sizeof(ForCtrlTyped<R>) plus space used by body", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_complexity_time_2u3v4w5x", "label": "for_loop_typed_impl_complexity_time_2u3v", "x": -290.810206007016, "y": 624.7535535918755, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(end - start) body invocations plus O(1) overhead from validate_unroll_factor", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_constraint_forwarding_reference_4g5h6i7j", "label": "for_loop_typed_impl_constraint_forwardin", "x": 135.44673575142022, "y": 148.3276503602606, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Parameter F&& is a forwarding reference accepting both lvalue and rvalue callable objects", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_constraint_static_cast_valid_2a3b4c5d", "label": "for_loop_typed_impl_constraint_static_ca", "x": 749.4590881099731, "y": 182.6086627471764, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "static_cast<T>(j) and static_cast<T>(N) must be valid conversions from std::size_t to T", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_constraint_type_T_arithmetic_8w9x0y1z", "label": "for_loop_typed_impl_constraint_type_T_ar", "x": 248.70229297628023, "y": 868.7664583755702, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type T must support arithmetic operations: addition, comparison (<=, <), and increment (+=)", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_effect_body_invocation_count_6q7r8s9t", "label": "for_loop_typed_impl_effect_body_invocati", "x": -328.94503930187614, "y": -540.5730107814861, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body is invoked exactly (end - start) times if ctrl.ok remains true throughout execution", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_effect_early_return_on_break_0u1v2w3x", "label": "for_loop_typed_impl_effect_early_return_", "x": -887.4027451758277, "y": 451.0274871502155, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body sets ctrl.ok = false, iteration stops immediately and returns ForResultTyped with ctrl.storage", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_effect_move_semantics_0c1d2e3f", "label": "for_loop_typed_impl_effect_move_semantic", "x": 514.0056185227409, "y": -746.5741293161802, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When returning early, ctrl.storage is moved (not copied) into return value, leaving ctrl.storage in moved-from state", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_effect_remainder_iteration_8c9d0e1f", "label": "for_loop_typed_impl_effect_remainder_ite", "x": 463.321816607778, "y": -259.40312086497795, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Remainder loop handles final (end - i) iterations when (end - i) < N", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_effect_unrolled_iteration_4y5z6a7b", "label": "for_loop_typed_impl_effect_unrolled_iter", "x": -526.2925398779341, "y": 849.0266509998021, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Unrolled loop invokes body N times per outer iteration with indices i, i+1, ..., i+N-1", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_effect_validate_first_2m3n4o5p", "label": "for_loop_typed_impl_effect_validate_firs", "x": -463.60899353310896, "y": -771.8591383587951, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "First operation validates unroll factor N via validate_unroll_factor<N>() before any loop execution", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_exception_body_throws_0i1j2k3l", "label": "for_loop_typed_impl_exception_body_throw", "x": 230.65040708474024, "y": 645.2660205516983, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body throws exception, it propagates immediately; ctrl.ok check is bypassed", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_exception_validate_propagates_6e7f8g9h", "label": "for_loop_typed_impl_exception_validate_p", "x": -934.0193302403543, "y": 241.28795045362975, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If validate_unroll_factor<N>() throws, exception propagates before any loop execution", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_invariant_ctrl_state_consistent_0o1p2q3r", "label": "for_loop_typed_impl_invariant_ctrl_state", "x": 64.00069358047074, "y": -854.0399142867814, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ctrl.ok == true OR function has returned; once ctrl.ok becomes false, no further iterations occur", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_invariant_index_bounds_4s5t6u7v", "label": "for_loop_typed_impl_invariant_index_boun", "x": -761.8751192070573, "y": 158.9541768554768, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop index i satisfies start <= i <= end throughout execution", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_postcond_complete_iteration_2g3h4i5j", "label": "for_loop_typed_impl_postcond_complete_it", "x": -305.219854768036, "y": 880.6144762946291, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If function returns ForResultTyped{false, {}}, all (end - start) iterations completed successfully with ctrl.ok == true", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_postcond_early_return_6k7l8m9n", "label": "for_loop_typed_impl_postcond_early_retur", "x": 449.61885923698554, "y": 874.7288579486365, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If function returns ForResultTyped{true, storage}, body set ctrl.ok = false at some iteration, and storage contains moved ctrl.storage", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_precond_addition_no_overflow_4f5g6h7i", "label": "for_loop_typed_impl_precond_addition_no_", "x": -333.82409496919803, "y": 905.8679285882341, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "i + static_cast<T>(j) must not overflow for all iterations where j < N", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_precond_body_callable_a1b2c3d4", "label": "for_loop_typed_impl_precond_body_callabl", "x": -151.6891529474171, "y": -572.7083692440817, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Body must be a callable object accepting (T, ForCtrlTyped<R>&) signature", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_precond_increment_no_overflow_8i9j0k1l", "label": "for_loop_typed_impl_precond_increment_no", "x": -689.4695222558224, "y": -666.4369489876073, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "i += static_cast<T>(N) must not overflow during unrolled loop iterations", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_precond_range_valid_9c8d7e6f", "label": "for_loop_typed_impl_precond_range_valid_", "x": 610.414627597385, "y": -74.93304790729131, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "start <= end to ensure non-negative iteration count", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_impl_precond_valid_unroll_factor_e5f6a7b8", "label": "for_loop_typed_impl_precond_valid_unroll", "x": -663.9566960438444, "y": 225.24826690784857, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be >= 1 (validated at compile time)", "function": "for_loop_typed_impl"}, {"id": "for_loop_typed_postcond_early_return_a8b9c0d1", "label": "for_loop_typed_postcond_early_return_a8b", "x": -640.396109203068, "y": 191.05428780832165, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body returns LoopControl with early_return set, returns ForResultTyped<R>{true, value}: return_set is true and storage contains the returned value", "function": "for_loop_typed"}, {"id": "for_loop_typed_postcond_success_return_a7b8c9d0", "label": "for_loop_typed_postcond_success_return_a", "x": -240.65322278239574, "y": 723.7070267231427, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If all iterations complete successfully without early return, returns ForResultTyped<R>{false, R{}}: return_set is false and storage is default-constructed", "function": "for_loop_typed"}, {"id": "for_loop_typed_precond_body_callable_a3b4c5d6", "label": "for_loop_typed_precond_body_callable_a3b", "x": 775.1211716972674, "y": -79.44410707310448, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "body must be callable with signature compatible with void(T) or return LoopControl", "function": "for_loop_typed"}, {"id": "for_loop_typed_precond_no_overflow_a2b3c4d5", "label": "for_loop_typed_precond_no_overflow_a2b3c", "x": -50.71589029744122, "y": 331.3665277664085, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "The iteration range must not cause overflow when computing i + N during unrolled loop iterations", "function": "for_loop_typed"}, {"id": "for_loop_typed_precond_valid_range_a1b2c3d4", "label": "for_loop_typed_precond_valid_range_a1b2c", "x": 32.67182769728745, "y": 331.73269351933135, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "start must be less than or equal to end to form a valid iteration range", "function": "for_loop_typed"}, {"id": "for_loop_untyped_impl_anti_pattern_large_n", "label": "for_loop_untyped_impl_anti_pattern_large", "x": -493.5074137248741, "y": -712.7909134086152, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_complexity_space_constant", "label": "for_loop_untyped_impl_complexity_space_c", "x": -462.25816434916123, "y": -250.900575185652, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Space complexity is O(1) for local variables (ctrl, i, j), excluding space used by body callable or ctrl.storage", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_complexity_time_linear", "label": "for_loop_untyped_impl_complexity_time_li", "x": 663.5330757079173, "y": -488.472665636899, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(end - start) body invocations, plus O(1) overhead for validate_unroll_factor<N>()", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_constraint_addition_no_overflow", "label": "for_loop_untyped_impl_constraint_additio", "x": -172.23318982684225, "y": 725.7584670581266, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "For all iterations, i + static_cast<T>(j) must not overflow where j < N", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_constraint_forwarding_reference", "label": "for_loop_untyped_impl_constraint_forward", "x": 135.59532151385866, "y": 102.16607540429814, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Body parameter F&& is a forwarding reference accepting both lvalue and rvalue callable objects, enabling move semantics for temporary functors", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_constraint_loop_increment_no_overflow", "label": "for_loop_untyped_impl_constraint_loop_in", "x": -111.7560299618212, "y": -611.4621607487966, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop increment i += static_cast<T>(N) must not overflow for any iteration", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_constraint_static_cast_valid", "label": "for_loop_untyped_impl_constraint_static_", "x": 711.1330782476969, "y": -634.911613485789, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "static_cast<T>(j) where j is std::size_t in [0, N) must be well-defined and produce values <= N-1", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_effect_body_invocation_count", "label": "for_loop_untyped_impl_effect_body_invoca", "x": 855.0693894379478, "y": 279.8172157599855, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "body is invoked exactly (end - start) times if no early return occurs, with index values [start, end)", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_effect_early_return_on_ctrl_not_ok", "label": "for_loop_untyped_impl_effect_early_retur", "x": 63.5399214908452, "y": -948.8492805892275, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body sets ctrl.ok to false, function returns immediately with ForResult{ctrl.return_set, std::move(ctrl.storage)}", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_effect_move_ctrl_storage", "label": "for_loop_untyped_impl_effect_move_ctrl_s", "x": -129.12487938214346, "y": -543.848711015399, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "On early return, ctrl.storage is moved into the returned ForResult, leaving ctrl.storage in a valid but unspecified state", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_effect_validate_first", "label": "for_loop_untyped_impl_effect_validate_fi", "x": -744.9904440336746, "y": 250.4520552001213, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "First operation validates unroll factor N via validate_unroll_factor<N>() before any loop execution", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_exception_body_propagates", "label": "for_loop_untyped_impl_exception_body_pro", "x": 982.0163084352275, "y": 110.03401309866375, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If body(i, ctrl) throws an exception E, it propagates to the caller; no exception safety guarantees on ctrl state", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_exception_validate_propagates", "label": "for_loop_untyped_impl_exception_validate", "x": 348.82394963972, "y": -851.7189593792349, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If validate_unroll_factor<N>() throws or fails, exception propagates before any loop execution or body invocations", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_invariant_ctrl_state_consistent", "label": "for_loop_untyped_impl_invariant_ctrl_sta", "x": -96.78121474836786, "y": -836.029192882975, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Throughout execution, ctrl.ok == true implies continued iteration; ctrl.ok == false triggers immediate return", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_invariant_loop_counter_bounds", "label": "for_loop_untyped_impl_invariant_loop_cou", "x": 188.64719003192604, "y": 910.4902519086127, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop counter i satisfies start <= i <= end throughout execution", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_postcond_early_return", "label": "for_loop_untyped_impl_postcond_early_ret", "x": 262.55976656269473, "y": -836.1572288146599, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If early return occurs, returns ForResult{ctrl.return_set, moved(ctrl.storage)} with return_set reflecting the control state", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_postcond_normal_return", "label": "for_loop_untyped_impl_postcond_normal_re", "x": -539.3359392212889, "y": 214.72638099096017, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If no early return occurs (ctrl.ok remains true for all iterations), returns ForResult{false, {}} with empty storage", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_precond_body_callable", "label": "for_loop_untyped_impl_precond_body_calla", "x": -118.49420321114569, "y": 774.7780880891618, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "body must be a callable object invocable with signature (T, ForCtrl&)", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_precond_n_positive", "label": "for_loop_untyped_impl_precond_n_positive", "x": 722.1546690370977, "y": 244.5878790608755, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be >= 1", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_precond_range_valid", "label": "for_loop_untyped_impl_precond_range_vali", "x": -272.5180974378203, "y": -672.1280518715093, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "start must be <= end to avoid undefined behavior in loop iteration", "function": "for_loop_untyped_impl"}, {"id": "for_loop_untyped_impl_precond_t_arithmetic", "label": "for_loop_untyped_impl_precond_t_arithmet", "x": -802.6537271591689, "y": -255.78824821573394, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type T must support arithmetic operations: addition (+=), comparison (<=, <), and static_cast from std::size_t", "function": "for_loop_untyped_impl"}, {"id": "ilp_always_inline.anti_pattern.definition_placement", "label": "ilp_always_inline.anti_pattern.definitio", "x": -178.66220098890423, "y": 598.1055109620174, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Functions declared with ILP_ALWAYS_INLINE must have their definition visible at all call sites (typically header-only), otherwise inlining cannot occur and compilation may fail", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline.complexity.code_size", "label": "ilp_always_inline.complexity.code_size", "x": 250.1261984027836, "y": -879.8180051036635, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Functions marked with ILP_ALWAYS_INLINE will increase code size at each call site due to forced inlining; use only for performance-critical small functions", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline.constraint.compiler_support", "label": "ilp_always_inline.constraint.compiler_su", "x": -125.43924199729015, "y": -707.2434966802678, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The [[gnu::always_inline]] attribute requires GCC, Clang, or compatible compiler support for GNU attributes", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline.constraint.usage_context", "label": "ilp_always_inline.constraint.usage_conte", "x": -628.5359498896374, "y": 556.5699027681386, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_ALWAYS_INLINE must be used in function declaration context where both attributes and inline specifier are valid", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline.effect.inlining_semantics", "label": "ilp_always_inline.effect.inlining_semant", "x": -935.3893242521607, "y": -126.83919791335825, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Functions declared with ILP_ALWAYS_INLINE must be inlined at all call sites; compiler will emit error or warning if inlining fails, unlike plain inline which is only a hint", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline.postcondition.attribute_expansion", "label": "ilp_always_inline.postcondition.attribut", "x": -538.4716383870407, "y": 691.3448099739642, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_ALWAYS_INLINE expands to [[gnu::always_inline]] inline, applying both the GNU always_inline attribute and the inline keyword to the function declaration", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_anti_pattern_large_functions", "label": "ilp_always_inline_anti_pattern_large_fun", "x": 150.8268503732657, "y": -693.6249030138672, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Avoid using ILP_ALWAYS_INLINE on large functions, as forced inlining can degrade performance by bloating instruction cache and increasing compilation time", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_anti_pattern_recursive", "label": "ilp_always_inline_anti_pattern_recursive", "x": 34.10322425555797, "y": 675.8847090811557, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not use ILP_ALWAYS_INLINE on recursive functions, as this can lead to compilation errors or infinite code expansion attempts", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_complexity_compile_time", "label": "ilp_always_inline_complexity_compile_tim", "x": 839.7926677569438, "y": -406.842343999507, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Extensive use of ILP_ALWAYS_INLINE increases compilation time as the compiler must perform inlining analysis and code generation at each call site", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_constraint_portability", "label": "ilp_always_inline_constraint_portability", "x": 609.9587843339089, "y": 713.982146545886, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_ALWAYS_INLINE is not portable across compilers; code using this macro should provide alternative definitions for non-MSVC compilers", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_effect_code_size", "label": "ilp_always_inline_effect_code_size", "x": 878.4007340289955, "y": 264.06831208164243, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_ALWAYS_INLINE may significantly increase code size if the function is called from many locations, as each call site gets a copy of the function body", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_postcondition_inline_hint", "label": "ilp_always_inline_postcondition_inline_h", "x": 433.2094685526595, "y": -366.67377917041324, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After expansion, the function is marked with __forceinline, giving a strong hint to the compiler to inline the function at all call sites", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_precondition_compiler_support", "label": "ilp_always_inline_precondition_compiler_", "x": 673.220274418592, "y": 64.26329855187966, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The compiler must support __forceinline (MSVC-specific attribute)", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_always_inline_precondition_function_declaration", "label": "ilp_always_inline_precondition_function_", "x": 549.0335810401427, "y": -252.69767269271634, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_ALWAYS_INLINE must be used as a function declaration specifier, not in arbitrary expressions", "function": "ILP_ALWAYS_INLINE"}, {"id": "ilp_break.anti_pattern.nested_context", "label": "ilp_break.anti_pattern.nested_context", "x": 443.84764084007145, "y": 668.793685314302, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK only exits the innermost loop/switch; to exit outer loops, different mechanisms are needed", "function": "ILP_BREAK"}, {"id": "ilp_break.complexity.constant", "label": "ilp_break.complexity.constant", "x": -651.7656907837475, "y": 568.9880942194147, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK has O(1) time and space complexity - simple control flow transfer", "function": "ILP_BREAK"}, {"id": "ilp_break.effect.loop_termination", "label": "ilp_break.effect.loop_termination", "x": 642.053821452648, "y": -5.2982019400481, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Expands to a break statement that immediately exits the innermost enclosing loop or switch statement", "function": "ILP_BREAK"}, {"id": "ilp_break.postcondition.no_evaluation", "label": "ilp_break.postcondition.no_evaluation", "x": -223.2840384026178, "y": -525.9736811185835, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After ILP_BREAK, no subsequent statements in the current loop/switch iteration are executed", "function": "ILP_BREAK"}, {"id": "ilp_break.precondition.loop_context", "label": "ilp_break.precondition.loop_context", "x": 617.0583014898649, "y": 4.132385354363471, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK must be used within a loop context (for, while, do-while) or switch statement where break is valid", "function": "ILP_BREAK"}, {"id": "ilp_break_anti_pattern_destructor_bypass", "label": "ilp_break_anti_pattern_destructor_bypass", "x": 514.4935983588962, "y": -90.24919259294025, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_BREAK bypasses destructors of objects constructed after the macro, potentially causing resource leaks if used before RAII cleanup", "function": "ILP_BREAK"}, {"id": "ilp_break_complexity_constant", "label": "ilp_break_complexity_constant", "x": 86.88902580660309, "y": -614.8523740838283, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK has O(1) time complexity - single assignment and return", "function": "ILP_BREAK"}, {"id": "ilp_break_constraint_void_return", "label": "ilp_break_constraint_void_return", "x": 266.0482062780999, "y": -581.4504100381764, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK can only be used in functions with void return type (naked return statement)", "function": "ILP_BREAK"}, {"id": "ilp_break_effect_dowhile_safety", "label": "ilp_break_effect_dowhile_safety", "x": -877.896143187272, "y": -387.37326431514805, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The do-while(0) wrapper ensures ILP_BREAK can be used safely in single-statement contexts (if/else) and requires semicolon", "function": "ILP_BREAK"}, {"id": "ilp_break_effect_early_return", "label": "ilp_break_effect_early_return", "x": -724.244128199592, "y": 690.264422508754, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK causes immediate return from the enclosing function, preventing subsequent code execution", "function": "ILP_BREAK"}, {"id": "ilp_break_effect_sets_ok_false", "label": "ilp_break_effect_sets_ok_false", "x": 916.5828599330839, "y": -148.44432254208516, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK sets __ilp_ctrl.ok to false before executing return", "function": "ILP_BREAK"}, {"id": "ilp_break_postcond_no_return", "label": "ilp_break_postcond_no_return", "x": 570.3093105846725, "y": -351.6306963509357, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After ILP_BREAK, no postconditions can be asserted as control flow has exited the function", "function": "ILP_BREAK"}, {"id": "ilp_break_precond_ilp_ctrl_exists", "label": "ilp_break_precond_ilp_ctrl_exists", "x": 309.79087143132926, "y": 680.3517306136364, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Variable '__ilp_ctrl' must be accessible in the current scope and have a member 'ok'", "function": "ILP_BREAK"}, {"id": "ilp_break_precond_lambda_context", "label": "ilp_break_precond_lambda_context", "x": 885.0239104022663, "y": -143.97955714247988, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_BREAK must be used within a lambda or function context where 'return' is valid", "function": "ILP_BREAK"}, {"id": "ilp_continue_anti_pattern_switch", "label": "ilp_continue_anti_pattern_switch", "x": 615.5586950528138, "y": -2.8548961290553168, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE should not be used in a switch statement without an enclosing loop (use break instead)", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_anti_pattern_unreachable_code", "label": "ilp_continue_anti_pattern_unreachable_co", "x": 708.7773448884687, "y": -712.6359219150506, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Placing any code after ILP_CONTINUE in the same scope creates unreachable code that will never execute", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_complexity_constant", "label": "ilp_continue_complexity_constant", "x": 354.4121211183305, "y": 487.0790618471536, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE has O(1) time complexity - it is a simple control flow transfer", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_complexity_zero_runtime_cost", "label": "ilp_continue_complexity_zero_runtime_cos", "x": 307.62189138733333, "y": -804.7939570746024, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE has zero runtime overhead; the do-while(0) wrapper is eliminated by any optimizer and reduces to a simple return instruction", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_constraint_no_expression_context", "label": "ilp_continue_constraint_no_expression_co", "x": 845.2016491414531, "y": -489.09808968169796, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE cannot be used in expression contexts as it expands to a statement (do-while block), not an expression", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_effect_do_while_zero_idiom", "label": "ilp_continue_effect_do_while_zero_idiom", "x": 243.72514091333133, "y": -686.9957003690779, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE uses the do-while(0) idiom to create a statement that requires a semicolon and can be used safely in all contexts (if/else branches, etc.)", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_effect_next_iteration", "label": "ilp_continue_effect_next_iteration", "x": -599.9558169747929, "y": 182.41420564424433, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE causes immediate jump to the next iteration of the enclosing loop, skipping remaining statements in the current iteration", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_effect_unconditional_return", "label": "ilp_continue_effect_unconditional_return", "x": -99.23115075284727, "y": -762.8815121882755, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE unconditionally returns from the enclosing function, terminating its execution immediately", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_postcondition_no_return", "label": "ilp_continue_postcondition_no_return", "x": -768.5550921926838, "y": -160.5508607403571, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Statements following ILP_CONTINUE in the same block are unreachable", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_postcondition_no_subsequent_execution", "label": "ilp_continue_postcondition_no_subsequent", "x": 447.41515344059445, "y": 773.3685333966765, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After ILP_CONTINUE is invoked, no code following it in the same function scope will execute", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_precondition_in_void_function", "label": "ilp_continue_precondition_in_void_functi", "x": -857.1123799574096, "y": -208.67320530900068, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE must be used within a function returning void, as it expands to a bare 'return' statement without a value", "function": "ILP_CONTINUE"}, {"id": "ilp_continue_precondition_loop_context", "label": "ilp_continue_precondition_loop_context", "x": -574.9100439506393, "y": -793.1025602895226, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CONTINUE must be used within a loop context (for, while, do-while)", "function": "ILP_CONTINUE"}, {"id": "ilp_cpu_profile.default_config", "label": "ilp_cpu_profile.default_config", "x": 497.00818997025283, "y": 348.69968980256806, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Expands to ilp::cpu::alderlake, providing a default CPU profile configuration", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile.namespace_requirement", "label": "ilp_cpu_profile.namespace_requirement", "x": -675.4386472833384, "y": -477.9699974899465, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The namespace ilp::cpu and the identifier alderlake must be declared and accessible in the scope where this macro is expanded", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile.no_parentheses", "label": "ilp_cpu_profile.no_parentheses", "x": -858.1454050399719, "y": 498.13821242745837, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not invoke as ILP_CPU_PROFILE() - this is an object-like macro, not function-like", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile.no_side_effects", "label": "ilp_cpu_profile.no_side_effects", "x": 820.7414587394477, "y": -553.7037060539354, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Object-like macro performs simple textual substitution with no argument evaluation or side effects", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile.scope_requirement", "label": "ilp_cpu_profile.scope_requirement", "x": -401.48651906508417, "y": 718.660008146932, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The identifier ilp::cpu::apple_m1 must be declared and accessible in the scope where ILP_CPU_PROFILE is used", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile.type_alias", "label": "ilp_cpu_profile.type_alias", "x": 863.1852732327618, "y": -104.13321897002724, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE expands to ilp::cpu::apple_m1, serving as a type or constant alias", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile.type_constraint", "label": "ilp_cpu_profile.type_constraint", "x": -661.8038102003025, "y": -702.1639075945254, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expanded identifier ilp::cpu::alderlake must be of a type compatible with the context where ILP_CPU_PROFILE is used", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_constraint_requires_namespace_visible", "label": "ilp_cpu_profile_macro_constraint_require", "x": 281.4410551850962, "y": -502.2693965447303, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The namespace ilp::cpu and the identifier zen5 must be declared and accessible at the point of use", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_constraint_type_determined_by_zen5", "label": "ilp_cpu_profile_macro_constraint_type_de", "x": -957.2435659092124, "y": 125.10791507222554, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The type of ILP_CPU_PROFILE is determined by the type of ilp::cpu::zen5, which is likely a type alias, class, or constexpr object representing a CPU profile configuration", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_context_preservation", "label": "ilp_cpu_profile_macro_context_preservati", "x": -895.2782302189399, "y": 408.8957851733654, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_CPU_PROFILE in any expression context becomes ilp::cpu::default_profile in that same context. The replacement preserves the syntactic context (e.g., if used as a type, it must expand to a type; if used as a value, it must expand to a value).", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_effect", "label": "ilp_cpu_profile_macro_effect", "x": -252.7387062865359, "y": -912.8154790137589, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This is a simple object-like macro that performs textual substitution with no parameters. No multiple evaluation concerns, no operator precedence issues, and no side effects beyond the substitution itself.", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_effect_textual_substitution", "label": "ilp_cpu_profile_macro_effect_textual_sub", "x": 393.72934176695895, "y": -394.9993035119083, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This is an object-like macro that performs textual substitution without argument evaluation, so no side effects occur during expansion", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_namespace_requirement", "label": "ilp_cpu_profile_macro_namespace_requirem", "x": 968.0792318413644, "y": 57.02030970091732, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Before using ILP_CPU_PROFILE, the namespace ilp::cpu must be defined and default_profile must be declared within it. This typically requires including the appropriate header that defines ilp::cpu::default_profile.", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_no_side_effects", "label": "ilp_cpu_profile_macro_no_side_effects", "x": -106.8531352628827, "y": -523.5116491486572, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has no side effects - it performs pure textual substitution to a qualified identifier", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_postcondition", "label": "ilp_cpu_profile_macro_postcondition", "x": -360.4631570736579, "y": 818.1113950082386, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, every occurrence of ILP_CPU_PROFILE is textually replaced with ilp::cpu::default_profile", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_postcondition_expands_to_qualified_name", "label": "ilp_cpu_profile_macro_postcondition_expa", "x": -519.8474439191078, "y": 221.18214109835665, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE expands to the fully qualified name ilp::cpu::zen5", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_precondition", "label": "ilp_cpu_profile_macro_precondition", "x": -910.9821232639879, "y": -86.03809271590963, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Before using ILP_CPU_PROFILE, the namespace ilp::cpu must be declared and default_profile must be a valid member accessible in the current scope", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_purpose", "label": "ilp_cpu_profile_macro_purpose", "x": 616.1670967011837, "y": 562.6935032213324, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE expands to ilp::cpu::skylake, representing a CPU profile constant for the Skylake microarchitecture", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_textual_substitution", "label": "ilp_cpu_profile_macro_textual_substituti", "x": -594.3812912222841, "y": -522.0323233471605, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE performs pure textual substitution with no argument evaluation. Every occurrence of ILP_CPU_PROFILE is replaced with ilp::cpu::default_profile during preprocessing. No side effects occur during expansion since this is an object-like macro with no parameters.", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_type_constraint", "label": "ilp_cpu_profile_macro_type_constraint", "x": 522.3460139088472, "y": 761.2425733733347, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE expands to ilp::cpu::default_profile, which must be a valid identifier in scope. The type of default_profile must be compatible with contexts where ILP_CPU_PROFILE is used.", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_cpu_profile_macro_type_requirement", "label": "ilp_cpu_profile_macro_type_requirement", "x": -868.7767481607651, "y": -73.0694011600501, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE expands to ilp::cpu::default_profile, which must be a valid type or object name. The identifier ilp::cpu::default_profile must be defined and accessible in the current scope.", "function": "ILP_CPU_PROFILE"}, {"id": "ilp_ctrl_set_anti_pattern_double_set_y5z6a7b8", "label": "ilp_ctrl_set_anti_pattern_double_set_y5z", "x": -247.50132816454064, "y": 820.8466943410573, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Calling set() multiple times without destroying the previously constructed object leads to undefined behavior (object lifetime violation)", "function": "set"}, {"id": "ilp_ctrl_set_complexity_constant_k7l8m9n0", "label": "ilp_ctrl_set_complexity_constant_k7l8m9n", "x": -769.5881318582706, "y": -487.1616068274199, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) plus the cost of U's move/copy constructor; space complexity is O(1) as storage is pre-allocated", "function": "set"}, {"id": "ilp_ctrl_set_constraint_align_alignof_e5f6g7h8", "label": "ilp_ctrl_set_constraint_align_alignof_e5", "x": 394.6784203249449, "y": -845.8520690358564, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The alignment requirement of the decayed type U must not exceed arch::sbo_size bytes", "function": "set"}, {"id": "ilp_ctrl_set_constraint_size_sizeof_a1b2c3d4", "label": "ilp_ctrl_set_constraint_size_sizeof_a1b2", "x": -73.09058034765594, "y": -521.0455706758019, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The size of the decayed type U must not exceed arch::sbo_size bytes", "function": "set"}, {"id": "ilp_ctrl_set_constraint_trivial_dtor_i9j0k1l2", "label": "ilp_ctrl_set_constraint_trivial_dtor_i9j", "x": -553.6390661579119, "y": -300.9409170225699, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The decayed type U must be trivially destructible", "function": "set"}, {"id": "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6", "label": "ilp_ctrl_set_effect_perfect_forward_g3h4", "x": -170.65510337198143, "y": -239.39584709455812, "size": 5.5, "color": "#26de81", "layer": "library", "module": "", "content": "The static_cast<T&&>(val) performs perfect forwarding: if T is an lvalue reference, val is forwarded as lvalue; otherwise as rvalue", "function": "set"}, {"id": "ilp_ctrl_set_effect_placement_new_q7r8s9t0", "label": "ilp_ctrl_set_effect_placement_new_q7r8s9", "x": 132.1680400639415, "y": 731.8923471039742, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Constructs an object of type U in the pre-allocated buffer storage using placement new, forwarding val with its original value category", "function": "set"}, {"id": "ilp_ctrl_set_exception_constructor_throw_c9d0e1f2", "label": "ilp_ctrl_set_exception_constructor_throw", "x": 468.5870322317169, "y": -687.8023483784966, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If the constructor of U throws an exception during placement new, the exception propagates and buffer remains uninitialized", "function": "set"}, {"id": "ilp_ctrl_set_postcondition_object_constructed_u1v2w3x4", "label": "ilp_ctrl_set_postcondition_object_constr", "x": -682.7068331779808, "y": -443.75964672723836, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After successful execution, buffer contains a fully constructed object of type U initialized from val", "function": "set"}, {"id": "ilp_ctrl_set_precondition_buffer_valid_m3n4o5p6", "label": "ilp_ctrl_set_precondition_buffer_valid_m", "x": -526.0523165244889, "y": -313.4936807619483, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The buffer member must point to valid, uninitialized storage with sufficient size and alignment for type U", "function": "set"}, {"id": "ilp_end_macro_anti_pattern_missing_ilp_ret_c1f4a8e9", "label": "ilp_end_macro_anti_pattern_missing_ilp_r", "x": 281.6928901502942, "y": -904.122074160241, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_END when __ilp_ret is not defined or out of scope will cause compilation failure", "function": "ILP_END"}, {"id": "ilp_end_macro_anti_pattern_standalone", "label": "ilp_end_macro_anti_pattern_standalone", "x": -920.3663021720258, "y": -155.75831223579223, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_END without a corresponding ILP_FOR* opening macro creates unbalanced syntactic structure", "function": "ILP_END"}, {"id": "ilp_end_macro_anti_pattern_unmatched_context_b7e9f1c4", "label": "ilp_end_macro_anti_pattern_unmatched_con", "x": 404.4499089986899, "y": -686.1885954587596, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_END without a corresponding ILP_FOR* macro or in an unmatched syntactic context will result in compilation errors due to unbalanced braces, parentheses, or if-else statements", "function": "ILP_END"}, {"id": "ilp_end_macro_constraint_error_function_callable_a8c4e7f2", "label": "ilp_end_macro_constraint_error_function_", "x": 345.1116891609884, "y": -572.3430949407455, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The function ilp::detail::ilp_end_with_return_error must be callable with no arguments and accessible from the point of ILP_END expansion", "function": "ILP_END"}, {"id": "ilp_end_macro_constraint_ilp_ret_bool_conversion_f9a3b2d1", "label": "ilp_end_macro_constraint_ilp_ret_bool_co", "x": 655.5291405207155, "y": 662.8538267763838, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "__ilp_ret.has_return must be contextually convertible to bool for use in the ternary conditional operator", "function": "ILP_END"}, {"id": "ilp_end_macro_effect_comma_operator_sequencing_a9f1e3c7", "label": "ilp_end_macro_effect_comma_operator_sequ", "x": -405.7127270541249, "y": -607.0338626630413, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The ternary operator uses comma operator to sequence ilp_end_with_return_error() before false, ensuring left-to-right evaluation and that the error function executes before the false result is produced", "function": "ILP_END"}, {"id": "ilp_end_macro_effect_conditional_error_call_d4e8a1b7", "label": "ilp_end_macro_effect_conditional_error_c", "x": -203.58479401497743, "y": -688.1671464716322, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If __ilp_ret.has_return evaluates to true, the function ilp::detail::ilp_end_with_return_error() is called (likely terminating the program or throwing an exception), otherwise no error function is called", "function": "ILP_END"}, {"id": "ilp_end_macro_effect_ilp_ret_evaluation_e7f2a8c3", "label": "ilp_end_macro_effect_ilp_ret_evaluation_", "x": 307.13928892574825, "y": 710.9234206815506, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The member __ilp_ret.has_return is evaluated exactly once during the expansion of ILP_END (in the ternary conditional)", "function": "ILP_END"}, {"id": "ilp_end_macro_effect_lambda_invocation_e8b3f9a2", "label": "ilp_end_macro_effect_lambda_invocation_e", "x": 341.7819922165836, "y": 663.7948776690886, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END closes a lambda definition with ); followed by immediate invocation with (); indicating that the preceding code is part of a lambda body that gets invoked", "function": "ILP_END"}, {"id": "ilp_end_macro_effect_no_side_effects", "label": "ilp_end_macro_effect_no_side_effects", "x": -155.43745765886317, "y": -752.3423893148633, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END has no side effects as it expands to nothing", "function": "ILP_END"}, {"id": "ilp_end_macro_empty_expansion", "label": "ilp_end_macro_empty_expansion", "x": 609.7384242025853, "y": -309.39865704348495, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END expands to nothing (empty expansion), acting as a syntactic marker", "function": "ILP_END"}, {"id": "ilp_end_macro_postcondition_control_flow_if_else_b2c9e3f4", "label": "ilp_end_macro_postcondition_control_flow", "x": 415.4949501644999, "y": -537.6466272544159, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After expansion, ILP_END completes an if-else statement where the else branch evaluates to (void)0, ensuring the entire construct evaluates to void and has no effect when __ilp_ret.has_return is false", "function": "ILP_END"}, {"id": "ilp_end_macro_postcondition_statement_termination_f2c8a4e1", "label": "ilp_end_macro_postcondition_statement_te", "x": -564.6519421143897, "y": 823.2877107472536, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After ILP_END expansion, the construct syntactically completes as a valid statement (the if-else terminates properly) and no semicolon is needed after ILP_END", "function": "ILP_END"}, {"id": "ilp_end_macro_postcondition_void_cast_d3a7e2f8", "label": "ilp_end_macro_postcondition_void_cast_d3", "x": -458.97991488192366, "y": 876.9029292625391, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The else branch contains an explicit cast to void of the literal 0, ensuring the result is discarded and the construct has no value in statement context", "function": "ILP_END"}, {"id": "ilp_end_macro_precondition_context_matching_fc8e2a91", "label": "ilp_end_macro_precondition_context_match", "x": 864.7829822310654, "y": 434.89265238110204, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END must be used in a context where it syntactically matches a preceding ILP_FOR* macro (e.g., ILP_FOR, ILP_FOR_T, ILP_FOR_AUTO, etc.) that sets up the expected code structure (lambda invocation, __ilp_ret variable, and if-else chain). ILP_RETURN must NOT be used in the loop body when using ILP_", "function": "ILP_END"}, {"id": "ilp_end_macro_precondition_ilp_ret_variable_a3d7f892", "label": "ilp_end_macro_precondition_ilp_ret_varia", "x": 529.0757826912693, "y": 258.2383583879427, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Variable __ilp_ret must be defined and in scope, with a boolean member has_return accessible via member access operator", "function": "ILP_END"}, {"id": "ilp_end_macro_precondition_paired", "label": "ilp_end_macro_precondition_paired", "x": 761.0896053378322, "y": -344.8365220044268, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END should be paired with a corresponding ILP_FOR* opening macro (e.g., ILP_FOR, ILP_FOR_T, ILP_FOR_AUTO, etc.) to form a syntactic block. ILP_RETURN must NOT be used in the loop body when using ILP_END (use ILP_END_RETURN instead).", "function": "ILP_END"}, {"id": "ilp_end_return_anti_pattern_context_dependent_g7h8i9j0", "label": "ilp_end_return_anti_pattern_context_depe", "x": -79.34640547792637, "y": 531.2859520278843, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_END_RETURN must be used in conjunction with a matching ILP_FOR* macro (e.g., ILP_FOR, ILP_FOR_T, etc.) and requires that ILP_RETURN be used somewhere in the loop body. Using it standalone will cause syntax errors due to unmatched parentheses and braces. Using it without ILP_RETURN in the body is", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_anti_pattern_ret_scope_h8i9j0k1", "label": "ilp_end_return_anti_pattern_ret_scope_h8", "x": -401.3463197082356, "y": -397.235561387128, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The __ilp_ret variable must be in scope at the point of macro expansion (likely defined by a paired macro)", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_constraint_boolean_context_j0k1l2m3", "label": "ilp_end_return_constraint_boolean_contex", "x": -559.5925376349937, "y": 233.98729680230684, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "__ilp_ret must be contextually convertible to bool for the implicit if-else pattern to work", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_constraint_ret_moveable_d4e5f6g7", "label": "ilp_end_return_constraint_ret_moveable_d", "x": 665.902943377324, "y": -520.9294571659391, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The object pointed to by __ilp_ret must be move-constructible for std::move to work properly", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_constraint_ret_pointer_type_c3d4e5f6", "label": "ilp_end_return_constraint_ret_pointer_ty", "x": 851.165869144455, "y": 334.4333528837989, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "__ilp_ret must be a pointer type for the dereference operation to be valid", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_effect_closes_lambda_i9j0k1l2", "label": "ilp_end_return_effect_closes_lambda_i9j0", "x": 771.7499664260515, "y": 110.6774533632258, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro closes a lambda expression with ); } (); pattern, suggesting it completes an immediately-invoked lambda expression (IIILE)", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_effect_moves_object_e5f6g7h8", "label": "ilp_end_return_effect_moves_object_e5f6g", "x": 418.6697937123493, "y": -898.4561510562147, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro moves the object pointed to by __ilp_ret, leaving it in a valid but unspecified state", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_postcond_returns_value_f6g7h8i9", "label": "ilp_end_return_postcond_returns_value_f6", "x": 475.3661019558419, "y": -810.4364795718002, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If __ilp_ret evaluates to true in boolean context, the macro returns the moved value; otherwise executes (void)0", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_precond_ret_not_null_b2c3d4e5", "label": "ilp_end_return_precond_ret_not_null_b2c3", "x": 543.2959129098728, "y": 796.6187593731091, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The __ilp_ret variable must be a valid pointer (not null or dangling) for safe dereferencing", "function": "ILP_END_RETURN"}, {"id": "ilp_end_return_precond_ret_pointer_valid_a1b2c3d4", "label": "ilp_end_return_precond_ret_pointer_valid", "x": -394.6567378143452, "y": -637.651555946459, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The __ilp_ret variable must point to a valid object before dereferencing with *std::move(__ilp_ret)", "function": "ILP_END_RETURN"}, {"id": "ilp_end_with_return_error_anti_pattern_no_recovery_f8b6d4a9", "label": "ilp_end_with_return_error_anti_pattern_n", "x": 586.9349937200343, "y": -477.5995476494511, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not call this function in contexts requiring cleanup or graceful shutdown - it terminates immediately without stack unwinding", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_complexity_constant_h3i6k9m2", "label": "ilp_end_with_return_error_complexity_con", "x": 600.9606782434023, "y": -686.858591608311, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "O(1) time and space complexity - performs one fprintf and one abort call", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_effect_abort_terminates_c3d8e5f6", "label": "ilp_end_with_return_error_effect_abort_t", "x": -724.1945033469218, "y": 262.8299478071488, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Causes abnormal program termination via std::abort() without cleanup", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_effect_diagnostic_purpose_e1a3c5b7", "label": "ilp_end_with_return_error_effect_diagnos", "x": 300.0470516652654, "y": 769.2691500963261, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Called when ILP_RETURN macro is used but ILP_END was used instead of ILP_END_RETURN, indicating programmer error in ILP_FOR framework usage", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_effect_fprintf_stderr_a8c9d2f3", "label": "ilp_end_with_return_error_effect_fprintf", "x": -423.1416199134322, "y": 507.14458123639344, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Writes diagnostic error message to stderr stream about ILP_RETURN/ILP_END mismatch", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_exception_no_throw_g2h5j8k1", "label": "ilp_end_with_return_error_exception_no_t", "x": 327.58119406074417, "y": -428.2670734260142, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Function cannot throw exceptions - terminates via std::abort() which is noexcept", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_postcond_never_returns_d9f2a7b4", "label": "ilp_end_with_return_error_postcond_never", "x": 575.4886137765195, "y": 232.8223983652118, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Function never returns (marked [[noreturn]]) - program terminates", "function": "ilp_end_with_return_error"}, {"id": "ilp_end_with_return_error_precond_stderr_valid_b7e4f1a2", "label": "ilp_end_with_return_error_precond_stderr", "x": -137.03895342129042, "y": -642.5673122339836, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "stderr must be a valid writable FILE* stream", "function": "ilp_end_with_return_error"}, {"id": "ilp_for_auto_anti_pattern_side_effects_in_args", "label": "ilp_for_auto_anti_pattern_side_effects_i", "x": 544.4694093608844, "y": -557.8969768664388, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "While parenthesization protects against precedence issues, using expressions with side effects in start or end (e.g., i++, func()) may still have those effects evaluated during iota's construction or iteration setup", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_complexity_linear", "label": "ilp_for_auto_complexity_linear", "x": 445.6161319101818, "y": -575.1628095482099, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expands to a loop that iterates (end - start) times, resulting in linear time complexity O(end - start)", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_constraint_element_type_compatibility", "label": "ilp_for_auto_constraint_element_type_com", "x": 264.3895349481096, "y": 125.78810498502376, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The type of loop_var_decl should be compatible with the value_type produced by ilp::iota's iterator, typically an integer-like type", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_constraint_unused_params", "label": "ilp_for_auto_constraint_unused_params", "x": -428.3777990883794, "y": -819.0828453250182, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_type and element_type parameters are not used in the macro expansion - they may be present for compatibility with other macro variants or future extensions", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_effect_namespace_qualified", "label": "ilp_for_auto_effect_namespace_qualified", "x": -809.4187904870838, "y": 173.74025741754338, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro uses fully qualified name ::ilp::iota to avoid ambiguity with other iota functions (e.g., std::iota) or namespace pollution", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_effect_single_evaluation", "label": "ilp_for_auto_effect_single_evaluation", "x": 510.640319520186, "y": -794.5405739102199, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are parenthesized in the expansion, protecting against precedence issues, but they are still passed to ilp::iota which may copy or evaluate them according to its semantics", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_anti_pattern_semicolon_after_brace_1d2e3f4a", "label": "ilp_for_auto_macro_anti_pattern_semicolo", "x": 595.9509519139426, "y": -357.46855670667026, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not place a semicolon after the closing brace or after ILP_END; the macro expands to an if-statement that expects the lambda body to complete the statement", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_anti_pattern_side_effects_in_params_5b6c7d8e", "label": "ilp_for_auto_macro_anti_pattern_side_eff", "x": 22.028122503845303, "y": 906.0204653384322, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "While start and end are evaluated only once, placing complex expressions with side effects in loop_type or element_type parameters is error-prone as these are used in template contexts", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_complexity_lambda_overhead_9e0f1a2b", "label": "ilp_for_auto_macro_complexity_lambda_ove", "x": -582.2243140385243, "y": -125.47030076570304, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro introduces nested lambda expressions which may incur overhead if not inlined; modern compilers typically optimize these away with inlining", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_constraint_lambda_capture_7a8b9c0d", "label": "ilp_for_auto_macro_constraint_lambda_cap", "x": -789.8700544662806, "y": -578.9839697626803, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro creates nested lambdas with [&] capture; all variables referenced in start, end, and the loop body must be capturable by reference and must remain valid for the loop duration", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_constraint_loop_var_shadowing_3c4d5e6f", "label": "ilp_for_auto_macro_constraint_loop_var_s", "x": -320.95162441375453, "y": -904.0606147539172, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro introduces names __ilp_ret, __ilp_ctx, and __ilp_ctrl in the enclosing scope; these names must not conflict with user code", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_effect_no_expansion_side_effects_5f6e7d8c", "label": "ilp_for_auto_macro_effect_no_expansion_s", "x": 483.7968134433439, "y": -300.70026345964476, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime within the expanded code", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_effect_single_eval_a1b2c3d4", "label": "ilp_for_auto_macro_effect_single_eval_a1", "x": 98.57928589177956, "y": -757.7107759169996, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "start and end arguments are evaluated exactly once due to parenthesization when passed to for_loop_auto; loop_var_decl and the implicit loop body are evaluated per iteration", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_postcond_incomplete_statement_2e3f4a5b", "label": "ilp_for_auto_macro_postcond_incomplete_s", "x": -535.543577457963, "y": 412.583368441827, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expansion is an incomplete if-statement that expects a trailing lambda body and closing brace; usage must follow the pattern: ILP_FOR_AUTO(...) { body } ILP_END", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_precond_range_8d5e3a2c", "label": "ilp_for_auto_macro_precond_range_8d5e3a2", "x": 726.5319302798736, "y": -661.0424410652817, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "start and end must be valid expressions compatible with the template parameter requirements of ::ilp::for_loop_auto<element_type, ::ilp::LoopType::loop_type>", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_macro_precond_types_9c4a2b1f", "label": "ilp_for_auto_macro_precond_types_9c4a2b1", "x": 872.2677473585561, "y": 107.72030302844676, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "element_type must be a valid type name; loop_type must be a valid enumerator name in ::ilp::LoopType; loop_var_decl must be a valid variable declaration (type and name or auto name)", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_postcondition_range_for_loop", "label": "ilp_for_auto_postcondition_range_for_loo", "x": -16.743056269234714, "y": 343.1100729425179, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expands to a C++ range-based for loop iterating over the range produced by ilp::iota(start, end)", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_precondition_loop_var_valid_decl", "label": "ilp_for_auto_precondition_loop_var_valid", "x": -20.55452950878754, "y": 294.20318021367507, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl parameter must be a valid variable declaration suitable for range-based for loop (e.g., 'auto i', 'int i', 'const auto& i')", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_auto_precondition_start_end_valid", "label": "ilp_for_auto_precondition_start_end_vali", "x": 255.33301383015305, "y": 107.58269016088735, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end parameters must be valid arguments to ilp::iota, which typically requires they are compatible integer-like or iterator-like types", "function": "ILP_FOR_AUTO"}, {"id": "ilp_for_macro_anti_pattern_dangling_reference", "label": "ilp_for_macro_anti_pattern_dangling_refe", "x": 833.2558273676242, "y": -158.38199288172012, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Passing temporary objects as start or end arguments can lead to dangling references since they are captured by reference in the lambda", "function": "ILP_FOR"}, {"id": "ilp_for_macro_anti_pattern_n_param_misleading_g3h4i5j6", "label": "ilp_for_macro_anti_pattern_n_param_misle", "x": -735.6847399590964, "y": 367.80486018808944, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Anti-pattern: Passing a value for N parameter expecting it to control loop behavior - N is completely ignored in this macro version", "function": "ILP_FOR"}, {"id": "ilp_for_macro_complexity_iota_range_construction_k7l8m9n0", "label": "ilp_for_macro_complexity_iota_range_cons", "x": -7.290402566482717, "y": 310.26614404263114, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion involves constructing a range object via iota(start, end); complexity depends on iota's implementation (typically O(1) for range construction)", "function": "ILP_FOR"}, {"id": "ilp_for_macro_complexity_template_instantiation", "label": "ilp_for_macro_complexity_template_instan", "x": 287.3240496299276, "y": 841.5678403628312, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Each unique value of N causes a separate template instantiation of ::ilp::for_loop<N>, potentially increasing compile time and code size with multiple different N values", "function": "ILP_FOR"}, {"id": "ilp_for_macro_constraint_incomplete_expansion", "label": "ilp_for_macro_constraint_incomplete_expa", "x": 617.2164702301358, "y": 400.232462604682, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This macro must be used with a companion macro or syntax that closes the lambda body and completes the if statement, as the expansion ends with an open lambda parameter list", "function": "ILP_FOR"}, {"id": "ilp_for_macro_constraint_iota_returns_range_y5z6a7b8", "label": "ilp_for_macro_constraint_iota_returns_ra", "x": 8.622494282069088, "y": 351.5029033356638, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "::ilp::iota(start, end) must return a range-compatible object (with begin() and end() iterators) for use in range-based for loop", "function": "ILP_FOR"}, {"id": "ilp_for_macro_constraint_loop_var_type_compatible_c9d0e1f2", "label": "ilp_for_macro_constraint_loop_var_type_c", "x": 5.830966698186626, "y": 292.42711902737983, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The type declared in loop_var_decl must be compatible with the element type of the range returned by iota", "function": "ILP_FOR"}, {"id": "ilp_for_macro_constraint_reference_capture", "label": "ilp_for_macro_constraint_reference_captu", "x": -449.5938975630854, "y": -591.9486596441245, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "All external variables used in the loop body are captured by reference ([&]) in both the outer and inner lambdas, allowing modifications to affect the outer scope", "function": "ILP_FOR"}, {"id": "ilp_for_macro_constraint_start_end_compatible_i9j0k1l2", "label": "ilp_for_macro_constraint_start_end_compa", "x": 271.8498897797014, "y": 135.44060594548492, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "start and end must have types compatible with ::ilp::iota's parameter types (typically integral or iterator types)", "function": "ILP_FOR"}, {"id": "ilp_for_macro_effect_lambda_body_deferred", "label": "ilp_for_macro_effect_lambda_body_deferre", "x": 139.7995219769122, "y": -952.0749175663545, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expansion creates an immediately-invoked lambda expression (IIFE) that returns ::ilp::ForResult, with the actual loop body provided after macro invocation", "function": "ILP_FOR"}, {"id": "ilp_for_macro_effect_no_preprocessing_side_effects", "label": "ilp_for_macro_effect_no_preprocessing_si", "x": 555.3490740963111, "y": -388.09298076725935, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime within the lambda expressions", "function": "ILP_FOR"}, {"id": "ilp_for_macro_effect_param_n_unused_q7r8s9t0", "label": "ilp_for_macro_effect_param_n_unused_q7r8", "x": 563.5413397122761, "y": 135.96057733687667, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The parameter N is completely unused in the macro expansion and has no effect on behavior", "function": "ILP_FOR"}, {"id": "ilp_for_macro_effect_single_eval_m3n4o5p6", "label": "ilp_for_macro_effect_single_eval_m3n4o5p", "x": -267.04071701899665, "y": -754.930218804335, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are each evaluated exactly once due to parenthesization in the expansion, making this macro safe with side-effect expressions", "function": "ILP_FOR"}, {"id": "ilp_for_macro_effect_single_evaluation", "label": "ilp_for_macro_effect_single_evaluation", "x": -760.7421950327829, "y": 495.95520655736453, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are captured by reference in the lambda and evaluated exactly once when ::ilp::for_loop is called, protecting against multiple evaluation side effects", "function": "ILP_FOR"}, {"id": "ilp_for_macro_postcond_range_for_expansion_u1v2w3x4", "label": "ilp_for_macro_postcond_range_for_expansi", "x": 14.553061585575644, "y": 351.94516810108036, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expands to a range-based for loop: for (loop_var_decl : ::ilp::iota((start), (end)))", "function": "ILP_FOR"}, {"id": "ilp_for_macro_postcondition_context_available", "label": "ilp_for_macro_postcondition_context_avai", "x": -827.3248299765112, "y": -144.05023748170598, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, the identifiers __ilp_ctx, __ilp_ctrl, and the loop variable are available in the scope following the macro, with __ilp_ctrl providing loop control operations", "function": "ILP_FOR"}, {"id": "ilp_for_macro_postcondition_return_value", "label": "ilp_for_macro_postcondition_return_value", "x": 479.8797014709685, "y": 577.283934385745, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The complete macro expansion produces an if-statement condition that evaluates to a ::ilp::ForResult object stored in __ilp_ret, which must be contextually convertible to bool for the if-statement", "function": "ILP_FOR"}, {"id": "ilp_for_macro_precond_iota_callable_e5f6g7h8", "label": "ilp_for_macro_precond_iota_callable_e5f6", "x": -554.3669899040539, "y": -834.8998253975399, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "::ilp::iota must be accessible and callable with (start, end) arguments", "function": "ILP_FOR"}, {"id": "ilp_for_macro_precond_loop_var_valid_decl_a1b2c3d4", "label": "ilp_for_macro_precond_loop_var_valid_dec", "x": -41.58410452856107, "y": 315.7299576244841, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "loop_var_decl must be a valid variable declaration (e.g., 'int i', 'auto x') suitable for range-based for loop", "function": "ILP_FOR"}, {"id": "ilp_for_macro_precondition_loop_var_type", "label": "ilp_for_macro_precondition_loop_var_type", "x": -317.10640847465646, "y": -938.7044294391698, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl parameter must be a valid variable declaration without initializer (e.g., 'int i' or 'size_t idx') that can be used as a lambda parameter", "function": "ILP_FOR"}, {"id": "ilp_for_macro_precondition_n_template_constant", "label": "ilp_for_macro_precondition_n_template_co", "x": 88.68810976937354, "y": 804.8033798520653, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The N parameter must be a compile-time constant expression suitable for template argument, representing the unroll factor", "function": "ILP_FOR"}, {"id": "ilp_for_macro_precondition_range_validity", "label": "ilp_for_macro_precondition_range_validit", "x": 941.295677336748, "y": 104.4942697699096, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end parameters must be valid integral or iterator-like values where start <= end, defining a valid loop range", "function": "ILP_FOR"}, {"id": "ilp_for_range_anti_pattern_incomplete_impl_f1c8d3a7", "label": "ilp_for_range_anti_pattern_incomplete_im", "x": 1.092938534469879, "y": 315.53085402439825, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The macro signature suggests ILP (Instruction-Level Parallelism) with parameter N (likely unroll factor), but expansion is a simple range-based for loop with no parallelization or unrolling, indicating incomplete or placeholder implementation", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_auto_anti_pattern_dangling_ref_9a7e3b52", "label": "ilp_for_range_auto_anti_pattern_dangling", "x": -42.165079632649984, "y": 335.51305931952146, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "If range is a temporary object and loop_var_decl uses a reference type, the reference may dangle if the temporary is not lifetime-extended", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "label": "ilp_for_range_auto_complexity_range_iter", "x": 116.33750474832371, "y": 216.3499792056957, "size": 6.0, "color": "#26de81", "layer": "library", "module": "", "content": "Performance characteristics depend on the range type's iterator operations - macro itself adds no overhead beyond standard range-based for loop", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_constraint_loop_var_type_3b6d8a41", "label": "ilp_for_range_auto_constraint_loop_var_t", "x": 15.335887012789772, "y": 315.26929603670595, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl must be a valid variable declaration suitable for range-based for loop (typically 'auto var' or 'auto& var' or 'const auto& var')", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_constraint_unused_params_5f1c7e92", "label": "ilp_for_range_auto_constraint_unused_par", "x": -96.7058817835469, "y": -486.4731871764933, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_type and element_type parameters are not used in the macro expansion - they exist for API consistency but have no effect", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_effect_no_preproc_side_effects_8c4f1d23", "label": "ilp_for_range_auto_effect_no_preproc_sid", "x": -427.62892959700883, "y": 894.728392694203, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs simple textual substitution with no side effects at preprocessing time", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_effect_single_eval_2d8b4c31", "label": "ilp_for_range_auto_effect_single_eval_2d", "x": 25.627020892180543, "y": 328.5586932997609, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument is evaluated exactly once during loop initialization due to range-based for semantics, protecting against multiple evaluation side effects", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_anti_pattern_name_collision", "label": "ilp_for_range_auto_macro_anti_pattern_na", "x": 532.1177432552097, "y": 828.4517938576633, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "User code must not declare variables named __ilp_ret, __ilp_ctx, or __ilp_ctrl in the surrounding scope, as these are reserved by the macro expansion and will cause name collisions", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_constraint_incomplete_syntax", "label": "ilp_for_range_auto_macro_constraint_inco", "x": 152.03024934289945, "y": 744.4254170100486, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This macro must be followed by a lambda body (braced statement) and terminated with ILP_END macro, as it opens an if statement and lambda parameter list without closing them", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_constraint_loop_var_decl_syntax", "label": "ilp_for_range_auto_macro_constraint_loop", "x": -434.86329566483425, "y": -491.3236426294904, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl parameter must be a valid variable declaration including type and name (e.g., 'int i' or 'auto& x'), as it becomes a lambda parameter", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_constraint_requires_ilp_end", "label": "ilp_for_range_auto_macro_constraint_requ", "x": -251.77904873811607, "y": 561.3689856211312, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The For_Context_USE_ILP_END type is specifically designed to produce a compile-time error if ILP_END is not used to close the loop construct", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_effect_lambda_capture", "label": "ilp_for_range_auto_macro_effect_lambda_c", "x": 455.29546779298386, "y": -473.2380215279029, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "All variables from the surrounding scope are captured by reference ([&]) in both the outer and inner lambda, allowing the loop body to modify external state", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_effect_no_expansion_side_effects", "label": "ilp_for_range_auto_macro_effect_no_expan", "x": -790.4432551924417, "y": 199.50122598041534, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime within the expanded code", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_effect_range_eval_once", "label": "ilp_for_range_auto_macro_effect_range_ev", "x": -823.4815979781623, "y": 128.61804122288902, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument is evaluated exactly once when the macro expands, as it is passed directly to the for_loop_range_auto function call within the lambda", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_postcond_ilp_ctrl_available", "label": "ilp_for_range_auto_macro_postcond_ilp_ct", "x": 474.96521796729536, "y": 488.68511393592024, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Within the loop body, __ilp_ctrl variable of type ::ilp::ForCtrl& is available and marked [[maybe_unused]] for loop control operations", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_postcond_ilp_ctx_available", "label": "ilp_for_range_auto_macro_postcond_ilp_ct", "x": 445.45350489607364, "y": 727.3100156744823, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The __ilp_ctx variable of type ::ilp::detail::For_Context_USE_ILP_END is created in the outer lambda scope and marked [[maybe_unused]]", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_postcond_ilp_ret_available", "label": "ilp_for_range_auto_macro_postcond_ilp_re", "x": -5.8907801644273645, "y": 667.8440135347041, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The __ilp_ret variable of type ::ilp::ForResult is created from the outer lambda return value and marked [[maybe_unused]], available in the if statement scope", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_precond_element_type_valid", "label": "ilp_for_range_auto_macro_precond_element", "x": 223.39290355345568, "y": -730.5495539474794, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The element_type parameter must be a valid type name that matches the element type of the range", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_precond_loop_type_valid", "label": "ilp_for_range_auto_macro_precond_loop_ty", "x": -929.7366450460448, "y": -335.15554767995883, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_type parameter must be a valid enumerator name from ::ilp::LoopType without the enum scope qualifier", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_macro_precond_range_valid", "label": "ilp_for_range_auto_macro_precond_range_v", "x": -180.260516820111, "y": 512.5726679279999, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range parameter must be a valid range-like object that can be passed to for_loop_range_auto, with valid begin/end iterators or compatible interface", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_postcond_loop_scope_4e2a9c71", "label": "ilp_for_range_auto_postcond_loop_scope_4", "x": 38.17545050977629, "y": 333.513078841905, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, a range-based for loop is created where the loop variable is scoped to the loop body", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "label": "ilp_for_range_auto_precond_range_valid_7", "x": -74.37508761192856, "y": 138.34584568909884, "size": 6.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument must be a valid expression that supports range-based for loop semantics (has begin()/end() or is an array)", "function": "ILP_FOR_RANGE_AUTO"}, {"id": "ilp_for_range_complexity_sequential_o_n_b4e7c2f9", "label": "ilp_for_range_complexity_sequential_o_n_", "x": -28.49540037405013, "y": 307.49657119445067, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Despite the ILP naming, the macro expands to a sequential range-based for loop with O(n) time complexity where n is the size of the range", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_constraint_loop_var_syntax_a3f9d2c8", "label": "ilp_for_range_constraint_loop_var_syntax", "x": -17.35961025956802, "y": 325.71562909012016, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl parameter must be a valid variable declaration syntax for range-based for loops (e.g., 'auto x', 'int& val', 'const auto& item')", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_constraint_range_expr_c7e2a4f1", "label": "ilp_for_range_constraint_range_expr_c7e2", "x": -57.60108616227411, "y": 156.15040110045194, "size": 6.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range parameter must be a valid range expression supporting begin() and end() operations or array type suitable for range-based for loops", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_constraint_range_parenthesized_e9a2f4b6", "label": "ilp_for_range_constraint_range_parenthes", "x": -32.150796006299174, "y": 262.6338064021244, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The range expression is parenthesized in the expansion, protecting against operator precedence issues if range contains comma operators or low-precedence operators", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_if_statement_context", "label": "ilp_for_range_macro_if_statement_context", "x": 92.07418148587111, "y": -696.1931239604804, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expands to an if statement with init-statement, creating a scope where __ilp_ret is valid; the condition is the result of the lambda execution", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_incomplete_syntax", "label": "ilp_for_range_macro_incomplete_syntax", "x": 230.05141336635734, "y": 734.7245608951363, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This macro expands to incomplete syntax requiring a user-supplied lambda body followed by ILP_END or similar closing macro; the expansion produces 'if ([[maybe_unused]] auto __ilp_ret = [&]() { ... [&](loop_var_decl, ::ilp::ForCtrl& __ilp_ctrl)' without closing braces", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_lambda_capture", "label": "ilp_for_range_macro_lambda_capture", "x": -959.6388791612256, "y": 28.882420239732824, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "All variables from the surrounding scope are captured by reference ([&]) in the outer lambda, making them accessible but potentially causing lifetime issues if the lambda outlives the scope", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_loop_var_decl_constraint", "label": "ilp_for_range_macro_loop_var_decl_constr", "x": 458.4737333630613, "y": -547.1065535537202, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl must be a valid lambda parameter declaration (e.g., 'int i', 'auto& x', 'const auto& elem') compatible with the iteration variable type produced by for_loop_range", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_n_constraint", "label": "ilp_for_range_macro_n_constraint", "x": -567.173461989312, "y": 306.16385595831775, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The N parameter must be a compile-time constant integral value suitable as a template argument for for_loop_range<N>", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_name_collision", "label": "ilp_for_range_macro_name_collision", "x": 745.9615332108935, "y": 483.7387260417771, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro introduces internal variables __ilp_ret, __ilp_ctx, and __ilp_ctrl into the scope; user code should not define variables with these names to avoid collisions", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_no_preprocessing_side_effects", "label": "ilp_for_range_macro_no_preprocessing_sid", "x": 181.13136130927748, "y": 630.208655294313, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all effects occur at runtime when the expanded code executes", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_no_side_effects_b9c4d7e2", "label": "ilp_for_range_macro_no_side_effects_b9c4", "x": -128.98756372916054, "y": -533.6244753994281, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs simple textual substitution with no evaluation or side effects at preprocessing time", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_param_eval_multiple", "label": "ilp_for_range_macro_param_eval_multiple", "x": -36.49490920331388, "y": -753.4045700414995, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument is captured by reference and passed to for_loop_range, which may evaluate it multiple times during iteration; the loop_var_decl is only used once in the lambda parameter declaration", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_param_unused_n_e4a7b3c2", "label": "ilp_for_range_macro_param_unused_n_e4a7b", "x": 600.2858920782911, "y": 157.98628429384542, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The parameter N is declared in the macro signature but never used in the expansion, suggesting either incomplete implementation or API design issue", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_range_type_constraint", "label": "ilp_for_range_macro_range_type_constrain", "x": -203.62427717420724, "y": 876.6225581134357, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument must be a valid range-like object compatible with ::ilp::for_loop_range<N>, typically supporting iteration or having begin/end", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_macro_single_eval_range_f2d8e1a9", "label": "ilp_for_range_macro_single_eval_range_f2", "x": 4.5752773613830255, "y": 303.5949674896483, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument is evaluated exactly once as it appears once in the expansion within a range-based for loop", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_postcondition_for_loop_generation_d8b3c5e7", "label": "ilp_for_range_postcondition_for_loop_gen", "x": -44.66509476155939, "y": 336.8692291784889, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion produces a syntactically valid range-based for loop: 'for (loop_var_decl : (range))'", "function": "ILP_FOR_RANGE"}, {"id": "ilp_for_range_t_anti_pattern_unused_params", "label": "ilp_for_range_t_anti_pattern_unused_para", "x": 508.62112363920573, "y": -397.298664529069, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Passing complex expressions or expressions with side effects for the unused 'type' and 'N' parameters is wasteful and misleading, as they are completely ignored", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_auto_complexity_linear_d8b4a1c3", "label": "ilp_for_range_t_auto_complexity_linear_d", "x": -18.816931915082904, "y": 342.94193506329344, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expands to a standard range-for loop with complexity O(n) where n is the size of the range, plus the complexity of the loop body", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_loop_var_scope_d3c9f1a5", "label": "ilp_for_range_t_auto_loop_var_scope_d3c9", "x": -45.30275201567924, "y": 320.60864510970015, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl introduces a new variable scoped to the for-loop body, following C++ range-for semantics", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_loop_var_type_deduced_f9a3c7e2", "label": "ilp_for_range_t_auto_loop_var_type_deduc", "x": -118.05960787267554, "y": 904.9937126819287, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The type of the loop variable is deduced from the loop_var_decl, which may include auto, const auto&, auto&&, or explicit type specifications", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_complexity_lambda_overhead", "label": "ilp_for_range_t_auto_macro_complexity_la", "x": -406.64118785721723, "y": -714.9585412188693, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro introduces lambda capture and function call overhead, though modern compilers typically inline the lambda eliminating most overhead", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_effect_no_side_effects", "label": "ilp_for_range_t_auto_macro_effect_no_sid", "x": 151.6219215007618, "y": 937.4683035477223, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_element_type_constraint", "label": "ilp_for_range_t_auto_macro_element_type_", "x": -161.4470454208223, "y": -871.729188828318, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The element_type parameter must be a valid type that can be used as a template argument and is compatible with the element type of range", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_incomplete_statement", "label": "ilp_for_range_t_auto_macro_incomplete_st", "x": -576.198791600167, "y": -32.566579658665255, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This macro expands to an incomplete statement (if-statement with lambda that lacks the closing braces and body). It must be followed by the loop body in braces and terminated with ILP_END or similar macro", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_lambda_capture_precondition", "label": "ilp_for_range_t_auto_macro_lambda_captur", "x": -743.622716835636, "y": 302.4726205162045, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "All variables referenced in the loop_var_decl and range expressions must be in scope at the macro invocation point, as they will be captured by reference in the generated lambda", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_loop_type_constraint", "label": "ilp_for_range_t_auto_macro_loop_type_con", "x": 996.2213692126248, "y": -43.02919179945025, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_type parameter must be a valid enumerator of ::ilp::LoopType without the scope prefix (e.g., Sequential, not LoopType::Sequential)", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_loop_var_decl_constraint", "label": "ilp_for_range_t_auto_macro_loop_var_decl", "x": -499.5410635364955, "y": -359.5829421754261, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl parameter must be a valid parameter declaration (e.g., 'auto& x' or 'const int i') that can appear in a lambda parameter list", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_postcondition_result_available", "label": "ilp_for_range_t_auto_macro_postcondition", "x": -660.5001956148268, "y": 608.198821660647, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After complete macro expansion and loop execution, the variable __ilp_ret of type ForResultTyped<ret_type> is available in the scope of the if-statement body", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_range_eval_single", "label": "ilp_for_range_t_auto_macro_range_eval_si", "x": -334.4617868797624, "y": -470.91810596662094, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument is evaluated exactly once when passed to for_loop_range_typed_auto, protecting against multiple evaluation of side effects", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_reserved_identifiers", "label": "ilp_for_range_t_auto_macro_reserved_iden", "x": 534.7352504335869, "y": -197.96755691614925, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "User code must not declare variables named __ilp_ret, __ilp_ctx, or __ilp_ctrl in the scope where this macro is used, as they will collide with the macro's internal identifiers", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_macro_ret_type_constraint", "label": "ilp_for_range_t_auto_macro_ret_type_cons", "x": 229.52495054533009, "y": -909.5151475782674, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The ret_type parameter must be a valid type identifier that can be used as a template argument to ForResultTyped and ForCtrlTyped", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_no_side_effects_expansion_c5f2e8d1", "label": "ilp_for_range_t_auto_no_side_effects_exp", "x": 506.86669238847423, "y": 798.3883915832233, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs simple textual substitution with no side effects at preprocessing time", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_range_eval_once_e8a4b7c2", "label": "ilp_for_range_t_auto_range_eval_once_e8a", "x": -6.434714826411807, "y": 358.9061375557065, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument is evaluated exactly once during macro expansion due to parenthesization, protecting against multiple evaluation side effects", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "label": "ilp_for_range_t_auto_range_type_constrai", "x": -66.11957363503308, "y": 151.60068989340536, "size": 6.0, "color": "#26de81", "layer": "library", "module": "", "content": "The range argument must be a valid range-expression: either an array, or an object with begin() and end() methods, or compatible with std::begin/std::end", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_auto_unused_params_b7d3a9c6", "label": "ilp_for_range_t_auto_unused_params_b7d3a", "x": 453.1511915245376, "y": 330.7986950472349, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The ret_type, loop_type, and element_type parameters are accepted but ignored in the macro expansion, making them vestigial and potentially misleading", "function": "ILP_FOR_RANGE_T_AUTO"}, {"id": "ilp_for_range_t_complexity_constant", "label": "ilp_for_range_t_complexity_constant", "x": -312.0877563737344, "y": -523.1619948737144, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has O(1) preprocessing complexity - simple textual substitution with no computation", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_expansion_no_preprocessing_side_effects", "label": "ilp_for_range_t_expansion_no_preprocessi", "x": -764.8095843037707, "y": -210.73617774573066, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs simple textual substitution with no evaluation or side effects at preprocessing time", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_loop_var_decl_precondition", "label": "ilp_for_range_t_loop_var_decl_preconditi", "x": -3.2213498310730433, "y": 340.42750173101183, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The 'loop_var_decl' parameter must be a valid variable declaration (with or without type) suitable for a range-based for loop", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_anti_pattern_missing_end", "label": "ilp_for_range_t_macro_anti_pattern_missi", "x": -466.99066030123095, "y": -811.1175047036447, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro without a proper closing construct (like ILP_END) leaves an incomplete if statement and open lambda body, causing compilation failure", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_capture_by_reference", "label": "ilp_for_range_t_macro_capture_by_referen", "x": 149.4109067975391, "y": 511.09799454420175, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro captures all surrounding variables by reference ([&]) in the outer lambda, making them available to the loop body but subject to lifetime and modification concerns", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_context_independence", "label": "ilp_for_range_t_macro_context_independen", "x": 830.7921976187077, "y": 158.05579846104018, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "No side effects occur during macro expansion; the macro performs simple textual substitution without argument evaluation at preprocessing time", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_context_variable_shadowing", "label": "ilp_for_range_t_macro_context_variable_s", "x": -271.75796256855233, "y": 673.5418888969232, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro introduces variables __ilp_ret, __ilp_ctx, and __ilp_ctrl in the expansion scope; code using this macro should avoid declaring variables with these names to prevent shadowing or conflicts", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_expansion_no_side_effects", "label": "ilp_for_range_t_macro_expansion_no_side_", "x": 53.70746952167809, "y": -897.150683377124, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all side effects occur at runtime during lambda execution", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_incomplete_statement", "label": "ilp_for_range_t_macro_incomplete_stateme", "x": 105.45951998054535, "y": 871.9047050601629, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This macro expands to an incomplete if statement with an open lambda body; it MUST be followed by a lambda body and closing braces, typically via a companion ILP_END macro", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_loop_var_decl_constraint", "label": "ilp_for_range_t_macro_loop_var_decl_cons", "x": -294.2200853336558, "y": -587.6847943092071, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'loop_var_decl' parameter must be a valid variable declaration that can be used as a lambda parameter", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_n_constraint", "label": "ilp_for_range_t_macro_n_constraint", "x": -627.8462378356526, "y": -611.5541744723436, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'N' parameter must be a compile-time constant integral value suitable as a template non-type parameter", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_range_eval_once", "label": "ilp_for_range_t_macro_range_eval_once", "x": -321.3556358256125, "y": 435.560631374095, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'range' argument is evaluated exactly once when passed to for_loop_range_typed, protecting against multiple evaluation side effects", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_return_type_constraint", "label": "ilp_for_range_t_macro_return_type_constr", "x": -645.7367530244267, "y": 657.3184765958429, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The for_loop_range_typed function must return a type compatible with ForResultTyped<type>, otherwise the explicit return type annotation will cause compilation failure", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_macro_type_constraint", "label": "ilp_for_range_t_macro_type_constraint", "x": 619.3109147595582, "y": 228.03222509320318, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'type' parameter must be a valid C++ type that can be used as a template argument and is compatible with the return type of ForResultTyped and ForCtrlTyped", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_n_param_unused_constraint", "label": "ilp_for_range_t_n_param_unused_constrain", "x": -104.28239916574803, "y": -526.1117148543103, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "The 'N' parameter is not used in the macro expansion and has no effect on the generated code", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_postcondition_range_for_loop", "label": "ilp_for_range_t_postcondition_range_for_", "x": -22.7279559921614, "y": 330.6150823943361, "size": 5.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expands to a standard C++ range-based for loop: 'for (loop_var_decl : (range))'", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_range_parenthesization", "label": "ilp_for_range_t_range_parenthesization", "x": 19.18337412506022, "y": 349.80909824299715, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The 'range' parameter is parenthesized in the expansion, protecting against operator precedence issues with comma operators", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_range_precondition", "label": "ilp_for_range_t_range_precondition", "x": -80.6116489833558, "y": 142.57193176409768, "size": 6.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'range' parameter must be an expression that satisfies the requirements of a range-based for loop (has begin() and end(), or is an array)", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_range_single_eval", "label": "ilp_for_range_t_range_single_eval", "x": -2.8799918460960625, "y": 318.3759278121918, "size": 6.5, "color": "#26de81", "layer": "library", "module": "", "content": "The 'range' argument is evaluated exactly once during range-based for loop initialization, protecting against multiple evaluation side effects", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_range_t_type_param_unused_constraint", "label": "ilp_for_range_t_type_param_unused_constr", "x": -125.82137501639555, "y": -547.7830105200313, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "The 'type' parameter is not used in the macro expansion and has no effect on the generated code", "function": "ILP_FOR_RANGE_T"}, {"id": "ilp_for_t_anti_pattern_side_effects_caution_4e7b9a3c", "label": "ilp_for_t_anti_pattern_side_effects_caut", "x": 309.7900540916878, "y": -906.4233583957266, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "While start and end are parenthesized, if ::ilp::iota copies its arguments or stores them, side effects in these expressions may still be observable; avoid expressions with side effects unless iota behavior is well understood", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_auto_anti_pattern_unused_params", "label": "ilp_for_t_auto_anti_pattern_unused_param", "x": -533.9806989892098, "y": 53.65956110020658, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Three of six parameters (ret_type, loop_type, element_type) are unused in the expansion, suggesting this macro may be part of a parameterized macro family where different variants use different parameters", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_complexity_iota_construction", "label": "ilp_for_t_auto_complexity_iota_construct", "x": -14.532103781703654, "y": 349.0548009787442, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion constructs an ilp::iota range object; complexity depends on iota implementation (typically O(1) for range construction)", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_constraint_element_type_compatible", "label": "ilp_for_t_auto_constraint_element_type_c", "x": 257.75620292870457, "y": 122.88083646300616, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The element_type parameter must be compatible with the type returned by ilp::iota iterator dereference, though it is unused in the expansion", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_constraint_loop_type_unused", "label": "ilp_for_t_auto_constraint_loop_type_unus", "x": 475.75120477835816, "y": 869.7052890900687, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_type parameter is unused in macro expansion and serves only for API compatibility", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_constraint_requires_cpp11", "label": "ilp_for_t_auto_constraint_requires_cpp11", "x": 14.079169041822858, "y": 310.332229239841, "size": 5.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro requires C++11 or later due to use of range-based for loop syntax", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_constraint_ret_type_unused", "label": "ilp_for_t_auto_constraint_ret_type_unuse", "x": -774.745860138634, "y": 456.71834739058613, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The ret_type parameter is unused in macro expansion and serves only for API compatibility", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_effect_single_eval_parenthesized", "label": "ilp_for_t_auto_effect_single_eval_parent", "x": -15.044711627772932, "y": 318.75725136148606, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are parenthesized in the expansion, protecting against precedence issues, and are passed to ilp::iota which evaluates them once during range construction", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_anti_pattern_missing_ilp_end", "label": "ilp_for_t_auto_macro_anti_pattern_missin", "x": -200.60299137829008, "y": 540.2401107994827, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro opens an if statement and lambda but does not close them - user must provide closing braces and likely use ILP_END macro", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_anti_pattern_scope_interaction", "label": "ilp_for_t_auto_macro_anti_pattern_scope_", "x": -144.784962977442, "y": -912.8220240080157, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro introduces hidden scopes (if statement scope and lambda scope) which can cause unexpected variable shadowing or lifetime issues", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_complexity_lambda_overhead", "label": "ilp_for_t_auto_macro_complexity_lambda_o", "x": 162.0391144257391, "y": 863.6635737879643, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro creates a lambda which is immediately invoked, potentially incurring lambda creation and invocation overhead unless optimized away by the compiler", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_constraint_element_type_complete", "label": "ilp_for_t_auto_macro_constraint_element_", "x": -239.16448192108575, "y": -690.4801582496362, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "element_type must be a complete type at the point of macro expansion to instantiate for_loop_typed_auto<element_type, ...>", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_constraint_loop_type_enum", "label": "ilp_for_t_auto_macro_constraint_loop_typ", "x": -23.393048420266968, "y": -905.2732654294169, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "loop_type must be a valid enumerator name in ::ilp::LoopType without the scope qualifier", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_constraint_loop_var_decl_syntax", "label": "ilp_for_t_auto_macro_constraint_loop_var", "x": 585.2324495384976, "y": 592.5453569308429, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "loop_var_decl must be syntactically valid as a lambda parameter declaration (e.g., 'auto& i', 'const int& x')", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_constraint_ret_type_complete", "label": "ilp_for_t_auto_macro_constraint_ret_type", "x": 321.5295708441256, "y": -505.22318717068237, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ret_type must be a complete type at the point of macro expansion to instantiate ForResultTyped<ret_type>", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_constraint_start_end_convertible", "label": "ilp_for_t_auto_macro_constraint_start_en", "x": 716.8338633062359, "y": 133.70353097650113, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "start and end must be convertible to types accepted by for_loop_typed_auto<element_type, ret_type, LoopType::loop_type>", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_effect_context_variable", "label": "ilp_for_t_auto_macro_effect_context_vari", "x": 742.8244067384285, "y": 271.47107303988173, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro creates a [[maybe_unused]] variable __ilp_ctx of type ::ilp::detail::For_Context_USE_ILP_END which may be used for compile-time checks or RAII patterns", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_effect_lambda_capture", "label": "ilp_for_t_auto_macro_effect_lambda_captu", "x": 693.3801978207493, "y": 253.22234753143104, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expands to a lambda with capture-by-reference [&], causing all variables referenced in loop_var_decl, start, end, and the loop body to be captured by reference", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_effect_multiple_eval_start_end", "label": "ilp_for_t_auto_macro_effect_multiple_eva", "x": -131.03211258194597, "y": 933.9585575401065, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are evaluated exactly once when the lambda is invoked, protected by function call semantics", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_effect_no_side_effects_expansion", "label": "ilp_for_t_auto_macro_effect_no_side_effe", "x": 113.93866268288629, "y": 529.6271524455369, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_macro_postcondition_if_condition", "label": "ilp_for_t_auto_macro_postcondition_if_co", "x": -697.152663061291, "y": 228.18348159043188, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expands to an if statement where the condition is the auto-declared __ilp_ret variable, which is contextually convertible to bool", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_postcond_range_for_expansion", "label": "ilp_for_t_auto_postcond_range_for_expans", "x": 5.415664946599, "y": 338.33574366798683, "size": 5.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expands to a C++11 range-based for loop iterating over the range returned by ilp::iota(start, end)", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_precond_iota_visible", "label": "ilp_for_t_auto_precond_iota_visible", "x": -895.6603135819315, "y": 172.67023433053018, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The ::ilp::iota function must be visible and callable at the point of macro expansion", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_precond_loop_var_decl_valid", "label": "ilp_for_t_auto_precond_loop_var_decl_val", "x": 17.867303114424455, "y": 333.9187807908659, "size": 5.0, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl must be a valid variable declaration compatible with range-based for loop syntax (e.g., 'auto i' or 'int i')", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_auto_precond_start_end_valid", "label": "ilp_for_t_auto_precond_start_end_valid", "x": -15.451735353890856, "y": 289.0967103719989, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments must be valid expressions that can be passed to ilp::iota, forming a valid range [start, end)", "function": "ILP_FOR_T_AUTO"}, {"id": "ilp_for_t_complexity_depends_on_iota_9f3a7e2c", "label": "ilp_for_t_complexity_depends_on_iota_9f3", "x": -854.9068384634908, "y": -141.91037204325923, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Loop iteration complexity is O(end - start) iterations, but actual performance depends on ::ilp::iota implementation and optimizer's ability to vectorize/unroll", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_constraint_iota_availability_8a5c3f2d", "label": "ilp_for_t_constraint_iota_availability_8", "x": -622.2069079421723, "y": -553.1638669090333, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The function ::ilp::iota must be defined and accessible at the point of macro expansion", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_constraint_start_end_compatible_types_5c2d8e9a", "label": "ilp_for_t_constraint_start_end_compatibl", "x": -690.1925455089187, "y": -234.12413324344652, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The types of start and end must be compatible with ::ilp::iota's parameter types for successful overload resolution", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_effect_no_expansion_side_effects_1a4b8c6d", "label": "ilp_for_t_effect_no_expansion_side_effec", "x": -110.46225968537217, "y": -506.58318964149987, "size": 3.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion itself performs simple textual substitution with no evaluation or side effects at preprocessing time", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_effect_single_eval_parenthesized_6f8d2a1b", "label": "ilp_for_t_effect_single_eval_parenthesiz", "x": 269.846374937436, "y": 114.61567440948504, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are parenthesized in the expansion, protecting them from operator precedence issues, but actual evaluation count depends on ::ilp::iota constructor/iterator behavior", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_anti_pattern_reuse_reserved_names", "label": "ilp_for_t_macro_anti_pattern_reuse_reser", "x": -158.80925943521004, "y": 776.7102746021163, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not use the reserved names __ilp_ret, __ilp_ctx, or __ilp_ctrl in the surrounding code or lambda body, as they will conflict with the macro-generated names", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_complexity_unroll_factor", "label": "ilp_for_t_macro_complexity_unroll_factor", "x": -792.2438360523191, "y": 47.89449143028912, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The N parameter controls the instruction-level parallelism unroll factor, affecting code size and performance - larger N increases code size but may improve ILP", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_constraint_lambda_context", "label": "ilp_for_t_macro_constraint_lambda_contex", "x": -686.0330658415479, "y": -626.2511932285344, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro must be used in a context where a lambda body can follow immediately, as the expansion creates an incomplete lambda expression that requires a body", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_constraint_scope_capture", "label": "ilp_for_t_macro_constraint_scope_capture", "x": 426.48430453974953, "y": 321.44530788699274, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro uses capture-by-reference [&] for both lambdas, requiring that all captured variables outlive the lambda execution", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_effect_context_independence", "label": "ilp_for_t_macro_effect_context_independe", "x": 834.9471240846149, "y": 66.4535666909556, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expansion is context-independent at preprocessing time - no side effects occur during expansion itself, only during runtime execution", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_effect_no_expansion_side_effects", "label": "ilp_for_t_macro_effect_no_expansion_side", "x": 685.5406837207488, "y": -679.9878161617203, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion itself has no side effects at preprocessing time - it performs simple textual substitution", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_effect_single_eval_start_end", "label": "ilp_for_t_macro_effect_single_eval_start", "x": -621.9374122730114, "y": -729.2560397056402, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end arguments are each evaluated exactly once when passed to for_loop_typed, protecting against multiple evaluation of side effects", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_postcond_ctrl_param_available", "label": "ilp_for_t_macro_postcond_ctrl_param_avai", "x": -738.5273500546455, "y": 81.76779827754038, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Within the lambda body following the macro, the loop control object __ilp_ctrl of type ::ilp::ForCtrlTyped<type>& is available for loop control operations", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_postcond_ilp_ret_bound", "label": "ilp_for_t_macro_postcond_ilp_ret_bound", "x": 218.05071457799906, "y": -949.9398484107816, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, the variable __ilp_ret is bound to the result of type ::ilp::ForResultTyped<type> and is available in the if-statement scope", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_precond_n_positive", "label": "ilp_for_t_macro_precond_n_positive", "x": 805.5439976503786, "y": 497.4858526458009, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The template parameter N must be a positive integer compile-time constant representing the unroll factor for instruction-level parallelism", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_precond_range_valid", "label": "ilp_for_t_macro_precond_range_valid", "x": -291.321231066749, "y": -831.1819682748251, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end parameters must form a valid range where start <= end and both are convertible to the loop index type", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_macro_precond_type_valid", "label": "ilp_for_t_macro_precond_type_valid", "x": -573.1770167747351, "y": -615.7579499206162, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The type parameter must be a valid typename that can be used with ::ilp::ForResultTyped<type> and ::ilp::for_loop_typed<type, N>", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_postcondition_range_for_expansion_2d9e7c4f", "label": "ilp_for_t_postcondition_range_for_expans", "x": -18.257265946286324, "y": 312.4000498484298, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expands to a C++11 range-based for loop over the range produced by ::ilp::iota(start, end)", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_precondition_loop_var_decl_syntax_9c3f1e5a", "label": "ilp_for_t_precondition_loop_var_decl_syn", "x": -24.335819472313606, "y": 311.78699208089137, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The loop_var_decl must be a valid range-for loop variable declaration (e.g., 'auto i', 'int& x', 'const auto& val')", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_precondition_n_unused_7b2e4c9f", "label": "ilp_for_t_precondition_n_unused_7b2e4c9f", "x": 939.1973989301569, "y": 299.20873594485903, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'N' parameter is unused in the macro expansion - likely intended for ILP unrolling factor but not implemented", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_precondition_type_unused_3a8f9d1c", "label": "ilp_for_t_precondition_type_unused_3a8f9", "x": 784.7022551350094, "y": -549.0054453986211, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The 'type' parameter is unused in the macro expansion - it exists for API consistency but has no effect", "function": "ILP_FOR_T"}, {"id": "ilp_for_t_precondition_valid_range_e4d7a2b8", "label": "ilp_for_t_precondition_valid_range_e4d7a", "x": -7.5359382112440105, "y": 315.9241595298802, "size": 4.5, "color": "#26de81", "layer": "library", "module": "", "content": "The start and end parameters must form a valid range for ::ilp::iota - typically start <= end for non-empty iteration", "function": "ILP_FOR_T"}, {"id": "ilp_n_bitwise_2_macro_anti_pattern_global_dependency", "label": "ilp_n_bitwise_2_macro_anti_pattern_globa", "x": -623.5046951796087, "y": -776.4463189039861, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_bitwise_2_macro_context_sensitivity", "label": "ilp_n_bitwise_2_macro_context_sensitivit", "x": 442.31904339904713, "y": 463.87281434452603, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_BITWISE_2 depends on the definition of ILP_CPU_PROFILE (and transitively ilp::cpu::default_profile) at the point of use, not at the point of macro definition", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_bitwise_2_macro_expansion", "label": "ilp_n_bitwise_2_macro_expansion", "x": -534.8149760917098, "y": -3.9086690824260635, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_BITWISE_2 is textually replaced with ILP_CPU_PROFILE.bitwise_2", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_bitwise_2_macro_lvalue_semantics", "label": "ilp_n_bitwise_2_macro_lvalue_semantics", "x": -96.74475801930562, "y": -965.9619465683045, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_BITWISE_2 directly modifies ILP_CPU_PROFILE.bitwise_2 (lvalue semantics preserved)", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_bitwise_2_macro_precondition_bitwise_2_member", "label": "ilp_n_bitwise_2_macro_precondition_bitwi", "x": -295.8145037079492, "y": -686.5405134789391, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expansion of ILP_CPU_PROFILE must have a member named bitwise_2", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_bitwise_2_macro_precondition_ilp_cpu_profile_defined", "label": "ilp_n_bitwise_2_macro_precondition_ilp_c", "x": -575.384742822081, "y": 778.3136431687842, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_BITWISE_2", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_bitwise_2_macro_simple_substitution", "label": "ilp_n_bitwise_2_macro_simple_substitutio", "x": 268.22523378350417, "y": 617.7255497963145, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_BITWISE_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_BITWISE_2"}, {"id": "ilp_n_copy_4_macro_anti_pattern_global_dependency", "label": "ilp_n_copy_4_macro_anti_pattern_global_d", "x": -572.2191350782213, "y": -268.16458330281944, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_copy_4_macro_context_sensitivity", "label": "ilp_n_copy_4_macro_context_sensitivity", "x": -415.56865071335716, "y": -734.7964624736079, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_COPY_4 depends on the definition of ilp::cpu::default_profile at the point of use, inherited through ILP_CPU_PROFILE, not at the point of macro definition", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_copy_4_macro_effect_lvalue", "label": "ilp_n_copy_4_macro_effect_lvalue", "x": -656.9458289489864, "y": 476.8932886578091, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_COPY_4 directly modifies ILP_CPU_PROFILE.copy_4 (lvalue semantics preserved)", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_copy_4_macro_expansion", "label": "ilp_n_copy_4_macro_expansion", "x": 590.4950693409381, "y": 99.55635335894551, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_COPY_4 is textually replaced with ILP_CPU_PROFILE.copy_4", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_copy_4_macro_precondition_copy_4_member_exists", "label": "ilp_n_copy_4_macro_precondition_copy_4_m", "x": -6.755524936541294, "y": 882.2109544559327, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expansion ILP_CPU_PROFILE must have a member named copy_4", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_copy_4_macro_precondition_ilp_cpu_profile_defined", "label": "ilp_n_copy_4_macro_precondition_ilp_cpu_", "x": -787.3324563512413, "y": -375.98207312942367, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before using ILP_N_COPY_4", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_copy_4_macro_simple_substitution", "label": "ilp_n_copy_4_macro_simple_substitution", "x": -306.3312389474897, "y": 641.1901896048626, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_COPY_4 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_COPY_4"}, {"id": "ilp_n_minmax_1_macro_anti_pattern_global_dependency", "label": "ilp_n_minmax_1_macro_anti_pattern_global", "x": 934.706783397898, "y": -367.392649946211, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.minmax_1 directly for clarity", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_1_macro_context_sensitivity", "label": "ilp_n_minmax_1_macro_context_sensitivity", "x": 715.8749036889826, "y": 536.7970688238759, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MINMAX_1 depends on the definition of ILP_CPU_PROFILE (and thus ilp::cpu::default_profile) at the point of use, not at the point of macro definition", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_1_macro_expansion", "label": "ilp_n_minmax_1_macro_expansion", "x": -683.7317217120504, "y": -196.50872852038322, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MINMAX_1 is textually replaced with ILP_CPU_PROFILE.minmax_1", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_1_macro_lvalue_semantics", "label": "ilp_n_minmax_1_macro_lvalue_semantics", "x": -138.99840516407815, "y": 971.2060784396919, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MINMAX_1 directly modifies ILP_CPU_PROFILE.minmax_1 (lvalue semantics preserved)", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_1_macro_member_existence", "label": "ilp_n_minmax_1_macro_member_existence", "x": -546.0496818851817, "y": 575.0528764514398, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named minmax_1 for this macro to be valid", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_1_macro_precondition_dependency", "label": "ilp_n_minmax_1_macro_precondition_depend", "x": -366.66685809988024, "y": 596.9503176773386, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MINMAX_1", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_1_macro_simple_substitution", "label": "ilp_n_minmax_1_macro_simple_substitution", "x": -385.14852160495803, "y": 382.3692465937386, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_MINMAX_1"}, {"id": "ilp_n_minmax_4i_macro_anti_pattern_double_expansion", "label": "ilp_n_minmax_4i_macro_anti_pattern_doubl", "x": 630.7994320263405, "y": 526.902394666494, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_4I expands to another macro ILP_CPU_PROFILE, creating a two-level expansion chain that may complicate debugging", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_anti_pattern_global_dependency", "label": "ilp_n_minmax_4i_macro_anti_pattern_globa", "x": 550.8125174898198, "y": -752.8301790421178, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_context_sensitivity", "label": "ilp_n_minmax_4i_macro_context_sensitivit", "x": 352.186574757424, "y": -773.0009665481092, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The ultimate binding of ILP_N_MINMAX_4I depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_effect_lvalue", "label": "ilp_n_minmax_4i_macro_effect_lvalue", "x": -385.7363455347259, "y": 352.2159886277859, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MINMAX_4I directly modifies ILP_CPU_PROFILE.minmax_4i (lvalue semantics preserved)", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_effect_simple_substitution", "label": "ilp_n_minmax_4i_macro_effect_simple_subs", "x": -521.0343937683051, "y": 138.94755994957595, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_4I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects during expansion", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_expansion", "label": "ilp_n_minmax_4i_macro_expansion", "x": 867.6860846492244, "y": -514.4988264843048, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MINMAX_4I is textually replaced with ILP_CPU_PROFILE.minmax_4i", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_precondition_ilp_cpu_profile_defined", "label": "ilp_n_minmax_4i_macro_precondition_ilp_c", "x": 475.58722213266117, "y": -369.37243606840326, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MINMAX_4I", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_4i_macro_precondition_minmax_4i_member_exists", "label": "ilp_n_minmax_4i_macro_precondition_minma", "x": -646.9157901083347, "y": -578.4678719158394, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must expand to an object or reference with a member named minmax_4i", "function": "ILP_N_MINMAX_4I"}, {"id": "ilp_n_minmax_8i_macro_anti_pattern_global_dependency", "label": "ilp_n_minmax_8i_macro_anti_pattern_globa", "x": 784.103840705273, "y": 564.788866759766, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.minmax_8i directly for clarity", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_context_sensitivity", "label": "ilp_n_minmax_8i_macro_context_sensitivit", "x": 601.0200591950924, "y": 782.8285792659831, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MINMAX_8I depends on the definition of ILP_CPU_PROFILE at the point of use, which transitively depends on ilp::cpu::default_profile", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_effect_lvalue", "label": "ilp_n_minmax_8i_macro_effect_lvalue", "x": -618.3773550774819, "y": -358.23731886859184, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MINMAX_8I directly modifies ILP_CPU_PROFILE.minmax_8i (lvalue semantics preserved)", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_expansion", "label": "ilp_n_minmax_8i_macro_expansion", "x": 591.3329826538765, "y": -48.0564435511682, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MINMAX_8I is textually replaced with ILP_CPU_PROFILE.minmax_8i", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_postcondition_type_preservation", "label": "ilp_n_minmax_8i_macro_postcondition_type", "x": -259.6434287903989, "y": -523.4225509443406, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After expansion, ILP_N_MINMAX_8I has exactly the same type as ILP_CPU_PROFILE.minmax_8i", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_precondition_ilp_cpu_profile_defined", "label": "ilp_n_minmax_8i_macro_precondition_ilp_c", "x": 453.10491013170093, "y": 298.30254114109925, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and accessible in the scope where ILP_N_MINMAX_8I is used", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_precondition_minmax_8i_member", "label": "ilp_n_minmax_8i_macro_precondition_minma", "x": -771.5630978332795, "y": -68.56064042130978, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named minmax_8i accessible at the point of use", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_minmax_8i_macro_simple_substitution", "label": "ilp_n_minmax_8i_macro_simple_substitutio", "x": 244.04370082621432, "y": 461.3603615707822, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_8I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_MINMAX_8I"}, {"id": "ilp_n_multiply_8i_macro_anti_pattern_global_dependency", "label": "ilp_n_multiply_8i_macro_anti_pattern_glo", "x": -575.7672498006267, "y": 505.5305138915945, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_multiply_8i_macro_context_sensitivity", "label": "ilp_n_multiply_8i_macro_context_sensitiv", "x": -923.4730537739833, "y": -215.37292882001637, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MULTIPLY_8I depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_multiply_8i_macro_effect_lvalue", "label": "ilp_n_multiply_8i_macro_effect_lvalue", "x": 693.3202163144563, "y": 131.0075543299512, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MULTIPLY_8I directly modifies ILP_CPU_PROFILE.multiply_8i (lvalue semantics preserved)", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_multiply_8i_macro_effect_simple_substitution", "label": "ilp_n_multiply_8i_macro_effect_simple_su", "x": -513.9360733718368, "y": 470.48228526965886, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MULTIPLY_8I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_multiply_8i_macro_expansion", "label": "ilp_n_multiply_8i_macro_expansion", "x": 110.84280237550848, "y": 720.8476963148807, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MULTIPLY_8I is textually replaced with ILP_CPU_PROFILE.multiply_8i", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_multiply_8i_macro_precondition_dependency", "label": "ilp_n_multiply_8i_macro_precondition_dep", "x": 592.1662380274737, "y": 303.56653667112687, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MULTIPLY_8I", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_multiply_8i_macro_precondition_member_exists", "label": "ilp_n_multiply_8i_macro_precondition_mem", "x": 2.134259859424851, "y": -803.7579325758618, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named multiply_8i accessible at the point of use", "function": "ILP_N_MULTIPLY_8I"}, {"id": "ilp_n_shift_2_macro_anti_pattern_global_dependency", "label": "ilp_n_shift_2_macro_anti_pattern_global_", "x": -630.7635944476473, "y": -214.8668622769868, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_complexity", "label": "ilp_n_shift_2_macro_complexity", "x": 532.5793113593381, "y": -17.7883187020542, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime cost (compile-time substitution only)", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_context_sensitivity", "label": "ilp_n_shift_2_macro_context_sensitivity", "x": -262.5120547485077, "y": -956.6705287745513, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SHIFT_2 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_effect_lvalue", "label": "ilp_n_shift_2_macro_effect_lvalue", "x": 3.3696081573428174, "y": -657.0194283895966, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SHIFT_2 directly modifies ILP_CPU_PROFILE.shift_2 (lvalue semantics preserved)", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_effect_no_side_effects", "label": "ilp_n_shift_2_macro_effect_no_side_effec", "x": 335.94250496567247, "y": -938.8801315490331, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SHIFT_2 performs simple textual substitution with no side effects and no argument evaluation", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_expansion", "label": "ilp_n_shift_2_macro_expansion", "x": 144.7692290184466, "y": 910.4895501065231, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SHIFT_2 is textually replaced with ILP_CPU_PROFILE.shift_2", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_precondition_member_exists", "label": "ilp_n_shift_2_macro_precondition_member_", "x": -735.7820851658514, "y": -82.8748621630893, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expansion of ILP_CPU_PROFILE must have a member named shift_2", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_shift_2_macro_precondition_profile_defined", "label": "ilp_n_shift_2_macro_precondition_profile", "x": -842.9506492705199, "y": 197.01517555607475, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined before using ILP_N_SHIFT_2", "function": "ILP_N_SHIFT_2"}, {"id": "ilp_n_sqrt_4f_macro_anti_pattern_global_dependency", "label": "ilp_n_sqrt_4f_macro_anti_pattern_global_", "x": 312.4876702673226, "y": -452.40647539428454, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sqrt_4f_macro_context_sensitivity", "label": "ilp_n_sqrt_4f_macro_context_sensitivity", "x": 47.860189519393906, "y": 864.6374086705677, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SQRT_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sqrt_4f_macro_effect_lvalue", "label": "ilp_n_sqrt_4f_macro_effect_lvalue", "x": -458.2118767266376, "y": -873.3838091045402, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SQRT_4F directly modifies ILP_CPU_PROFILE.sqrt_4f (lvalue semantics preserved)", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sqrt_4f_macro_expansion", "label": "ilp_n_sqrt_4f_macro_expansion", "x": 782.1476250856457, "y": 160.71707442729098, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SQRT_4F is textually replaced with ILP_CPU_PROFILE.sqrt_4f", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sqrt_4f_macro_precondition_ilp_cpu_profile_defined", "label": "ilp_n_sqrt_4f_macro_precondition_ilp_cpu", "x": 857.0985543475224, "y": 206.4512841420491, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before using ILP_N_SQRT_4F", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sqrt_4f_macro_precondition_member_exists", "label": "ilp_n_sqrt_4f_macro_precondition_member_", "x": 735.478023088342, "y": -167.62818964499516, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named sqrt_4f accessible at the point of use", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sqrt_4f_macro_simple_substitution", "label": "ilp_n_sqrt_4f_macro_simple_substitution", "x": 422.0302742563961, "y": 802.3447677306792, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SQRT_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SQRT_4F"}, {"id": "ilp_n_sum_1_macro_anti_pattern_global_dependency", "label": "ilp_n_sum_1_macro_anti_pattern_global_de", "x": 140.0270636119163, "y": -769.8169870213156, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ilp::cpu::default_profile.sum_1 directly for clarity", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_1_macro_complexity_zero_overhead", "label": "ilp_n_sum_1_macro_complexity_zero_overhe", "x": -445.8448927348766, "y": -638.7734206773138, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_1 has zero runtime overhead as it is purely a compile-time textual substitution with no additional operations", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_1_macro_context_sensitivity", "label": "ilp_n_sum_1_macro_context_sensitivity", "x": -614.2351080023607, "y": -429.87524357686317, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SUM_1 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_1_macro_effect_lvalue", "label": "ilp_n_sum_1_macro_effect_lvalue", "x": 159.07984078399136, "y": 491.838929805325, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SUM_1 directly modifies ILP_CPU_PROFILE.sum_1 (lvalue semantics preserved)", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_1_macro_effect_no_side_effects", "label": "ilp_n_sum_1_macro_effect_no_side_effects", "x": -318.0966453616475, "y": 459.4578486471697, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_1_macro_expansion", "label": "ilp_n_sum_1_macro_expansion", "x": -666.5838314672861, "y": -649.785399573064, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SUM_1 is textually replaced with ILP_CPU_PROFILE.sum_1, which further expands to ilp::cpu::default_profile.sum_1", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_1_macro_precondition_dependency", "label": "ilp_n_sum_1_macro_precondition_dependenc", "x": -745.4839644651042, "y": 38.355440111910376, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and evaluate to an object with a member named sum_1 before using ILP_N_SUM_1", "function": "ILP_N_SUM_1"}, {"id": "ilp_n_sum_4_alias_precondition_f8a2c1e9", "label": "ilp_n_sum_4_alias_precondition_f8a2c1e9", "x": -609.511204245417, "y": -462.9772038669433, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4 requires that ILP_N_SUM_4F is defined before use, as this is a simple redirection macro", "function": "ILP_N_SUM_4"}, {"id": "ilp_n_sum_4_complexity_zero_overhead_8a3f2e61", "label": "ilp_n_sum_4_complexity_zero_overhead_8a3", "x": -118.92976401913953, "y": 733.6740818124956, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4 has zero runtime overhead as it is resolved entirely at preprocessing time. Performance characteristics are identical to directly using ILP_CPU_PROFILE.sum_4f", "function": "ILP_N_SUM_4"}, {"id": "ilp_n_sum_4_constraint_no_params_c7e9d4b2", "label": "ilp_n_sum_4_constraint_no_params_c7e9d4b", "x": -966.4592335687303, "y": 215.41955179790554, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4 is an object-like macro (no parameters), so it cannot accept arguments and does not have multiple evaluation concerns", "function": "ILP_N_SUM_4"}, {"id": "ilp_n_sum_4_effect_pure_substitution_6d4e2a17", "label": "ilp_n_sum_4_effect_pure_substitution_6d4", "x": 311.17622138207247, "y": 643.5275377226883, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4 performs pure textual substitution to ILP_N_SUM_4F with no side effects during expansion. The macro is object-like (no parameters), so there are no argument evaluation concerns.", "function": "ILP_N_SUM_4"}, {"id": "ilp_n_sum_4_postcondition_type_inheritance_3f1a8c29", "label": "ilp_n_sum_4_postcondition_type_inheritan", "x": 621.0088924952142, "y": -774.9837134768137, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After expansion, ILP_N_SUM_4 has the same type and value as ILP_CPU_PROFILE.sum_4f (via ILP_N_SUM_4F), establishing type equivalence through the redirection chain", "function": "ILP_N_SUM_4"}, {"id": "ilp_n_sum_4_transitive_preconditions_2b9f7d43", "label": "ilp_n_sum_4_transitive_preconditions_2b9", "x": -567.4470518601197, "y": 704.2351955347963, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "All preconditions of ILP_N_SUM_4F apply transitively to ILP_N_SUM_4. This includes requirements on ILP_CPU_PROFILE being defined and having a valid sum_4f member.", "function": "ILP_N_SUM_4"}, {"id": "ilp_n_sum_8_expansion_semantics", "label": "ilp_n_sum_8_expansion_semantics", "x": -194.62177571303405, "y": 488.91252951985643, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_8 expands to ILP_N_SUM_8F through textual substitution. The expansion is transitive: ILP_N_SUM_8 \u2192 ILP_N_SUM_8F \u2192 ILP_CPU_PROFILE.sum_8f. No side effects occur during expansion.", "function": "ILP_N_SUM_8"}, {"id": "ilp_n_sum_8_final_form_member_access", "label": "ilp_n_sum_8_final_form_member_access", "x": 411.9472051729127, "y": 492.27775509956365, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After full macro expansion, ILP_N_SUM_8 evaluates to a member access expression ILP_CPU_PROFILE.sum_8f. The validity of this expression depends on ILP_CPU_PROFILE being defined and sum_8f being a valid member.", "function": "ILP_N_SUM_8"}, {"id": "ilp_n_sum_8_no_argument_evaluation", "label": "ilp_n_sum_8_no_argument_evaluation", "x": 625.6630187752304, "y": 776.5343558607331, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_8 is an object-like macro with no parameters, therefore there are no arguments to evaluate and no risk of multiple evaluation side effects.", "function": "ILP_N_SUM_8"}, {"id": "ilp_n_sum_8_type_inherited", "label": "ilp_n_sum_8_type_inherited", "x": 514.0593536427039, "y": -486.38115513743895, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The type of ILP_N_SUM_8 is determined by the type of ILP_CPU_PROFILE.sum_8f. Since this is a simple alias chain, type constraints are inherited from the final expansion target.", "function": "ILP_N_SUM_8"}, {"id": "ilp_n_transform_1_macro_anti_pattern_global_dependency", "label": "ilp_n_transform_1_macro_anti_pattern_glo", "x": 574.7799181086342, "y": -776.6319003491192, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.transform_1 directly for clarity", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_n_transform_1_macro_constraint_member_existence", "label": "ilp_n_transform_1_macro_constraint_membe", "x": -433.5269494736003, "y": 768.2100355083936, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The type of ILP_CPU_PROFILE must have a member named transform_1", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_n_transform_1_macro_context_sensitivity", "label": "ilp_n_transform_1_macro_context_sensitiv", "x": -497.7878783311434, "y": -587.9054191018855, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_TRANSFORM_1 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_n_transform_1_macro_expansion", "label": "ilp_n_transform_1_macro_expansion", "x": -609.4315081390632, "y": 605.387512193752, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_TRANSFORM_1 is textually replaced with ILP_CPU_PROFILE.transform_1", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_n_transform_1_macro_lvalue_semantics", "label": "ilp_n_transform_1_macro_lvalue_semantics", "x": 53.117287017960905, "y": 581.1047058879584, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_TRANSFORM_1 directly modifies ILP_CPU_PROFILE.transform_1 (lvalue semantics preserved)", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_n_transform_1_macro_precondition_dependency", "label": "ilp_n_transform_1_macro_precondition_dep", "x": -539.0722525865306, "y": 551.2961033636017, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_TRANSFORM_1 is used", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_n_transform_1_macro_simple_substitution", "label": "ilp_n_transform_1_macro_simple_substitut", "x": 608.0108050047778, "y": -409.46134275668345, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_TRANSFORM_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_TRANSFORM_1"}, {"id": "ilp_return_macro_anti_pattern_complex_expression", "label": "ilp_return_macro_anti_pattern_complex_ex", "x": -189.31785850680373, "y": -712.97066226478, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "While safe, using ILP_RETURN instead of bare 'return' provides no benefit and reduces code clarity", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_anti_pattern_exception_unsafe_b9c2d5e8", "label": "ilp_return_macro_anti_pattern_exception_", "x": 969.2710428700565, "y": 197.52457429103976, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If storage.set(x) throws an exception, return_set and ok will not be updated, leading to inconsistent state; the macro does not provide exception safety", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_complexity_constant_c7d3e1f9", "label": "ilp_return_macro_complexity_constant_c7d", "x": 816.0629138902366, "y": -317.5848830976382, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro expansion has O(1) overhead beyond the cost of storage.set(x), consisting of two boolean assignments", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_constraint_do_while_safe_d8e4f2a1", "label": "ilp_return_macro_constraint_do_while_saf", "x": 553.5352756041021, "y": 542.5704783003813, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro uses do-while(0) idiom making it safe to use in single-statement contexts (if/else without braces) and requiring semicolon after invocation", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_constraint_no_parenthesization_needed", "label": "ilp_return_macro_constraint_no_parenthes", "x": 254.71471339450335, "y": 919.0607597015404, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "No argument parenthesization is needed because 'return' statement handles arbitrary expressions safely", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_constraint_x_type_c5d8f2a3", "label": "ilp_return_macro_constraint_x_type_c5d8f", "x": -150.3428193993838, "y": -812.7240844629928, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The parameter x must be of a type compatible with the storage.set() method's parameter type", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_effect_control_flow_exit_a1b8c4d7", "label": "ilp_return_macro_effect_control_flow_exi", "x": 402.7722932895812, "y": 547.3016393100132, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro unconditionally exits the enclosing function via 'return', preventing any subsequent code in the function from executing", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_effect_no_preproc_side_effects_f5a2c3d6", "label": "ilp_return_macro_effect_no_preproc_side_", "x": 129.652366087585, "y": -717.2097651044038, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs textual substitution with no side effects at preprocessing time; all effects occur at runtime", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_effect_no_preprocessing_side_effects", "label": "ilp_return_macro_effect_no_preprocessing", "x": 13.261443263750863, "y": -612.8005979888582, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion performs simple textual substitution with no side effects at preprocessing time", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_effect_single_eval_d3e9a1b4", "label": "ilp_return_macro_effect_single_eval_d3e9", "x": -231.51350078963787, "y": 541.1793861730669, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The parameter x is evaluated exactly once during macro expansion, so side effects in x occur exactly once", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_effect_single_evaluation", "label": "ilp_return_macro_effect_single_evaluatio", "x": 514.1042090997171, "y": -557.4083675810629, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The argument x is evaluated exactly once during the return statement execution", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_postcond_control_transfer", "label": "ilp_return_macro_postcond_control_transf", "x": -223.72414239768136, "y": -648.1848596770361, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Execution control transfers to the caller of the enclosing function with the value of x", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_postcond_state_modified_e4f1b2c5", "label": "ilp_return_macro_postcond_state_modified", "x": -576.2605610850064, "y": 531.4759059607314, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, __ilp_ctrl.storage contains x, return_set is true, ok is false, and control flow exits the enclosing function", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_precond_in_function_scope", "label": "ilp_return_macro_precond_in_function_sco", "x": 808.1935634509947, "y": -230.9872713437269, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro must be used within a function scope where 'return' is valid", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_precond_storage_valid_a8f9d3e2", "label": "ilp_return_macro_precond_storage_valid_a", "x": 410.78748266816274, "y": 770.8593003755104, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The __ilp_ctrl object must be accessible in the current scope and its storage member must be a valid object", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_precond_type_compatible", "label": "ilp_return_macro_precond_type_compatible", "x": 632.0375971018477, "y": -558.2486501489623, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expression x must be convertible to the enclosing function's return type", "function": "ILP_RETURN"}, {"id": "ilp_return_macro_precond_void_context_b2c7e4f1", "label": "ilp_return_macro_precond_void_context_b2", "x": 882.7057402533809, "y": -226.72309821271452, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The macro must be used within a void-returning function or lambda, as it contains a bare 'return' statement", "function": "ILP_RETURN"}, {"id": "macro_ilp_n_bitwise_1_anti_pattern_global_dependency", "label": "macro_ilp_n_bitwise_1_anti_pattern_globa", "x": -219.2325670349042, "y": -876.6877960775091, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_complexity_zero", "label": "macro_ilp_n_bitwise_1_complexity_zero", "x": 15.661173370383313, "y": -837.8831167320133, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_BITWISE_1 has zero runtime overhead - it is purely a compile-time textual substitution that resolves to a member access", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_context_sensitivity", "label": "macro_ilp_n_bitwise_1_context_sensitivit", "x": -556.2448655583365, "y": -423.2519286229105, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_BITWISE_1 depends on the definition of ILP_CPU_PROFILE (and transitively ilp::cpu::default_profile) at the point of use, not at the point of macro definition", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_effect_lvalue", "label": "macro_ilp_n_bitwise_1_effect_lvalue", "x": 527.4441605040787, "y": 722.8921253619503, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_BITWISE_1 directly modifies ILP_CPU_PROFILE.bitwise_1 (lvalue semantics preserved)", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_effect_no_side_effects", "label": "macro_ilp_n_bitwise_1_effect_no_side_eff", "x": -331.52414260151386, "y": 761.9209103687209, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_BITWISE_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_expansion", "label": "macro_ilp_n_bitwise_1_expansion", "x": 681.4968967311299, "y": 450.4487351453369, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_BITWISE_1 is textually replaced with ILP_CPU_PROFILE.bitwise_1", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_precondition_bitwise_1_member", "label": "macro_ilp_n_bitwise_1_precondition_bitwi", "x": -715.4156087000334, "y": 314.57454794705137, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named bitwise_1 accessible at the point of use", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_1_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_bitwise_1_precondition_ilp_c", "x": 911.3502328354051, "y": 273.676829091916, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_BITWISE_1 is used", "function": "ILP_N_BITWISE_1"}, {"id": "macro_ilp_n_bitwise_4_anti_pattern_global_dependency", "label": "macro_ilp_n_bitwise_4_anti_pattern_globa", "x": -581.3553252471885, "y": -73.80243319324205, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_complexity_zero", "label": "macro_ilp_n_bitwise_4_complexity_zero", "x": 555.7874952481131, "y": -44.6277634884766, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime cost; complexity is O(1) textual substitution at compile time", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_effect_context_sensitivity", "label": "macro_ilp_n_bitwise_4_effect_context_sen", "x": -778.4983880637658, "y": -350.11031730059915, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_BITWISE_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_effect_lvalue", "label": "macro_ilp_n_bitwise_4_effect_lvalue", "x": 535.6825356674638, "y": 694.0098394578313, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_BITWISE_4 directly modifies ILP_CPU_PROFILE.bitwise_4 (lvalue semantics preserved)", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_effect_no_side_effects", "label": "macro_ilp_n_bitwise_4_effect_no_side_eff", "x": -489.33935362515723, "y": 811.8621815502104, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_BITWISE_4 performs simple textual substitution with no side effects and no multiple evaluation", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_postcondition_expansion", "label": "macro_ilp_n_bitwise_4_postcondition_expa", "x": -440.23473854353153, "y": 458.85344883408163, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_BITWISE_4 is textually replaced with ILP_CPU_PROFILE.bitwise_4", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_precondition_bitwise_4_member", "label": "macro_ilp_n_bitwise_4_precondition_bitwi", "x": 482.31746588987505, "y": 638.5562705349341, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named bitwise_4 accessible at the point of use", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_4_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_bitwise_4_precondition_ilp_c", "x": 869.1413885329924, "y": -297.191532236149, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_BITWISE_4 is used", "function": "ILP_N_BITWISE_4"}, {"id": "macro_ilp_n_bitwise_8_anti_pattern_global_dependency", "label": "macro_ilp_n_bitwise_8_anti_pattern_globa", "x": 612.0985593298471, "y": -655.8421646459725, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_complexity", "label": "macro_ilp_n_bitwise_8_complexity", "x": 460.3395869407621, "y": 550.7405152541065, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_N_BITWISE_8 has zero runtime overhead compared to accessing ILP_CPU_PROFILE.bitwise_8 directly (textual substitution only)", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_context_sensitivity", "label": "macro_ilp_n_bitwise_8_context_sensitivit", "x": 403.41382542584137, "y": -581.0265971326025, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_BITWISE_8 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_effect_lvalue", "label": "macro_ilp_n_bitwise_8_effect_lvalue", "x": 670.1886771568945, "y": -578.2506809800204, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_BITWISE_8 directly modifies ILP_CPU_PROFILE.bitwise_8 (lvalue semantics preserved)", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_effect_simple_substitution", "label": "macro_ilp_n_bitwise_8_effect_simple_subs", "x": -902.9210179645975, "y": 334.2963696815612, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_BITWISE_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_expansion", "label": "macro_ilp_n_bitwise_8_expansion", "x": -29.33514305626573, "y": 789.2054448535123, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_BITWISE_8 is textually replaced with ILP_CPU_PROFILE.bitwise_8", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_precondition_bitwise_8_member", "label": "macro_ilp_n_bitwise_8_precondition_bitwi", "x": -200.6017597848229, "y": -732.9739358356161, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named bitwise_8 accessible at the point of use", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_bitwise_8_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_bitwise_8_precondition_ilp_c", "x": 800.6444584016178, "y": 75.95215232521863, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_BITWISE_8 is used", "function": "ILP_N_BITWISE_8"}, {"id": "macro_ilp_n_copy_1_anti_pattern_global_dependency", "label": "macro_ilp_n_copy_1_anti_pattern_global_d", "x": -666.1811117238577, "y": 421.8049909534725, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_1_complexity_zero", "label": "macro_ilp_n_copy_1_complexity_zero", "x": 172.29067730455904, "y": 517.49284621137, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime cost - it is a compile-time textual substitution", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_1_effect_lvalue", "label": "macro_ilp_n_copy_1_effect_lvalue", "x": -62.23002603496267, "y": 758.0504197615669, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_COPY_1 directly modifies ILP_CPU_PROFILE.copy_1 (lvalue semantics preserved)", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_1_effect_simple_substitution", "label": "macro_ilp_n_copy_1_effect_simple_substit", "x": 679.4015149224966, "y": 381.86598958772504, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_COPY_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_1_postcondition_alias", "label": "macro_ilp_n_copy_1_postcondition_alias", "x": -726.7314652838272, "y": 525.7805731671552, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_COPY_1 is an alias for ILP_CPU_PROFILE.copy_1, referring to the same object", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_1_precondition_copy_1_member_exists", "label": "macro_ilp_n_copy_1_precondition_copy_1_m", "x": 431.9413345882983, "y": 513.8127429658418, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named copy_1 accessible at the point of use", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_1_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_copy_1_precondition_ilp_cpu_", "x": -180.7407006160144, "y": 829.879580173071, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_COPY_1 is used", "function": "ILP_N_COPY_1"}, {"id": "macro_ilp_n_copy_2_anti_pattern_global_dependency", "label": "macro_ilp_n_copy_2_anti_pattern_global_d", "x": 396.91158576979984, "y": -767.0502570162569, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_complexity_zero", "label": "macro_ilp_n_copy_2_complexity_zero", "x": -124.8654939896182, "y": 837.8513158202534, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime cost; complexity depends on what operations are performed on the expanded member", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_context_sensitivity", "label": "macro_ilp_n_copy_2_context_sensitivity", "x": -684.5124577119198, "y": 697.3041677841271, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_COPY_2 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_effect_lvalue", "label": "macro_ilp_n_copy_2_effect_lvalue", "x": 497.5247282256708, "y": 403.4902002340215, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_COPY_2 directly modifies ILP_CPU_PROFILE.copy_2 (lvalue semantics preserved)", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_effect_simple_substitution", "label": "macro_ilp_n_copy_2_effect_simple_substit", "x": -476.66280582168076, "y": -540.0319644134667, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_COPY_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_expansion", "label": "macro_ilp_n_copy_2_expansion", "x": 853.5892193429986, "y": -322.56007227631653, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_COPY_2 is textually replaced with ILP_CPU_PROFILE.copy_2", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_precondition_member_exists", "label": "macro_ilp_n_copy_2_precondition_member_e", "x": 682.1208839827383, "y": -240.55923631833315, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named copy_2 accessible at the point of use", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_2_precondition_profile_defined", "label": "macro_ilp_n_copy_2_precondition_profile_", "x": -524.2796162560678, "y": -847.2957923952324, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_COPY_2", "function": "ILP_N_COPY_2"}, {"id": "macro_ilp_n_copy_8_anti_pattern_global_dependency", "label": "macro_ilp_n_copy_8_anti_pattern_global_d", "x": 86.44263540849165, "y": 957.8857411690104, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_complexity_zero", "label": "macro_ilp_n_copy_8_complexity_zero", "x": -386.6396737910791, "y": -486.30246377517904, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead - it is a compile-time textual substitution", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_context_sensitivity", "label": "macro_ilp_n_copy_8_context_sensitivity", "x": -548.8461836487705, "y": 112.28864693589588, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_COPY_8 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_effect_lvalue", "label": "macro_ilp_n_copy_8_effect_lvalue", "x": -73.73814281240456, "y": 816.0001873244353, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_COPY_8 directly modifies ILP_CPU_PROFILE.copy_8 (lvalue semantics preserved)", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_effect_simple_substitution", "label": "macro_ilp_n_copy_8_effect_simple_substit", "x": -228.2058683574494, "y": 490.08670198850774, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_COPY_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_expansion", "label": "macro_ilp_n_copy_8_expansion", "x": -484.7499106222452, "y": 863.3508017223742, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_COPY_8 is textually replaced with ILP_CPU_PROFILE.copy_8", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_precondition_copy_8_member", "label": "macro_ilp_n_copy_8_precondition_copy_8_m", "x": -356.19084147803943, "y": -792.7975607100485, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expanded ILP_CPU_PROFILE must have a member named copy_8", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_copy_8_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_copy_8_precondition_ilp_cpu_", "x": 494.29666926974966, "y": 324.6951941018155, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_COPY_8", "function": "ILP_N_COPY_8"}, {"id": "macro_ilp_n_divide_4f_anti_pattern_global_dependency", "label": "macro_ilp_n_divide_4f_anti_pattern_globa", "x": -354.39614542601964, "y": -440.64472636566086, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_complexity_zero_overhead", "label": "macro_ilp_n_divide_4f_complexity_zero_ov", "x": 535.5988389686239, "y": -591.8227886986025, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead - it is purely a compile-time textual substitution", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_effect_context_sensitivity", "label": "macro_ilp_n_divide_4f_effect_context_sen", "x": 741.7949713002604, "y": 298.2828548080667, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_DIVIDE_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_effect_lvalue", "label": "macro_ilp_n_divide_4f_effect_lvalue", "x": -500.7637834630037, "y": -238.21425572515423, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_DIVIDE_4F directly modifies ILP_CPU_PROFILE.divide_4f (lvalue semantics preserved)", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_effect_no_side_effects", "label": "macro_ilp_n_divide_4f_effect_no_side_eff", "x": -495.3874006469302, "y": 549.7859637409517, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_DIVIDE_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_postcondition_expansion", "label": "macro_ilp_n_divide_4f_postcondition_expa", "x": 82.3536498215347, "y": -594.8512439050062, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_DIVIDE_4F is textually replaced with ILP_CPU_PROFILE.divide_4f", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_precondition_member_exists", "label": "macro_ilp_n_divide_4f_precondition_membe", "x": 173.8321225209447, "y": 965.1218301225057, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named divide_4f", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_4f_precondition_profile_defined", "label": "macro_ilp_n_divide_4f_precondition_profi", "x": -75.80645880691979, "y": 889.8099203306265, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_DIVIDE_4F", "function": "ILP_N_DIVIDE_4F"}, {"id": "macro_ilp_n_divide_8f_anti_pattern_global_dependency", "label": "macro_ilp_n_divide_8f_anti_pattern_globa", "x": -213.1874119184757, "y": -906.7673828210601, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_complexity_zero_overhead", "label": "macro_ilp_n_divide_8f_complexity_zero_ov", "x": -679.9158966423317, "y": -160.88055946534817, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_DIVIDE_8F has zero runtime overhead compared to direct member access since it is a compile-time textual substitution", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_effect_context_sensitivity", "label": "macro_ilp_n_divide_8f_effect_context_sen", "x": -383.4621940701647, "y": -920.7863390334853, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_DIVIDE_8F depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_effect_lvalue", "label": "macro_ilp_n_divide_8f_effect_lvalue", "x": 779.4904805705049, "y": 533.4051886436679, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_DIVIDE_8F directly modifies ILP_CPU_PROFILE.divide_8f (lvalue semantics preserved)", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_effect_no_side_effects", "label": "macro_ilp_n_divide_8f_effect_no_side_eff", "x": 451.90603783160367, "y": -654.3333333236743, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_DIVIDE_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_postcondition_expansion", "label": "macro_ilp_n_divide_8f_postcondition_expa", "x": -619.4832990569404, "y": -702.2203189260932, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_DIVIDE_8F is textually replaced with ILP_CPU_PROFILE.divide_8f", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_precondition_member_exists", "label": "macro_ilp_n_divide_8f_precondition_membe", "x": 322.4756274946483, "y": 896.7474277624714, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named divide_8f accessible at the point of use", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_divide_8f_precondition_profile_defined", "label": "macro_ilp_n_divide_8f_precondition_profi", "x": -56.7989485253251, "y": -845.2222909893517, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before using ILP_N_DIVIDE_8F", "function": "ILP_N_DIVIDE_8F"}, {"id": "macro_ilp_n_dotproduct_4_anti_pattern_global_dependency", "label": "macro_ilp_n_dotproduct_4_anti_pattern_gl", "x": 68.45448008587255, "y": -557.1594129588738, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_4_context_sensitivity", "label": "macro_ilp_n_dotproduct_4_context_sensiti", "x": -439.01153841572904, "y": 386.11919017471337, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_DOTPRODUCT_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_4_effect_lvalue", "label": "macro_ilp_n_dotproduct_4_effect_lvalue", "x": 339.289315025005, "y": -794.5103493380367, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_DOTPRODUCT_4 directly modifies ILP_CPU_PROFILE.dotproduct_4 (lvalue semantics preserved)", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_4_effect_no_side_effects", "label": "macro_ilp_n_dotproduct_4_effect_no_side_", "x": -645.5145034638726, "y": 741.7076792688208, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_DOTPRODUCT_4 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_4_expansion", "label": "macro_ilp_n_dotproduct_4_expansion", "x": -390.5416267195349, "y": -814.3850654931084, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_DOTPRODUCT_4 is textually replaced with ILP_CPU_PROFILE.dotproduct_4", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_4_precondition_dotproduct_4_member", "label": "macro_ilp_n_dotproduct_4_precondition_do", "x": -494.4029331504687, "y": -800.0277770071322, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named dotproduct_4", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_4_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_dotproduct_4_precondition_il", "x": -125.28256628820439, "y": 691.8585922151492, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_DOTPRODUCT_4 is used", "function": "ILP_N_DOTPRODUCT_4"}, {"id": "macro_ilp_n_dotproduct_8_anti_pattern_global_dependency", "label": "macro_ilp_n_dotproduct_8_anti_pattern_gl", "x": -573.5816070314662, "y": -159.90491995148713, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ILP_CPU_PROFILE.dotproduct_8 directly for clarity", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_complexity_zero_overhead", "label": "macro_ilp_n_dotproduct_8_complexity_zero", "x": 585.4396300027678, "y": 14.63486788161772, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_DOTPRODUCT_8 has zero runtime overhead as it is a compile-time textual substitution", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_context_sensitivity", "label": "macro_ilp_n_dotproduct_8_context_sensiti", "x": 625.5161749423265, "y": 634.4551261263032, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_DOTPRODUCT_8 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_effect_lvalue_preserved", "label": "macro_ilp_n_dotproduct_8_effect_lvalue_p", "x": -902.3704103385462, "y": 381.59443154786885, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_DOTPRODUCT_8 directly modifies ILP_CPU_PROFILE.dotproduct_8 (lvalue semantics preserved)", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_effect_no_side_effects", "label": "macro_ilp_n_dotproduct_8_effect_no_side_", "x": -39.6410805100528, "y": 995.5460443879746, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_DOTPRODUCT_8 performs simple textual substitution with no side effects and no multiple evaluation", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_expansion", "label": "macro_ilp_n_dotproduct_8_expansion", "x": 19.389414263787604, "y": 984.0207446979992, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_DOTPRODUCT_8 is textually replaced with ILP_CPU_PROFILE.dotproduct_8", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_precondition_dotproduct_8_member", "label": "macro_ilp_n_dotproduct_8_precondition_do", "x": 543.1277969706669, "y": -506.93897603166005, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named dotproduct_8", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_dotproduct_8_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_dotproduct_8_precondition_il", "x": 74.88563276705214, "y": 983.7786426574863, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_DOTPRODUCT_8", "function": "ILP_N_DOTPRODUCT_8"}, {"id": "macro_ilp_n_minmax_2_anti_pattern_global_dependency", "label": "macro_ilp_n_minmax_2_anti_pattern_global", "x": 551.0107208008624, "y": -723.0471608001053, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_complexity_zero_overhead", "label": "macro_ilp_n_minmax_2_complexity_zero_ove", "x": 540.2617652982757, "y": -357.2068496879612, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_N_MINMAX_2 has zero runtime overhead compared to using ILP_CPU_PROFILE.minmax_2 directly (compile-time substitution)", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_effect_context_sensitivity", "label": "macro_ilp_n_minmax_2_effect_context_sens", "x": -975.6626204461331, "y": -146.70192239691383, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MINMAX_2 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_effect_lvalue", "label": "macro_ilp_n_minmax_2_effect_lvalue", "x": -503.33829998030956, "y": 610.5672022836517, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MINMAX_2 directly modifies ILP_CPU_PROFILE.minmax_2 (lvalue semantics preserved)", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_effect_simple_substitution", "label": "macro_ilp_n_minmax_2_effect_simple_subst", "x": -289.8712749256632, "y": 708.4856058474361, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_postcondition_expansion", "label": "macro_ilp_n_minmax_2_postcondition_expan", "x": -956.0062887053714, "y": -285.883470450654, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MINMAX_2 is textually replaced with ILP_CPU_PROFILE.minmax_2", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_minmax_2_precondition_ilp_cp", "x": -559.4257715610149, "y": -532.7092243263695, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_MINMAX_2 is used", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_2_precondition_minmax_2_member_exists", "label": "macro_ilp_n_minmax_2_precondition_minmax", "x": -787.5390791507415, "y": -501.9208501833895, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named minmax_2 accessible at the point of use", "function": "ILP_N_MINMAX_2"}, {"id": "macro_ilp_n_minmax_4f_anti_pattern_implicit_dependency", "label": "macro_ilp_n_minmax_4f_anti_pattern_impli", "x": 193.18555278242843, "y": -593.7160500225002, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_N_MINMAX_4F creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_4f_complexity_zero_overhead", "label": "macro_ilp_n_minmax_4f_complexity_zero_ov", "x": -310.67777903366544, "y": -495.3536828025442, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_4F has zero runtime overhead - it is purely compile-time textual substitution", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_4f_context_sensitivity", "label": "macro_ilp_n_minmax_4f_context_sensitivit", "x": 617.0244480294383, "y": 688.5255795463837, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The semantic binding of ILP_N_MINMAX_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_4f_effect_lvalue", "label": "macro_ilp_n_minmax_4f_effect_lvalue", "x": -29.59332881808026, "y": -579.7981323643199, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MINMAX_4F directly modifies ILP_CPU_PROFILE.minmax_4f (lvalue semantics preserved)", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_4f_effect_no_side_effects", "label": "macro_ilp_n_minmax_4f_effect_no_side_eff", "x": -563.787421697338, "y": 754.6105657670826, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects at expansion time", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_4f_expansion", "label": "macro_ilp_n_minmax_4f_expansion", "x": -808.6249280754757, "y": -340.8465892845415, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MINMAX_4F is textually replaced with ILP_CPU_PROFILE.minmax_4f", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_4f_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_minmax_4f_precondition_ilp_c", "x": -507.3198372719171, "y": -460.57209994973005, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE macro must be defined and expand to an object with a minmax_4f member before ILP_N_MINMAX_4F can be used", "function": "ILP_N_MINMAX_4F"}, {"id": "macro_ilp_n_minmax_8f_anti_pattern_global_dependency", "label": "macro_ilp_n_minmax_8f_anti_pattern_globa", "x": -677.9224220644086, "y": 468.399665428353, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_minmax_8f_effect_context_sensitivity", "label": "macro_ilp_n_minmax_8f_effect_context_sen", "x": -812.3565362363855, "y": 224.8162806057384, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MINMAX_8F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_minmax_8f_effect_lvalue", "label": "macro_ilp_n_minmax_8f_effect_lvalue", "x": -594.4942392417931, "y": -693.4838017985222, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MINMAX_8F directly modifies ILP_CPU_PROFILE.minmax_8f (lvalue semantics preserved)", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_minmax_8f_effect_no_side_effects", "label": "macro_ilp_n_minmax_8f_effect_no_side_eff", "x": 742.3013703185708, "y": -516.17289916221, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MINMAX_8F performs simple textual substitution with no side effects and no multiple evaluation (object-like macro with no arguments)", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_minmax_8f_postcondition_expansion", "label": "macro_ilp_n_minmax_8f_postcondition_expa", "x": 786.4178861311246, "y": 55.99579127712834, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MINMAX_8F is textually replaced with ILP_CPU_PROFILE.minmax_8f", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_minmax_8f_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_minmax_8f_precondition_ilp_c", "x": -604.7020107318232, "y": 766.0140895202353, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MINMAX_8F", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_minmax_8f_precondition_member_exists", "label": "macro_ilp_n_minmax_8f_precondition_membe", "x": -450.19284227194123, "y": 701.7489611594536, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named minmax_8f accessible at the point of use", "function": "ILP_N_MINMAX_8F"}, {"id": "macro_ilp_n_multiply_4f_anti_pattern_global_dependency", "label": "macro_ilp_n_multiply_4f_anti_pattern_glo", "x": -575.8846962112127, "y": 619.2696259379676, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_complexity_zero_overhead", "label": "macro_ilp_n_multiply_4f_complexity_zero_", "x": -955.0657005787826, "y": 78.20271210313754, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead - it is a compile-time textual substitution", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_effect_context_sensitivity", "label": "macro_ilp_n_multiply_4f_effect_context_s", "x": 410.6088284401889, "y": 838.6212007827041, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MULTIPLY_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_effect_lvalue", "label": "macro_ilp_n_multiply_4f_effect_lvalue", "x": 786.1875811521704, "y": 510.712549690627, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MULTIPLY_4F directly modifies ILP_CPU_PROFILE.multiply_4f (lvalue semantics preserved)", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_effect_no_side_effects", "label": "macro_ilp_n_multiply_4f_effect_no_side_e", "x": 693.6356161941713, "y": -504.7002965308818, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MULTIPLY_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_postcondition_expansion", "label": "macro_ilp_n_multiply_4f_postcondition_ex", "x": -502.4932110295808, "y": -499.8977999921487, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MULTIPLY_4F is textually replaced with ILP_CPU_PROFILE.multiply_4f", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_precondition_member_exists", "label": "macro_ilp_n_multiply_4f_precondition_mem", "x": -368.206322865465, "y": -474.4618123287793, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named multiply_4f", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4f_precondition_profile_defined", "label": "macro_ilp_n_multiply_4f_precondition_pro", "x": 84.72146207630824, "y": -778.2722945885472, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MULTIPLY_4F", "function": "ILP_N_MULTIPLY_4F"}, {"id": "macro_ilp_n_multiply_4i_anti_pattern_global_dependency", "label": "macro_ilp_n_multiply_4i_anti_pattern_glo", "x": 378.35531732760484, "y": -698.5551254133313, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.multiply_4i directly for clarity", "function": "ILP_N_MULTIPLY_4I"}, {"id": "macro_ilp_n_multiply_4i_context_sensitivity", "label": "macro_ilp_n_multiply_4i_context_sensitiv", "x": -620.1509359666808, "y": -73.36155877886348, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_MULTIPLY_4I depends on the definition of ILP_CPU_PROFILE at the point of use, which itself depends on ilp::cpu::default_profile", "function": "ILP_N_MULTIPLY_4I"}, {"id": "macro_ilp_n_multiply_4i_effect_lvalue", "label": "macro_ilp_n_multiply_4i_effect_lvalue", "x": 613.7477399148605, "y": 469.5518345550887, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MULTIPLY_4I directly modifies ILP_CPU_PROFILE.multiply_4i (lvalue semantics preserved through member access)", "function": "ILP_N_MULTIPLY_4I"}, {"id": "macro_ilp_n_multiply_4i_effect_simple_substitution", "label": "macro_ilp_n_multiply_4i_effect_simple_su", "x": 244.76052429750476, "y": -780.5838050588935, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MULTIPLY_4I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects at macro expansion time", "function": "ILP_N_MULTIPLY_4I"}, {"id": "macro_ilp_n_multiply_4i_expansion", "label": "macro_ilp_n_multiply_4i_expansion", "x": 103.05989442307205, "y": -859.4475723836563, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MULTIPLY_4I is textually replaced with ILP_CPU_PROFILE.multiply_4i", "function": "ILP_N_MULTIPLY_4I"}, {"id": "macro_ilp_n_multiply_4i_precondition_dependency", "label": "macro_ilp_n_multiply_4i_precondition_dep", "x": -468.499677000192, "y": -352.81764434047847, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and refer to an object/struct with a multiply_4i member before ILP_N_MULTIPLY_4I can be used", "function": "ILP_N_MULTIPLY_4I"}, {"id": "macro_ilp_n_multiply_8f_anti_pattern_global_dependency", "label": "macro_ilp_n_multiply_8f_anti_pattern_glo", "x": -893.7952409074783, "y": -354.52190509497785, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ILP_CPU_PROFILE.multiply_8f directly for clarity", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_multiply_8f_context_sensitivity", "label": "macro_ilp_n_multiply_8f_context_sensitiv", "x": 718.1144666607441, "y": 674.8125068427568, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The semantic meaning of ILP_N_MULTIPLY_8F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_multiply_8f_effect_lvalue", "label": "macro_ilp_n_multiply_8f_effect_lvalue", "x": -183.0579672926195, "y": -932.7057004211275, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_MULTIPLY_8F directly modifies ILP_CPU_PROFILE.multiply_8f (lvalue semantics preserved)", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_multiply_8f_effect_simple_substitution", "label": "macro_ilp_n_multiply_8f_effect_simple_su", "x": -715.1082892107703, "y": -204.7196354200584, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_MULTIPLY_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects during expansion", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_multiply_8f_expansion", "label": "macro_ilp_n_multiply_8f_expansion", "x": 755.9868992687747, "y": -577.8020898249503, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_MULTIPLY_8F is textually replaced with ILP_CPU_PROFILE.multiply_8f", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_multiply_8f_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_multiply_8f_precondition_ilp", "x": 471.64610539186634, "y": -743.8433600919125, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MULTIPLY_8F", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_multiply_8f_precondition_multiply_8f_member", "label": "macro_ilp_n_multiply_8f_precondition_mul", "x": 955.3848949334078, "y": -194.4572722858289, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named multiply_8f accessible at the point of use", "function": "ILP_N_MULTIPLY_8F"}, {"id": "macro_ilp_n_search_1_anti_pattern_global_dependency", "label": "macro_ilp_n_search_1_anti_pattern_global", "x": 669.9873393176314, "y": -299.85428013637375, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_complexity_zero_overhead", "label": "macro_ilp_n_search_1_complexity_zero_ove", "x": 258.36510611327697, "y": -706.8426432903781, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SEARCH_1 has zero runtime overhead - it is purely a compile-time textual substitution", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_context_sensitivity", "label": "macro_ilp_n_search_1_context_sensitivity", "x": -509.32973222919514, "y": 787.9557212903825, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SEARCH_1 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_effect_lvalue", "label": "macro_ilp_n_search_1_effect_lvalue", "x": 718.2599358523215, "y": 618.9236544405381, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SEARCH_1 directly modifies ILP_CPU_PROFILE.search_1 (lvalue semantics preserved)", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_effect_no_side_effects", "label": "macro_ilp_n_search_1_effect_no_side_effe", "x": 224.47671852026986, "y": 711.251113392743, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SEARCH_1 performs simple textual substitution with no side effects and no evaluation (no parameters)", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_expansion", "label": "macro_ilp_n_search_1_expansion", "x": -830.29660701577, "y": -215.30719039701, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SEARCH_1 is textually replaced with ILP_CPU_PROFILE.search_1", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_search_1_precondition_ilp_cp", "x": -501.92142675978255, "y": 369.5068966225852, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and accessible in the scope where ILP_N_SEARCH_1 is used", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_1_precondition_search_1_member", "label": "macro_ilp_n_search_1_precondition_search", "x": -242.1697412866589, "y": -750.7387274506847, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named search_1", "function": "ILP_N_SEARCH_1"}, {"id": "macro_ilp_n_search_2_anti_pattern_global_dependency", "label": "macro_ilp_n_search_2_anti_pattern_global", "x": 191.85305818930928, "y": 733.9375048975481, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_complexity_zero_overhead", "label": "macro_ilp_n_search_2_complexity_zero_ove", "x": -183.67184441002274, "y": -801.1696053953891, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead - it is purely a compile-time textual substitution", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_context_sensitivity", "label": "macro_ilp_n_search_2_context_sensitivity", "x": -615.5394010973716, "y": -496.02664616631597, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SEARCH_2 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_effect_lvalue", "label": "macro_ilp_n_search_2_effect_lvalue", "x": -512.5446733325462, "y": 420.5128987825596, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SEARCH_2 directly modifies ILP_CPU_PROFILE.search_2 (lvalue semantics preserved)", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_effect_no_side_effects", "label": "macro_ilp_n_search_2_effect_no_side_effe", "x": 287.67959528577956, "y": 552.1070298628109, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SEARCH_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_expansion", "label": "macro_ilp_n_search_2_expansion", "x": -194.41570474893726, "y": 745.4415201962001, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SEARCH_2 is textually replaced with ILP_CPU_PROFILE.search_2", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_search_2_precondition_ilp_cp", "x": -705.6928835248857, "y": -114.90568192416467, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SEARCH_2", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_2_precondition_member_exists", "label": "macro_ilp_n_search_2_precondition_member", "x": 560.5656599545695, "y": -603.585754534293, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named search_2 accessible in the current context", "function": "ILP_N_SEARCH_2"}, {"id": "macro_ilp_n_search_4_anti_pattern_global_dependency", "label": "macro_ilp_n_search_4_anti_pattern_global", "x": -686.9872833494339, "y": 594.7348312748948, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_complexity_zero_overhead", "label": "macro_ilp_n_search_4_complexity_zero_ove", "x": -346.9473230888866, "y": 535.0944123561592, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead; it is purely a compile-time textual substitution", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_context_sensitivity", "label": "macro_ilp_n_search_4_context_sensitivity", "x": -930.3767206218212, "y": 295.31127116800974, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SEARCH_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_effect_lvalue", "label": "macro_ilp_n_search_4_effect_lvalue", "x": -273.45267184199383, "y": -880.0200958943674, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SEARCH_4 directly modifies ILP_CPU_PROFILE.search_4 (lvalue semantics preserved)", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_effect_simple_substitution", "label": "macro_ilp_n_search_4_effect_simple_subst", "x": 238.96701291846324, "y": -640.4047002679824, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SEARCH_4 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_postcondition_expansion", "label": "macro_ilp_n_search_4_postcondition_expan", "x": -122.00127832693863, "y": -847.9208384508177, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SEARCH_4 is textually replaced with ILP_CPU_PROFILE.search_4", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_search_4_precondition_ilp_cp", "x": -705.4835023192516, "y": -411.7134352571696, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SEARCH_4", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_4_precondition_search_4_member", "label": "macro_ilp_n_search_4_precondition_search", "x": -694.4555578251195, "y": 662.7789892424631, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expansion of ILP_CPU_PROFILE must have a member named search_4", "function": "ILP_N_SEARCH_4"}, {"id": "macro_ilp_n_search_8_anti_pattern_global_dependency", "label": "macro_ilp_n_search_8_anti_pattern_global", "x": -993.0969234189928, "y": 4.364199116533043, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ilp::cpu::default_profile.search_8 directly for clarity", "function": "ILP_N_SEARCH_8"}, {"id": "macro_ilp_n_search_8_complexity_zero_overhead", "label": "macro_ilp_n_search_8_complexity_zero_ove", "x": -731.2098617754262, "y": -383.0573579864228, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SEARCH_8 has zero runtime overhead as it is a compile-time textual substitution that resolves to a direct member access", "function": "ILP_N_SEARCH_8"}, {"id": "macro_ilp_n_search_8_effect_lvalue", "label": "macro_ilp_n_search_8_effect_lvalue", "x": 734.3496527808227, "y": -549.8758928820025, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SEARCH_8 directly modifies ILP_CPU_PROFILE.search_8 (lvalue semantics preserved through member access)", "function": "ILP_N_SEARCH_8"}, {"id": "macro_ilp_n_search_8_effect_no_side_effects", "label": "macro_ilp_n_search_8_effect_no_side_effe", "x": 867.1698144737621, "y": -413.0499877170419, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SEARCH_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SEARCH_8"}, {"id": "macro_ilp_n_search_8_expansion", "label": "macro_ilp_n_search_8_expansion", "x": 649.3489539076429, "y": 121.82784983162715, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SEARCH_8 is textually replaced with ILP_CPU_PROFILE.search_8, which further expands to ilp::cpu::default_profile.search_8", "function": "ILP_N_SEARCH_8"}, {"id": "macro_ilp_n_search_8_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_search_8_precondition_ilp_cp", "x": 862.3861238106816, "y": 59.71664454201504, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before ILP_N_SEARCH_8 is used", "function": "ILP_N_SEARCH_8"}, {"id": "macro_ilp_n_shift_1_anti_pattern_global_dependency", "label": "macro_ilp_n_shift_1_anti_pattern_global_", "x": 43.91436504728304, "y": -754.3953324295552, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_1_effect_context_sensitivity", "label": "macro_ilp_n_shift_1_effect_context_sensi", "x": -480.69158274243216, "y": 777.255952810087, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SHIFT_1 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_1_effect_lvalue", "label": "macro_ilp_n_shift_1_effect_lvalue", "x": -508.78451206305533, "y": -377.27215717272503, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SHIFT_1 directly modifies ILP_CPU_PROFILE.shift_1 (lvalue semantics preserved)", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_1_effect_simple_substitution", "label": "macro_ilp_n_shift_1_effect_simple_substi", "x": 622.3998350856352, "y": -348.2738022122865, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SHIFT_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_1_postcondition_expansion", "label": "macro_ilp_n_shift_1_postcondition_expans", "x": 849.2803437205545, "y": 374.4217566970697, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SHIFT_1 is textually replaced with ILP_CPU_PROFILE.shift_1", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_1_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_shift_1_precondition_ilp_cpu", "x": 155.1217832885284, "y": 836.6132806019028, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SHIFT_1", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_1_precondition_shift_1_member_exists", "label": "macro_ilp_n_shift_1_precondition_shift_1", "x": -825.7769640563283, "y": -421.04431438887576, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named shift_1", "function": "ILP_N_SHIFT_1"}, {"id": "macro_ilp_n_shift_4_anti_pattern_indirection", "label": "macro_ilp_n_shift_4_anti_pattern_indirec", "x": -43.83812088664116, "y": -708.6539512304247, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "This macro adds an unnecessary layer of indirection over ILP_CPU_PROFILE.shift_4; consider using the qualified name directly for clarity and to avoid hidden dependencies", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_4_effect_context_sensitivity", "label": "macro_ilp_n_shift_4_effect_context_sensi", "x": 396.53861043284365, "y": 861.5369462249403, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The semantic meaning of ILP_N_SHIFT_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point where ILP_N_SHIFT_4 is defined", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_4_effect_lvalue", "label": "macro_ilp_n_shift_4_effect_lvalue", "x": -185.33594958932525, "y": -580.9685926298832, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SHIFT_4 directly modifies ILP_CPU_PROFILE.shift_4 (lvalue semantics preserved)", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_4_effect_no_side_effects", "label": "macro_ilp_n_shift_4_effect_no_side_effec", "x": 918.94362405233, "y": -57.98382136372628, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SHIFT_4 performs simple textual substitution with no side effects and no evaluations", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_4_postcondition_expansion", "label": "macro_ilp_n_shift_4_postcondition_expans", "x": -7.170510064955968, "y": -562.2925290930253, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SHIFT_4 is textually replaced with ILP_CPU_PROFILE.shift_4", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_4_precondition_profile_defined", "label": "macro_ilp_n_shift_4_precondition_profile", "x": 897.6898800874726, "y": 95.56020469879078, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SHIFT_4", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_4_precondition_shift_4_member", "label": "macro_ilp_n_shift_4_precondition_shift_4", "x": 540.0515029125922, "y": 608.5056158761563, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The expansion of ILP_CPU_PROFILE must have a member named shift_4", "function": "ILP_N_SHIFT_4"}, {"id": "macro_ilp_n_shift_8_anti_pattern_implicit_dependency", "label": "macro_ilp_n_shift_8_anti_pattern_implici", "x": -557.7639383168491, "y": -226.40767153743516, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using ILP_N_SHIFT_8 creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.shift_8 directly for clarity", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_complexity_zero_overhead", "label": "macro_ilp_n_shift_8_complexity_zero_over", "x": 759.0151351544422, "y": -253.94161203879284, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SHIFT_8 has zero runtime overhead - it is a compile-time textual substitution", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_context_sensitivity", "label": "macro_ilp_n_shift_8_context_sensitivity", "x": 436.82131298054696, "y": 834.4284506537545, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SHIFT_8 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_effect_lvalue", "label": "macro_ilp_n_shift_8_effect_lvalue", "x": 321.52371841619737, "y": 607.5853408439887, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SHIFT_8 directly modifies ILP_CPU_PROFILE.shift_8 (lvalue semantics preserved)", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_effect_no_side_effects", "label": "macro_ilp_n_shift_8_effect_no_side_effec", "x": 525.0820157085648, "y": 666.9969441221969, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SHIFT_8 performs simple textual substitution with no side effects and no argument evaluation", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_expansion", "label": "macro_ilp_n_shift_8_expansion", "x": -107.54192086229264, "y": -908.1831035134529, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SHIFT_8 is textually replaced with ILP_CPU_PROFILE.shift_8", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_shift_8_precondition_ilp_cpu", "x": -242.1239562946548, "y": 583.3371591824819, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SHIFT_8", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_shift_8_precondition_shift_8_member", "label": "macro_ilp_n_shift_8_precondition_shift_8", "x": -100.10532242965338, "y": 709.3777065725918, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named shift_8 for ILP_N_SHIFT_8 to be valid", "function": "ILP_N_SHIFT_8"}, {"id": "macro_ilp_n_sqrt_8f_anti_pattern_global_dependency", "label": "macro_ilp_n_sqrt_8f_anti_pattern_global_", "x": -466.941570988657, "y": 410.9314479952364, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sqrt_8f_context_sensitivity", "label": "macro_ilp_n_sqrt_8f_context_sensitivity", "x": -636.7787659342185, "y": 481.90393686293953, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SQRT_8F depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sqrt_8f_effect_lvalue", "label": "macro_ilp_n_sqrt_8f_effect_lvalue", "x": 97.88854641546946, "y": -734.1747831096862, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SQRT_8F directly modifies ILP_CPU_PROFILE.sqrt_8f (lvalue semantics preserved)", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sqrt_8f_effect_simple_substitution", "label": "macro_ilp_n_sqrt_8f_effect_simple_substi", "x": -437.94442612108065, "y": 577.9213501436257, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SQRT_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sqrt_8f_expansion", "label": "macro_ilp_n_sqrt_8f_expansion", "x": -11.472078976564704, "y": -719.2050905701492, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SQRT_8F is textually replaced with ILP_CPU_PROFILE.sqrt_8f", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sqrt_8f_precondition_cpu_profile_defined", "label": "macro_ilp_n_sqrt_8f_precondition_cpu_pro", "x": 928.5992004517597, "y": 334.67226182303574, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_SQRT_8F can be used", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sqrt_8f_precondition_member_exists", "label": "macro_ilp_n_sqrt_8f_precondition_member_", "x": 896.1038815133883, "y": -98.4128820343895, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named sqrt_8f accessible at the point of use", "function": "ILP_N_SQRT_8F"}, {"id": "macro_ilp_n_sum_2_anti_pattern_global_dependency", "label": "macro_ilp_n_sum_2_anti_pattern_global_de", "x": 0.19314714701725538, "y": 860.087603418347, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_complexity", "label": "macro_ilp_n_sum_2_complexity", "x": 91.38885378816755, "y": 642.0217235594179, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion incurs zero runtime cost; it is purely a compile-time textual substitution", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_context_sensitivity", "label": "macro_ilp_n_sum_2_context_sensitivity", "x": -665.7344547014111, "y": -129.82277782707104, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SUM_2 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point where ILP_N_SUM_2 is defined", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_effect_lvalue", "label": "macro_ilp_n_sum_2_effect_lvalue", "x": -699.9392959873978, "y": -499.72608378063904, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SUM_2 directly modifies ILP_CPU_PROFILE.sum_2 (lvalue semantics preserved)", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_effect_simple_substitution", "label": "macro_ilp_n_sum_2_effect_simple_substitu", "x": -757.195659377065, "y": -641.2593426351259, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_expansion", "label": "macro_ilp_n_sum_2_expansion", "x": 881.3240823813203, "y": -369.906678239005, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SUM_2 is textually replaced with ILP_CPU_PROFILE.sum_2", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_precondition_member_exists", "label": "macro_ilp_n_sum_2_precondition_member_ex", "x": 280.15170415251, "y": 756.146292826531, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The object referenced by ILP_CPU_PROFILE must have a member named sum_2", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_2_precondition_profile_defined", "label": "macro_ilp_n_sum_2_precondition_profile_d", "x": 116.51756350753041, "y": -799.6369756489229, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_SUM_2 is used", "function": "ILP_N_SUM_2"}, {"id": "macro_ilp_n_sum_4f_anti_pattern_global_dependency", "label": "macro_ilp_n_sum_4f_anti_pattern_global_d", "x": 589.096598691149, "y": 272.257969238091, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4f_constraint_context_sensitivity", "label": "macro_ilp_n_sum_4f_constraint_context_se", "x": 487.2250148668345, "y": 549.3034494579139, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SUM_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4f_effect_lvalue", "label": "macro_ilp_n_sum_4f_effect_lvalue", "x": 979.3168825359434, "y": 149.40877145739154, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SUM_4F directly modifies ILP_CPU_PROFILE.sum_4f (lvalue semantics preserved)", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4f_effect_no_side_effects", "label": "macro_ilp_n_sum_4f_effect_no_side_effect", "x": -433.3242953586795, "y": 437.55946413255657, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4f_postcondition_expansion", "label": "macro_ilp_n_sum_4f_postcondition_expansi", "x": -765.6320521311413, "y": 574.5475870875074, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SUM_4F is textually replaced with ILP_CPU_PROFILE.sum_4f", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4f_precondition_member_exists", "label": "macro_ilp_n_sum_4f_precondition_member_e", "x": -753.7790819856739, "y": -342.03620202457813, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named sum_4f at the point of macro use", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4f_precondition_profile_defined", "label": "macro_ilp_n_sum_4f_precondition_profile_", "x": 745.1985848335113, "y": 215.93608021700086, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SUM_4F", "function": "ILP_N_SUM_4F"}, {"id": "macro_ilp_n_sum_4i_anti_pattern_global_dependency", "label": "macro_ilp_n_sum_4i_anti_pattern_global_d", "x": -536.1062293142634, "y": -108.18461155549606, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.sum_4i directly for clarity", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_complexity_zero_overhead", "label": "macro_ilp_n_sum_4i_complexity_zero_overh", "x": 763.5231977843907, "y": -282.0185756134584, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4I has zero runtime overhead as it is resolved entirely at preprocessing time", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_context_sensitivity", "label": "macro_ilp_n_sum_4i_context_sensitivity", "x": 589.6644538939363, "y": -726.4221407262999, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SUM_4I depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_effect_lvalue", "label": "macro_ilp_n_sum_4i_effect_lvalue", "x": 501.9906403834769, "y": 667.1781460125443, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SUM_4I directly modifies ILP_CPU_PROFILE.sum_4i (lvalue semantics preserved)", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_effect_simple_substitution", "label": "macro_ilp_n_sum_4i_effect_simple_substit", "x": -727.5828998500045, "y": -127.16846497150422, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_4I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_expansion", "label": "macro_ilp_n_sum_4i_expansion", "x": -700.8235844636843, "y": 385.3193442563662, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SUM_4I is textually replaced with ILP_CPU_PROFILE.sum_4i", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_sum_4i_precondition_ilp_cpu_", "x": 102.73482147895018, "y": 567.4138773059684, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SUM_4I", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_4i_precondition_sum_4i_member", "label": "macro_ilp_n_sum_4i_precondition_sum_4i_m", "x": -583.0486974192481, "y": -550.7228056281826, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named sum_4i accessible at the point of use", "function": "ILP_N_SUM_4I"}, {"id": "macro_ilp_n_sum_8f_anti_pattern_global_dependency", "label": "macro_ilp_n_sum_8f_anti_pattern_global_d", "x": -902.5251163927753, "y": -275.1512900673391, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8f_context_sensitivity", "label": "macro_ilp_n_sum_8f_context_sensitivity", "x": 111.50354392240446, "y": 819.2594251721571, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SUM_8F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8f_effect_lvalue", "label": "macro_ilp_n_sum_8f_effect_lvalue", "x": 534.4055552488054, "y": -231.24141058372913, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SUM_8F directly modifies ILP_CPU_PROFILE.sum_8f (lvalue semantics preserved)", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8f_effect_simple_substitution", "label": "macro_ilp_n_sum_8f_effect_simple_substit", "x": 879.327677484793, "y": 352.52261259436864, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8f_expansion", "label": "macro_ilp_n_sum_8f_expansion", "x": 906.8369581451367, "y": 31.128413784178953, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SUM_8F is textually replaced with ILP_CPU_PROFILE.sum_8f", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8f_precondition_member_exists", "label": "macro_ilp_n_sum_8f_precondition_member_e", "x": -331.3282106558666, "y": -865.843413661848, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named sum_8f accessible at the point of use", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8f_precondition_profile_defined", "label": "macro_ilp_n_sum_8f_precondition_profile_", "x": 413.1313094495401, "y": -725.8698026328799, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before ILP_N_SUM_8F is used", "function": "ILP_N_SUM_8F"}, {"id": "macro_ilp_n_sum_8i_anti_pattern_global_dependency", "label": "macro_ilp_n_sum_8i_anti_pattern_global_d", "x": -605.2619180649948, "y": 148.41889411745882, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.sum_8i directly for clarity", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_complexity_zero_overhead", "label": "macro_ilp_n_sum_8i_complexity_zero_overh", "x": 306.55737840609606, "y": 459.856426400672, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_8I has zero runtime overhead as it is a compile-time textual substitution", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_effect_context_sensitivity", "label": "macro_ilp_n_sum_8i_effect_context_sensit", "x": -734.0080956621318, "y": -263.46065208183455, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_SUM_8I depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of ILP_N_SUM_8I definition", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_effect_lvalue", "label": "macro_ilp_n_sum_8i_effect_lvalue", "x": 191.6649997423228, "y": 941.60003003921, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_SUM_8I directly modifies ILP_CPU_PROFILE.sum_8i (lvalue semantics preserved)", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_effect_no_side_effects", "label": "macro_ilp_n_sum_8i_effect_no_side_effect", "x": 350.7652007942313, "y": 862.3753787186125, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_SUM_8I performs simple textual substitution with no side effects and no argument evaluation (object-like macro)", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_postcondition_expansion", "label": "macro_ilp_n_sum_8i_postcondition_expansi", "x": 652.9998525755924, "y": 248.35164306844976, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_SUM_8I is textually replaced with ILP_CPU_PROFILE.sum_8i", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_precondition_member_exists", "label": "macro_ilp_n_sum_8i_precondition_member_e", "x": -694.7962671248141, "y": 303.5006573733147, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must expand to an object with a member named sum_8i", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_sum_8i_precondition_profile_defined", "label": "macro_ilp_n_sum_8i_precondition_profile_", "x": 422.3770694080433, "y": 387.24591114260664, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before using ILP_N_SUM_8I", "function": "ILP_N_SUM_8I"}, {"id": "macro_ilp_n_transform_2_anti_pattern_global_dependency", "label": "macro_ilp_n_transform_2_anti_pattern_glo", "x": -79.53334435025764, "y": 517.378326268633, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_complexity_zero_overhead", "label": "macro_ilp_n_transform_2_complexity_zero_", "x": -569.7123323143998, "y": 112.81054750835932, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead - it is purely a compile-time textual substitution", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_context_sensitivity", "label": "macro_ilp_n_transform_2_context_sensitiv", "x": -528.4863088886958, "y": 608.04162684942, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_TRANSFORM_2 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_effect_lvalue", "label": "macro_ilp_n_transform_2_effect_lvalue", "x": -528.3240851667312, "y": -706.9487345797983, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_TRANSFORM_2 directly modifies ILP_CPU_PROFILE.transform_2 (lvalue semantics preserved)", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_effect_simple_substitution", "label": "macro_ilp_n_transform_2_effect_simple_su", "x": -187.0219588290837, "y": 573.679396732438, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_TRANSFORM_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_expansion", "label": "macro_ilp_n_transform_2_expansion", "x": -70.37276078496033, "y": -660.3256749262171, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_TRANSFORM_2 is textually replaced with ILP_CPU_PROFILE.transform_2", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_precondition_cpu_profile_defined", "label": "macro_ilp_n_transform_2_precondition_cpu", "x": 212.07212840247533, "y": -554.182123974313, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before using ILP_N_TRANSFORM_2", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_2_precondition_transform_2_member_exists", "label": "macro_ilp_n_transform_2_precondition_tra", "x": 704.9157911449583, "y": 640.6428549136256, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named transform_2 accessible at the point of use", "function": "ILP_N_TRANSFORM_2"}, {"id": "macro_ilp_n_transform_4_anti_pattern_global_dependency", "label": "macro_ilp_n_transform_4_anti_pattern_glo", "x": 31.995946777642196, "y": -592.2987483727416, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_4_complexity_zero_overhead", "label": "macro_ilp_n_transform_4_complexity_zero_", "x": 345.5022485139706, "y": -913.2972785983795, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Zero runtime overhead - this is a compile-time textual substitution with no function call or evaluation cost", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_4_effect_lvalue", "label": "macro_ilp_n_transform_4_effect_lvalue", "x": -72.70986729203932, "y": -593.3158878938237, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_TRANSFORM_4 directly modifies ILP_CPU_PROFILE.transform_4 (lvalue semantics preserved)", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_4_effect_no_side_effects", "label": "macro_ilp_n_transform_4_effect_no_side_e", "x": 589.8011833285591, "y": -802.3230800754096, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_TRANSFORM_4 performs simple textual substitution with no side effects and no argument evaluation (object-like macro)", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_4_postcondition_expansion", "label": "macro_ilp_n_transform_4_postcondition_ex", "x": 84.25289439149957, "y": 688.6262270505027, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_TRANSFORM_4 is textually replaced with ILP_CPU_PROFILE.transform_4", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_4_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_transform_4_precondition_ilp", "x": 12.734578374688953, "y": -870.8896699937895, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined and in scope before using ILP_N_TRANSFORM_4", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_4_precondition_transform_4_member", "label": "macro_ilp_n_transform_4_precondition_tra", "x": 980.619988133953, "y": 26.67312919785896, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must have a member named transform_4", "function": "ILP_N_TRANSFORM_4"}, {"id": "macro_ilp_n_transform_8_anti_pattern_global_dependency", "label": "macro_ilp_n_transform_8_anti_pattern_glo", "x": 242.05819831685645, "y": -662.3298957570363, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_complexity_zero_overhead", "label": "macro_ilp_n_transform_8_complexity_zero_", "x": -213.5672793952945, "y": -502.7889989268652, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Macro expansion has zero runtime overhead - identical performance to using ILP_CPU_PROFILE.transform_8 directly", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_effect_context_sensitivity", "label": "macro_ilp_n_transform_8_effect_context_s", "x": -702.9325706470302, "y": -584.9644684482895, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The meaning of ILP_N_TRANSFORM_8 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_effect_lvalue", "label": "macro_ilp_n_transform_8_effect_lvalue", "x": 652.3131697098395, "y": -464.26752537996634, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Any modification to ILP_N_TRANSFORM_8 directly modifies ILP_CPU_PROFILE.transform_8 (lvalue semantics preserved)", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_effect_no_side_effects", "label": "macro_ilp_n_transform_8_effect_no_side_e", "x": -742.3130405526629, "y": 10.690570456722392, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_N_TRANSFORM_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_postcondition_expansion", "label": "macro_ilp_n_transform_8_postcondition_ex", "x": 437.9090160289074, "y": -817.1467675877433, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After macro expansion, ILP_N_TRANSFORM_8 is textually replaced with ILP_CPU_PROFILE.transform_8", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_precondition_ilp_cpu_profile_defined", "label": "macro_ilp_n_transform_8_precondition_ilp", "x": 122.86503041200868, "y": -836.143491836113, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE must be defined in scope before using ILP_N_TRANSFORM_8", "function": "ILP_N_TRANSFORM_8"}, {"id": "macro_ilp_n_transform_8_precondition_transform_8_member_exists", "label": "macro_ilp_n_transform_8_precondition_tra", "x": -733.3601553458077, "y": -662.774968955501, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "ILP_CPU_PROFILE.transform_8 must be a valid member expression (ILP_CPU_PROFILE must have a member named transform_8)", "function": "ILP_N_TRANSFORM_8"}, {"id": "return_with_anti_pattern_no_reuse_after_call_5c2e8d91", "label": "return_with_anti_pattern_no_reuse_after_", "x": 572.8117706333528, "y": -686.6590986212448, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not use val after calling this function, as it has been moved from", "function": "return_with"}, {"id": "return_with_complexity_constant_time_1a9e4bc7", "label": "return_with_complexity_constant_time_1a9", "x": -910.6500078021958, "y": -55.48619420078689, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Time complexity is O(1) plus the cost of R's move assignment operator", "function": "return_with"}, {"id": "return_with_effect_sets_ok_false_9b4c1e82", "label": "return_with_effect_sets_ok_false_9b4c1e8", "x": 716.5961738073913, "y": -409.4792131171449, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Sets member variable 'ok' to false, indicating a return state", "function": "return_with"}, {"id": "return_with_effect_stores_return_value_3c7d8fa1", "label": "return_with_effect_stores_return_value_3", "x": -93.14943551481753, "y": -936.9938751607968, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Moves val into member variable 'return_value', transferring ownership", "function": "return_with"}, {"id": "return_with_exception_noexcept_if_r_noexcept_6f8a3de4", "label": "return_with_exception_noexcept_if_r_noex", "x": 331.46229245999245, "y": -412.07534276025797, "size": 4.0, "color": "#26de81", "layer": "library", "module": "", "content": "Function is noexcept if R's move constructor/assignment is noexcept; otherwise may throw if R's move operations throw", "function": "return_with"}, {"id": "return_with_postcondition_state_transition_2d1f7e93", "label": "return_with_postcondition_state_transiti", "x": 236.69730555124644, "y": -563.5343212641842, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After execution, object state is: ok=false and return_value holds the moved value", "function": "return_with"}, {"id": "return_with_postcondition_val_moved_from_8e5f3bc2", "label": "return_with_postcondition_val_moved_from", "x": -304.30841775233773, "y": -770.3185850468345, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After execution, val is in a valid but unspecified moved-from state", "function": "return_with"}, {"id": "return_with_precondition_r_movable_7a3e2f91", "label": "return_with_precondition_r_movable_7a3e2", "x": -149.69398814281644, "y": -843.7031188207662, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Type R must be move-constructible or move-assignable to support std::move(val)", "function": "return_with"}, {"id": "set_anti_pattern_buffer_reuse_g3h4i5j6", "label": "set_anti_pattern_buffer_reuse_g3h4i5j6", "x": 376.2420407608028, "y": 902.9204983946531, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not reuse buffer storage without ensuring the previous object's lifetime has ended, even for trivially destructible types", "function": "set"}, {"id": "set_anti_pattern_no_dtor_call_c9d0e1f2", "label": "set_anti_pattern_no_dtor_call_c9d0e1f2", "x": 856.1508112504758, "y": 502.8968950620365, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Do not call set() multiple times without manually destroying the previous object, as SmallStorage does not track object lifetime for non-trivial types", "function": "set"}, {"id": "set_complexity_constant_time_k7l8m9n0", "label": "set_complexity_constant_time_k7l8m9n0", "x": 258.19281229504685, "y": 579.9426647207562, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The function executes in constant time O(1) as it performs a single placement new construction", "function": "set"}, {"id": "set_constraint_alignof_sbo_size_e5f6g7h8", "label": "set_constraint_alignof_sbo_size_e5f6g7h8", "x": -580.7194048489337, "y": 332.02027990572867, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The decayed type U must have alignment less than or equal to arch::sbo_size for proper memory alignment in buffer", "function": "set"}, {"id": "set_constraint_sizeof_sbo_size_a1b2c3d4", "label": "set_constraint_sizeof_sbo_size_a1b2c3d4", "x": -469.7854771070594, "y": -268.0588773433137, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The decayed type U must have size less than or equal to arch::sbo_size for placement new in buffer to be valid", "function": "set"}, {"id": "set_constraint_trivially_destructible_i9j0k1l2", "label": "set_constraint_trivially_destructible_i9", "x": 569.699778361474, "y": -456.5410867422841, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The decayed type U must be trivially destructible since SmallStorage does not call destructors explicitly", "function": "set"}, {"id": "set_effect_perfect_forwarding_u1v2w3x4", "label": "set_effect_perfect_forwarding_u1v2w3x4", "x": -257.11703872931804, "y": 881.1822994233362, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The static_cast<T&&>(val) performs perfect forwarding, preserving the value category of the original argument for move or copy construction", "function": "set"}, {"id": "set_effect_placement_new_q7r8s9t0", "label": "set_effect_placement_new_q7r8s9t0", "x": -916.1567566997203, "y": -24.497001639807195, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Constructs an object of type U in the pre-allocated buffer using placement new with perfect forwarding of val", "function": "set"}, {"id": "set_postcondition_object_constructed_y5z6a7b8", "label": "set_postcondition_object_constructed_y5z", "x": 893.8282999358362, "y": 167.71427583349154, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After successful execution, buffer contains a fully constructed object of type U initialized from val", "function": "set"}, {"id": "set_precondition_buffer_valid_m3n4o5p6", "label": "set_precondition_buffer_valid_m3n4o5p6", "x": 99.12893342996523, "y": -665.2207942763748, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "The buffer member must be properly aligned and have sufficient storage for placement new of type U", "function": "set"}, {"id": "validate_unroll_factor_anti_pattern_excessive_unroll", "label": "validate_unroll_factor_anti_pattern_exce", "x": -232.88039213705062, "y": 783.5485914568986, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Using N > 16 without careful consideration can cause code bloat and reduced performance due to excessive loop unrolling", "function": "validate_unroll_factor"}, {"id": "validate_unroll_factor_complexity_compile_time", "label": "validate_unroll_factor_complexity_compil", "x": 515.8572267905229, "y": 53.51598810772449, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "O(1) compile-time evaluation; O(1) runtime complexity (no-op after compilation)", "function": "validate_unroll_factor"}, {"id": "validate_unroll_factor_constraint_N_minimum", "label": "validate_unroll_factor_constraint_N_mini", "x": -609.2129272488944, "y": -804.6346163914346, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Template parameter N must be at least 1 (enforced via static_assert)", "function": "validate_unroll_factor"}, {"id": "validate_unroll_factor_effect_constexpr_evaluation", "label": "validate_unroll_factor_effect_constexpr_", "x": 927.2311609195496, "y": -215.96221483524775, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "Function is constexpr and performs all validation at compile-time; no runtime overhead", "function": "validate_unroll_factor"}, {"id": "validate_unroll_factor_effect_warn_on_large_N", "label": "validate_unroll_factor_effect_warn_on_la", "x": 158.77289784216816, "y": -881.2481571781491, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "When N > 16, invokes warn_large_unroll_factor<N>() to issue a compile-time warning about large unroll factors", "function": "validate_unroll_factor"}, {"id": "validate_unroll_factor_exception_propagation", "label": "validate_unroll_factor_exception_propaga", "x": 267.91948752156907, "y": 889.648925729247, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "If warn_large_unroll_factor<N>() throws or fails, exception propagates to caller before any subsequent operations", "function": "validate_unroll_factor"}, {"id": "validate_unroll_factor_postcondition_N_validated", "label": "validate_unroll_factor_postcondition_N_v", "x": 89.92643667701331, "y": -813.6396336660445, "size": 3.0, "color": "#26de81", "layer": "library", "module": "", "content": "After successful compilation, N is guaranteed to be >= 1; if N > 16, warning has been issued", "function": "validate_unroll_factor"}];
        const edgesData = [{"id": "e0", "source": "cpp20_func_require_invoke_reference_converts_ill_formed_a1b2c3d4", "target": "ilp_break_anti_pattern_destructor_bypass"}, {"id": "e1", "source": "ilp_for_range_t_n_param_unused_constraint", "target": "ilp_cpu_profile_macro_no_side_effects"}, {"id": "e2", "source": "ilp_for_range_t_type_param_unused_constraint", "target": "ilp_cpu_profile_macro_no_side_effects"}, {"id": "e3", "source": "ilp_for_t_effect_no_expansion_side_effects_1a4b8c6d", "target": "ilp_cpu_profile_macro_no_side_effects"}, {"id": "e4", "source": "ilp_for_range_auto_constraint_unused_params_5f1c7e92", "target": "ilp_cpu_profile_macro_no_side_effects"}, {"id": "e5", "source": "ilp_for_range_macro_no_side_effects_b9c4d7e2", "target": "ilp_cpu_profile_macro_no_side_effects"}, {"id": "e6", "source": "check_sum_overflow_exception_noexcept_t5u6v7w8", "target": "return_with_exception_noexcept_if_r_noexcept_6f8a3de4"}, {"id": "e7", "source": "ilp_end_with_return_error_exception_no_throw_g2h5j8k1", "target": "return_with_exception_noexcept_if_r_noexcept_6f8a3de4"}, {"id": "e8", "source": "cpp20_refwrap_const_constraint_fun_well_formed_a7b8c9d0", "target": "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6"}, {"id": "e9", "source": "cpp20_meta_trans_ref_add_rvalue_reference_lvalue_ref_not_rvalue_c5d9e2f8", "target": "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6"}, {"id": "e10", "source": "cpp20_meta_trans_ref_add_lvalue_reference_collapse_semantics_e5f1a8c4", "target": "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6"}, {"id": "e11", "source": "cpp20_meta_trans_ref_add_lvalue_reference_referenceable_c2d8f4a1", "target": "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6"}, {"id": "e12", "source": "cpp20_meta_unary_cat_is_lvalue_reference_condition_7e3f0c4b", "target": "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6"}, {"id": "e13", "source": "cpp20_func_require_invoke_reference_converts_ill_formed_a1b2c3d4", "target": "extract_precond_buffer_valid_storage_a8f3d2e1"}, {"id": "e14", "source": "cpp20_coroutine_handle_from_address_typed_precond_e1a7c3d9", "target": "extract_precond_buffer_non_null_b7c8d9e0"}, {"id": "e15", "source": "cpp20_coroutine_handle_from_address_void_precond_c9e5a1f7", "target": "extract_precond_buffer_non_null_b7c8d9e0"}, {"id": "e16", "source": "cpp20_comparisons_pointer_strict_total_order_c9d0e1f2", "target": "extract_precond_buffer_non_null_b7c8d9e0"}, {"id": "e17", "source": "cpp20_compare_three_way_precond_pointer_equality_preserving_d1e2f3a4", "target": "extract_precond_buffer_alignment_e3d9a1f5"}, {"id": "e18", "source": "cpp20_inplace_stop_token_stop_requested_ub_after_dtor_f9c3a7e5", "target": "extract_precond_object_lifetime_started_b8c2d4e6"}, {"id": "e19", "source": "cpp20_bit_cast_indeterminate_from_non_lifetime_a1c5e7b3", "target": "extract_precond_object_lifetime_started_b8c2d4e6"}, {"id": "e20", "source": "cpp20_span_elem_back_hardened_g7h8i9j0", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e21", "source": "cpp20_span_elem_front_hardened_c3d4e5f6", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e22", "source": "cpp20_span_elem_subscript_hardened_u5v6w7x8", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e23", "source": "cpp20_span_cons_default_postcond_k7l8m9n0", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e24", "source": "cpp20_atomics_ref_pointer_operator_compound_const_constraint_a9b3c7d1", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e25", "source": "cpp20_atomics_ref_pointer_store_undefined_address_no_ub_f8a2b6c0", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e26", "source": "cpp20_atomics_ref_pointer_store_key_order_precondition_e7f1a5b9", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e27", "source": "cpp20_atomics_ref_pointer_store_key_complete_type_mandate_d6e0f4a8", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e28", "source": "cpp20_atomics_ref_pointer_store_key_const_constraint_c5d9e3f7", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e29", "source": "cpp20_atomics_ref_pointer_undefined_address_no_ub_b4c8d2e6", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e30", "source": "cpp20_atomics_ref_pointer_fetch_key_complete_type_mandate_a3b7c1d5", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e31", "source": "cpp20_atomics_ref_pointer_fetch_key_const_constraint_f2a6b0c4", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e32", "source": "cpp20_atomic_pointer_fetch_key_mandate_complete_type_c7d8e9f0", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e33", "source": "cpp20_atomic_pointer_fetch_key_volatile_constraint_lock_free_b6c7d8e9", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e34", "source": "cpp20_stop_source_stop_possible_definition_b5e8d3f1", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e35", "source": "cpp20_coroutine_handle_bool_conversion_a3c9e5f1", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e36", "source": "cpp20_coroutine_handle_from_address_typed_postcond_f2b8d4e0", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e37", "source": "cpp20_coroutine_handle_from_address_typed_precond_e1a7c3d9", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e38", "source": "cpp20_coroutine_handle_from_address_void_postcond_d0f6b2a8", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e39", "source": "cpp20_coroutine_handle_from_address_void_precond_c9e5a1f7", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e40", "source": "cpp20_coroutine_handle_assign_null_postcond_b8d4e0f6", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e41", "source": "cpp20_coroutine_handle_from_promise_postcond_a7c3d9e5", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e42", "source": "cpp20_coroutine_handle_default_ctor_postcond_e5a9b3c7", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e43", "source": "cpp20_coroutine_handle_equality_via_address_b7c3e9f4", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e44", "source": "cpp20_midpoint_pointer_precond_same_array_a7b2d0e5", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e45", "source": "cpp20_midpoint_pointer_mandate_complete_f6a1c9d4", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e46", "source": "cpp20_midpoint_pointer_constraint_object_e5f0b8c3", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e47", "source": "cpp20_ranges_less_precond_pointer_equality_preserving_b3c4d5e6", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e48", "source": "cpp20_ranges_equal_to_precond_pointer_equality_preserving_f3a4b5c6", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e49", "source": "cpp20_compare_three_way_precond_pointer_equality_preserving_d1e2f3a4", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e50", "source": "cpp20_comparisons_void_spec_pointer_order_a7b8c9d0", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e51", "source": "cpp20_comparisons_pointer_strict_total_order_c9d0e1f2", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e52", "source": "cpp20_meta_trans_ptr_add_pointer_reference_removal_e3f7b9c2", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e53", "source": "cpp20_meta_trans_ptr_add_pointer_referenceable_c5d8a1e7", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e54", "source": "cpp20_meta_unary_cat_is_pointer_includes_function_ptr_6d2e9b3a", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e55", "source": "cpp20_meta_unary_cat_is_pointer_condition_5c1d8a2f", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e56", "source": "cpp20_bit_cast_constexpr_condition_no_pointer_f4b8d0a6", "target": "extract_precond_pointer_non_null_a5f7c3d1"}, {"id": "e57", "source": "cpp20_meta_trans_ref_add_rvalue_reference_collapse_semantics_f7a4b9e1", "target": "extract_effect_perfect_forward_rvalue_c7b4d9e2"}, {"id": "e58", "source": "cpp20_meta_trans_ref_add_rvalue_reference_referenceable_b8d2f5a3", "target": "extract_effect_perfect_forward_rvalue_c7b4d9e2"}, {"id": "e59", "source": "cpp20_range_access_cbegin_rvalue_non_borrowed_illformed_e8f1a5b9", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e60", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e61", "source": "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e62", "source": "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e63", "source": "cpp20_range_access_data_rvalue_non_borrowed_illformed_d9e2f6a0", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e64", "source": "cpp20_range_access_crend_rvalue_non_borrowed_illformed_f5a8b2c6", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e65", "source": "cpp20_range_access_crbegin_rvalue_non_borrowed_illformed_e4f7a1b5", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e66", "source": "cpp20_range_access_rend_rvalue_non_borrowed_illformed_c2d5e9f3", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e67", "source": "cpp20_range_access_rbegin_rvalue_non_borrowed_illformed_a0b3c7d1", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e68", "source": "cpp20_range_access_cend_rvalue_non_borrowed_illformed_f9a2b6c0", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e69", "source": "ctrl_r_conversion_operator_precondition_rvalue_ref_b2e9f7d1", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e70", "source": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e71", "source": "ctrl_r_conversion_operator_precondition_rvalue_143", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e72", "source": "for_loop_untyped_impl_constraint_forwarding_reference", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e73", "source": "for_loop_typed_impl_constraint_forwarding_reference_4g5h6i7j", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e74", "source": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e75", "source": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e76", "source": "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e77", "source": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e78", "source": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e79", "source": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e80", "source": "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e81", "source": "for_loop_effect_perfect_forward_body_e5f6g7h8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e82", "source": "for_loop_typed_effect_perfect_forward_a5b6c7d8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e83", "source": "for_loop_range_effect_perfect_forward_range_q7r8s9t0", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e84", "source": "for_loop_range_effect_perfect_forward_body_u0v1w2x3", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e85", "source": "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e86", "source": "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e87", "source": "for_loop_range_typed_effect_perfect_forward_body_a7b8c9d0", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e88", "source": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e89", "source": "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e90", "source": "for_loop_range_ret_simple_effect_perfect_forward_body_7b2c9d4e", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e91", "source": "for_loop_auto_effect_perfect_forwarding_e5f6g7h8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e92", "source": "for_loop_typed_auto_effect_perfect_forward_f6a7b8c9", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e93", "source": "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e94", "source": "for_loop_range_auto_effect_perfect_forward_body_4d7f8a1e", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e95", "source": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e96", "source": "for_loop_range_typed_auto_effect_perfect_forward_body_b9c0d1e2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e97", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e98", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e99", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e100", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e101", "source": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e102", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e103", "source": "cpp20_expr_eq_lvalue_to_rvalue_conversion_g4c2e9f7", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e104", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e105", "source": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e106", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e107", "source": "cpp20_over_match_funcs_implicit_object_param_rvalue_ref_f1a2b3c4", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e108", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e109", "source": "cpp20_move_returns_rvalue_ref_e4b6d2a8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e110", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e111", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e112", "source": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e113", "source": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e114", "source": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e115", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e116", "source": "cpp20_range_access_begin_rvalue_non_borrowed_illformed_a3b7c1d9", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e117", "source": "cpp20_range_access_end_rvalue_non_borrowed_illformed_b4c8d2e6", "target": "extract_constraint_type_r_moveable_f6c8d2e4"}, {"id": "e118", "source": "for_loop_range_typed_auto_effect_perfect_forward_body_b9c0d1e2", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e119", "source": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e120", "source": "for_loop_range_auto_effect_perfect_forward_body_4d7f8a1e", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e121", "source": "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e122", "source": "for_loop_typed_auto_effect_perfect_forward_f6a7b8c9", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e123", "source": "for_loop_auto_effect_perfect_forwarding_e5f6g7h8", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e124", "source": "for_loop_range_ret_simple_effect_perfect_forward_body_7b2c9d4e", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e125", "source": "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e126", "source": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e127", "source": "for_loop_range_typed_effect_perfect_forward_body_a7b8c9d0", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e128", "source": "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e129", "source": "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e130", "source": "for_loop_range_effect_perfect_forward_body_u0v1w2x3", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e131", "source": "for_loop_range_effect_perfect_forward_range_q7r8s9t0", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e132", "source": "for_loop_typed_effect_perfect_forward_a5b6c7d8", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e133", "source": "for_loop_effect_perfect_forward_body_e5f6g7h8", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e134", "source": "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e135", "source": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e136", "source": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e137", "source": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e138", "source": "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e139", "source": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e140", "source": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e141", "source": "for_loop_typed_impl_constraint_forwarding_reference_4g5h6i7j", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e142", "source": "for_loop_untyped_impl_constraint_forwarding_reference", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e143", "source": "ctrl_r_conversion_operator_anti_pattern_use_after_move_143", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e144", "source": "ctrl_r_conversion_operator_effect_move_semantics_143", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e145", "source": "ctrl_r_conversion_operator_precondition_rvalue_143", "target": "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"}, {"id": "e146", "source": "cpp20_jthread_move_assign_postcond_ssource_from_x_c7d8e9f0", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e147", "source": "cpp20_jthread_move_assign_postcond_id_from_x_e3f4a5b6", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e148", "source": "cpp20_jthread_move_assign_effect_request_stop_join_a9b0c1d2", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e149", "source": "cpp20_jthread_move_assign_effect_self_no_effect_c5d6e7f8", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e150", "source": "cpp20_meta_trans_ref_add_rvalue_reference_referenceable_b8d2f5a3", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e151", "source": "cpp20_meta_unary_cat_is_rvalue_reference_condition_8f4a1d5c", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e152", "source": "cpp20_bit_cast_constexpr_condition_no_reference_members_c7e1a3d9", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e153", "source": "ctrl_r_conversion_operator_anti_pattern_use_after_move_143", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e154", "source": "ctrl_r_conversion_operator_effect_move_semantics_143", "target": "ctrl_r_conversion_operator_precondition_rvalue_143"}, {"id": "e155", "source": "for_loop_range_typed_auto_effect_perfect_forward_body_b9c0d1e2", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e156", "source": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e157", "source": "for_loop_range_auto_effect_perfect_forward_body_4d7f8a1e", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e158", "source": "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e159", "source": "for_loop_typed_auto_effect_perfect_forward_f6a7b8c9", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e160", "source": "for_loop_auto_effect_perfect_forwarding_e5f6g7h8", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e161", "source": "for_loop_range_ret_simple_effect_perfect_forward_body_7b2c9d4e", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e162", "source": "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e163", "source": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e164", "source": "for_loop_range_typed_effect_perfect_forward_body_a7b8c9d0", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e165", "source": "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e166", "source": "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e167", "source": "for_loop_range_effect_perfect_forward_body_u0v1w2x3", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e168", "source": "for_loop_range_effect_perfect_forward_range_q7r8s9t0", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e169", "source": "for_loop_typed_effect_perfect_forward_a5b6c7d8", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e170", "source": "for_loop_effect_perfect_forward_body_e5f6g7h8", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e171", "source": "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e172", "source": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e173", "source": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e174", "source": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e175", "source": "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e176", "source": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e177", "source": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e178", "source": "for_loop_typed_impl_constraint_forwarding_reference_4g5h6i7j", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e179", "source": "for_loop_untyped_impl_constraint_forwarding_reference", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e180", "source": "ctrl_r_conversion_operator_anti_pattern_use_after_move_143", "target": "ctrl_r_conversion_operator_effect_move_semantics_143"}, {"id": "e181", "source": "cpp20_stoptoken_concepts_callback_terminate_on_exception_c9e5a2f7", "target": "ilp_end_with_return_error_effect_abort_terminates_c3d8e5f6"}, {"id": "e182", "source": "check_sum_overflow_exception_noexcept_t5u6v7w8", "target": "ilp_end_with_return_error_exception_no_throw_g2h5j8k1"}, {"id": "e183", "source": "for_loop_typed_auto_precond_valid_range_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e184", "source": "cpp20_span_cons_range_precond_borrowed_u3v4w5x6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e185", "source": "cpp20_span_cons_range_precond_contiguous_q9r0s1t2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e186", "source": "ilp_for_range_t_auto_complexity_linear_d8b4a1c3", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e187", "source": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e188", "source": "ilp_for_range_t_auto_loop_var_scope_d3c9f1a5", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e189", "source": "ilp_for_range_t_auto_range_eval_once_e8a4b7c2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e190", "source": "ilp_for_t_auto_constraint_requires_cpp11", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e191", "source": "ilp_for_t_auto_complexity_iota_construction", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e192", "source": "ilp_for_t_auto_postcond_range_for_expansion", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e193", "source": "ilp_for_t_auto_effect_single_eval_parenthesized", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e194", "source": "ilp_for_t_auto_precond_loop_var_decl_valid", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e195", "source": "ilp_for_t_auto_precond_start_end_valid", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e196", "source": "ilp_for_range_t_range_parenthesization", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e197", "source": "ilp_for_range_t_postcondition_range_for_loop", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e198", "source": "ilp_for_range_t_range_single_eval", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e199", "source": "ilp_for_range_t_range_precondition", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e200", "source": "ilp_for_range_t_loop_var_decl_precondition", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e201", "source": "ilp_for_t_postcondition_range_for_expansion_2d9e7c4f", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e202", "source": "ilp_for_t_precondition_loop_var_decl_syntax_9c3f1e5a", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e203", "source": "ilp_for_t_precondition_valid_range_e4d7a2b8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e204", "source": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e205", "source": "ilp_for_range_auto_anti_pattern_dangling_ref_9a7e3b52", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e206", "source": "ilp_for_range_auto_postcond_loop_scope_4e2a9c71", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e207", "source": "ilp_for_range_auto_constraint_loop_var_type_3b6d8a41", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e208", "source": "ilp_for_range_auto_effect_single_eval_2d8b4c31", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e209", "source": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e210", "source": "ilp_for_auto_postcondition_range_for_loop", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e211", "source": "ilp_for_auto_precondition_loop_var_valid_decl", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e212", "source": "ilp_for_range_complexity_sequential_o_n_b4e7c2f9", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e213", "source": "ilp_for_range_anti_pattern_incomplete_impl_f1c8d3a7", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e214", "source": "ilp_for_range_constraint_range_parenthesized_e9a2f4b6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e215", "source": "ilp_for_range_postcondition_for_loop_generation_d8b3c5e7", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e216", "source": "ilp_for_range_constraint_range_expr_c7e2a4f1", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e217", "source": "ilp_for_range_constraint_loop_var_syntax_a3f9d2c8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e218", "source": "ilp_for_range_macro_single_eval_range_f2d8e1a9", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e219", "source": "ilp_for_macro_complexity_iota_range_construction_k7l8m9n0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e220", "source": "ilp_for_macro_constraint_loop_var_type_compatible_c9d0e1f2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e221", "source": "ilp_for_macro_constraint_iota_returns_range_y5z6a7b8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e222", "source": "ilp_for_macro_postcond_range_for_expansion_u1v2w3x4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e223", "source": "ilp_for_macro_precond_loop_var_valid_decl_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e224", "source": "for_loop_range_typed_auto_complexity_delegates_complexity_c6d7e8f9", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e225", "source": "for_loop_range_typed_auto_exception_propagates_from_delegate_d5e6f7a8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e226", "source": "for_loop_range_typed_auto_effect_delegates_to_typed_f2a3b4c5", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e227", "source": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e228", "source": "for_loop_range_typed_auto_constraint_element_type_compatible_d4e5f6a7", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e229", "source": "for_loop_range_typed_auto_precond_body_callable_e5f6a7b8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e230", "source": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e231", "source": "for_loop_range_auto_complexity_depends_on_impl_1f3a7c8d", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e232", "source": "for_loop_range_auto_exception_propagates_from_impl_2b6d9e4f", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e233", "source": "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e234", "source": "for_loop_range_auto_precond_body_callable_7b4e1c8f", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e235", "source": "for_loop_range_auto_precond_range_valid_8a3f2e9d", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e236", "source": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e237", "source": "for_loop_range_impl_precond_body_callable_f0a1b2c3", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e238", "source": "for_loop_range_impl_effect_range_single_evaluation_f9a0b1c2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e239", "source": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e240", "source": "for_loop_range_impl_exception_ranges_begin_propagates_f3a4b5c6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e241", "source": "for_loop_range_impl_exception_ranges_size_propagates_d7e8f9a0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e242", "source": "for_loop_range_impl_complexity_time_linear_a3b4c5d6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e243", "source": "for_loop_range_impl_complexity_space_constant_c7d8e9f0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e244", "source": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e245", "source": "for_loop_range_untyped_impl_precond_range_sized_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e246", "source": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e247", "source": "for_loop_range_untyped_impl_effect_range_eval_once_f6a7b8c9", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e248", "source": "for_loop_range_untyped_impl_complexity_linear_a9b0c1d2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e249", "source": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e250", "source": "for_loop_range_typed_impl_precond_range_valid_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e251", "source": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e252", "source": "for_loop_range_typed_impl_effect_evaluates_range_once_h7i8j9k0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e253", "source": "for_loop_range_typed_impl_effect_invokes_body_unrolled_l1m2n3o4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e254", "source": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e255", "source": "for_loop_range_typed_impl_postcond_all_elements_processed_b7c8d9e0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e256", "source": "for_loop_range_typed_impl_complexity_time_linear_v7w8x9y0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e257", "source": "for_loop_range_typed_impl_constraint_size_representable_d5e6f7g8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e258", "source": "for_loop_range_ret_simple_impl_precond_range_valid_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e259", "source": "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e260", "source": "for_loop_range_ret_simple_impl_precond_body_callable_f7g8h9i0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e261", "source": "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e262", "source": "for_loop_range_ret_simple_impl_effect_evaluates_range_once_v3w4x5y6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e263", "source": "for_loop_range_ret_simple_impl_complexity_space_x3y4z5a6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e264", "source": "for_loop_precond_valid_range_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e265", "source": "for_loop_constraint_type_t_comparable_h8i9j0k1", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e266", "source": "for_loop_typed_precond_valid_range_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e267", "source": "for_loop_typed_precond_no_overflow_a2b3c4d5", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e268", "source": "for_loop_range_precond_range_sized_e7f8g9h0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e269", "source": "for_loop_range_precond_range_has_iterator_i1j2k3l4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e270", "source": "for_loop_range_precond_body_invocable_m4n5o6p7", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e271", "source": "for_loop_range_effect_perfect_forward_range_q7r8s9t0", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e272", "source": "for_loop_range_effect_delegates_to_impl_y3z4a5b6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e273", "source": "for_loop_range_postcond_returns_forresult_c6d7e8f9", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e274", "source": "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e275", "source": "for_loop_range_typed_precond_range_valid_c4d5e6f7", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e276", "source": "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e277", "source": "for_loop_range_typed_postcond_returns_typed_result_b8c9d0e1", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e278", "source": "for_loop_range_typed_constraint_range_rvalue_ref_c9d0e1f2", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e279", "source": "for_loop_range_typed_exception_propagates_impl_e1f2a3b4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e280", "source": "for_loop_range_ret_simple_precond_range_valid_5a7b3c9d", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e281", "source": "for_loop_range_ret_simple_precond_body_callable_8d4e2f1a", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e282", "source": "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e283", "source": "for_loop_range_ret_simple_effect_delegates_to_impl_6e3f8a1c", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e284", "source": "for_loop_auto_precond_valid_range_a1b2c3d4", "target": "for_loop_range_impl_precond_range_valid_b3c4d5e6"}, {"id": "e285", "source": "cpp20_span_iterators_contiguous_model_k1l2m3n4", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e286", "source": "cpp20_span_cons_iter_sentinel_precond_contiguous_e7f8g9h0", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e287", "source": "cpp20_span_cons_iter_sentinel_precond_valid_range_a3b4c5d6", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e288", "source": "cpp20_span_cons_iter_count_precond_contiguous_s5t6u7v8", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e289", "source": "cpp20_span_cons_iter_count_precond_valid_range_o1p2q3r4", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e290", "source": "cpp20_range_access_data_contiguous_iterator_a0b3c7d1", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e291", "source": "cpp20_range_access_empty_fallback_forward_iterator_f9a2b6c0", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e292", "source": "cpp20_range_access_rend_fallback_bidirectional_d7e0f4a8", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e293", "source": "cpp20_range_access_rbegin_fallback_bidirectional_c6d9e3f7", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e294", "source": "cpp20_range_access_end_member_models_sentinel_a4b7c1d5", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e295", "source": "cpp20_range_access_begin_member_models_iterator_f3a6b0c4", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e296", "source": "cpp20_range_access_rend_models_sentinel_for_e6f9a3b7", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e297", "source": "cpp20_range_access_rbegin_models_input_or_output_iterator_d5e8f2a6", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e298", "source": "cpp20_range_access_end_models_sentinel_for_b3c6d0e4", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e299", "source": "cpp20_range_access_begin_models_input_or_output_iterator_a2b5c9d3", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e300", "source": "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e301", "source": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e302", "source": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5", "target": "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"}, {"id": "e303", "source": "cpp20_range_access_data_incomplete_array_ndr_e0f3a7b1", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e304", "source": "cpp20_range_access_empty_unknown_bound_array_illformed_c8d1e5f9", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e305", "source": "cpp20_range_access_size_unknown_bound_array_illformed_a6b9c3d7", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e306", "source": "cpp20_range_access_rend_incomplete_array_ndr_d3e6f0a4", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e307", "source": "cpp20_range_access_rbegin_incomplete_array_ndr_b1c4d8e2", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e308", "source": "cpp20_range_access_end_unknown_bound_array_illformed_d7e0f4a8", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e309", "source": "cpp20_range_access_end_incomplete_array_ndr_c6d9e3f7", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e310", "source": "cpp20_range_access_begin_incomplete_array_ndr_e5f2a8c4", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e311", "source": "cpp20_expected_value_type_constraint_e5f6a7b8", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e312", "source": "cpp20_expected_unexpected_illformed_type_a1b2c3d4", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e313", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e314", "source": "cpp20_make_shared_for_overwrite_unbounded_constraint_7a8b9c0d", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e315", "source": "cpp20_make_shared_for_overwrite_constraint_3c4d5e6f", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e316", "source": "cpp20_make_shared_bounded_array_constraint_9e0f1a2b", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e317", "source": "cpp20_make_shared_unbounded_array_constraint_5a6b7c8d", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e318", "source": "cpp20_make_shared_non_array_constraint_1c2d3e4f", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e319", "source": "cpp20_shared_ptr_ctor_constraints_non_array_type_1a2b3c4d", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e320", "source": "cpp20_shared_ptr_ctor_constraints_array_type_7c8d9e0f", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e321", "source": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e322", "source": "cpp20_shared_ptr_ctor_pointer_precondition_delete_c1d2e3f4", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e323", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e324", "source": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e325", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e326", "source": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e327", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e328", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e329", "source": "cpp20_expr_eq_array_to_pointer_conversion_h8d5f3a1", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e330", "source": "cpp20_expr_delete_array_type_mismatch_364d460b", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e331", "source": "cpp20_expr_delete_array_valid_pointer_142b24f9", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e332", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e333", "source": "cpp20_expr_new_invalid_size_throwing_e1f8f1c6", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e334", "source": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e335", "source": "cpp20_expr_new_invalid_size_ill_formed_cfd6d9a4", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e336", "source": "cpp20_expr_new_unknown_bound_initializer_bec5c893", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e337", "source": "cpp20_expr_new_complete_object_type_9cf3a671", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e338", "source": "cpp20_expr_alignof_complete_object_type_8be2f560", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e339", "source": "cpp20_expr_context_discarded_no_arr_func_conv_f2a5d8b1", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e340", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e341", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e342", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e343", "source": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e344", "source": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e345", "source": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e346", "source": "for_loop_range_impl_constraint_array_access_bounds_remainder_loop_a7b8c9d0", "target": "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"}, {"id": "e347", "source": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4", "target": "for_loop_range_impl_constraint_array_access_bounds_remainder_loop_a7b8c9d0"}, {"id": "e348", "source": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e349", "source": "for_loop_range_typed_constraint_range_rvalue_ref_c9d0e1f2", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e350", "source": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e351", "source": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e352", "source": "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e353", "source": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e354", "source": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8", "target": "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"}, {"id": "e355", "source": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "target": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"}, {"id": "e356", "source": "for_loop_range_typed_constraint_range_rvalue_ref_c9d0e1f2", "target": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"}, {"id": "e357", "source": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5", "target": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"}, {"id": "e358", "source": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "target": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"}, {"id": "e359", "source": "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8", "target": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"}, {"id": "e360", "source": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4", "target": "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"}, {"id": "e361", "source": "cpp20_span_elem_at_throws_y9z0a1b2", "target": "for_loop_range_impl_exception_ranges_begin_propagates_f3a4b5c6"}, {"id": "e362", "source": "ilp_for_t_auto_constraint_element_type_compatible", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e363", "source": "ilp_for_t_effect_single_eval_parenthesized_6f8d2a1b", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e364", "source": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e365", "source": "ilp_for_auto_constraint_element_type_compatibility", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e366", "source": "ilp_for_auto_precondition_start_end_valid", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e367", "source": "ilp_for_macro_constraint_start_end_compatible_i9j0k1l2", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e368", "source": "for_loop_range_precond_range_has_iterator_i1j2k3l4", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e369", "source": "for_loop_range_ret_simple_impl_effect_early_return_bool_b5c6d7e8", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e370", "source": "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e371", "source": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5", "target": "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"}, {"id": "e372", "source": "cpp20_meta_trans_ref_add_rvalue_reference_lvalue_ref_not_rvalue_c5d9e2f8", "target": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4"}, {"id": "e373", "source": "cpp20_meta_trans_ref_add_lvalue_reference_referenceable_c2d8f4a1", "target": "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4"}, {"id": "e374", "source": "ilp_for_t_auto_constraint_element_type_compatible", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e375", "source": "ilp_for_t_effect_single_eval_parenthesized_6f8d2a1b", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e376", "source": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e377", "source": "ilp_for_auto_constraint_element_type_compatibility", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e378", "source": "ilp_for_auto_precondition_start_end_valid", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e379", "source": "ilp_for_macro_constraint_start_end_compatible_i9j0k1l2", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e380", "source": "for_loop_range_precond_range_has_iterator_i1j2k3l4", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e381", "source": "for_loop_range_ret_simple_impl_effect_early_return_bool_b5c6d7e8", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e382", "source": "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e383", "source": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8", "target": "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"}, {"id": "e384", "source": "cpp20_range_access_data_incomplete_array_ndr_e0f3a7b1", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e385", "source": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e386", "source": "for_loop_range_ret_simple_impl_constraint_array_access_i_j_z7a8b9c0", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e387", "source": "for_loop_range_ret_simple_impl_constraint_array_access_i_d1e2f3g4", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e388", "source": "for_loop_range_ret_simple_impl_constraint_matches_bounds_h5i6j7k8", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e389", "source": "for_loop_range_ret_simple_impl_constraint_results_bounds_l9m0n1o2", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e390", "source": "ilp_for_range_constraint_range_expr_c7e2a4f1", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e391", "source": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e392", "source": "ilp_for_range_t_range_precondition", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e393", "source": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e394", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e395", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e396", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e397", "source": "cpp20_expr_context_discarded_no_arr_func_conv_f2a5d8b1", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e398", "source": "cpp20_expr_alignof_complete_object_type_8be2f560", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e399", "source": "cpp20_expr_new_complete_object_type_9cf3a671", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e400", "source": "cpp20_expr_new_unknown_bound_initializer_bec5c893", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e401", "source": "cpp20_expr_new_invalid_size_ill_formed_cfd6d9a4", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e402", "source": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e403", "source": "cpp20_expr_new_invalid_size_throwing_e1f8f1c6", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e404", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e405", "source": "cpp20_expr_delete_array_valid_pointer_142b24f9", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e406", "source": "cpp20_expr_delete_array_type_mismatch_364d460b", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e407", "source": "cpp20_expr_eq_array_to_pointer_conversion_h8d5f3a1", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e408", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e409", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e410", "source": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e411", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e412", "source": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e413", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e414", "source": "cpp20_shared_ptr_ctor_pointer_precondition_delete_c1d2e3f4", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e415", "source": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e416", "source": "cpp20_shared_ptr_ctor_constraints_array_type_7c8d9e0f", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e417", "source": "cpp20_shared_ptr_ctor_constraints_non_array_type_1a2b3c4d", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e418", "source": "cpp20_make_shared_non_array_constraint_1c2d3e4f", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e419", "source": "cpp20_make_shared_unbounded_array_constraint_5a6b7c8d", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e420", "source": "cpp20_make_shared_bounded_array_constraint_9e0f1a2b", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e421", "source": "cpp20_make_shared_for_overwrite_constraint_3c4d5e6f", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e422", "source": "cpp20_make_shared_for_overwrite_unbounded_constraint_7a8b9c0d", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e423", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e424", "source": "cpp20_expected_unexpected_illformed_type_a1b2c3d4", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e425", "source": "cpp20_expected_value_type_constraint_e5f6a7b8", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e426", "source": "cpp20_range_access_begin_incomplete_array_ndr_e5f2a8c4", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e427", "source": "cpp20_range_access_end_incomplete_array_ndr_c6d9e3f7", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e428", "source": "cpp20_range_access_end_unknown_bound_array_illformed_d7e0f4a8", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e429", "source": "cpp20_range_access_rbegin_incomplete_array_ndr_b1c4d8e2", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e430", "source": "cpp20_range_access_rend_incomplete_array_ndr_d3e6f0a4", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e431", "source": "cpp20_range_access_size_unknown_bound_array_illformed_a6b9c3d7", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e432", "source": "cpp20_range_access_empty_unknown_bound_array_illformed_c8d1e5f9", "target": "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"}, {"id": "e433", "source": "cpp20_coroutine_handle_promise_returns_ref_c1e7a3b9", "target": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4"}, {"id": "e434", "source": "cpp20_coroutine_handle_promise_precond_refers_b0d6f2a8", "target": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4"}, {"id": "e435", "source": "cpp20_coroutine_handle_from_promise_postcond_a7c3d9e5", "target": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4"}, {"id": "e436", "source": "cpp20_coroutine_handle_from_promise_precond_f6b2c8d4", "target": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4"}, {"id": "e437", "source": "cpp20_meta_trans_ptr_add_pointer_reference_removal_e3f7b9c2", "target": "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4"}, {"id": "e438", "source": "cpp20_jthread_cons_f_mandate_invocable_f1a2b3c4", "target": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5"}, {"id": "e439", "source": "cpp20_jthread_cons_f_mandate_args_constructible_b7c8d9e0", "target": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5"}, {"id": "e440", "source": "cpp20_jthread_cons_f_mandate_f_constructible_a3b4c5d6", "target": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5"}, {"id": "e441", "source": "cpp20_jthread_cons_f_constraint_not_jthread_c9d0e1f2", "target": "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5"}, {"id": "e442", "source": "cpp20_vformat_to_precondition_output_iterator_c3d4e5f6", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e443", "source": "ilp_for_t_auto_constraint_element_type_compatible", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e444", "source": "ilp_for_t_effect_single_eval_parenthesized_6f8d2a1b", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e445", "source": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e446", "source": "ilp_for_auto_constraint_element_type_compatibility", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e447", "source": "ilp_for_auto_precondition_start_end_valid", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e448", "source": "ilp_for_macro_constraint_start_end_compatible_i9j0k1l2", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e449", "source": "for_loop_range_precond_range_has_iterator_i1j2k3l4", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e450", "source": "for_loop_range_ret_simple_impl_effect_early_return_bool_b5c6d7e8", "target": "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"}, {"id": "e451", "source": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e452", "source": "ilp_for_range_t_range_precondition", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e453", "source": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e454", "source": "ilp_for_range_constraint_range_expr_c7e2a4f1", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e455", "source": "for_loop_range_ret_simple_impl_constraint_results_bounds_l9m0n1o2", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e456", "source": "for_loop_range_ret_simple_impl_constraint_matches_bounds_h5i6j7k8", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e457", "source": "for_loop_range_ret_simple_impl_constraint_array_access_i_d1e2f3g4", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e458", "source": "for_loop_range_ret_simple_impl_constraint_array_access_i_j_z7a8b9c0", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e459", "source": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4", "target": "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"}, {"id": "e460", "source": "cpp20_range_access_empty_unknown_bound_array_illformed_c8d1e5f9", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e461", "source": "cpp20_range_access_data_incomplete_array_ndr_e0f3a7b1", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e462", "source": "for_loop_range_ret_simple_impl_constraint_array_access_i_j_z7a8b9c0", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e463", "source": "for_loop_range_ret_simple_impl_constraint_array_access_i_d1e2f3g4", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e464", "source": "for_loop_range_ret_simple_impl_constraint_matches_bounds_h5i6j7k8", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e465", "source": "for_loop_range_ret_simple_impl_constraint_results_bounds_l9m0n1o2", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e466", "source": "ilp_for_range_constraint_range_expr_c7e2a4f1", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e467", "source": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e468", "source": "ilp_for_range_t_range_precondition", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e469", "source": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e470", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e471", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e472", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e473", "source": "cpp20_expr_context_discarded_no_arr_func_conv_f2a5d8b1", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e474", "source": "cpp20_expr_alignof_complete_object_type_8be2f560", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e475", "source": "cpp20_expr_new_complete_object_type_9cf3a671", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e476", "source": "cpp20_expr_new_unknown_bound_initializer_bec5c893", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e477", "source": "cpp20_expr_new_invalid_size_ill_formed_cfd6d9a4", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e478", "source": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e479", "source": "cpp20_expr_new_invalid_size_throwing_e1f8f1c6", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e480", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e481", "source": "cpp20_expr_delete_array_valid_pointer_142b24f9", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e482", "source": "cpp20_expr_delete_array_type_mismatch_364d460b", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e483", "source": "cpp20_expr_eq_array_to_pointer_conversion_h8d5f3a1", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e484", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e485", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e486", "source": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e487", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e488", "source": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e489", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e490", "source": "cpp20_shared_ptr_ctor_pointer_precondition_delete_c1d2e3f4", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e491", "source": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e492", "source": "cpp20_shared_ptr_ctor_constraints_array_type_7c8d9e0f", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e493", "source": "cpp20_shared_ptr_ctor_constraints_non_array_type_1a2b3c4d", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e494", "source": "cpp20_make_shared_non_array_constraint_1c2d3e4f", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e495", "source": "cpp20_make_shared_unbounded_array_constraint_5a6b7c8d", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e496", "source": "cpp20_make_shared_bounded_array_constraint_9e0f1a2b", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e497", "source": "cpp20_make_shared_for_overwrite_constraint_3c4d5e6f", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e498", "source": "cpp20_make_shared_for_overwrite_unbounded_constraint_7a8b9c0d", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e499", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e500", "source": "cpp20_expected_unexpected_illformed_type_a1b2c3d4", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e501", "source": "cpp20_expected_value_type_constraint_e5f6a7b8", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e502", "source": "cpp20_range_access_begin_incomplete_array_ndr_e5f2a8c4", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e503", "source": "cpp20_range_access_end_incomplete_array_ndr_c6d9e3f7", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e504", "source": "cpp20_range_access_end_unknown_bound_array_illformed_d7e0f4a8", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e505", "source": "cpp20_range_access_rbegin_incomplete_array_ndr_b1c4d8e2", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e506", "source": "cpp20_range_access_rend_incomplete_array_ndr_d3e6f0a4", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e507", "source": "cpp20_range_access_size_unknown_bound_array_illformed_a6b9c3d7", "target": "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"}, {"id": "e508", "source": "ilp_for_macro_constraint_iota_returns_range_y5z6a7b8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e509", "source": "ilp_for_range_t_auto_complexity_linear_d8b4a1c3", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e510", "source": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e511", "source": "ilp_for_range_t_auto_loop_var_scope_d3c9f1a5", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e512", "source": "ilp_for_range_t_auto_range_eval_once_e8a4b7c2", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e513", "source": "ilp_for_t_auto_constraint_requires_cpp11", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e514", "source": "ilp_for_t_auto_complexity_iota_construction", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e515", "source": "ilp_for_t_auto_postcond_range_for_expansion", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e516", "source": "ilp_for_t_auto_effect_single_eval_parenthesized", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e517", "source": "ilp_for_t_auto_precond_loop_var_decl_valid", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e518", "source": "ilp_for_t_auto_precond_start_end_valid", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e519", "source": "ilp_for_range_t_range_parenthesization", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e520", "source": "ilp_for_range_t_postcondition_range_for_loop", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e521", "source": "ilp_for_range_t_range_single_eval", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e522", "source": "ilp_for_range_t_range_precondition", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e523", "source": "ilp_for_range_t_loop_var_decl_precondition", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e524", "source": "ilp_for_t_postcondition_range_for_expansion_2d9e7c4f", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e525", "source": "ilp_for_t_precondition_loop_var_decl_syntax_9c3f1e5a", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e526", "source": "ilp_for_t_precondition_valid_range_e4d7a2b8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e527", "source": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e528", "source": "ilp_for_range_auto_anti_pattern_dangling_ref_9a7e3b52", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e529", "source": "ilp_for_range_auto_postcond_loop_scope_4e2a9c71", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e530", "source": "ilp_for_range_auto_constraint_loop_var_type_3b6d8a41", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e531", "source": "ilp_for_range_auto_effect_single_eval_2d8b4c31", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e532", "source": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e533", "source": "ilp_for_auto_postcondition_range_for_loop", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e534", "source": "ilp_for_auto_precondition_loop_var_valid_decl", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e535", "source": "ilp_for_range_complexity_sequential_o_n_b4e7c2f9", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e536", "source": "ilp_for_range_anti_pattern_incomplete_impl_f1c8d3a7", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e537", "source": "ilp_for_range_constraint_range_parenthesized_e9a2f4b6", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e538", "source": "ilp_for_range_postcondition_for_loop_generation_d8b3c5e7", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e539", "source": "ilp_for_range_constraint_range_expr_c7e2a4f1", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e540", "source": "ilp_for_range_constraint_loop_var_syntax_a3f9d2c8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e541", "source": "ilp_for_range_macro_single_eval_range_f2d8e1a9", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e542", "source": "ilp_for_macro_complexity_iota_range_construction_k7l8m9n0", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e543", "source": "ilp_for_macro_constraint_loop_var_type_compatible_c9d0e1f2", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e544", "source": "for_loop_range_typed_impl_postcond_all_elements_processed_b7c8d9e0", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e545", "source": "for_loop_range_typed_impl_complexity_time_linear_v7w8x9y0", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e546", "source": "for_loop_range_typed_impl_constraint_size_representable_d5e6f7g8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e547", "source": "for_loop_range_ret_simple_impl_precond_range_valid_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e548", "source": "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e549", "source": "for_loop_range_ret_simple_impl_precond_body_callable_f7g8h9i0", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e550", "source": "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e551", "source": "for_loop_range_ret_simple_impl_effect_evaluates_range_once_v3w4x5y6", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e552", "source": "for_loop_range_ret_simple_impl_complexity_space_x3y4z5a6", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e553", "source": "for_loop_precond_valid_range_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e554", "source": "for_loop_constraint_type_t_comparable_h8i9j0k1", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e555", "source": "for_loop_typed_precond_valid_range_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e556", "source": "for_loop_typed_precond_no_overflow_a2b3c4d5", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e557", "source": "for_loop_range_precond_range_sized_e7f8g9h0", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e558", "source": "for_loop_range_precond_range_has_iterator_i1j2k3l4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e559", "source": "for_loop_range_precond_body_invocable_m4n5o6p7", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e560", "source": "for_loop_range_effect_perfect_forward_range_q7r8s9t0", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e561", "source": "for_loop_range_effect_delegates_to_impl_y3z4a5b6", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e562", "source": "for_loop_range_postcond_returns_forresult_c6d7e8f9", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e563", "source": "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e564", "source": "for_loop_range_typed_precond_range_valid_c4d5e6f7", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e565", "source": "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e566", "source": "for_loop_range_typed_postcond_returns_typed_result_b8c9d0e1", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e567", "source": "for_loop_range_typed_constraint_range_rvalue_ref_c9d0e1f2", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e568", "source": "for_loop_range_typed_exception_propagates_impl_e1f2a3b4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e569", "source": "for_loop_range_ret_simple_precond_range_valid_5a7b3c9d", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e570", "source": "for_loop_range_ret_simple_precond_body_callable_8d4e2f1a", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e571", "source": "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e572", "source": "for_loop_range_ret_simple_effect_delegates_to_impl_6e3f8a1c", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e573", "source": "for_loop_auto_precond_valid_range_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e574", "source": "for_loop_typed_auto_precond_valid_range_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e575", "source": "for_loop_range_auto_precond_range_valid_8a3f2e9d", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e576", "source": "for_loop_range_auto_precond_body_callable_7b4e1c8f", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e577", "source": "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e578", "source": "for_loop_range_auto_exception_propagates_from_impl_2b6d9e4f", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e579", "source": "for_loop_range_auto_complexity_depends_on_impl_1f3a7c8d", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e580", "source": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e581", "source": "for_loop_range_typed_auto_precond_body_callable_e5f6a7b8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e582", "source": "for_loop_range_typed_auto_constraint_element_type_compatible_d4e5f6a7", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e583", "source": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e584", "source": "for_loop_range_typed_auto_effect_delegates_to_typed_f2a3b4c5", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e585", "source": "for_loop_range_typed_auto_exception_propagates_from_delegate_d5e6f7a8", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e586", "source": "for_loop_range_typed_auto_complexity_delegates_complexity_c6d7e8f9", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e587", "source": "ilp_for_macro_precond_loop_var_valid_decl_a1b2c3d4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e588", "source": "ilp_for_macro_postcond_range_for_expansion_u1v2w3x4", "target": "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"}, {"id": "e589", "source": "for_loop_range_ret_simple_exception_propagates_impl_exceptions_4c7e1f8a", "target": "for_loop_range_ret_simple_impl_precond_range_valid_a1b2c3d4"}, {"id": "e590", "source": "for_loop_range_ret_simple_exception_propagates_impl_exceptions_4c7e1f8a", "target": "for_loop_range_ret_simple_impl_invariant_i_bounds_p3q4r5s6"}, {"id": "e591", "source": "for_loop_range_typed_auto_constraint_optimal_n_valid_c2d3e4f5", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e592", "source": "for_loop_range_auto_constraint_optimal_n_valid_9c2d5a7e", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e593", "source": "for_loop_typed_auto_constraint_optimal_n_valid_b2c3d4e5", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e594", "source": "for_loop_auto_complexity_delegates_complexity_i9j0k1l2", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e595", "source": "for_loop_auto_constraint_optimal_n_valid_b2c3d4e5", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e596", "source": "for_loop_range_ret_simple_constraint_template_param_n_1e8c4f2d", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e597", "source": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e598", "source": "for_loop_range_constraint_template_n_compile_time_g0h1i2j3", "target": "for_loop_typed_constraint_return_type_r_b1c2d3e4"}, {"id": "e599", "source": "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e600", "source": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e601", "source": "cpp20_thread_condition_condvarany_lock_requirement_e7f8a9b0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e602", "source": "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e603", "source": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e604", "source": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e605", "source": "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e606", "source": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e607", "source": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e608", "source": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e609", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e610", "source": "cpp20_bad_expected_access_exception_purpose_c9d0e1f2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e611", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e612", "source": "cpp20_expected_error_type_constraint_c9d0e1f2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e613", "source": "cpp20_variant_no_args_illformed_a1b2c3d4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e614", "source": "cpp20_declval_incomplete_type_allowed_b5a9d4c1", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e615", "source": "cpp20_declval_odr_use_forbidden_7c8e3f2a", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e616", "source": "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e617", "source": "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e618", "source": "cpp20_weak_ptr_general_incomplete_type_allowed_a7c3f8e2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e619", "source": "cpp20_dcl_init_list_std_initializer_list_not_predefined_e8f7d6c5", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e620", "source": "cpp20_temp_inst_narrowing_instantiation_error_b5c6d7e8", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e621", "source": "cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e622", "source": "cpp20_temp_expl_spec_each_enclosing_template_prefix_c3d4e5f6", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e623", "source": "cpp20_temp_expl_spec_after_use_error_f9a0b1c2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e624", "source": "cpp20_temp_expl_spec_member_explicit_definition_required_e5f6a7b8", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e625", "source": "cpp20_temp_explicit_variable_unqualified_id_simple_template_id_c9d0e1f2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e626", "source": "cpp20_temp_explicit_class_elaborated_type_specifier_e5f6a7b8", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e627", "source": "cpp20_temp_explicit_simple_template_id_variable_class_a1b2c3d4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e628", "source": "cpp20_temp_inst_requires_invalid_expression_ndr_d7e8f9a0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e629", "source": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e630", "source": "cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e631", "source": "cpp20_temp_inst_deleted_member_redefinition_error_c5d6e7f8", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e632", "source": "cpp20_temp_inst_friend_def_second_error_e1f2a3b4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e633", "source": "cpp20_temp_inst_incomplete_class_error_a7b8c9d0", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e634", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e635", "source": "cpp20_expr_prim_qual_splice_specialization_class_e9f3a5b6", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e636", "source": "cpp20_expr_prim_qual_id_dtor_computed_type_a5b9c1d2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e637", "source": "cpp20_expr_prim_lambda_capture_shadows_param_f4a8b0c1", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e638", "source": "cpp20_basic_stc_dynamic_dealloc_template_not_usual_e1f2a3b4", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e639", "source": "for_loop_range_typed_auto_constraint_optimal_n_valid_c2d3e4f5", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e640", "source": "for_loop_range_auto_constraint_optimal_n_valid_9c2d5a7e", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e641", "source": "for_loop_range_auto_precond_body_callable_7b4e1c8f", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e642", "source": "for_loop_range_auto_precond_range_valid_8a3f2e9d", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e643", "source": "for_loop_typed_auto_constraint_optimal_n_valid_b2c3d4e5", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e644", "source": "for_loop_auto_complexity_delegates_complexity_i9j0k1l2", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e645", "source": "for_loop_auto_constraint_optimal_n_valid_b2c3d4e5", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e646", "source": "for_loop_range_ret_simple_constraint_template_param_n_1e8c4f2d", "target": "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"}, {"id": "e647", "source": "cpp20_refwrap_const_constraint_fun_well_formed_a7b8c9d0", "target": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3"}, {"id": "e648", "source": "cpp20_refwrap_const_constraint_not_self_b3c4d5e6", "target": "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3"}, {"id": "e649", "source": "for_loop_range_ret_simple_exception_propagates_impl_exceptions_4c7e1f8a", "target": "for_loop_range_ret_simple_precond_range_valid_5a7b3c9d"}, {"id": "e650", "source": "cpp20_refwrap_invoke_mandate_t_complete_c5d6e7f8", "target": "for_loop_typed_auto_constraint_f_callable_d4e5f6a7"}, {"id": "e651", "source": "cpp20_func_invoke_r_constraint_invocable_r_d9e0f1a2", "target": "for_loop_typed_auto_constraint_f_callable_d4e5f6a7"}, {"id": "e652", "source": "cpp20_func_invoke_constraint_invocable_e5f6a7b8", "target": "for_loop_typed_auto_constraint_f_callable_d4e5f6a7"}, {"id": "e653", "source": "cpp20_stop_source_constructor_bad_alloc_f3d1b6a9", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e654", "source": "cpp20_jthread_detach_throws_invalid_argument_b7c8d9e0", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e655", "source": "cpp20_jthread_detach_throws_no_such_process_a3b4c5d6", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e656", "source": "cpp20_jthread_join_throws_invalid_argument_e5f6a7b8", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e657", "source": "cpp20_jthread_join_throws_no_such_process_a1b2c3d4", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e658", "source": "cpp20_jthread_join_throws_self_join_b7c8d9e0", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e659", "source": "cpp20_jthread_join_throws_deadlock_detected_d3e4f5a6", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e660", "source": "cpp20_jthread_cons_f_throws_system_error_b1c2d3e4", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e661", "source": "cpp20_jthread_cons_f_effect_terminate_on_exception_d5e6f7a8", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e662", "source": "cpp20_time_duration_exceptions_from_rep_8b3d0e95", "target": "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"}, {"id": "e663", "source": "ilp_for_range_t_auto_complexity_linear_d8b4a1c3", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e664", "source": "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e665", "source": "ilp_for_range_t_auto_loop_var_scope_d3c9f1a5", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e666", "source": "ilp_for_range_t_auto_range_eval_once_e8a4b7c2", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e667", "source": "ilp_for_t_auto_constraint_requires_cpp11", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e668", "source": "ilp_for_t_auto_complexity_iota_construction", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e669", "source": "ilp_for_t_auto_postcond_range_for_expansion", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e670", "source": "ilp_for_t_auto_effect_single_eval_parenthesized", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e671", "source": "ilp_for_t_auto_precond_loop_var_decl_valid", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e672", "source": "ilp_for_t_auto_precond_start_end_valid", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e673", "source": "ilp_for_range_t_range_parenthesization", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e674", "source": "ilp_for_range_t_postcondition_range_for_loop", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e675", "source": "ilp_for_range_t_range_single_eval", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e676", "source": "ilp_for_range_t_range_precondition", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e677", "source": "ilp_for_range_t_loop_var_decl_precondition", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e678", "source": "ilp_for_t_postcondition_range_for_expansion_2d9e7c4f", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e679", "source": "ilp_for_t_precondition_loop_var_decl_syntax_9c3f1e5a", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e680", "source": "ilp_for_t_precondition_valid_range_e4d7a2b8", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e681", "source": "ilp_for_range_auto_complexity_range_iteration_2c5e8d91", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e682", "source": "ilp_for_range_auto_anti_pattern_dangling_ref_9a7e3b52", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e683", "source": "ilp_for_range_auto_postcond_loop_scope_4e2a9c71", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e684", "source": "ilp_for_range_auto_constraint_loop_var_type_3b6d8a41", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e685", "source": "ilp_for_range_auto_effect_single_eval_2d8b4c31", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e686", "source": "ilp_for_range_auto_precond_range_valid_7a3e9f21", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e687", "source": "ilp_for_auto_postcondition_range_for_loop", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e688", "source": "ilp_for_auto_precondition_loop_var_valid_decl", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e689", "source": "ilp_for_range_complexity_sequential_o_n_b4e7c2f9", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e690", "source": "ilp_for_range_anti_pattern_incomplete_impl_f1c8d3a7", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e691", "source": "ilp_for_range_constraint_range_parenthesized_e9a2f4b6", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e692", "source": "ilp_for_range_postcondition_for_loop_generation_d8b3c5e7", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e693", "source": "ilp_for_range_constraint_range_expr_c7e2a4f1", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e694", "source": "ilp_for_range_constraint_loop_var_syntax_a3f9d2c8", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e695", "source": "ilp_for_range_macro_single_eval_range_f2d8e1a9", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e696", "source": "ilp_for_macro_complexity_iota_range_construction_k7l8m9n0", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e697", "source": "ilp_for_macro_constraint_loop_var_type_compatible_c9d0e1f2", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e698", "source": "ilp_for_macro_constraint_iota_returns_range_y5z6a7b8", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e699", "source": "ilp_for_macro_postcond_range_for_expansion_u1v2w3x4", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e700", "source": "ilp_for_macro_precond_loop_var_valid_decl_a1b2c3d4", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e701", "source": "for_loop_range_typed_auto_complexity_delegates_complexity_c6d7e8f9", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e702", "source": "for_loop_range_typed_auto_exception_propagates_from_delegate_d5e6f7a8", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e703", "source": "for_loop_range_typed_auto_effect_delegates_to_typed_f2a3b4c5", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e704", "source": "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e705", "source": "for_loop_range_typed_auto_constraint_element_type_compatible_d4e5f6a7", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e706", "source": "for_loop_range_typed_auto_precond_body_callable_e5f6a7b8", "target": "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"}, {"id": "e707", "source": "ilp_for_t_auto_constraint_requires_cpp11", "target": "ilp_for_range_t_range_single_eval"}, {"id": "e708", "source": "ilp_for_t_auto_postcond_range_for_expansion", "target": "ilp_for_range_t_range_single_eval"}, {"id": "e709", "source": "ilp_for_t_auto_precond_loop_var_decl_valid", "target": "ilp_for_range_t_range_single_eval"}, {"id": "e710", "source": "ilp_for_range_t_postcondition_range_for_loop", "target": "ilp_for_range_t_range_single_eval"}, {"id": "e711", "source": "ilp_break.effect.loop_termination", "target": "ilp_continue_anti_pattern_switch"}, {"id": "e712", "source": "ilp_break.precondition.loop_context", "target": "ilp_continue_anti_pattern_switch"}, {"id": "e713", "source": "cpp20_variant_emplace_valueless_w9x0y1z2", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e714", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e715", "source": "cpp20_any_emplace_initlist_precondition_copyconstruct_d9e0f1a2", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e716", "source": "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e717", "source": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e718", "source": "cpp20_algorithms_requirements_ranges_dispatch_end_o5p6q7r8", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e719", "source": "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e720", "source": "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e721", "source": "cpp20_expr_prim_this_context_restriction_a3b7c2d1", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e722", "source": "cpp20_expr_prim_lambda_capture_unique_c1d5e7f8", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e723", "source": "cpp20_expr_prim_lambda_capture_scope_restriction_d2e6f8a9", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e724", "source": "cpp20_expr_new_unknown_bound_initializer_bec5c893", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e725", "source": "cpp20_expr_await_static_storage_8b9c9b50", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e726", "source": "cpp20_dcl_init_ref_arg_pass_return_init_7a3b8c2d", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e727", "source": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e728", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e729", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e730", "source": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e731", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e732", "source": "cpp20_dcl_init_ref_user_conv_no_second_user_conv_8e9f0a1b", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e733", "source": "cpp20_dcl_init_ref_not_direct_bind_definition_2c3d4e5f", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e734", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e735", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e736", "source": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e737", "source": "cpp20_over_match_ctor_explicit_default_init_copy_list_b3c4d5e6", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e738", "source": "cpp20_over_match_list_explicit_copy_list_init_f7a8b9c1", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e739", "source": "cpp20_over_match_class_deduct_no_aggregate_candidate_f7a8b9c1", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e740", "source": "cpp20_over_match_conv_permissible_types_standard_conv_d2e3f4a5", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e741", "source": "cpp20_over_match_conv_explicit_direct_init_only_b6c7d8e9", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e742", "source": "cpp20_temp_explicit_single_init_declarator_no_initializer_a3b4c5d6", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e743", "source": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e744", "source": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e745", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e746", "source": "cpp20_except_ctor_subobj_destroy_reverse_order_e1a7b2f6", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e747", "source": "cpp20_except_ctor_known_init_not_anon_union_f2b8c3a7", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e748", "source": "cpp20_dcl_init_list_std_initializer_list_not_predefined_e8f7d6c5", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e749", "source": "cpp20_dcl_init_list_designated_aggregate_class_required_b4c5d6e7", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e750", "source": "cpp20_dcl_init_list_designator_order_constraint_a3b4c5d6", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e751", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e752", "source": "cpp20_dcl_init_list_enum_direct_only_c7d8e9f0", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e753", "source": "cpp20_dcl_init_list_enum_narrowing_conversion_b8c9d0e1", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e754", "source": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e755", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e756", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e757", "source": "cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e758", "source": "cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e759", "source": "cpp20_dcl_init_list_evaluation_order_guarantee_c5d6e7f8", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e760", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e761", "source": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e762", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e763", "source": "cpp20_dcl_init_list_aggregate_narrowing_illformed_f4a5b6c7", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e764", "source": "cpp20_shared_ptr_ctor_deleter_precondition_move_5a6b7c8d", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e765", "source": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e766", "source": "cpp20_sequence_reqmts_assign_il_precondition_c1d2e3f4", "target": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a"}, {"id": "e767", "source": "cpp20_temp_expl_spec_member_explicit_definition_required_e5f6a7b8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e768", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e769", "source": "cpp20_any_reset_destroys_contained_value_f5a6b7c8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e770", "source": "cpp20_bad_expected_access_exception_purpose_c9d0e1f2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e771", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e772", "source": "cpp20_dcl_init_list_designator_order_constraint_a3b4c5d6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e773", "source": "cpp20_dcl_init_list_designated_aggregate_class_required_b4c5d6e7", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e774", "source": "cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e775", "source": "cpp20_temp_expl_spec_each_enclosing_template_prefix_c3d4e5f6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e776", "source": "cpp20_basic_stc_dynamic_dealloc_destroying_first_param_a7b8c9d0", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e777", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e778", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e779", "source": "cpp20_expr_prim_this_context_restriction_a3b7c2d1", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e780", "source": "cpp20_expr_prim_this_static_member_forbidden_e4f8a1b2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e781", "source": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e782", "source": "cpp20_expr_prim_id_nonstatic_member_usage_d6e0f5a7", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e783", "source": "cpp20_expr_prim_id_base_class_splice_a7b1c2d3", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e784", "source": "cpp20_expr_prim_id_dtor_pseudo_constraint_b8c2d4e5", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e785", "source": "cpp20_expr_prim_lambda_capture_explicit_object_type_d6e0f2a3", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e786", "source": "cpp20_expr_prim_qual_nested_name_computed_type_c7d1e3f4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e787", "source": "cpp20_expr_prim_qual_splice_class_enum_namespace_d8e2f4a5", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e788", "source": "cpp20_expr_prim_qual_splice_specialization_class_e9f3a5b6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e789", "source": "cpp20_expr_unary_op_address_incomplete_class_e1a8b5c6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e790", "source": "cpp20_expr_new_complete_object_type_9cf3a671", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e791", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e792", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e793", "source": "cpp20_expr_delete_incomplete_class_475e571c", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e794", "source": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e795", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e796", "source": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e797", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e798", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e799", "source": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e800", "source": "cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e801", "source": "cpp20_expr_cast_incomplete_class_ptr_dest_c6e9d2a3", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e802", "source": "cpp20_expr_cast_incomplete_unspecified_d8a4b5e7", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e803", "source": "cpp20_expr_eq_ptm_same_member_equal_c5d8f1a3", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e804", "source": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e805", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e806", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e807", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e808", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e809", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e810", "source": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e811", "source": "cpp20_class_dtor_implicit_definition_order_c8a4d9e1", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e812", "source": "cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e813", "source": "cpp20_class_dtor_implicit_form_e6b2c8f4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e814", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e815", "source": "cpp20_special_implicit_declaration_location_f2c8d4e5", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e816", "source": "cpp20_special_potentially_constructed_subobjects_cad8f4a7", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e817", "source": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e818", "source": "cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e819", "source": "cpp20_temp_inst_incomplete_class_error_a7b8c9d0", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e820", "source": "cpp20_temp_inst_friend_def_second_error_e1f2a3b4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e821", "source": "cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e822", "source": "cpp20_temp_explicit_simple_template_id_variable_class_a1b2c3d4", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e823", "source": "cpp20_temp_explicit_class_elaborated_type_specifier_e5f6a7b8", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e824", "source": "cpp20_temp_explicit_single_init_declarator_no_initializer_a3b4c5d6", "target": "cpp20_basic_life_end_without_destructor_9c0d1e2f"}, {"id": "e825", "source": "cpp20_algorithms_requirements_binarypredicate_value_glvalue_equiv_e9f0a1b2", "target": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a"}, {"id": "e826", "source": "cpp20_algorithms_requirements_predicate_glvalue_equivalence_k9l0m1n2", "target": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a"}, {"id": "e827", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a"}, {"id": "e828", "source": "cpp20_expr_sizeof_bitfield_58bfc23d", "target": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a"}, {"id": "e829", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a"}, {"id": "e830", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a"}, {"id": "e831", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e832", "source": "cpp20_intro_multithread_thread_object_access_d6e0f5a4", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e833", "source": "cpp20_except_ctor_auto_destroy_condition_b8d4e9c3", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e834", "source": "cpp20_except_ctor_auto_storage_destroy_order_a7c3f8b2", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e835", "source": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e836", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e837", "source": "cpp20_expr_await_static_storage_8b9c9b50", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e838", "source": "cpp20_basic_stc_dynamic_new_expression_d9e0f1a2", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e839", "source": "cpp20_basic_stc_auto_parameter_scope_b1c2d3e4", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e840", "source": "cpp20_basic_stc_auto_block_exit_d7e8f9a0", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e841", "source": "cpp20_basic_stc_auto_block_scope_f3a4b5c6", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e842", "source": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e843", "source": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e844", "source": "cpp20_basic_stc_thread_duration_f1a2b3c4", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e845", "source": "cpp20_basic_stc_static_namespace_scope_b7c8d9e0", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e846", "source": "cpp20_basic_stc_static_program_duration_a3b4c5d6", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e847", "source": "cpp20_basic_stc_general_subobject_duration_c9d0e1f2", "target": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4"}, {"id": "e848", "source": "cpp20_basic_stc_general_subobject_duration_c9d0e1f2", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e849", "source": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e850", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e851", "source": "cpp20_intro_multithread_thread_object_access_d6e0f5a4", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e852", "source": "cpp20_except_ctor_auto_destroy_condition_b8d4e9c3", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e853", "source": "cpp20_except_ctor_auto_storage_destroy_order_a7c3f8b2", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e854", "source": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e855", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e856", "source": "cpp20_expr_await_static_storage_8b9c9b50", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e857", "source": "cpp20_basic_stc_dynamic_new_expression_d9e0f1a2", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e858", "source": "cpp20_basic_stc_auto_parameter_scope_b1c2d3e4", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e859", "source": "cpp20_basic_stc_auto_block_exit_d7e8f9a0", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e860", "source": "cpp20_basic_stc_auto_block_scope_f3a4b5c6", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e861", "source": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e862", "source": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e863", "source": "cpp20_basic_stc_thread_duration_f1a2b3c4", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e864", "source": "cpp20_basic_stc_static_namespace_scope_b7c8d9e0", "target": "cpp20_basic_stc_static_program_duration_a3b4c5d6"}, {"id": "e865", "source": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e866", "source": "cpp20_basic_stc_thread_duration_f1a2b3c4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e867", "source": "cpp20_basic_stc_static_namespace_scope_b7c8d9e0", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e868", "source": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e869", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e870", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e871", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e872", "source": "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e873", "source": "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e874", "source": "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e875", "source": "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e876", "source": "cpp20_thread_condition_condvarany_dtor_precond_no_blocked_c9d0e1f2", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e877", "source": "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e878", "source": "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e879", "source": "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e880", "source": "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e881", "source": "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e882", "source": "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e883", "source": "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e884", "source": "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e885", "source": "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e886", "source": "cpp20_thread_condition_condvar_dtor_precond_no_blocked_a1b2c3d4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e887", "source": "cpp20_atomics_fences_signal_fence_scope_6d2b8e5c", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e888", "source": "cpp20_intro_races_compiler_no_spurious_write_i1g3h5j9", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e889", "source": "cpp20_intro_races_signal_handler_ordering_h0f2g4i8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e890", "source": "cpp20_intro_races_object_value_visibility_a3b7c9e1", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e891", "source": "cpp20_intro_multithread_thread_object_access_d6e0f5a4", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e892", "source": "cpp20_intro_multithread_freestanding_threads_impl_defined_c5d9e4f3", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e893", "source": "cpp20_intro_progress_delegation_unblock_a3b7c2d1", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e894", "source": "cpp20_intro_progress_delegation_strengthening_f2a6b1c0", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e895", "source": "cpp20_intro_progress_weakly_parallel_no_guarantee_d0e4f9a8", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e896", "source": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e897", "source": "cpp20_intro_progress_main_thread_impl_defined_b8c2d7e6", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e898", "source": "cpp20_intro_progress_concurrent_guarantee_a7b1c6d5", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e899", "source": "cpp20_intro_progress_lockfree_single_thread_completion_e5f9a4b3", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e900", "source": "cpp20_intro_progress_thread_assumption_d4e8f3a2", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e901", "source": "cpp20_intro_multithread_signal_handler_thread_unspecified_a3f7b2c1", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e902", "source": "cpp20_expr_await_static_storage_8b9c9b50", "target": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2"}, {"id": "e903", "source": "cpp20_basic_stc_auto_block_scope_f3a4b5c6", "target": "cpp20_basic_stc_auto_block_exit_d7e8f9a0"}, {"id": "e904", "source": "cpp20_except_ctor_auto_destroy_condition_b8d4e9c3", "target": "cpp20_basic_stc_auto_block_exit_d7e8f9a0"}, {"id": "e905", "source": "cpp20_except_ctor_auto_storage_destroy_order_a7c3f8b2", "target": "cpp20_basic_stc_auto_block_exit_d7e8f9a0"}, {"id": "e906", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_basic_stc_auto_block_exit_d7e8f9a0"}, {"id": "e907", "source": "cpp20_basic_stc_auto_parameter_scope_b1c2d3e4", "target": "cpp20_basic_stc_auto_block_exit_d7e8f9a0"}, {"id": "e908", "source": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4", "target": "cpp20_basic_stc_dynamic_new_expression_d9e0f1a2"}, {"id": "e909", "source": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "target": "cpp20_basic_stc_dynamic_new_expression_d9e0f1a2"}, {"id": "e910", "source": "cpp20_range_contiguous_data_address_a9b0c1d2", "target": "cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0"}, {"id": "e911", "source": "cpp20_range_access_data_contiguous_iterator_a0b3c7d1", "target": "cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0"}, {"id": "e912", "source": "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a", "target": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2"}, {"id": "e913", "source": "cpp20_algorithms_requirements_binarypredicate_value_glvalue_equiv_e9f0a1b2", "target": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2"}, {"id": "e914", "source": "cpp20_algorithms_requirements_predicate_glvalue_equivalence_k9l0m1n2", "target": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2"}, {"id": "e915", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2"}, {"id": "e916", "source": "cpp20_expr_sizeof_bitfield_58bfc23d", "target": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2"}, {"id": "e917", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2"}, {"id": "e918", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e919", "source": "cpp20_basic_life_indirection_limited_use_7f8a9b0c", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e920", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e921", "source": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e922", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e923", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e924", "source": "cpp20_expr_prim_req_general_prvalue_bool_a1c2e3f4", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e925", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e926", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e927", "source": "cpp20_over_match_funcs_implicit_object_param_lvalue_ref_b6c7d8e9", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e928", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e929", "source": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e930", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e931", "source": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e932", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e933", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e934", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e935", "source": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e936", "source": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e937", "source": "cpp20_expr_eq_lvalue_to_rvalue_conversion_g4c2e9f7", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e938", "source": "cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e939", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e940", "source": "cpp20_expr_cast_prvalue_result_e1a4b7f6", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e941", "source": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e942", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e943", "source": "cpp20_expr_await_suspend_type_9cad0c61", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e944", "source": "cpp20_expr_unary_op_bitwise_not_operand_14dbe8f9", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e945", "source": "cpp20_expr_unary_op_minus_operand_03cad7e8", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e946", "source": "cpp20_expr_unary_op_plus_operand_f2b9c6d7", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e947", "source": "cpp20_expr_unary_op_address_incomplete_class_e1a8b5c6", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e948", "source": "cpp20_expr_unary_op_address_of_lvalue_c9e6f3a4", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e949", "source": "cpp20_expr_unary_op_indirection_operand_b8d4e5f2", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e950", "source": "cpp20_expr_prim_contract_var_const_lvalue_f0a4b6c7", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e951", "source": "cpp20_expr_context_discarded_temp_materialization_h4c7f0d3", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e952", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e953", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "cpp20_basic_lval_temp_materialization_b4e9f1c5"}, {"id": "e954", "source": "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e955", "source": "cpp20_any_cast_pointer_returns_nullptr_type_mismatch_b9c0d1e2", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e956", "source": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e957", "source": "cpp20_reinterpret_pointer_cast_mandates_1e2f3a4b", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e958", "source": "cpp20_const_pointer_cast_mandates_7a8b9c0d", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e959", "source": "cpp20_dynamic_pointer_cast_mandates_3c4d5e6f", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e960", "source": "cpp20_static_pointer_cast_mandates_9e0f1a2b", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e961", "source": "cpp20_make_shared_postcondition_non_null_7e8f9a0b", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e962", "source": "cpp20_shared_ptr_operator_subscript_precondition_null_9a0b1c2d", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e963", "source": "cpp20_shared_ptr_operator_arrow_precondition_5c6d7e8f", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e964", "source": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "target": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5"}, {"id": "e965", "source": "cpp20_any_reset_noexcept_b7c8d9e0", "target": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8"}, {"id": "e966", "source": "cpp20_any_swap_noexcept_d3e4f5a6", "target": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8"}, {"id": "e967", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8"}, {"id": "e968", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8"}, {"id": "e969", "source": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "target": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8"}, {"id": "e970", "source": "cpp20_utility_swap_noexcept_spec_g8h2i6j0", "target": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8"}, {"id": "e971", "source": "cpp20_expr_delete_array_valid_pointer_142b24f9", "target": "cpp20_expr_delete_virtual_destructor_253c350a"}, {"id": "e972", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "cpp20_expr_delete_virtual_destructor_253c350a"}, {"id": "e973", "source": "cpp20_basic_stc_dynamic_dealloc_destroying_first_param_a7b8c9d0", "target": "cpp20_expr_delete_virtual_destructor_253c350a"}, {"id": "e974", "source": "cpp20_basic_stc_dynamic_dealloc_nonnull_first_param_c3d4e5f6", "target": "cpp20_expr_delete_virtual_destructor_253c350a"}, {"id": "e975", "source": "cpp20_expr_delete_array_type_mismatch_364d460b", "target": "cpp20_expr_delete_virtual_destructor_253c350a"}, {"id": "e976", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "cpp20_expr_cast_xvalue_result_b2f5c8d9"}, {"id": "e977", "source": "cpp20_expr_await_suspend_type_9cad0c61", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e978", "source": "cpp20_expr_unary_op_bitwise_not_operand_14dbe8f9", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e979", "source": "cpp20_expr_unary_op_minus_operand_03cad7e8", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e980", "source": "cpp20_expr_unary_op_plus_operand_f2b9c6d7", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e981", "source": "cpp20_expr_unary_op_indirection_operand_b8d4e5f2", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e982", "source": "cpp20_expr_context_discarded_temp_materialization_h4c7f0d3", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e983", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e984", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e985", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e986", "source": "cpp20_expr_prim_req_general_prvalue_bool_a1c2e3f4", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e987", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e988", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e989", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e990", "source": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e991", "source": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e992", "source": "cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1", "target": "cpp20_expr_cast_prvalue_result_e1a4b7f6"}, {"id": "e993", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8"}, {"id": "e994", "source": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "target": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8"}, {"id": "e995", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8"}, {"id": "e996", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8"}, {"id": "e997", "source": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "target": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8"}, {"id": "e998", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8"}, {"id": "e999", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2"}, {"id": "e1000", "source": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "target": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2"}, {"id": "e1001", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2"}, {"id": "e1002", "source": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "target": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2"}, {"id": "e1003", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2"}, {"id": "e1004", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2"}, {"id": "e1005", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1006", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1007", "source": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1008", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1009", "source": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1010", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1011", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1012", "source": "cpp20_expr_prim_id_base_class_splice_a7b1c2d3", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1013", "source": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "target": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2"}, {"id": "e1014", "source": "cpp20_reinterpret_pointer_cast_mandates_1e2f3a4b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1015", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1016", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1017", "source": "cpp20_expr_cast_prvalue_result_e1a4b7f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1018", "source": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1019", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1020", "source": "cpp20_expr_alignof_complete_object_type_8be2f560", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1021", "source": "cpp20_expr_prim_contract_var_const_lvalue_f0a4b6c7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1022", "source": "cpp20_expr_prim_lambda_capture_explicit_object_type_d6e0f2a3", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1023", "source": "cpp20_expr_type_composite_ptr_ref_related_n0i3l6j9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1024", "source": "cpp20_expr_type_ref_adjust_c8d2a5e7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1025", "source": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1026", "source": "cpp20_basic_stc_general_subobject_duration_c9d0e1f2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1027", "source": "cpp20_basic_life_ref_auto_refers_new_obj_0a1b2c3d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1028", "source": "cpp20_basic_life_runtime_property_1a2b3c4d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1029", "source": "cpp20_basic_life_reference_lifetime_end_3f8a2b1c", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1030", "source": "cpp20_basic_life_reference_lifetime_end_scalar_7e8f9a0b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1031", "source": "cpp20_any_swap_noexcept_d3e4f5a6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1032", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1033", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1034", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1035", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1036", "source": "cpp20_any_type_returns_void_when_empty_d7e8f9a0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1037", "source": "cpp20_any_cast_rvalue_ref_mandates_constructible_f1a2b3c4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1038", "source": "cpp20_any_cast_lvalue_ref_mandates_constructible_b7c8d9e0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1039", "source": "cpp20_any_cast_const_ref_mandates_constructible_d3e4f5a6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1040", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1041", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1042", "source": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1043", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1044", "source": "cpp20_any_emplace_exception_state_b3c4d5e6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1045", "source": "cpp20_any_emplace_initlist_precondition_copyconstruct_d9e0f1a2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1046", "source": "cpp20_any_emplace_precondition_copyconstruct_f5a6b7c8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1047", "source": "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1048", "source": "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1049", "source": "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1050", "source": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1051", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1052", "source": "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1053", "source": "cpp20_format_to_n_precondition_output_iterator_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1054", "source": "cpp20_basic_format_string_consteval_invalid_b5c6d7e8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1055", "source": "cpp20_format_err_report_throws_format_error_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1056", "source": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1057", "source": "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1058", "source": "cpp20_thread_condition_spurious_wakeup_e7f8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1059", "source": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1060", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1061", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1062", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1063", "source": "cpp20_thread_condition_condvarany_intwait_until_terminate_e3f4a5b6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1064", "source": "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1065", "source": "cpp20_thread_condition_condvarany_intwait_terminate_c5d6e7f8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1066", "source": "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1067", "source": "cpp20_thread_condition_condvarany_wait_for_terminate_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1068", "source": "cpp20_thread_condition_condvarany_wait_until_terminate_c3d4e5f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1069", "source": "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1070", "source": "cpp20_thread_condition_condvarany_wait_relock_fail_terminate_a5b6c7d8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1071", "source": "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1072", "source": "cpp20_thread_condition_condvar_wait_for_pred_terminate_e5f6a7b8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1073", "source": "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1074", "source": "cpp20_thread_condition_condvar_wait_until_pred_terminate_c7d8e9f0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1075", "source": "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1076", "source": "cpp20_thread_condition_condvar_wait_for_terminate_a9b0c1d2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1077", "source": "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1078", "source": "cpp20_thread_condition_condvar_wait_until_terminate_e1f2a3b4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1079", "source": "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1080", "source": "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1081", "source": "cpp20_thread_condition_condvar_wait_pred_terminate_e9f0a1b2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1082", "source": "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1083", "source": "cpp20_thread_condition_condvar_wait_relock_fail_terminate_c1d2e3f4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1084", "source": "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1085", "source": "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1086", "source": "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1087", "source": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1088", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1089", "source": "cpp20_expected_void_transform_mandates_c1d2e3f4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1090", "source": "cpp20_expected_void_or_else_mandates_e7f8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1091", "source": "cpp20_expected_void_and_then_mandates_a3b4c5d6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1092", "source": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1093", "source": "cpp20_expected_error_or_mandates_a1b2c3d4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1094", "source": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1095", "source": "cpp20_expected_value_or_mandates_e3f4a5b6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1096", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1097", "source": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1098", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1099", "source": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1100", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1101", "source": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1102", "source": "cpp20_expected_void_value_throws_bad_access_a5b6c7d8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1103", "source": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1104", "source": "cpp20_expected_void_error_precondition_e7f8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1105", "source": "cpp20_unexpected_equality_mandates_c9d0e1f2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1106", "source": "cpp20_unexpected_swap_mandates_e5f6a7b8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1107", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1108", "source": "cpp20_expected_transform_mandates_c7d8e9f0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1109", "source": "cpp20_expected_or_else_mandates_e3f4a5b6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1110", "source": "cpp20_expected_and_then_mandates_a9b0c1d2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1111", "source": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1112", "source": "cpp20_expected_error_precondition_e1f2a3b4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1113", "source": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1114", "source": "cpp20_expected_value_throws_bad_access_c3d4e5f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1115", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1116", "source": "cpp20_expected_deref_precondition_a5b6c7d8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1117", "source": "cpp20_variant_swap_specialized_constraints_o5p6q7r8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1118", "source": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1119", "source": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1120", "source": "cpp20_variant_spaceship_valueless_ordering_c3d4e5f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1121", "source": "cpp20_variant_relops_valueless_less_y9z0a1b2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1122", "source": "cpp20_variant_relops_valueless_equal_u5v6w7x8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1123", "source": "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1124", "source": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1125", "source": "cpp20_variant_emplace_type_unique_a5b6c7d8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1126", "source": "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1127", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1128", "source": "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1129", "source": "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1130", "source": "cpp20_variant_visit_mandates_valid_expression_m5n6o7p8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1131", "source": "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1132", "source": "cpp20_variant_swap_mandates_move_constructible_e7f8g9h0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1133", "source": "cpp20_variant_swap_precondition_swappable_a3b4c5d6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1134", "source": "cpp20_variant_emplace_valueless_w9x0y1z2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1135", "source": "cpp20_variant_emplace_mandates_s5t6u7v8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1136", "source": "cpp20_variant_holds_alternative_mandates_k7l8m9n0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1137", "source": "cpp20_variant_get_type_mandates_unique_g3h4i5j6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1138", "source": "cpp20_variant_get_index_mandates_c9d0e1f2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1139", "source": "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1140", "source": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1141", "source": "cpp20_variant_get_index_precondition_m3n4o5p6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1142", "source": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1143", "source": "cpp20_utility_swap_array_effect_swap_ranges_s1t5u9v3", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1144", "source": "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1145", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1146", "source": "cpp20_utility_swap_noexcept_spec_g8h2i6j0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1147", "source": "cpp20_utility_swap_effect_exchange_values_c7d1e5f9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1148", "source": "cpp20_utility_swap_precond_cpp17moveassignable_f6g0h4i8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1149", "source": "cpp20_utility_swap_precond_cpp17moveconstructible_b5c9d3e7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1150", "source": "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1151", "source": "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1152", "source": "cpp20_forward_signal_safe_a2d4f6c8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1153", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1154", "source": "cpp20_move_returns_rvalue_ref_e4b6d2a8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1155", "source": "cpp20_forward_like_return_type_d8f1c3a9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1156", "source": "cpp20_forward_like_mandates_referenceable_c7a2b4e6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1157", "source": "cpp20_forward_rvalue_overload_returns_b5d9e3f7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1158", "source": "cpp20_forward_lvalue_overload_returns_f2e8a1c4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1159", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1160", "source": "cpp20_container_node_mapped_precondition_a9b0c1d2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1161", "source": "cpp20_container_node_key_precondition_f8a9b0c1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1162", "source": "cpp20_container_node_value_precondition_e7f8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1163", "source": "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1164", "source": "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1165", "source": "cpp20_sequence_reqmts_push_back_move_precondition_c9d0e1f2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1166", "source": "cpp20_sequence_reqmts_push_back_copy_precondition_b8c9d0e1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1167", "source": "cpp20_sequence_reqmts_push_front_move_precondition_a7b8c9d0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1168", "source": "cpp20_sequence_reqmts_push_front_copy_precondition_f6a7b8c9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1169", "source": "cpp20_sequence_reqmts_emplace_back_precondition_e5f6a7b8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1170", "source": "cpp20_sequence_reqmts_emplace_front_precondition_d4e5f6a7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1171", "source": "cpp20_sequence_reqmts_back_precondition_c3d4e5f6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1172", "source": "cpp20_sequence_reqmts_front_precondition_b2c3d4e5", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1173", "source": "cpp20_sequence_reqmts_assign_n_no_self_ref_a1b2c3d4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1174", "source": "cpp20_make_shared_non_array_constraint_1c2d3e4f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1175", "source": "cpp20_shared_ptr_ctor_unique_ptr_constraints_7e8f9a0b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1176", "source": "cpp20_shared_ptr_ctor_weak_ptr_compatible_constraint_3a4b5c6d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1177", "source": "cpp20_shared_ptr_ctor_compatible_pointer_constraint_9c0d1e2f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1178", "source": "cpp20_shared_ptr_aliasing_ctor_dangling_pointer_3e4f5a6b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1179", "source": "cpp20_get_deleter_validity_lifetime_9a0b1c2d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1180", "source": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1181", "source": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1182", "source": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1183", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1184", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1185", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1186", "source": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1187", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1188", "source": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1189", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1190", "source": "cpp20_dcl_init_ref_user_conv_no_second_user_conv_8e9f0a1b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1191", "source": "cpp20_dcl_init_ref_not_direct_bind_definition_2c3d4e5f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1192", "source": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1193", "source": "cpp20_over_match_funcs_implicit_object_param_lvalue_ref_b6c7d8e9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1194", "source": "cpp20_over_match_funcs_implicit_object_param_rvalue_ref_f1a2b3c4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1195", "source": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1196", "source": "cpp20_except_ctor_ref_member_temp_lifetime_e7adb8fc", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1197", "source": "cpp20_dcl_init_list_designated_aggregate_class_required_b4c5d6e7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1198", "source": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1199", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1200", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1201", "source": "cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1202", "source": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1203", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1204", "source": "cpp20_weak_ptr_copy_ctor_constraint_compatible_d3f7b1a6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1205", "source": "cpp20_weak_ptr_copy_ctor_shared_ptr_constraint_e4a8c2b7", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1206", "source": "cpp20_weak_ptr_copy_ctor_postcondition_use_count_f5b9d3c8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1207", "source": "cpp20_weak_ptr_move_ctor_constraint_compatible_a6c0e4d9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1208", "source": "cpp20_weak_ptr_move_ctor_postcondition_b7d1f5e0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1209", "source": "cpp20_weak_ptr_owner_before_strict_weak_ordering_a2c6e0d5", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1210", "source": "cpp20_weak_ptr_owner_before_owner_equal_relation_b3d7f1e6", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1211", "source": "cpp20_weak_ptr_owner_equal_shared_ownership_d5f9b3a8", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1212", "source": "cpp20_weak_ptr_owner_equal_equivalence_relation_e6a0c4b9", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1213", "source": "cpp20_weak_ptr_swap_exchanges_contents_f7b1d5c0", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1214", "source": "cpp20_weak_ptr_assignment_copy_effect_b9d3f7e2", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1215", "source": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1216", "source": "cpp20_weak_ptr_free_swap_equivalent_d1f5b9a4", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1217", "source": "cpp20_shared_ptr_ctor_weak_ptr_throws_bad_weak_ptr_7a8b9c0d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1218", "source": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1219", "source": "cpp20_shared_ptr_operator_subscript_precondition_null_9a0b1c2d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1220", "source": "cpp20_shared_ptr_operator_subscript_hardened_nonneg_3e4f5a6b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1221", "source": "cpp20_shared_ptr_operator_subscript_hardened_bounds_7c8d9e0f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1222", "source": "cpp20_make_shared_allocator_precondition_9c0d1e2f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1223", "source": "cpp20_make_shared_exception_safety_3a4b5c6d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1224", "source": "cpp20_make_shared_postcondition_non_null_7e8f9a0b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1225", "source": "cpp20_dynamic_pointer_cast_precondition_wellformed_5a6b7c8d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1226", "source": "cpp20_static_pointer_cast_mandates_9e0f1a2b", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1227", "source": "cpp20_dynamic_pointer_cast_mandates_3c4d5e6f", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1228", "source": "cpp20_const_pointer_cast_mandates_7a8b9c0d", "target": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7"}, {"id": "e1229", "source": "cpp20_expr_eq_lvalue_to_rvalue_conversion_g4c2e9f7", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1230", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1231", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1232", "source": "cpp20_expr_unary_op_address_incomplete_class_e1a8b5c6", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1233", "source": "cpp20_expr_unary_op_address_of_lvalue_c9e6f3a4", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1234", "source": "cpp20_expr_prim_contract_var_const_lvalue_f0a4b6c7", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1235", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1236", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1237", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1238", "source": "cpp20_basic_life_indirection_limited_use_7f8a9b0c", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1239", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1240", "source": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1241", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1242", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1243", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1244", "source": "cpp20_over_match_funcs_implicit_object_param_lvalue_ref_b6c7d8e9", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1245", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1246", "source": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1247", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1248", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1249", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b"}, {"id": "e1250", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1251", "source": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1252", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1253", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1254", "source": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1255", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1256", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1257", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1258", "source": "cpp20_over_match_funcs_implicit_object_param_lvalue_ref_b6c7d8e9", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1259", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j"}, {"id": "e1260", "source": "cpp20_shared_ptr_ctor_compatible_pointer_constraint_9c0d1e2f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1261", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1262", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1263", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1264", "source": "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1265", "source": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1266", "source": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1267", "source": "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1268", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1269", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1270", "source": "cpp20_expr_cast_prvalue_result_e1a4b7f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1271", "source": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1272", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1273", "source": "cpp20_expr_alignof_complete_object_type_8be2f560", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1274", "source": "cpp20_expr_prim_contract_var_const_lvalue_f0a4b6c7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1275", "source": "cpp20_expr_prim_lambda_capture_explicit_object_type_d6e0f2a3", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1276", "source": "cpp20_expr_type_composite_ptr_ref_related_n0i3l6j9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1277", "source": "cpp20_expr_type_ref_adjust_c8d2a5e7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1278", "source": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1279", "source": "cpp20_basic_stc_general_subobject_duration_c9d0e1f2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1280", "source": "cpp20_basic_life_ref_auto_refers_new_obj_0a1b2c3d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1281", "source": "cpp20_basic_life_runtime_property_1a2b3c4d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1282", "source": "cpp20_basic_life_reference_lifetime_end_3f8a2b1c", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1283", "source": "cpp20_basic_life_reference_lifetime_end_scalar_7e8f9a0b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1284", "source": "cpp20_any_swap_noexcept_d3e4f5a6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1285", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1286", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1287", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1288", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1289", "source": "cpp20_any_type_returns_void_when_empty_d7e8f9a0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1290", "source": "cpp20_any_cast_rvalue_ref_mandates_constructible_f1a2b3c4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1291", "source": "cpp20_any_cast_lvalue_ref_mandates_constructible_b7c8d9e0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1292", "source": "cpp20_any_cast_const_ref_mandates_constructible_d3e4f5a6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1293", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1294", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1295", "source": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1296", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1297", "source": "cpp20_any_emplace_exception_state_b3c4d5e6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1298", "source": "cpp20_any_emplace_initlist_precondition_copyconstruct_d9e0f1a2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1299", "source": "cpp20_any_emplace_precondition_copyconstruct_f5a6b7c8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1300", "source": "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1301", "source": "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1302", "source": "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1303", "source": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1304", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1305", "source": "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1306", "source": "cpp20_format_to_n_precondition_output_iterator_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1307", "source": "cpp20_basic_format_string_consteval_invalid_b5c6d7e8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1308", "source": "cpp20_format_err_report_throws_format_error_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1309", "source": "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1310", "source": "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1311", "source": "cpp20_thread_condition_spurious_wakeup_e7f8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1312", "source": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1313", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1314", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1315", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1316", "source": "cpp20_thread_condition_condvarany_intwait_until_terminate_e3f4a5b6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1317", "source": "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1318", "source": "cpp20_thread_condition_condvarany_intwait_terminate_c5d6e7f8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1319", "source": "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1320", "source": "cpp20_thread_condition_condvarany_wait_for_terminate_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1321", "source": "cpp20_thread_condition_condvarany_wait_until_terminate_c3d4e5f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1322", "source": "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1323", "source": "cpp20_thread_condition_condvarany_wait_relock_fail_terminate_a5b6c7d8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1324", "source": "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1325", "source": "cpp20_thread_condition_condvar_wait_for_pred_terminate_e5f6a7b8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1326", "source": "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1327", "source": "cpp20_thread_condition_condvar_wait_until_pred_terminate_c7d8e9f0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1328", "source": "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1329", "source": "cpp20_thread_condition_condvar_wait_for_terminate_a9b0c1d2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1330", "source": "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1331", "source": "cpp20_thread_condition_condvar_wait_until_terminate_e1f2a3b4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1332", "source": "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1333", "source": "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1334", "source": "cpp20_thread_condition_condvar_wait_pred_terminate_e9f0a1b2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1335", "source": "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1336", "source": "cpp20_thread_condition_condvar_wait_relock_fail_terminate_c1d2e3f4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1337", "source": "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1338", "source": "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1339", "source": "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1340", "source": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1341", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1342", "source": "cpp20_expected_void_transform_mandates_c1d2e3f4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1343", "source": "cpp20_expected_void_or_else_mandates_e7f8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1344", "source": "cpp20_expected_void_and_then_mandates_a3b4c5d6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1345", "source": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1346", "source": "cpp20_expected_error_or_mandates_a1b2c3d4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1347", "source": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1348", "source": "cpp20_expected_value_or_mandates_e3f4a5b6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1349", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1350", "source": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1351", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1352", "source": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1353", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1354", "source": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1355", "source": "cpp20_expected_void_value_throws_bad_access_a5b6c7d8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1356", "source": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1357", "source": "cpp20_expected_void_error_precondition_e7f8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1358", "source": "cpp20_unexpected_equality_mandates_c9d0e1f2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1359", "source": "cpp20_unexpected_swap_mandates_e5f6a7b8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1360", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1361", "source": "cpp20_expected_transform_mandates_c7d8e9f0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1362", "source": "cpp20_expected_or_else_mandates_e3f4a5b6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1363", "source": "cpp20_expected_and_then_mandates_a9b0c1d2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1364", "source": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1365", "source": "cpp20_expected_error_precondition_e1f2a3b4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1366", "source": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1367", "source": "cpp20_expected_value_throws_bad_access_c3d4e5f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1368", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1369", "source": "cpp20_expected_deref_precondition_a5b6c7d8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1370", "source": "cpp20_variant_swap_specialized_constraints_o5p6q7r8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1371", "source": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1372", "source": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1373", "source": "cpp20_variant_spaceship_valueless_ordering_c3d4e5f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1374", "source": "cpp20_variant_relops_valueless_less_y9z0a1b2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1375", "source": "cpp20_variant_relops_valueless_equal_u5v6w7x8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1376", "source": "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1377", "source": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1378", "source": "cpp20_variant_emplace_type_unique_a5b6c7d8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1379", "source": "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1380", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1381", "source": "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1382", "source": "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1383", "source": "cpp20_variant_visit_mandates_valid_expression_m5n6o7p8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1384", "source": "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1385", "source": "cpp20_variant_swap_mandates_move_constructible_e7f8g9h0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1386", "source": "cpp20_variant_swap_precondition_swappable_a3b4c5d6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1387", "source": "cpp20_variant_emplace_valueless_w9x0y1z2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1388", "source": "cpp20_variant_emplace_mandates_s5t6u7v8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1389", "source": "cpp20_variant_holds_alternative_mandates_k7l8m9n0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1390", "source": "cpp20_variant_get_type_mandates_unique_g3h4i5j6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1391", "source": "cpp20_variant_get_index_mandates_c9d0e1f2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1392", "source": "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1393", "source": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1394", "source": "cpp20_variant_get_index_precondition_m3n4o5p6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1395", "source": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1396", "source": "cpp20_utility_swap_array_effect_swap_ranges_s1t5u9v3", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1397", "source": "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1398", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1399", "source": "cpp20_utility_swap_noexcept_spec_g8h2i6j0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1400", "source": "cpp20_utility_swap_effect_exchange_values_c7d1e5f9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1401", "source": "cpp20_utility_swap_precond_cpp17moveassignable_f6g0h4i8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1402", "source": "cpp20_utility_swap_precond_cpp17moveconstructible_b5c9d3e7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1403", "source": "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1404", "source": "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1405", "source": "cpp20_forward_signal_safe_a2d4f6c8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1406", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1407", "source": "cpp20_move_returns_rvalue_ref_e4b6d2a8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1408", "source": "cpp20_forward_like_return_type_d8f1c3a9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1409", "source": "cpp20_forward_like_mandates_referenceable_c7a2b4e6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1410", "source": "cpp20_forward_rvalue_overload_returns_b5d9e3f7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1411", "source": "cpp20_forward_lvalue_overload_returns_f2e8a1c4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1412", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1413", "source": "cpp20_container_node_mapped_precondition_a9b0c1d2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1414", "source": "cpp20_container_node_key_precondition_f8a9b0c1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1415", "source": "cpp20_container_node_value_precondition_e7f8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1416", "source": "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1417", "source": "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1418", "source": "cpp20_sequence_reqmts_push_back_move_precondition_c9d0e1f2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1419", "source": "cpp20_sequence_reqmts_push_back_copy_precondition_b8c9d0e1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1420", "source": "cpp20_sequence_reqmts_push_front_move_precondition_a7b8c9d0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1421", "source": "cpp20_sequence_reqmts_push_front_copy_precondition_f6a7b8c9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1422", "source": "cpp20_sequence_reqmts_emplace_back_precondition_e5f6a7b8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1423", "source": "cpp20_sequence_reqmts_emplace_front_precondition_d4e5f6a7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1424", "source": "cpp20_sequence_reqmts_back_precondition_c3d4e5f6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1425", "source": "cpp20_sequence_reqmts_front_precondition_b2c3d4e5", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1426", "source": "cpp20_sequence_reqmts_assign_n_no_self_ref_a1b2c3d4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1427", "source": "cpp20_make_shared_non_array_constraint_1c2d3e4f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1428", "source": "cpp20_shared_ptr_ctor_unique_ptr_constraints_7e8f9a0b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1429", "source": "cpp20_shared_ptr_ctor_weak_ptr_compatible_constraint_3a4b5c6d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1430", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1431", "source": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1432", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1433", "source": "cpp20_dcl_init_ref_user_conv_no_second_user_conv_8e9f0a1b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1434", "source": "cpp20_dcl_init_ref_not_direct_bind_definition_2c3d4e5f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1435", "source": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1436", "source": "cpp20_over_match_funcs_implicit_object_param_lvalue_ref_b6c7d8e9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1437", "source": "cpp20_over_match_funcs_implicit_object_param_rvalue_ref_f1a2b3c4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1438", "source": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1439", "source": "cpp20_except_ctor_ref_member_temp_lifetime_e7adb8fc", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1440", "source": "cpp20_dcl_init_list_designated_aggregate_class_required_b4c5d6e7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1441", "source": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1442", "source": "cpp20_dcl_init_list_ref_lvalue_nonconst_prvalue_d0e1f2a3", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1443", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1444", "source": "cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1445", "source": "cpp20_dcl_init_list_backing_array_lifetime_e7f8a9b0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1446", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1447", "source": "cpp20_weak_ptr_copy_ctor_constraint_compatible_d3f7b1a6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1448", "source": "cpp20_weak_ptr_copy_ctor_shared_ptr_constraint_e4a8c2b7", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1449", "source": "cpp20_weak_ptr_copy_ctor_postcondition_use_count_f5b9d3c8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1450", "source": "cpp20_weak_ptr_move_ctor_constraint_compatible_a6c0e4d9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1451", "source": "cpp20_weak_ptr_move_ctor_postcondition_b7d1f5e0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1452", "source": "cpp20_weak_ptr_owner_before_strict_weak_ordering_a2c6e0d5", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1453", "source": "cpp20_weak_ptr_owner_before_owner_equal_relation_b3d7f1e6", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1454", "source": "cpp20_weak_ptr_owner_equal_shared_ownership_d5f9b3a8", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1455", "source": "cpp20_weak_ptr_owner_equal_equivalence_relation_e6a0c4b9", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1456", "source": "cpp20_weak_ptr_swap_exchanges_contents_f7b1d5c0", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1457", "source": "cpp20_weak_ptr_assignment_copy_effect_b9d3f7e2", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1458", "source": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1459", "source": "cpp20_weak_ptr_free_swap_equivalent_d1f5b9a4", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1460", "source": "cpp20_shared_ptr_ctor_weak_ptr_throws_bad_weak_ptr_7a8b9c0d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1461", "source": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1462", "source": "cpp20_shared_ptr_operator_subscript_precondition_null_9a0b1c2d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1463", "source": "cpp20_shared_ptr_operator_subscript_hardened_nonneg_3e4f5a6b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1464", "source": "cpp20_shared_ptr_operator_subscript_hardened_bounds_7c8d9e0f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1465", "source": "cpp20_make_shared_allocator_precondition_9c0d1e2f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1466", "source": "cpp20_make_shared_exception_safety_3a4b5c6d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1467", "source": "cpp20_make_shared_postcondition_non_null_7e8f9a0b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1468", "source": "cpp20_dynamic_pointer_cast_precondition_wellformed_5a6b7c8d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1469", "source": "cpp20_static_pointer_cast_mandates_9e0f1a2b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1470", "source": "cpp20_dynamic_pointer_cast_mandates_3c4d5e6f", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1471", "source": "cpp20_const_pointer_cast_mandates_7a8b9c0d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1472", "source": "cpp20_reinterpret_pointer_cast_mandates_1e2f3a4b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1473", "source": "cpp20_get_deleter_validity_lifetime_9a0b1c2d", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1474", "source": "cpp20_shared_ptr_aliasing_ctor_dangling_pointer_3e4f5a6b", "target": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r"}, {"id": "e1475", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1476", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1477", "source": "cpp20_dcl_init_ref_implicit_conv_to_t1_4a5b6c7d", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1478", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1479", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1480", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1481", "source": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1482", "source": "cpp20_expr_eq_ptm_same_member_equal_c5d8f1a3", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1483", "source": "cpp20_expr_cast_incomplete_unspecified_d8a4b5e7", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1484", "source": "cpp20_expr_cast_incomplete_class_ptr_dest_c6e9d2a3", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1485", "source": "cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1486", "source": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1487", "source": "cpp20_class_dtor_implicit_definition_order_c8a4d9e1", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1488", "source": "cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1489", "source": "cpp20_class_dtor_implicit_form_e6b2c8f4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1490", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1491", "source": "cpp20_special_implicit_declaration_location_f2c8d4e5", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1492", "source": "cpp20_special_potentially_constructed_subobjects_cad8f4a7", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1493", "source": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1494", "source": "cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1495", "source": "cpp20_temp_inst_incomplete_class_error_a7b8c9d0", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1496", "source": "cpp20_temp_inst_friend_def_second_error_e1f2a3b4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1497", "source": "cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1498", "source": "cpp20_temp_explicit_simple_template_id_variable_class_a1b2c3d4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1499", "source": "cpp20_temp_explicit_class_elaborated_type_specifier_e5f6a7b8", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1500", "source": "cpp20_temp_explicit_single_init_declarator_no_initializer_a3b4c5d6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1501", "source": "cpp20_temp_expl_spec_member_explicit_definition_required_e5f6a7b8", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1502", "source": "cpp20_temp_expl_spec_each_enclosing_template_prefix_c3d4e5f6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1503", "source": "cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1504", "source": "cpp20_dcl_init_list_designated_aggregate_class_required_b4c5d6e7", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1505", "source": "cpp20_dcl_init_list_designator_order_constraint_a3b4c5d6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1506", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1507", "source": "cpp20_bad_expected_access_exception_purpose_c9d0e1f2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1508", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1509", "source": "cpp20_basic_life_end_without_destructor_9c0d1e2f", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1510", "source": "cpp20_basic_stc_dynamic_dealloc_destroying_first_param_a7b8c9d0", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1511", "source": "cpp20_expr_type_prvalue_cv_strip_d9e3b6f8", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1512", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1513", "source": "cpp20_expr_prim_this_context_restriction_a3b7c2d1", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1514", "source": "cpp20_expr_prim_this_static_member_forbidden_e4f8a1b2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1515", "source": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1516", "source": "cpp20_expr_prim_id_nonstatic_member_usage_d6e0f5a7", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1517", "source": "cpp20_expr_prim_id_base_class_splice_a7b1c2d3", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1518", "source": "cpp20_expr_prim_id_dtor_pseudo_constraint_b8c2d4e5", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1519", "source": "cpp20_expr_prim_lambda_capture_explicit_object_type_d6e0f2a3", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1520", "source": "cpp20_expr_prim_qual_nested_name_computed_type_c7d1e3f4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1521", "source": "cpp20_expr_prim_qual_splice_class_enum_namespace_d8e2f4a5", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1522", "source": "cpp20_expr_prim_qual_splice_specialization_class_e9f3a5b6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1523", "source": "cpp20_expr_unary_op_address_incomplete_class_e1a8b5c6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1524", "source": "cpp20_expr_new_complete_object_type_9cf3a671", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1525", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1526", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1527", "source": "cpp20_expr_delete_incomplete_class_475e571c", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1528", "source": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1529", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1530", "source": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1531", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_class_dtor_trivial_conditions_a9d6e5b8"}, {"id": "e1532", "source": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1533", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1534", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1535", "source": "cpp20_expr_delete_dealloc_accessible_d0e4a4a5", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1536", "source": "cpp20_expr_delete_destructor_accessible_586f682d", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1537", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1538", "source": "cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1539", "source": "cpp20_expr_prim_id_dtor_pseudo_constraint_b8c2d4e5", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1540", "source": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1541", "source": "cpp20_basic_stc_auto_parameter_lifetime_f5a6b7c8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1542", "source": "cpp20_basic_life_end_without_destructor_9c0d1e2f", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1543", "source": "cpp20_any_destructor_calls_reset_d9e0f1a2", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1544", "source": "cpp20_range_view_moved_from_O1_destruction_s1t2u3v4", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1545", "source": "cpp20_range_view_copy_assignment_complexity_o7p8q9r0", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1546", "source": "cpp20_range_view_copy_destruction_linear_g9h0i1j2", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1547", "source": "cpp20_range_view_move_assignment_complexity_c5d6e7f8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1548", "source": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1549", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1550", "source": "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1551", "source": "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1552", "source": "cpp20_variant_dtor_destroys_value_i3j4k5l6", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1553", "source": "cpp20_weak_ptr_destructor_no_effect_on_object_c8e2a6f1", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1554", "source": "cpp20_except_ctor_delegating_destroy_before_handler_d6fca7eb", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1555", "source": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1556", "source": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1557", "source": "cpp20_except_ctor_dtor_except_continue_a3c9d4b8", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1558", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1559", "source": "cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1560", "source": "cpp20_except_throw_destruction_ordering_d5e1c7b9", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1561", "source": "cpp20_except_throw_destruction_exception_ptr_2b7d8a3f", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1562", "source": "cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1563", "source": "cpp20_over_call_func_postcondition_assertion_dtor_a1b3c5d7", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1564", "source": "cpp20_special_member_function_kinds_e7b4a9c2", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1565", "source": "cpp20_class_dtor_qualified_call_in_body_f8c5a3b7", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1566", "source": "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1567", "source": "cpp20_class_dtor_implicit_form_e6b2c8f4", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1568", "source": "cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1569", "source": "cpp20_class_dtor_implicit_definition_order_c8a4d9e1", "target": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4"}, {"id": "e1570", "source": "cpp20_class_dtor_implicit_form_e6b2c8f4", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1571", "source": "cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1572", "source": "cpp20_class_dtor_implicit_definition_order_c8a4d9e1", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1573", "source": "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1574", "source": "cpp20_class_dtor_trivial_conditions_a9d6e5b8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1575", "source": "cpp20_class_dtor_deleted_union_variant_dmi_f4b8c3a2", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1576", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1577", "source": "cpp20_expr_delete_dealloc_accessible_d0e4a4a5", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1578", "source": "cpp20_expr_delete_destructor_accessible_586f682d", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1579", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1580", "source": "cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1581", "source": "cpp20_expr_prim_id_dtor_pseudo_constraint_b8c2d4e5", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1582", "source": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1583", "source": "cpp20_basic_stc_auto_parameter_lifetime_f5a6b7c8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1584", "source": "cpp20_basic_life_end_without_destructor_9c0d1e2f", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1585", "source": "cpp20_any_destructor_calls_reset_d9e0f1a2", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1586", "source": "cpp20_range_view_moved_from_O1_destruction_s1t2u3v4", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1587", "source": "cpp20_range_view_copy_assignment_complexity_o7p8q9r0", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1588", "source": "cpp20_range_view_copy_destruction_linear_g9h0i1j2", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1589", "source": "cpp20_range_view_move_assignment_complexity_c5d6e7f8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1590", "source": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1591", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1592", "source": "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1593", "source": "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1594", "source": "cpp20_variant_dtor_destroys_value_i3j4k5l6", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1595", "source": "cpp20_weak_ptr_destructor_no_effect_on_object_c8e2a6f1", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1596", "source": "cpp20_except_ctor_delegating_destroy_before_handler_d6fca7eb", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1597", "source": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1598", "source": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1599", "source": "cpp20_except_ctor_dtor_except_continue_a3c9d4b8", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1600", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1601", "source": "cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1602", "source": "cpp20_except_throw_destruction_ordering_d5e1c7b9", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1603", "source": "cpp20_except_throw_destruction_exception_ptr_2b7d8a3f", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1604", "source": "cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1605", "source": "cpp20_over_call_func_postcondition_assertion_dtor_a1b3c5d7", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1606", "source": "cpp20_special_member_function_kinds_e7b4a9c2", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1607", "source": "cpp20_class_dtor_qualified_call_in_body_f8c5a3b7", "target": "cpp20_class_dtor_member_destruction_order_a7e4c9d2"}, {"id": "e1608", "source": "cpp20_dcl_init_ref_reference_related_def_c8d9e0f1", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1609", "source": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1610", "source": "cpp20_expr_cast_base_to_derived_ref_f1c7d4a9", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1611", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1612", "source": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1613", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1614", "source": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1615", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1616", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1617", "source": "cpp20_expr_prim_id_base_class_splice_a7b1c2d3", "target": "cpp20_special_potentially_constructed_subobjects_cad8f4a7"}, {"id": "e1618", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1619", "source": "cpp20_expr_prim_overload_requires_unsatisfied_a1b5c7d8", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1620", "source": "cpp20_expr_pre_builtin_conversion_before_operation_a8d7c5b2", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1621", "source": "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1622", "source": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1623", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1624", "source": "cpp20_forward_rvalue_overload_returns_b5d9e3f7", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1625", "source": "cpp20_forward_lvalue_overload_returns_f2e8a1c4", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1626", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1627", "source": "cpp20_concept_same_subsumption_bidirectional_c2e9d5b3", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1628", "source": "cpp20_over_match_list_explicit_copy_list_init_f7a8b9c1", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1629", "source": "cpp20_over_match_oper_rewritten_eq_bool_return_d8e9f1a2", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1630", "source": "cpp20_over_call_func_contrived_object_nonstatic_e4f6a8b9", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1631", "source": "cpp20_over_call_func_postcondition_assertion_dtor_a1b3c5d7", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1632", "source": "cpp20_over_call_func_precondition_assertion_ctor_d9e7b4c2", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1633", "source": "cpp20_over_match_call_general_member_from_address_f2c8a3b1", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1634", "source": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a", "target": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d"}, {"id": "e1635", "source": "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1636", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1637", "source": "cpp20_expr_prim_overload_requires_unsatisfied_a1b5c7d8", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1638", "source": "cpp20_expr_pre_builtin_conversion_before_operation_a8d7c5b2", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1639", "source": "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1640", "source": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1641", "source": "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1642", "source": "cpp20_forward_rvalue_overload_returns_b5d9e3f7", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1643", "source": "cpp20_forward_lvalue_overload_returns_f2e8a1c4", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1644", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1645", "source": "cpp20_concept_same_subsumption_bidirectional_c2e9d5b3", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1646", "source": "cpp20_over_match_list_explicit_copy_list_init_f7a8b9c1", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1647", "source": "cpp20_over_match_oper_rewritten_eq_bool_return_d8e9f1a2", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1648", "source": "cpp20_over_call_func_contrived_object_nonstatic_e4f6a8b9", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1649", "source": "cpp20_over_call_func_postcondition_assertion_dtor_a1b3c5d7", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1650", "source": "cpp20_over_call_func_precondition_assertion_ctor_d9e7b4c2", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1651", "source": "cpp20_over_match_call_general_member_from_address_f2c8a3b1", "target": "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a"}, {"id": "e1652", "source": "cpp20_dcl_init_ref_user_conv_no_second_user_conv_8e9f0a1b", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1653", "source": "cpp20_dcl_init_ref_temp_materialization_prvalue_0w1x2y3z", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1654", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1655", "source": "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1656", "source": "cpp20_dcl_init_ref_lvalue_ref_conversion_bind_0c1d2e3f", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1657", "source": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1658", "source": "cpp20_expr_eq_array_to_pointer_conversion_h8d5f3a1", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1659", "source": "cpp20_expr_cast_static_const_ambiguous_illformed_a5c9d3e7", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1660", "source": "cpp20_expr_cast_unlisted_illformed_c3d7e2a5", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1661", "source": "cpp20_expr_prim_contract_var_const_lvalue_f0a4b6c7", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1662", "source": "cpp20_expr_context_discarded_temp_materialization_h4c7f0d3", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1663", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1664", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1665", "source": "cpp20_dcl_init_list_aggregate_narrowing_illformed_f4a5b6c7", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1666", "source": "cpp20_dcl_init_list_narrowing_ptr_to_bool_e3f4a5b6", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1667", "source": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1668", "source": "cpp20_dcl_init_list_narrowing_int_to_float_c1d2e3f4", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1669", "source": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1670", "source": "cpp20_dcl_init_list_narrowing_float_to_int_a9b0c1d2", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1671", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1672", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1673", "source": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1674", "source": "cpp20_dcl_init_list_enum_narrowing_conversion_b8c9d0e1", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1675", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1676", "source": "cpp20_temp_inst_narrowing_instantiation_error_b5c6d7e8", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1677", "source": "cpp20_over_match_conv_explicit_direct_init_only_b6c7d8e9", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1678", "source": "cpp20_over_match_conv_permissible_types_standard_conv_d2e3f4a5", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1679", "source": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1680", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1681", "source": "cpp20_over_match_oper_assignment_standard_conv_only_f4a5b6c7", "target": "cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9"}, {"id": "e1682", "source": "cpp20_over_match_oper_arrow_second_operand_ignored_d8e9f1a2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1683", "source": "cpp20_over_match_oper_rewritten_eq_bool_return_d8e9f1a2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1684", "source": "cpp20_over_match_oper_builtin_empty_comma_addr_arrow_b9c1d2e3", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1685", "source": "cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1686", "source": "cpp20_expr_eq_unequal_yields_false_f1a5d8c2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1687", "source": "cpp20_expr_eq_equal_yields_true_e7b3c1d9", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1688", "source": "cpp20_expr_delete_virtual_destructor_253c350a", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1689", "source": "cpp20_expr_sizeof_bitfield_58bfc23d", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1690", "source": "cpp20_expr_sizeof_incomplete_type_47aeb12c", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1691", "source": "cpp20_expr_sizeof_function_type_36fda01b", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1692", "source": "cpp20_expr_unary_op_bitwise_not_operand_14dbe8f9", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1693", "source": "cpp20_expr_unary_op_minus_operand_03cad7e8", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1694", "source": "cpp20_expr_unary_op_plus_operand_f2b9c6d7", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1695", "source": "cpp20_expr_unary_op_address_incomplete_class_e1a8b5c6", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1696", "source": "cpp20_expr_unary_op_address_bitfield_d0f7a4b5", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1697", "source": "cpp20_expr_unary_op_address_of_lvalue_c9e6f3a4", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1698", "source": "cpp20_expr_unary_op_indirection_operand_b8d4e5f2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1699", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1700", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1701", "source": "cpp20_expr_pre_builtin_conversion_before_operation_a8d7c5b2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1702", "source": "cpp20_expr_pre_overload_builtin_invariant_b2e4d519", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1703", "source": "cpp20_basic_stc_dynamic_dealloc_destroying_first_param_a7b8c9d0", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1704", "source": "cpp20_basic_stc_dynamic_dealloc_nonnull_first_param_c3d4e5f6", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1705", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1706", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1707", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1708", "source": "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1709", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1710", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1711", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1712", "source": "cpp20_expected_deref_precondition_a5b6c7d8", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1713", "source": "cpp20_expected_arrow_precondition_c1d2e3f4", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1714", "source": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1715", "source": "cpp20_container_opt_reqmts_threeway_precondition_b4c5d6e7", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1716", "source": "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1717", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1718", "source": "cpp20_shared_ptr_operator_subscript_hardened_bounds_7c8d9e0f", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1719", "source": "cpp20_shared_ptr_operator_subscript_hardened_nonneg_3e4f5a6b", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1720", "source": "cpp20_shared_ptr_operator_subscript_precondition_null_9a0b1c2d", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1721", "source": "cpp20_shared_ptr_operator_arrow_precondition_5c6d7e8f", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1722", "source": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1723", "source": "cpp20_over_oper_precedence_immutable_a7c3f8e2", "target": "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6"}, {"id": "e1724", "source": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "target": "cpp20_over_match_conv_permissible_types_standard_conv_d2e3f4a5"}, {"id": "e1725", "source": "cpp20_over_match_conv_explicit_direct_init_only_b6c7d8e9", "target": "cpp20_over_match_conv_permissible_types_standard_conv_d2e3f4a5"}, {"id": "e1726", "source": "cpp20_over_match_conv_permissible_types_standard_conv_d2e3f4a5", "target": "cpp20_over_match_conv_explicit_direct_init_only_b6c7d8e9"}, {"id": "e1727", "source": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "target": "cpp20_over_match_conv_explicit_direct_init_only_b6c7d8e9"}, {"id": "e1728", "source": "cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1729", "source": "cpp20_temp_inst_deleted_member_redefinition_error_c5d6e7f8", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1730", "source": "cpp20_temp_inst_friend_def_second_error_e1f2a3b4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1731", "source": "cpp20_temp_inst_incomplete_class_error_a7b8c9d0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1732", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1733", "source": "cpp20_expr_prim_qual_splice_specialization_class_e9f3a5b6", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1734", "source": "cpp20_expr_prim_qual_id_dtor_computed_type_a5b9c1d2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1735", "source": "cpp20_expr_prim_lambda_capture_shadows_param_f4a8b0c1", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1736", "source": "cpp20_basic_stc_dynamic_dealloc_template_not_usual_e1f2a3b4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1737", "source": "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1738", "source": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1739", "source": "cpp20_thread_condition_condvarany_lock_requirement_e7f8a9b0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1740", "source": "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1741", "source": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1742", "source": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1743", "source": "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1744", "source": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1745", "source": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1746", "source": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1747", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1748", "source": "cpp20_bad_expected_access_exception_purpose_c9d0e1f2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1749", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1750", "source": "cpp20_expected_error_type_constraint_c9d0e1f2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1751", "source": "cpp20_variant_no_args_illformed_a1b2c3d4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1752", "source": "cpp20_declval_incomplete_type_allowed_b5a9d4c1", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1753", "source": "cpp20_declval_odr_use_forbidden_7c8e3f2a", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1754", "source": "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1755", "source": "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1756", "source": "cpp20_weak_ptr_general_incomplete_type_allowed_a7c3f8e2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1757", "source": "cpp20_dcl_init_list_std_initializer_list_not_predefined_e8f7d6c5", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1758", "source": "cpp20_temp_inst_narrowing_instantiation_error_b5c6d7e8", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1759", "source": "cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1760", "source": "cpp20_temp_expl_spec_each_enclosing_template_prefix_c3d4e5f6", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1761", "source": "cpp20_temp_expl_spec_after_use_error_f9a0b1c2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1762", "source": "cpp20_temp_expl_spec_member_explicit_definition_required_e5f6a7b8", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1763", "source": "cpp20_temp_explicit_variable_unqualified_id_simple_template_id_c9d0e1f2", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1764", "source": "cpp20_temp_explicit_class_elaborated_type_specifier_e5f6a7b8", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1765", "source": "cpp20_temp_explicit_simple_template_id_variable_class_a1b2c3d4", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1766", "source": "cpp20_temp_inst_requires_invalid_expression_ndr_d7e8f9a0", "target": "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2"}, {"id": "e1767", "source": "cpp20_except_throw_destruction_exception_ptr_2b7d8a3f", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1768", "source": "cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1769", "source": "cpp20_except_throw_rethrow_same_object_7f3a2c8d", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1770", "source": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1771", "source": "cpp20_except_throw_control_transfer_nearest_handler_5a7c3d9e", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1772", "source": "cpp20_expr_new_invalid_size_throwing_e1f8f1c6", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1773", "source": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1774", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1775", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1776", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1777", "source": "cpp20_any_emplace_exception_state_b3c4d5e6", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1778", "source": "cpp20_format_precision_negative_throws_f3a4b5c6", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1779", "source": "cpp20_format_width_negative_throws_c9d0e1f2", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1780", "source": "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1781", "source": "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1782", "source": "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1783", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1784", "source": "cpp20_variant_emplace_valueless_w9x0y1z2", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1785", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1786", "source": "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1787", "source": "cpp20_container_reqmts_swap_nothrow_c9d0e1f2", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1788", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1789", "source": "cpp20_container_reqmts_push_exception_safety_f6a7b8c9", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1790", "source": "cpp20_container_reqmts_insert_single_exception_safety_e5f6a7b8", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1791", "source": "cpp20_make_shared_exception_safety_3a4b5c6d", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1792", "source": "cpp20_except_ctor_ref_member_temp_lifetime_e7adb8fc", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1793", "source": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1794", "source": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1795", "source": "cpp20_except_ctor_dtor_except_continue_a3c9d4b8", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1796", "source": "cpp20_except_ctor_subobj_destroy_reverse_order_e1a7b2f6", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1797", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1798", "source": "cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1799", "source": "cpp20_except_throw_active_handler_still_uncaught_if_rethrown_3b5c9d1a", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1800", "source": "cpp20_except_throw_caught_when_handler_active_6e2a8b7d", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1801", "source": "cpp20_except_throw_rethrow_uncaught_until_caught_9d4f3a2c", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1802", "source": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "target": "cpp20_except_throw_destruction_ordering_d5e1c7b9"}, {"id": "e1803", "source": "cpp20_except_throw_destruction_ordering_d5e1c7b9", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1804", "source": "cpp20_except_throw_destruction_exception_ptr_2b7d8a3f", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1805", "source": "cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1806", "source": "cpp20_except_throw_rethrow_same_object_7f3a2c8d", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1807", "source": "cpp20_except_throw_exception_object_dynamic_storage_8b2f4e1a", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1808", "source": "cpp20_except_throw_control_transfer_nearest_handler_5a7c3d9e", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1809", "source": "cpp20_expr_new_invalid_size_throwing_e1f8f1c6", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1810", "source": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1811", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1812", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1813", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1814", "source": "cpp20_any_emplace_exception_state_b3c4d5e6", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1815", "source": "cpp20_format_precision_negative_throws_f3a4b5c6", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1816", "source": "cpp20_format_width_negative_throws_c9d0e1f2", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1817", "source": "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1818", "source": "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1819", "source": "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1820", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1821", "source": "cpp20_variant_emplace_valueless_w9x0y1z2", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1822", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1823", "source": "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1824", "source": "cpp20_container_reqmts_swap_nothrow_c9d0e1f2", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1825", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1826", "source": "cpp20_container_reqmts_push_exception_safety_f6a7b8c9", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1827", "source": "cpp20_container_reqmts_insert_single_exception_safety_e5f6a7b8", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1828", "source": "cpp20_make_shared_exception_safety_3a4b5c6d", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1829", "source": "cpp20_except_ctor_ref_member_temp_lifetime_e7adb8fc", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1830", "source": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1831", "source": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1832", "source": "cpp20_except_ctor_dtor_except_continue_a3c9d4b8", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1833", "source": "cpp20_except_ctor_subobj_destroy_reverse_order_e1a7b2f6", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1834", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1835", "source": "cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1836", "source": "cpp20_except_throw_active_handler_still_uncaught_if_rethrown_3b5c9d1a", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1837", "source": "cpp20_except_throw_caught_when_handler_active_6e2a8b7d", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1838", "source": "cpp20_except_throw_rethrow_uncaught_until_caught_9d4f3a2c", "target": "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b"}, {"id": "e1839", "source": "cpp20_intro_progress_main_thread_impl_defined_b8c2d7e6", "target": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7"}, {"id": "e1840", "source": "cpp20_intro_progress_concurrent_guarantee_a7b1c6d5", "target": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7"}, {"id": "e1841", "source": "cpp20_intro_progress_delegation_unblock_a3b7c2d1", "target": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7"}, {"id": "e1842", "source": "cpp20_intro_progress_delegation_strengthening_f2a6b1c0", "target": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7"}, {"id": "e1843", "source": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9", "target": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7"}, {"id": "e1844", "source": "cpp20_intro_progress_weakly_parallel_no_guarantee_d0e4f9a8", "target": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7"}, {"id": "e1845", "source": "cpp20_intro_progress_weakly_parallel_no_guarantee_d0e4f9a8", "target": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9"}, {"id": "e1846", "source": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7", "target": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9"}, {"id": "e1847", "source": "cpp20_intro_progress_main_thread_impl_defined_b8c2d7e6", "target": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9"}, {"id": "e1848", "source": "cpp20_intro_progress_concurrent_guarantee_a7b1c6d5", "target": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9"}, {"id": "e1849", "source": "cpp20_intro_progress_delegation_unblock_a3b7c2d1", "target": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9"}, {"id": "e1850", "source": "cpp20_intro_progress_delegation_strengthening_f2a6b1c0", "target": "cpp20_intro_progress_guarantee_ordering_e1f5a0b9"}, {"id": "e1851", "source": "cpp20_intro_multithread_thread_object_access_d6e0f5a4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1852", "source": "cpp20_intro_multithread_freestanding_threads_impl_defined_c5d9e4f3", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1853", "source": "cpp20_intro_progress_delegation_unblock_a3b7c2d1", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1854", "source": "cpp20_intro_progress_delegation_strengthening_f2a6b1c0", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1855", "source": "cpp20_intro_progress_weakly_parallel_no_guarantee_d0e4f9a8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1856", "source": "cpp20_intro_progress_parallel_guarantee_c9d3e8f7", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1857", "source": "cpp20_intro_progress_main_thread_impl_defined_b8c2d7e6", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1858", "source": "cpp20_intro_progress_concurrent_guarantee_a7b1c6d5", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1859", "source": "cpp20_intro_progress_lockfree_single_thread_completion_e5f9a4b3", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1860", "source": "cpp20_intro_progress_thread_assumption_d4e8f3a2", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1861", "source": "cpp20_intro_multithread_signal_handler_thread_unspecified_a3f7b2c1", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1862", "source": "cpp20_expr_await_static_storage_8b9c9b50", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1863", "source": "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1864", "source": "cpp20_basic_stc_thread_distinct_per_thread_d5e6f7a8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1865", "source": "cpp20_basic_stc_thread_duration_f1a2b3c4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1866", "source": "cpp20_basic_stc_static_namespace_scope_b7c8d9e0", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1867", "source": "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1868", "source": "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1869", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1870", "source": "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1871", "source": "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1872", "source": "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1873", "source": "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1874", "source": "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1875", "source": "cpp20_thread_condition_condvarany_dtor_precond_no_blocked_c9d0e1f2", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1876", "source": "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1877", "source": "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1878", "source": "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1879", "source": "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1880", "source": "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1881", "source": "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1882", "source": "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1883", "source": "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1884", "source": "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1885", "source": "cpp20_thread_condition_condvar_dtor_precond_no_blocked_a1b2c3d4", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1886", "source": "cpp20_atomics_fences_signal_fence_scope_6d2b8e5c", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1887", "source": "cpp20_intro_races_compiler_no_spurious_write_i1g3h5j9", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1888", "source": "cpp20_intro_races_signal_handler_ordering_h0f2g4i8", "target": "cpp20_intro_races_object_value_visibility_a3b7c9e1"}, {"id": "e1889", "source": "cpp20_intro_progress_visibility_recommendation_b4c8d3e2", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1890", "source": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1891", "source": "cpp20_shared_ptr_use_count_no_synchronization_1a2b3c4d", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1892", "source": "cpp20_atomics_fences_thread_fence_seq_cst_effect_9c3e7f1a", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1893", "source": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1894", "source": "cpp20_atomics_fences_thread_fence_acquire_effect_8f2d6a3e", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1895", "source": "cpp20_atomics_fences_thread_fence_relaxed_no_effect_1e9a4c7b", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1896", "source": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1897", "source": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1898", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1899", "source": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1900", "source": "cpp20_intro_races_relaxed_not_sync_e7c9d1f5", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1901", "source": "cpp20_intro_races_fence_categories_d6b8c0e4", "target": "cpp20_intro_races_sync_op_categories_c5a7b9d3"}, {"id": "e1902", "source": "cpp20_intro_races_sync_op_categories_c5a7b9d3", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1903", "source": "cpp20_intro_progress_visibility_recommendation_b4c8d3e2", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1904", "source": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1905", "source": "cpp20_shared_ptr_use_count_no_synchronization_1a2b3c4d", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1906", "source": "cpp20_atomics_fences_thread_fence_relaxed_no_effect_1e9a4c7b", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1907", "source": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1908", "source": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1909", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1910", "source": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1911", "source": "cpp20_intro_races_relaxed_not_sync_e7c9d1f5", "target": "cpp20_intro_races_fence_categories_d6b8c0e4"}, {"id": "e1912", "source": "cpp20_intro_races_fence_categories_d6b8c0e4", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1913", "source": "cpp20_intro_races_sync_op_categories_c5a7b9d3", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1914", "source": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1915", "source": "cpp20_atomics_fences_thread_fence_seq_cst_effect_9c3e7f1a", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1916", "source": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1917", "source": "cpp20_atomics_fences_thread_fence_release_effect_4b7c9e2d", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1918", "source": "cpp20_atomics_fences_thread_fence_acquire_effect_8f2d6a3e", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1919", "source": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1920", "source": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1921", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6"}, {"id": "e1922", "source": "cpp20_intro_races_atomic_reorder_precluded_k3i5j7l1", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1923", "source": "cpp20_intro_races_visible_ambiguity_ub_g9e1f3h7", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1924", "source": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1925", "source": "cpp20_intro_races_relaxed_not_sync_e7c9d1f5", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1926", "source": "cpp20_intro_progress_visibility_recommendation_b4c8d3e2", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1927", "source": "cpp20_intro_progress_thread_assumption_d4e8f3a2", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1928", "source": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1929", "source": "cpp20_thread_condition_atomic_notify_c9d0e1f2", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1930", "source": "cpp20_shared_ptr_enable_shared_from_this_concurrency_3a4b5c6d", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1931", "source": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1932", "source": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1933", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_atomics_order_timely_visibility_2f8a3b4c"}, {"id": "e1934", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1935", "source": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1936", "source": "cpp20_intro_races_fence_categories_d6b8c0e4", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1937", "source": "cpp20_intro_races_sync_op_categories_c5a7b9d3", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1938", "source": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1939", "source": "cpp20_atomics_fences_signal_fence_no_hw_fence_a4f2c9d7", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1940", "source": "cpp20_atomics_fences_thread_fence_seq_cst_effect_9c3e7f1a", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1941", "source": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1942", "source": "cpp20_atomics_fences_thread_fence_release_effect_4b7c9e2d", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1943", "source": "cpp20_atomics_fences_thread_fence_acquire_effect_8f2d6a3e", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1944", "source": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "target": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f"}, {"id": "e1945", "source": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1946", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1947", "source": "cpp20_atomics_order_timely_visibility_2f8a3b4c", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1948", "source": "cpp20_intro_races_atomic_reorder_precluded_k3i5j7l1", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1949", "source": "cpp20_intro_races_visible_ambiguity_ub_g9e1f3h7", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1950", "source": "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1951", "source": "cpp20_intro_races_relaxed_not_sync_e7c9d1f5", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1952", "source": "cpp20_intro_progress_visibility_recommendation_b4c8d3e2", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1953", "source": "cpp20_intro_progress_thread_assumption_d4e8f3a2", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1954", "source": "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1955", "source": "cpp20_thread_condition_atomic_notify_c9d0e1f2", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1956", "source": "cpp20_shared_ptr_enable_shared_from_this_concurrency_3a4b5c6d", "target": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1"}, {"id": "e1957", "source": "cpp20_atomics_fences_thread_fence_release_effect_4b7c9e2d", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1958", "source": "cpp20_atomics_fences_thread_fence_acquire_effect_8f2d6a3e", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1959", "source": "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1960", "source": "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1961", "source": "cpp20_atomics_fences_release_acquire_sync_2a8f1b3c", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1962", "source": "cpp20_intro_races_fence_categories_d6b8c0e4", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1963", "source": "cpp20_atomics_fences_signal_fence_no_hw_fence_a4f2c9d7", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1964", "source": "cpp20_atomics_fences_thread_fence_seq_cst_effect_9c3e7f1a", "target": "cpp20_atomics_fences_thread_fence_acq_rel_effect_5a1d8b4f"}, {"id": "e1965", "source": "cpp20_range_formatter_constraint_same_as_c3d4e5f6", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1966", "source": "cpp20_range_common_range_same_iterator_sentinel_e5f6a7b8", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1967", "source": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1968", "source": "cpp20_concept_same_symmetric_f1b2a3c4", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1969", "source": "cpp20_concept_same_reflexive_e8a4c7d9", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1970", "source": "cpp20_concept_same_subsumption_bidirectional_c2e9d5b3", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1971", "source": "cpp20_concept_same_is_same_v_equivalence_d4b8f6a1", "target": "cpp20_concept_same_definition_symmetric_a7c3e1f2"}, {"id": "e1972", "source": "cpp20_concept_same_definition_symmetric_a7c3e1f2", "target": "cpp20_concept_same_reflexive_e8a4c7d9"}, {"id": "e1973", "source": "cpp20_range_common_range_same_iterator_sentinel_e5f6a7b8", "target": "cpp20_concept_same_reflexive_e8a4c7d9"}, {"id": "e1974", "source": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "target": "cpp20_concept_same_reflexive_e8a4c7d9"}, {"id": "e1975", "source": "cpp20_range_view_O1_copy_construction_k3l4m5n6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1976", "source": "cpp20_except_ctor_delegating_destroy_before_handler_d6fca7eb", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1977", "source": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1978", "source": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1979", "source": "cpp20_except_ctor_subobj_destroy_reverse_order_e1a7b2f6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1980", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1981", "source": "cpp20_except_ctor_auto_destroy_condition_b8d4e9c3", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1982", "source": "cpp20_except_ctor_auto_storage_destroy_order_a7c3f8b2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1983", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1984", "source": "cpp20_over_match_list_explicit_copy_list_init_f7a8b9c1", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1985", "source": "cpp20_over_match_ctor_explicit_default_init_copy_list_b3c4d5e6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1986", "source": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1987", "source": "cpp20_over_call_func_precondition_assertion_ctor_d9e7b4c2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1988", "source": "cpp20_special_potentially_constructed_subobjects_cad8f4a7", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1989", "source": "cpp20_special_same_kind_copy_move_ctor_d5e3a9b2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1990", "source": "cpp20_special_same_kind_default_ctor_c4d2f8a1", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1991", "source": "cpp20_special_member_function_kinds_e7b4a9c2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1992", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1993", "source": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1994", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1995", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1996", "source": "cpp20_any_default_ctor_postcondition_no_value_d1e2f3a4", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1997", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1998", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e1999", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2000", "source": "cpp20_any_emplace_exception_state_b3c4d5e6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2001", "source": "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2002", "source": "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2003", "source": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2004", "source": "cpp20_basic_format_string_consteval_invalid_b5c6d7e8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2005", "source": "cpp20_range_viewable_range_view_constructible_e3f4a5b6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2006", "source": "cpp20_range_view_copy_assignment_complexity_o7p8q9r0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2007", "source": "cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2008", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2009", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2010", "source": "cpp20_weak_ptr_default_ctor_empty_postcondition_c8e5a2d9", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2011", "source": "cpp20_weak_ptr_copy_ctor_constraint_compatible_d3f7b1a6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2012", "source": "cpp20_weak_ptr_copy_ctor_shared_ptr_constraint_e4a8c2b7", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2013", "source": "cpp20_weak_ptr_copy_ctor_postcondition_use_count_f5b9d3c8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2014", "source": "cpp20_weak_ptr_move_ctor_constraint_compatible_a6c0e4d9", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2015", "source": "cpp20_weak_ptr_move_ctor_postcondition_b7d1f5e0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2016", "source": "cpp20_shared_ptr_ctor_pointer_mandates_complete_7e8f9a0b", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2017", "source": "cpp20_shared_ptr_ctor_deleter_precondition_move_5a6b7c8d", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2018", "source": "cpp20_shared_ptr_ctor_allocator_precondition_3c4d5e6f", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2019", "source": "cpp20_shared_ptr_ctor_weak_ptr_throws_bad_weak_ptr_7a8b9c0d", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2020", "source": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2021", "source": "cpp20_shared_ptr_aliasing_ctor_dangling_pointer_3e4f5a6b", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2022", "source": "cpp20_shared_ptr_ctor_deleter_constraints_5e6f7a8b", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2023", "source": "cpp20_shared_ptr_ctor_compatible_pointer_constraint_9c0d1e2f", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2024", "source": "cpp20_shared_ptr_ctor_weak_ptr_compatible_constraint_3a4b5c6d", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2025", "source": "cpp20_shared_ptr_ctor_unique_ptr_constraints_7e8f9a0b", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2026", "source": "cpp20_container_reqmts_copy_ctor_precondition_b2c3d4e5", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2027", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2028", "source": "cpp20_container_alloc_reqmts_default_ctor_precondition_f2a3b4c5", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2029", "source": "cpp20_container_alloc_reqmts_copy_ctor_alloc_precondition_a3b4c5d6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2030", "source": "cpp20_container_alloc_reqmts_move_ctor_alloc_precondition_b4c5d6e7", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2031", "source": "cpp20_sequence_reqmts_n_copies_precondition_a9b0c1d2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2032", "source": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2033", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2034", "source": "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2035", "source": "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2036", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2037", "source": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2038", "source": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2039", "source": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2040", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2041", "source": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2042", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2043", "source": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2044", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2045", "source": "cpp20_expected_value_or_mandates_e3f4a5b6", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2046", "source": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2047", "source": "cpp20_expected_error_or_mandates_a1b2c3d4", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2048", "source": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2049", "source": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2050", "source": "cpp20_range_view_O1_move_construction_e1f2a3b4", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2051", "source": "cpp20_range_view_move_assignment_complexity_c5d6e7f8", "target": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8"}, {"id": "e2052", "source": "cpp20_dcl_init_list_narrowing_float_to_int_a9b0c1d2", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2053", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2054", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2055", "source": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2056", "source": "cpp20_dcl_init_list_enum_narrowing_conversion_b8c9d0e1", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2057", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2058", "source": "cpp20_temp_inst_narrowing_instantiation_error_b5c6d7e8", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2059", "source": "cpp20_dcl_init_list_aggregate_narrowing_illformed_f4a5b6c7", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2060", "source": "cpp20_dcl_init_list_narrowing_ptr_to_bool_e3f4a5b6", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2061", "source": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2062", "source": "cpp20_dcl_init_list_narrowing_int_to_float_c1d2e3f4", "target": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3"}, {"id": "e2063", "source": "cpp20_dcl_init_list_narrowing_int_to_float_c1d2e3f4", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2064", "source": "cpp20_dcl_init_list_narrowing_float_to_lower_rank_b0c1d2e3", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2065", "source": "cpp20_dcl_init_list_narrowing_float_to_int_a9b0c1d2", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2066", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2067", "source": "cpp20_dcl_init_list_ref_narrowing_conversion_e1f2a3b4", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2068", "source": "cpp20_dcl_init_list_single_element_narrowing_f9a0b1c2", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2069", "source": "cpp20_dcl_init_list_enum_narrowing_conversion_b8c9d0e1", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2070", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2071", "source": "cpp20_temp_inst_narrowing_instantiation_error_b5c6d7e8", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2072", "source": "cpp20_dcl_init_list_aggregate_narrowing_illformed_f4a5b6c7", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2073", "source": "cpp20_dcl_init_list_narrowing_ptr_to_bool_e3f4a5b6", "target": "cpp20_dcl_init_list_narrowing_int_to_smaller_int_d2e3f4a5"}, {"id": "e2074", "source": "cpp20_special_same_kind_copy_move_assign_e6f4b0c3", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2075", "source": "cpp20_special_member_function_kinds_e7b4a9c2", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2076", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2077", "source": "cpp20_range_view_move_assignment_complexity_c5d6e7f8", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2078", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2079", "source": "cpp20_container_node_move_assign_precondition_d6e7f8a9", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2080", "source": "cpp20_container_alloc_reqmts_move_assign_precondition_d6e7f8a9", "target": "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3"}, {"id": "e2081", "source": "cpp20_expr_delete_array_valid_pointer_142b24f9", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2082", "source": "cpp20_weak_ptr_destructor_no_effect_on_object_c8e2a6f1", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2083", "source": "cpp20_weak_ptr_move_ctor_postcondition_b7d1f5e0", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2084", "source": "cpp20_weak_ptr_default_ctor_empty_postcondition_c8e5a2d9", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2085", "source": "cpp20_dcl_init_list_narrowing_ptr_to_bool_e3f4a5b6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2086", "source": "cpp20_over_call_object_surrogate_non_explicit_only_f4a5b6c7", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2087", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2088", "source": "cpp20_dcl_init_ref_reference_compatible_def_2a3b4c5d", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2089", "source": "cpp20_expr_eq_array_to_pointer_conversion_h8d5f3a1", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2090", "source": "cpp20_expr_eq_lvalue_to_rvalue_conversion_g4c2e9f7", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2091", "source": "cpp20_expr_cast_ambiguous_base_illformed_e2c8f1a6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2092", "source": "cpp20_expr_cast_incomplete_class_ptr_dest_c6e9d2a3", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2093", "source": "cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2094", "source": "cpp20_expr_cast_base_to_derived_ptrmem_a8d5e3b2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2095", "source": "cpp20_expr_cast_base_to_derived_ptr_e4b8c2d6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2096", "source": "cpp20_expr_cast_inaccessible_base_ptrmem_c9a3f5e2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2097", "source": "cpp20_expr_cast_inaccessible_base_derived_ptr_b7f4a2c8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2098", "source": "cpp20_shared_ptr_ctor_pointer_mandates_complete_7e8f9a0b", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2099", "source": "cpp20_shared_ptr_ctor_pointer_precondition_delete_c1d2e3f4", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2100", "source": "cpp20_shared_ptr_ctor_deleter_precondition_move_5a6b7c8d", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2101", "source": "cpp20_shared_ptr_ctor_deleter_precondition_wellformed_9e0f1a2b", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2102", "source": "cpp20_shared_ptr_ctor_allocator_precondition_3c4d5e6f", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2103", "source": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2104", "source": "cpp20_shared_ptr_operator_arrow_precondition_5c6d7e8f", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2105", "source": "cpp20_get_deleter_validity_lifetime_9a0b1c2d", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2106", "source": "cpp20_shared_ptr_aliasing_ctor_dangling_pointer_3e4f5a6b", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2107", "source": "cpp20_shared_ptr_ctor_constraints_array_type_7c8d9e0f", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2108", "source": "cpp20_shared_ptr_ctor_constraints_non_array_type_1a2b3c4d", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2109", "source": "cpp20_shared_ptr_ctor_deleter_constraints_5e6f7a8b", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2110", "source": "cpp20_shared_ptr_ctor_unique_ptr_constraints_7e8f9a0b", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2111", "source": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2112", "source": "cpp20_variant_get_if_mandates_index_s7t8u9v0", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2113", "source": "cpp20_variant_get_if_type_mandates_unique_w1x2y3z4", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2114", "source": "cpp20_expected_arrow_precondition_c1d2e3f4", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2115", "source": "cpp20_expected_deref_precondition_a5b6c7d8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2116", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2117", "source": "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2118", "source": "cpp20_range_access_data_returns_pointer_to_object_d1e4f8a2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2119", "source": "cpp20_range_access_cdata_returns_pointer_to_const_object_e2f5a9b3", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2120", "source": "cpp20_format_zero_option_constraint_e5f6a7b8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2121", "source": "cpp20_any_cast_pointer_mandates_not_void_d5e6f7a8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2122", "source": "cpp20_any_cast_pointer_returns_nullptr_type_mismatch_b9c0d1e2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2123", "source": "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2124", "source": "cpp20_basic_life_ptr_void_star_well_defined_3b4c5d6e", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2125", "source": "cpp20_basic_life_indirection_limited_use_7f8a9b0c", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2126", "source": "cpp20_basic_life_ptr_auto_refers_new_obj_8c9d0e1f", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2127", "source": "cpp20_basic_life_launder_required_6c7d8e9f", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2128", "source": "cpp20_basic_stc_dynamic_dealloc_stdlib_null_no_effect_b5c6d7e8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2129", "source": "cpp20_basic_stc_dynamic_dealloc_stdlib_shall_deallocate_f9a0b1c2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2130", "source": "cpp20_basic_stc_dynamic_alloc_disjoint_storage_c3d4e5f6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2131", "source": "cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2132", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2133", "source": "cpp20_expr_context_discarded_no_arr_func_conv_f2a5d8b1", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2134", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2135", "source": "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2136", "source": "cpp20_expr_type_composite_ptr_one_null_k7f0i3g6", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2137", "source": "cpp20_expr_type_composite_ptr_void_l8g1j4h7", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2138", "source": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2139", "source": "cpp20_expr_type_composite_ptr_ref_related_n0i3l6j9", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2140", "source": "cpp20_expr_type_composite_ptr_similar_o1j4m7k0", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2141", "source": "cpp20_expr_prim_id_nonstatic_member_usage_d6e0f5a7", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2142", "source": "cpp20_expr_unary_op_indirection_ub_a7c3f2d1", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2143", "source": "cpp20_expr_unary_op_indirection_operand_b8d4e5f2", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2144", "source": "cpp20_expr_unary_op_plus_operand_f2b9c6d7", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2145", "source": "cpp20_expr_new_invalid_size_nothrow_null_d0e7e0b5", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2146", "source": "cpp20_expr_delete_single_valid_pointer_031a13e8", "target": "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2"}, {"id": "e2147", "source": "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6", "target": "cpp20_const_pointer_cast_mandates_7a8b9c0d"}, {"id": "e2148", "source": "cpp20_any_cast_pointer_mandates_not_void_d5e6f7a8", "target": "cpp20_const_pointer_cast_mandates_7a8b9c0d"}, {"id": "e2149", "source": "cpp20_range_access_cdata_returns_pointer_to_const_object_e2f5a9b3", "target": "cpp20_const_pointer_cast_mandates_7a8b9c0d"}, {"id": "e2150", "source": "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2", "target": "cpp20_const_pointer_cast_mandates_7a8b9c0d"}, {"id": "e2151", "source": "cpp20_expected_arrow_precondition_c1d2e3f4", "target": "cpp20_const_pointer_cast_mandates_7a8b9c0d"}, {"id": "e2152", "source": "cpp20_container_node_get_allocator_precondition_b0c1d2e3", "target": "cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4"}, {"id": "e2153", "source": "cpp20_intro_races_no_adjacent_member_overwrite_j2h4i6k0", "target": "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0"}, {"id": "e2154", "source": "cpp20_intro_races_compiler_no_spurious_write_i1g3h5j9", "target": "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0"}, {"id": "e2155", "source": "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1", "target": "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0"}, {"id": "e2156", "source": "cpp20_utility_swap_noexcept_spec_g8h2i6j0", "target": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"}, {"id": "e2157", "source": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "target": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"}, {"id": "e2158", "source": "cpp20_any_reset_noexcept_b7c8d9e0", "target": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"}, {"id": "e2159", "source": "cpp20_any_swap_noexcept_d3e4f5a6", "target": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"}, {"id": "e2160", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"}, {"id": "e2161", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"}, {"id": "e2162", "source": "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4", "target": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0"}, {"id": "e2163", "source": "cpp20_variant_bad_variant_access_u1v2w3x4", "target": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0"}, {"id": "e2164", "source": "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8", "target": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0"}, {"id": "e2165", "source": "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8", "target": "cpp20_variant_bad_variant_access_u1v2w3x4"}, {"id": "e2166", "source": "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0", "target": "cpp20_variant_bad_variant_access_u1v2w3x4"}, {"id": "e2167", "source": "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4", "target": "cpp20_variant_bad_variant_access_u1v2w3x4"}, {"id": "e2168", "source": "cpp20_reinterpret_pointer_cast_mandates_1e2f3a4b", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2169", "source": "cpp20_const_pointer_cast_mandates_7a8b9c0d", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2170", "source": "cpp20_dynamic_pointer_cast_mandates_3c4d5e6f", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2171", "source": "cpp20_static_pointer_cast_mandates_9e0f1a2b", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2172", "source": "cpp20_make_shared_postcondition_non_null_7e8f9a0b", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2173", "source": "cpp20_shared_ptr_operator_subscript_precondition_null_9a0b1c2d", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2174", "source": "cpp20_shared_ptr_operator_arrow_precondition_5c6d7e8f", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2175", "source": "cpp20_shared_ptr_operator_deref_precondition_1e2f3a4b", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2176", "source": "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2177", "source": "cpp20_any_cast_pointer_returns_nullptr_type_mismatch_b9c0d1e2", "target": "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"}, {"id": "e2178", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0"}, {"id": "e2179", "source": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "target": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0"}, {"id": "e2180", "source": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "target": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0"}, {"id": "e2181", "source": "cpp20_container_alloc_reqmts_copy_assign_precondition_c5d6e7f8", "target": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"}, {"id": "e2182", "source": "cpp20_weak_ptr_assignment_copy_effect_b9d3f7e2", "target": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"}, {"id": "e2183", "source": "cpp20_special_member_function_kinds_e7b4a9c2", "target": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"}, {"id": "e2184", "source": "cpp20_range_view_copy_assignment_complexity_o7p8q9r0", "target": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"}, {"id": "e2185", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"}, {"id": "e2186", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"}, {"id": "e2187", "source": "cpp20_unexpected_swap_mandates_e5f6a7b8", "target": "cpp20_expected_unexpected_illformed_type_a1b2c3d4"}, {"id": "e2188", "source": "cpp20_container_node_value_precondition_e7f8a9b0", "target": "cpp20_expected_value_type_constraint_e5f6a7b8"}, {"id": "e2189", "source": "cpp20_unexpected_swap_mandates_e5f6a7b8", "target": "cpp20_expected_error_type_constraint_c9d0e1f2"}, {"id": "e2190", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2191", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2192", "source": "cpp20_move_returns_rvalue_ref_e4b6d2a8", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2193", "source": "cpp20_forward_rvalue_overload_mandates_a3b7c9d1", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2194", "source": "cpp20_over_match_funcs_implicit_object_param_rvalue_ref_f1a2b3c4", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2195", "source": "cpp20_dcl_init_ref_rvalue_conversion_bind_6s7t8u9v", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2196", "source": "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2197", "source": "cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2198", "source": "cpp20_expr_eq_lvalue_to_rvalue_conversion_g4c2e9f7", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2199", "source": "cpp20_expr_cast_inaccessible_base_derived_ref_d2e6b1a4", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2200", "source": "cpp20_expr_cast_xvalue_result_b2f5c8d9", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2201", "source": "cpp20_expr_cast_lvalue_result_d4e8a1c3", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2202", "source": "cpp20_expr_context_discarded_volatile_lval_conv_g3b6e9c2", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2203", "source": "cpp20_basic_lval_temp_materialization_b4e9f1c5", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2204", "source": "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2205", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2206", "source": "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2207", "source": "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2208", "source": "cpp20_range_access_data_rvalue_non_borrowed_illformed_d9e2f6a0", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2209", "source": "cpp20_range_access_crend_rvalue_non_borrowed_illformed_f5a8b2c6", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2210", "source": "cpp20_range_access_crbegin_rvalue_non_borrowed_illformed_e4f7a1b5", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2211", "source": "cpp20_range_access_rend_rvalue_non_borrowed_illformed_c2d5e9f3", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2212", "source": "cpp20_range_access_rbegin_rvalue_non_borrowed_illformed_a0b3c7d1", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2213", "source": "cpp20_range_access_cend_rvalue_non_borrowed_illformed_f9a2b6c0", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2214", "source": "cpp20_range_access_cbegin_rvalue_non_borrowed_illformed_e8f1a5b9", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2215", "source": "cpp20_range_access_end_rvalue_non_borrowed_illformed_b4c8d2e6", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2216", "source": "cpp20_range_access_begin_rvalue_non_borrowed_illformed_a3b7c1d9", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2217", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2218", "source": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2219", "source": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "target": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"}, {"id": "e2220", "source": "cpp20_expected_void_value_throws_bad_access_a5b6c7d8", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2221", "source": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2222", "source": "cpp20_expected_void_error_precondition_e7f8a9b0", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2223", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2224", "source": "cpp20_expected_transform_mandates_c7d8e9f0", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2225", "source": "cpp20_expected_or_else_mandates_e3f4a5b6", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2226", "source": "cpp20_expected_and_then_mandates_a9b0c1d2", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2227", "source": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2228", "source": "cpp20_expected_error_precondition_e1f2a3b4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2229", "source": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2230", "source": "cpp20_expected_value_throws_bad_access_c3d4e5f6", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2231", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2232", "source": "cpp20_expected_deref_precondition_a5b6c7d8", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2233", "source": "cpp20_expected_arrow_precondition_c1d2e3f4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2234", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2235", "source": "cpp20_expected_void_transform_mandates_c1d2e3f4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2236", "source": "cpp20_expected_void_or_else_mandates_e7f8a9b0", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2237", "source": "cpp20_expected_void_and_then_mandates_a3b4c5d6", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2238", "source": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2239", "source": "cpp20_expected_error_or_mandates_a1b2c3d4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2240", "source": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2241", "source": "cpp20_expected_value_or_mandates_e3f4a5b6", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2242", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2243", "source": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2244", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2245", "source": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2246", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_expected_copy_ctor_deleted_e9f0a1b2"}, {"id": "e2247", "source": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2248", "source": "cpp20_expected_void_value_throws_bad_access_a5b6c7d8", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2249", "source": "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2250", "source": "cpp20_expected_void_error_precondition_e7f8a9b0", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2251", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2252", "source": "cpp20_expected_transform_mandates_c7d8e9f0", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2253", "source": "cpp20_expected_or_else_mandates_e3f4a5b6", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2254", "source": "cpp20_expected_and_then_mandates_a9b0c1d2", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2255", "source": "cpp20_expected_error_rvalue_precondition_c5d6e7f8", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2256", "source": "cpp20_expected_error_precondition_e1f2a3b4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2257", "source": "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2258", "source": "cpp20_expected_value_throws_bad_access_c3d4e5f6", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2259", "source": "cpp20_expected_deref_rvalue_precondition_e9f0a1b2", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2260", "source": "cpp20_expected_deref_precondition_a5b6c7d8", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2261", "source": "cpp20_expected_arrow_precondition_c1d2e3f4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2262", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2263", "source": "cpp20_expected_void_transform_mandates_c1d2e3f4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2264", "source": "cpp20_expected_void_or_else_mandates_e7f8a9b0", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2265", "source": "cpp20_expected_void_and_then_mandates_a3b4c5d6", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2266", "source": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2267", "source": "cpp20_expected_error_or_mandates_a1b2c3d4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2268", "source": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2269", "source": "cpp20_expected_value_or_mandates_e3f4a5b6", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2270", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2271", "source": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2272", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2273", "source": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0", "target": "cpp20_expected_copy_assign_deleted_c3d4e5f6"}, {"id": "e2274", "source": "cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2275", "source": "cpp20_expected_copy_assign_deleted_c3d4e5f6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2276", "source": "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2277", "source": "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2278", "source": "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2279", "source": "cpp20_variant_move_assign_exception_valueless_y7z8a9b0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2280", "source": "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2281", "source": "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2282", "source": "cpp20_move_if_noexcept_conditional_f9c5a1b3", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2283", "source": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2284", "source": "cpp20_sequence_reqmts_n_copies_precondition_a9b0c1d2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2285", "source": "cpp20_container_alloc_reqmts_move_ctor_alloc_precondition_b4c5d6e7", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2286", "source": "cpp20_container_alloc_reqmts_copy_ctor_alloc_precondition_a3b4c5d6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2287", "source": "cpp20_container_alloc_reqmts_default_ctor_precondition_f2a3b4c5", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2288", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2289", "source": "cpp20_container_reqmts_copy_ctor_precondition_b2c3d4e5", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2290", "source": "cpp20_shared_ptr_ctor_unique_ptr_constraints_7e8f9a0b", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2291", "source": "cpp20_shared_ptr_ctor_weak_ptr_compatible_constraint_3a4b5c6d", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2292", "source": "cpp20_shared_ptr_ctor_compatible_pointer_constraint_9c0d1e2f", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2293", "source": "cpp20_shared_ptr_ctor_deleter_constraints_5e6f7a8b", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2294", "source": "cpp20_shared_ptr_aliasing_ctor_dangling_pointer_3e4f5a6b", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2295", "source": "cpp20_make_shared_array_reverse_destruction_1c2d3e4f", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2296", "source": "cpp20_shared_ptr_ctor_weak_ptr_throws_bad_weak_ptr_7a8b9c0d", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2297", "source": "cpp20_shared_ptr_ctor_allocator_precondition_3c4d5e6f", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2298", "source": "cpp20_shared_ptr_ctor_deleter_precondition_move_5a6b7c8d", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2299", "source": "cpp20_shared_ptr_ctor_pointer_mandates_complete_7e8f9a0b", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2300", "source": "cpp20_weak_ptr_move_ctor_postcondition_b7d1f5e0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2301", "source": "cpp20_weak_ptr_move_ctor_constraint_compatible_a6c0e4d9", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2302", "source": "cpp20_weak_ptr_copy_ctor_postcondition_use_count_f5b9d3c8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2303", "source": "cpp20_weak_ptr_copy_ctor_shared_ptr_constraint_e4a8c2b7", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2304", "source": "cpp20_weak_ptr_copy_ctor_constraint_compatible_d3f7b1a6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2305", "source": "cpp20_weak_ptr_default_ctor_empty_postcondition_c8e5a2d9", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2306", "source": "cpp20_dcl_init_list_ctor_initializer_dangling_ref_f8a9b0c1", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2307", "source": "cpp20_dcl_init_list_backing_array_narrowing_d6e7f8a9", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2308", "source": "cpp20_expected_void_copy_assign_deleted_e1f2a3b4", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2309", "source": "cpp20_expected_value_mandates_copy_e_c5d6e7f8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2310", "source": "cpp20_expected_value_rvalue_mandates_a9b0c1d2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2311", "source": "cpp20_expected_value_or_mandates_e3f4a5b6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2312", "source": "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2313", "source": "cpp20_expected_error_or_mandates_a1b2c3d4", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2314", "source": "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2315", "source": "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2316", "source": "cpp20_range_view_O1_move_construction_e1f2a3b4", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2317", "source": "cpp20_range_view_move_assignment_complexity_c5d6e7f8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2318", "source": "cpp20_range_view_O1_copy_construction_k3l4m5n6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2319", "source": "cpp20_range_view_copy_assignment_complexity_o7p8q9r0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2320", "source": "cpp20_range_viewable_range_view_constructible_e3f4a5b6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2321", "source": "cpp20_basic_format_string_consteval_invalid_b5c6d7e8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2322", "source": "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2323", "source": "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2324", "source": "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2325", "source": "cpp20_any_emplace_exception_state_b3c4d5e6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2326", "source": "cpp20_any_emplace_initlist_exception_state_f7a8b9c0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2327", "source": "cpp20_any_copy_assignment_exception_safety_b3c4d5e6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2328", "source": "cpp20_any_template_assignment_exception_safety_f7a8b9c0", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2329", "source": "cpp20_any_default_ctor_postcondition_no_value_d1e2f3a4", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2330", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2331", "source": "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2332", "source": "cpp20_expr_prim_id_transform_precond_ctor_c5d9e3f4", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2333", "source": "cpp20_class_dtor_deleted_union_ctor_trivial_e2c7a4f9", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2334", "source": "cpp20_special_member_function_kinds_e7b4a9c2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2335", "source": "cpp20_special_same_kind_default_ctor_c4d2f8a1", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2336", "source": "cpp20_special_same_kind_copy_move_ctor_d5e3a9b2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2337", "source": "cpp20_special_potentially_constructed_subobjects_cad8f4a7", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2338", "source": "cpp20_over_call_func_precondition_assertion_ctor_d9e7b4c2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2339", "source": "cpp20_over_match_funcs_general_inherited_ctor_exclusion_8a2b4c6d", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2340", "source": "cpp20_over_match_ctor_explicit_default_init_copy_list_b3c4d5e6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2341", "source": "cpp20_over_match_list_explicit_copy_list_init_f7a8b9c1", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2342", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2343", "source": "cpp20_except_ctor_auto_storage_destroy_order_a7c3f8b2", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2344", "source": "cpp20_except_ctor_auto_destroy_condition_b8d4e9c3", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2345", "source": "cpp20_except_ctor_init_except_subobj_destroy_d0f6a1e5", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2346", "source": "cpp20_except_ctor_subobj_destroy_reverse_order_e1a7b2f6", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2347", "source": "cpp20_except_ctor_destroy_before_handler_b4dae5c9", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2348", "source": "cpp20_except_ctor_delegating_dtor_invoke_c5ebf6da", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2349", "source": "cpp20_except_ctor_delegating_destroy_before_handler_d6fca7eb", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2350", "source": "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "target": "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"}, {"id": "e2351", "source": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2352", "source": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2353", "source": "cpp20_container_reqmts_swap_no_invalidate_d0e1f2a3", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2354", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2355", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2356", "source": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2357", "source": "cpp20_range_sized_non_forward_size_w3x4y5z6", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2358", "source": "cpp20_range_approximately_sized_non_forward_reserve_hint_k1l2m3n4", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2359", "source": "cpp20_range_range_begin_end_denotes_range_a3b4c5d6", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2360", "source": "cpp20_range_access_size_fallback_sized_sentinel_e8f1a5b9", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2361", "source": "cpp20_range_access_crbegin_models_constant_iterator_f7a0b4c8", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2362", "source": "cpp20_range_access_cbegin_models_constant_iterator_c4d7e1f5", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2363", "source": "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2364", "source": "cpp20_algorithms_requirements_integer_like_difference_type_cast_s9t0u1v2", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2365", "source": "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2366", "source": "cpp20_algorithms_requirements_binarypredicate_wellformed_o3p4q5r6", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2367", "source": "cpp20_algorithms_requirements_predicate_wellformed_c1d2e3f4", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2368", "source": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2369", "source": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2370", "source": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2371", "source": "cpp20_algorithms_requirements_mutable_iterator_required_e5f2a8b4", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2372", "source": "cpp20_algorithms_requirements_no_data_race_modify_a3b7c9d1", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2373", "source": "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2374", "source": "cpp20_iterator_operations_prev_effect_d6a0b3c8", "target": "cpp20_iterator_operations_next_effect_c5f9a2b7"}, {"id": "e2375", "source": "cpp20_iterator_operations_next_effect_c5f9a2b7", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2376", "source": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2377", "source": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2378", "source": "cpp20_container_reqmts_swap_no_invalidate_d0e1f2a3", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2379", "source": "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2380", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2381", "source": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2382", "source": "cpp20_range_sized_non_forward_size_w3x4y5z6", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2383", "source": "cpp20_range_approximately_sized_non_forward_reserve_hint_k1l2m3n4", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2384", "source": "cpp20_range_range_begin_end_denotes_range_a3b4c5d6", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2385", "source": "cpp20_range_access_size_fallback_sized_sentinel_e8f1a5b9", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2386", "source": "cpp20_range_access_crbegin_models_constant_iterator_f7a0b4c8", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2387", "source": "cpp20_range_access_cbegin_models_constant_iterator_c4d7e1f5", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2388", "source": "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2389", "source": "cpp20_algorithms_requirements_integer_like_difference_type_cast_s9t0u1v2", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2390", "source": "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2391", "source": "cpp20_algorithms_requirements_binarypredicate_wellformed_o3p4q5r6", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2392", "source": "cpp20_algorithms_requirements_predicate_wellformed_c1d2e3f4", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2393", "source": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2394", "source": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2395", "source": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2396", "source": "cpp20_algorithms_requirements_mutable_iterator_required_e5f2a8b4", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2397", "source": "cpp20_algorithms_requirements_no_data_race_modify_a3b7c9d1", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2398", "source": "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9", "target": "cpp20_iterator_operations_prev_effect_d6a0b3c8"}, {"id": "e2399", "source": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "target": "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9"}, {"id": "e2400", "source": "cpp20_iterator_operations_next_effect_c5f9a2b7", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2401", "source": "cpp20_iterator_operations_distance_reachable_precondition_b4e8d1f6", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2402", "source": "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2403", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2404", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2405", "source": "cpp20_expected_error_type_constraint_c9d0e1f2", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2406", "source": "cpp20_declval_incomplete_type_allowed_b5a9d4c1", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2407", "source": "cpp20_weak_ptr_general_incomplete_type_allowed_a7c3f8e2", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2408", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2409", "source": "cpp20_expr_prim_lambda_capture_shadows_param_f4a8b0c1", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2410", "source": "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2411", "source": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2412", "source": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2413", "source": "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2414", "source": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2415", "source": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "target": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"}, {"id": "e2416", "source": "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2417", "source": "cpp20_expected_void_transform_error_mandates_a5b6c7d8", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2418", "source": "cpp20_expected_transform_error_mandates_a1b2c3d4", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2419", "source": "cpp20_expected_error_type_constraint_c9d0e1f2", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2420", "source": "cpp20_declval_incomplete_type_allowed_b5a9d4c1", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2421", "source": "cpp20_weak_ptr_general_incomplete_type_allowed_a7c3f8e2", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2422", "source": "cpp20_over_match_funcs_value_dependent_explicit_deduction_first_b9c1d2e3", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2423", "source": "cpp20_expr_prim_lambda_capture_shadows_param_f4a8b0c1", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2424", "source": "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2425", "source": "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2426", "source": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2427", "source": "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2428", "source": "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8", "target": "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"}, {"id": "e2429", "source": "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9", "target": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6"}, {"id": "e2430", "source": "cpp20_iterator_operations_prev_effect_d6a0b3c8", "target": "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6"}, {"id": "e2431", "source": "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6", "target": "cpp20_range_access_size_returns_integer_like_a8b1c5d9"}, {"id": "e2432", "source": "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5", "target": "cpp20_range_access_size_returns_integer_like_a8b1c5d9"}, {"id": "e2433", "source": "cpp20_range_range_begin_equality_preserving_c1d2e3f4", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2434", "source": "cpp20_range_range_begin_end_amortized_constant_7e8f9a0b", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2435", "source": "cpp20_range_range_begin_end_denotes_range_a3b4c5d6", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2436", "source": "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2437", "source": "cpp20_algorithms_requirements_ranges_dispatch_end_o5p6q7r8", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2438", "source": "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2439", "source": "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2440", "source": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2441", "source": "cpp20_expr_pre_cast_assignment_conversion_required_d4a1b6f8", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2442", "source": "cpp20_expr_pre_floating_point_extended_precision_c7f8a2e3", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2443", "source": "cpp20_expr_pre_result_undefined_math_range_8a3f7c21", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2444", "source": "cpp20_format_range_disabled_constraint_f9a0b1c2", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2445", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2446", "source": "cpp20_format_c_type_throws_out_of_range_c3d4e5f6", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2447", "source": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "target": "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"}, {"id": "e2448", "source": "cpp20_range_range_begin_equality_preserving_c1d2e3f4", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2449", "source": "cpp20_range_range_begin_end_amortized_constant_7e8f9a0b", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2450", "source": "cpp20_range_range_begin_end_denotes_range_a3b4c5d6", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2451", "source": "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2452", "source": "cpp20_algorithms_requirements_ranges_dispatch_end_o5p6q7r8", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2453", "source": "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2454", "source": "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2455", "source": "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2456", "source": "cpp20_expr_pre_cast_assignment_conversion_required_d4a1b6f8", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2457", "source": "cpp20_expr_pre_floating_point_extended_precision_c7f8a2e3", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2458", "source": "cpp20_expr_pre_result_undefined_math_range_8a3f7c21", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2459", "source": "cpp20_format_range_disabled_constraint_f9a0b1c2", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2460", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2461", "source": "cpp20_format_c_type_throws_out_of_range_c3d4e5f6", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2462", "source": "cpp20_range_constant_range_non_modifiable_a1b2c3d4", "target": "cpp20_range_sized_size_O1_o5p6q7r8"}, {"id": "e2463", "source": "cpp20_format_c_type_throws_out_of_range_c3d4e5f6", "target": "cpp20_format_err_report_throws_format_error_a7b8c9d0"}, {"id": "e2464", "source": "cpp20_format_precision_negative_throws_f3a4b5c6", "target": "cpp20_format_err_report_throws_format_error_a7b8c9d0"}, {"id": "e2465", "source": "cpp20_format_width_negative_throws_c9d0e1f2", "target": "cpp20_format_err_report_throws_format_error_a7b8c9d0"}, {"id": "e2466", "source": "cpp20_format_parse_context_check_dynamic_spec_a7b8c9d0", "target": "cpp20_format_err_report_throws_format_error_a7b8c9d0"}, {"id": "e2467", "source": "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8", "target": "cpp20_format_err_report_throws_format_error_a7b8c9d0"}, {"id": "e2468", "source": "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6", "target": "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4"}, {"id": "e2469", "source": "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5", "target": "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4"}, {"id": "e2470", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4"}, {"id": "e2471", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4"}, {"id": "e2472", "source": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "target": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4"}, {"id": "e2473", "source": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4", "target": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4"}, {"id": "e2474", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4"}, {"id": "e2475", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4"}, {"id": "e2476", "source": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "target": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8"}, {"id": "e2477", "source": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4", "target": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8"}, {"id": "e2478", "source": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "target": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8"}, {"id": "e2479", "source": "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "target": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2"}, {"id": "e2480", "source": "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "target": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2"}, {"id": "e2481", "source": "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4", "target": "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2"}, {"id": "e2482", "source": "cpp20_weak_ptr_move_ctor_constraint_compatible_a6c0e4d9", "target": "cpp20_any_move_ctor_noexcept_b5c6d7e8"}, {"id": "e2483", "source": "cpp20_any_swap_noexcept_d3e4f5a6", "target": "cpp20_any_reset_noexcept_b7c8d9e0"}, {"id": "e2484", "source": "cpp20_any_move_assignment_noexcept_f9a0b1c2", "target": "cpp20_any_reset_noexcept_b7c8d9e0"}, {"id": "e2485", "source": "cpp20_any_move_ctor_noexcept_b5c6d7e8", "target": "cpp20_any_reset_noexcept_b7c8d9e0"}, {"id": "e2486", "source": "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "target": "cpp20_any_reset_noexcept_b7c8d9e0"}, {"id": "e2487", "source": "cpp20_utility_swap_noexcept_spec_g8h2i6j0", "target": "cpp20_any_reset_noexcept_b7c8d9e0"}, {"id": "e2488", "source": "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "target": "cpp20_any_reset_noexcept_b7c8d9e0"}];
        const layerColors = {"c11_core": "#ff6b6b", "c11_stdlib": "#ee5a24", "cpp_core": "#a55eea", "cpp_stdlib": "#8854d0", "cpp20_language": "#45aaf2", "cpp20_stdlib": "#0984e3", "library": "#26de81"};

        // Build graph
        const graph = new graphology.Graph();

        nodesData.forEach(n => {
            graph.addNode(n.id, {
                x: n.x,
                y: n.y,
                size: n.size,
                color: n.color,
                label: n.label,
                layer: n.layer,
                module: n.module,
                content: n.content,
                function: n.function,
                hidden: false,
            });
        });

        edgesData.forEach(e => {
            if (graph.hasNode(e.source) && graph.hasNode(e.target)) {
                graph.addEdge(e.source, e.target, {
                    color: 'rgba(100,100,100,0.15)',
                    size: 0.3,
                });
            }
        });

        // Build lookup maps
        const depsMap = new Map();
        const dependentsMap = new Map();
        edgesData.forEach(e => {
            if (!depsMap.has(e.source)) depsMap.set(e.source, []);
            depsMap.get(e.source).push(e.target);
            if (!dependentsMap.has(e.target)) dependentsMap.set(e.target, []);
            dependentsMap.get(e.target).push(e.source);
        });

        // Track hidden nodes in a Set for reliable filtering
        const hiddenNodes = new Set();

        // Initialize sigma with reducers for visibility
        const container = document.getElementById('graph');
        const renderer = new Sigma(graph, container, {
            renderLabels: true,
            labelRenderedSizeThreshold: 8,
            labelFont: 'monospace',
            labelSize: 10,
            labelColor: { color: '#888' },
            defaultEdgeColor: 'rgba(100,100,100,0.15)',
            minCameraRatio: 0.05,
            maxCameraRatio: 5,
            nodeReducer: (node, data) => {
                if (hiddenNodes.has(node)) {
                    return { ...data, hidden: true };
                }
                return data;
            },
            edgeReducer: (edge, data) => {
                const source = graph.source(edge);
                const target = graph.target(edge);
                if (hiddenNodes.has(source) || hiddenNodes.has(target)) {
                    return { ...data, hidden: true };
                }
                return data;
            },
        });

        // Helper to update visibility
        function setNodeHidden(nodeId, hidden) {
            if (hidden) {
                hiddenNodes.add(nodeId);
            } else {
                hiddenNodes.delete(nodeId);
            }
        }

        function showAllNodes() {
            hiddenNodes.clear();
            renderer.refresh();
        }

        // Click handler
        renderer.on('clickNode', ({ node }) => {
            showInfo(node);
        });

        renderer.on('clickStage', () => {
            closeInfo();
        });

        function showInfo(nodeId) {
            currentSelectedNode = nodeId;
            const attrs = graph.getNodeAttributes(nodeId);

            document.getElementById('info-id').textContent = nodeId;
            document.getElementById('info-layer').textContent = attrs.layer;
            document.getElementById('info-layer').style.background = layerColors[attrs.layer] || '#666';
            document.getElementById('info-module').textContent = attrs.module || '-';
            document.getElementById('info-content').textContent = attrs.content || '-';

            const funcField = document.getElementById('info-function-field');
            if (attrs.function) {
                document.getElementById('info-function').textContent = attrs.function;
                funcField.style.display = 'block';
            } else {
                funcField.style.display = 'none';
            }

            const deps = depsMap.get(nodeId) || [];
            document.getElementById('info-deps').innerHTML = deps.length
                ? deps.slice(0, 8).map(d => `<span class="dep-link" onclick="focusNode('${d}')">${d}</span>`).join('<br>') + (deps.length > 8 ? `<br><em style="color:#555">+${deps.length - 8} more</em>` : '')
                : '<em style="color:#555">None</em>';

            const dependents = dependentsMap.get(nodeId) || [];
            document.getElementById('info-dependents').innerHTML = dependents.length
                ? dependents.slice(0, 8).map(d => `<span class="dep-link" onclick="focusNode('${d}')">${d}</span>`).join('<br>') + (dependents.length > 8 ? `<br><em style="color:#555">+${dependents.length - 8} more</em>` : '')
                : '<em style="color:#555">None</em>';

            document.getElementById('info-panel').classList.add('visible');

            // Highlight node
            graph.setNodeAttribute(nodeId, 'highlighted', true);
            renderer.refresh();
        }

        function closeInfo() {
            currentSelectedNode = null;
            document.getElementById('info-panel').classList.remove('visible');
            graph.forEachNode(n => graph.setNodeAttribute(n, 'highlighted', false));
            renderer.refresh();
        }

        function focusNode(nodeId) {
            const attrs = graph.getNodeAttributes(nodeId);
            renderer.getCamera().animate({ x: attrs.x, y: attrs.y, ratio: 0.3 }, { duration: 300 });
            showInfo(nodeId);
        }

        // Search
        const searchInput = document.getElementById('search');
        searchInput.addEventListener('input', (e) => {
            const q = e.target.value.toLowerCase().trim();
            console.log('Search query:', q || '(empty)');

            hiddenNodes.clear();
            let matchCount = 0;
            graph.forEachNode((nodeId, attrs) => {
                const match = !q || nodeId.toLowerCase().includes(q) || (attrs.content || '').toLowerCase().includes(q);
                if (match) {
                    matchCount++;
                } else {
                    hiddenNodes.add(nodeId);
                }
            });

            console.log('Matches:', matchCount, 'Hidden:', hiddenNodes.size);
            renderer.refresh();

            // Focus on first match
            if (q && matchCount > 0) {
                const firstMatch = graph.findNode((nodeId) => !hiddenNodes.has(nodeId));
                if (firstMatch) {
                    const attrs = graph.getNodeAttributes(firstMatch);
                    renderer.getCamera().animate({ x: attrs.x, y: attrs.y, ratio: 0.5 }, { duration: 300 });
                }
            }
        });

        // Layer filters
        document.querySelectorAll('.layer-filter input').forEach(cb => {
            cb.addEventListener('change', () => {
                const checkedLayers = Array.from(document.querySelectorAll('.layer-filter input:checked'))
                    .map(i => i.dataset.layer);

                hiddenNodes.clear();
                graph.forEachNode((nodeId, attrs) => {
                    if (!checkedLayers.includes(attrs.layer)) {
                        hiddenNodes.add(nodeId);
                    }
                });

                renderer.refresh();
            });
        });

        function resetView() {
            searchInput.value = '';
            document.querySelectorAll('.layer-filter input').forEach(cb => cb.checked = true);
            hiddenNodes.clear();
            renderer.getCamera().animate({ x: 0.5, y: 0.5, ratio: 1 }, { duration: 300 });
            renderer.refresh();
            closeInfo();
        }

        function zoomIn() {
            const camera = renderer.getCamera();
            camera.animate({ ratio: camera.ratio / 1.5 }, { duration: 200 });
        }

        function zoomOut() {
            const camera = renderer.getCamera();
            camera.animate({ ratio: camera.ratio * 1.5 }, { duration: 200 });
        }

        let currentSelectedNode = null;

        function filterToSubtree() {
            if (!currentSelectedNode) {
                console.log('No node selected');
                return;
            }

            console.log('Filtering to subtree of:', currentSelectedNode);

            // BFS to find all dependencies (downstream)
            const subtree = new Set();
            const queue = [currentSelectedNode];

            while (queue.length > 0) {
                const nodeId = queue.shift();
                if (subtree.has(nodeId)) continue;
                subtree.add(nodeId);

                // Add all dependencies (nodes this one depends on)
                const deps = depsMap.get(nodeId) || [];
                deps.forEach(d => {
                    if (!subtree.has(d) && graph.hasNode(d)) queue.push(d);
                });
            }

            console.log('Subtree size:', subtree.size);

            // Hide all nodes not in subtree
            hiddenNodes.clear();
            graph.forEachNode((nodeId) => {
                if (!subtree.has(nodeId)) {
                    hiddenNodes.add(nodeId);
                }
            });

            console.log('Visible nodes:', subtree.size, 'Hidden:', hiddenNodes.size);
            renderer.refresh();

            // Fit camera to visible nodes
            const visibleNodes = [];
            graph.forEachNode((nodeId, attrs) => {
                if (!hiddenNodes.has(nodeId)) visibleNodes.push({ x: attrs.x, y: attrs.y });
            });

            if (visibleNodes.length > 0) {
                const xs = visibleNodes.map(n => n.x);
                const ys = visibleNodes.map(n => n.y);
                const cx = (Math.min(...xs) + Math.max(...xs)) / 2;
                const cy = (Math.min(...ys) + Math.max(...ys)) / 2;
                renderer.getCamera().animate({ x: cx, y: cy, ratio: 0.5 }, { duration: 300 });
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeInfo();
            if (e.key === '/' && e.target !== searchInput) {
                e.preventDefault();
                searchInput.focus();
            }
        });
    </script>
</body>
</html>
