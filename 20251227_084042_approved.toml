[[axioms]]
id = "return_with_move_requires_moveconstructible_a7f3e2d1"
content = "std::move(val) requires that type R meets Cpp17MoveConstructible requirements for assignment to return_value"
formal_spec = "return_value = std::move(val) => Cpp17MoveConstructible(R)"
layer = "library"
function = "return_with"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "compilation error if R is not move-constructible"
confidence = 0.85

[[axioms]]
id = "set_placement_new_buffer_alignment_73"
content = "Placement new requires buffer to have proper alignment for type U (std::decay_t<T>)"
formal_spec = "alignof(U) <= arch::sbo_size && buffer_aligned_for(buffer, alignof(U))"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "set_placement_new_buffer_size_73"
content = "Placement new requires buffer to have sufficient size for type U (std::decay_t<T>)"
formal_spec = "sizeof(U) <= arch::sbo_size && buffer_size(buffer) >= sizeof(U)"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "set_placement_new_trivially_destructible_73"
content = "Type U (std::decay_t<T>) must be trivially destructible for placement new in SmallStorage without explicit destructor calls"
formal_spec = "std::is_trivially_destructible_v<U> == true"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "constraint"
on_violation = "static assertion failure, ill-formed program"
confidence = 0.85

[[axioms]]
id = "set_static_cast_rvalue_reference_73"
content = "static_cast<T&&>(val) requires val to be a valid forwarding reference of type T&&"
formal_spec = "is_valid_rvalue_reference_cast(T&&, val) && type(val) == T&&"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "ill-formed if cast is invalid"
confidence = 0.8

[[axioms]]
id = "set_placement_new_construction_73"
content = "After placement new, an object of type U is constructed in buffer from static_cast<T&&>(val)"
formal_spec = "after_placement_new(buffer) => object_constructed(buffer, U) && initialized_from(buffer, static_cast<T&&>(val))"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "postcondition"
on_violation = "undefined behavior if construction fails"
confidence = 0.85

[[axioms]]
id = "extract_reinterpret_cast_buffer_alignment_a1b2c3d4"
content = "reinterpret_cast<R*>(buffer) requires buffer to be properly aligned for type R and point to storage of sufficient size for R"
formal_spec = "reinterpret_cast<R*>(buffer) => is_aligned_for<R>(buffer) && storage_size(buffer) >= sizeof(R)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.75

[[axioms]]
id = "extract_launder_pointer_validity_e4f5a6b7"
content = "std::launder requires that reinterpret_cast<R*>(buffer) points to storage where an object of type R has been created (lifetime has started)"
formal_spec = "std::launder(reinterpret_cast<R*>(buffer)) => object_lifetime_started(reinterpret_cast<R*>(buffer), R)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "extract_pointer_deref_non_null_c7d8e9f0"
content = "Dereferencing std::launder(reinterpret_cast<R*>(buffer)) requires the pointer to be non-null and valid"
formal_spec = "dereference(std::launder(reinterpret_cast<R*>(buffer))) => !is_null(std::launder(reinterpret_cast<R*>(buffer))) && is_valid_pointer(std::launder(reinterpret_cast<R*>(buffer)))"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "extract_static_cast_rvalue_valid_object_b3c4d5e6"
content = "static_cast<R&&> requires the dereferenced object to be a valid, complete object of type R whose lifetime has started and not ended"
formal_spec = "static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer))) => is_complete_type(R) && object_lifetime_active(*std::launder(reinterpret_cast<R*>(buffer)), R)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "extract_buffer_contains_constructed_object_f5a6b7c8"
content = "buffer must contain a properly constructed object of type R before extract() is called"
formal_spec = "extract() => exists_constructed_object_at(buffer, R) && object_lifetime_active(buffer, R)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "set_placement_new_buffer_alignment_a1b2c3d4"
content = "Placement new requires buffer to have proper alignment for type U (std::decay_t<T>). Static assertion ensures alignof(U) <= arch::sbo_size."
formal_spec = "alignof(std::decay_t<T>) <= arch::sbo_size && is_properly_aligned(buffer, alignof(std::decay_t<T>))"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior (misaligned memory access)"
confidence = 0.85

[[axioms]]
id = "set_placement_new_buffer_size_e5f6g7h8"
content = "Placement new requires buffer to have sufficient storage for type U (std::decay_t<T>). Static assertion ensures sizeof(U) <= arch::sbo_size."
formal_spec = "sizeof(std::decay_t<T>) <= arch::sbo_size && buffer_size >= sizeof(std::decay_t<T>)"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior (buffer overflow)"
confidence = 0.85

[[axioms]]
id = "set_placement_new_trivially_destructible_i9j0k1l2"
content = "Type U (std::decay_t<T>) must be trivially destructible. Static assertion enforces std::is_trivially_destructible_v<U>. This avoids need for manual destructor invocation on SmallStorage buffer."
formal_spec = "std::is_trivially_destructible_v<std::decay_t<T>> == true"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "constraint"
on_violation = "compilation error (static_assert failure)"
confidence = 0.75

[[axioms]]
id = "set_static_cast_rvalue_reference_m3n4o5p6"
content = "static_cast<T&&>(val) preserves the value category of val as an rvalue reference, enabling move semantics when constructing U."
formal_spec = "is_rvalue_reference(static_cast<T&&>(val)) && type(static_cast<T&&>(val)) == T&&"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "postcondition"
on_violation = "compilation error if cast is invalid"
confidence = 0.9

[[axioms]]
id = "set_placement_new_buffer_lifetime_q7r8s9t0"
content = "Before placement new, buffer must not contain a live object that requires destruction, or any previous object must have been properly destroyed."
formal_spec = "!contains_live_object(buffer) || (contains_live_object(buffer) && std::is_trivially_destructible_v<previous_object_type>)"
layer = "library"
function = "set"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior (object lifetime violation, resource leak)"
confidence = 0.7

[[axioms]]
id = "extract_reinterpret_cast_buffer_alignment_a1b2c3d4"
content = "The buffer must point to storage with proper alignment for type R"
formal_spec = "reinterpret_cast<R*>(buffer) => aligned_for_type(buffer, R)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "extract_buffer_lifetime_started_e4f5a6b7"
content = "An object of type R must have been constructed in buffer and its lifetime must have started before calling extract"
formal_spec = "reinterpret_cast<R*>(buffer) => lifetime_started(buffer, R) && !after_lifetime_end(buffer, R)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "extract_launder_pointer_equivalence_f6g7h8i9"
content = "std::launder must be used because reinterpret_cast may produce a pointer that does not point to the object representation, requiring pointer value computation"
formal_spec = "std::launder(reinterpret_cast<R*>(buffer)) => pointer_interconvertible_with_object(result, R) && within_lifetime(result)"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "constraint"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "extract_deref_valid_pointer_b3c4d5e6"
content = "The pointer returned by std::launder must be valid and non-null for dereferencing"
formal_spec = "dereference(std::launder(reinterpret_cast<R*>(buffer))) => !null_pointer(std::launder(reinterpret_cast<R*>(buffer))) && valid_pointer(std::launder(reinterpret_cast<R*>(buffer)))"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "extract_static_cast_rvalue_ref_glvalue_c7d8e9f0"
content = "static_cast to rvalue reference R&& requires the dereferenced expression to be a glvalue of compatible type"
formal_spec = "static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer))) => is_glvalue(*std::launder(reinterpret_cast<R*>(buffer))) && type_of(*std::launder(reinterpret_cast<R*>(buffer))) == R"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "constraint"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "extract_buffer_contains_type_r_d8e9f0a1"
content = "The buffer must contain an object of exactly type R (not a base or derived class)"
formal_spec = "reinterpret_cast<R*>(buffer) => dynamic_type(object_at(buffer)) == R"
layer = "library"
function = "extract"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.8

[[axioms]]
id = "ctrl_operator_r_extract_wellformed_a1b2c3d4"
content = "Template member function s.template extract<R>() must be well-formed for type R and callable on rvalue s"
formal_spec = "well_formed(s.template extract<R>()) && is_member_function(s, extract<R>) && is_callable_on_rvalue(s, extract<R>)"
layer = "library"
function = "R"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "substitution failure, ill-formed program"
confidence = 0.75

[[axioms]]
id = "ctrl_operator_r_extract_return_type_e5f6g7h8"
content = "The result of s.template extract<R>() must be convertible to type R for the conversion operator to succeed"
formal_spec = "is_convertible<decltype(s.template extract<R>()), R> || is_same<decltype(s.template extract<R>()), R>"
layer = "library"
function = "R"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "postcondition"
on_violation = "compilation error, type mismatch"
confidence = 0.85

[[axioms]]
id = "ctrl_operator_r_extract_wellformed_a1b2c3d4"
content = "Template member function s.extract<R>() must be well-formed for type R"
formal_spec = "well_formed(s.template extract<R>()) && valid_member_template(s, extract<R>)"
layer = "library"
function = "R"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "Compilation error (substitution failure)"
confidence = 0.85

[[axioms]]
id = "ctrl_operator_r_extract_convertible_e5f6a7b8"
content = "The result of s.extract<R>() must be convertible to type R for the return statement"
formal_spec = "is_convertible(decltype(s.template extract<R>()), R) && valid_return(s.template extract<R>(), R)"
layer = "library"
function = "R"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "postcondition"
on_violation = "Compilation error (invalid return type conversion)"
confidence = 0.9

[[axioms]]
id = "ctrl_operator_r_rvalue_valid_c9d0e1f2"
content = "Operator R() && requires the object to be an rvalue (moved-from state after call)"
formal_spec = "is_rvalue_ref(this) && can_move(*this) => valid_call(s.template extract<R>())"
layer = "library"
function = "R"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "Compilation error (cannot call rvalue-qualified operator on lvalue)"
confidence = 0.95

[[axioms]]
id = "ilp_for_ctrl_fprintf_stderr_valid_a1b2c3d4"
content = "std::fprintf requires stderr to be a valid FILE* stream pointer"
formal_spec = "std::fprintf(stderr, format_string) => valid_file_pointer(stderr) && stream_open(stderr)"
layer = "library"
function = "ilp_end_with_return_error"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "ilp_for_ctrl_abort_noreturn_postcond_e5f6g7h8"
content = "std::abort() terminates the program abnormally and never returns, matching the [[noreturn]] attribute"
formal_spec = "std::abort() => abnormal_termination() && never_returns()"
layer = "library"
function = "ilp_end_with_return_error"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "postcondition"
on_violation = "implementation defined behavior if abort returns"

[[axioms]]
id = "ilp_for_ctrl_function_noreturn_invariant_i9j0k1l2"
content = "Function marked [[noreturn]] must not return to caller; control flow must terminate via std::abort()"
formal_spec = "[[noreturn]] ilp_end_with_return_error() => terminates_via_abort() && !returns_to_caller()"
layer = "library"
function = "ilp_end_with_return_error"
header = "../../cpp/ilp_for/ilp_for/detail/ctrl.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior if function returns"

[[axioms]]
id = "validate_unroll_factor_template_param_constraint_n_gte_1_a1b2c3d4"
content = "Template parameter N must be at least 1 (enforced by static_assert)"
formal_spec = "N >= 1"
layer = "library"
function = "validate_unroll_factor"
header = "../../cpp/ilp_for/ilp_for/detail/loops_common.hpp"
axiom_type = "constraint"
on_violation = "compilation error: static_assert failure"
confidence = 0.9

[[axioms]]
id = "validate_unroll_factor_warn_threshold_n_gt_16_e5f6g7h8"
content = "Function call to warn_large_unroll_factor<N>() requires N > 16 (guarded by constexpr if)"
formal_spec = "N > 16 => warn_large_unroll_factor<N>()"
layer = "library"
function = "validate_unroll_factor"
header = "../../cpp/ilp_for/ilp_for/detail/loops_common.hpp"
axiom_type = "precondition"
on_violation = "function not called: guard prevents execution when N <= 16"
confidence = 0.85

[[axioms]]
id = "check_sum_overflow_accumulator_size_constraint_a1b2c3d4"
content = "When AccumT and ElemT are both integral types and sizeof(AccumT) < sizeof(ElemT), warn_accumulator_overflow must be called to signal potential overflow in accumulation operations."
formal_spec = "(std::integral<AccumT> && std::integral<ElemT> && sizeof(AccumT) < sizeof(ElemT)) => warn_accumulator_overflow<AccumT, ElemT>()"
layer = "library"
function = "check_sum_overflow"
header = "../../cpp/ilp_for/ilp_for/detail/loops_common.hpp"
axiom_type = "constraint"
on_violation = "Potential silent overflow in accumulation when accumulator type is smaller than element type"
confidence = 0.85

[[axioms]]
id = "for_loop_untyped_impl_validate_unroll_factor_precond_a1b2c3d4"
content = "Template parameter N must be a valid unroll factor as validated by validate_unroll_factor<N>()"
formal_spec = "valid_unroll_factor(N)"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compile-time error or undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_untyped_impl_static_cast_overflow_precond_e5f6g7h8"
content = "static_cast<T>(j) where j is std::size_t must not overflow when converting to type T"
formal_spec = "j <= numeric_limits<T>::max() && static_cast<T>(j) preserves_value(j)"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior due to integer overflow or truncation"
confidence = 0.8

[[axioms]]
id = "for_loop_untyped_impl_addition_overflow_precond_i9j0k1l2"
content = "Addition i + static_cast<T>(j) must not overflow for type T in loop body invocation"
formal_spec = "i <= numeric_limits<T>::max() - static_cast<T>(j)"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior due to signed integer overflow"
confidence = 0.85

[[axioms]]
id = "for_loop_untyped_impl_loop_increment_overflow_precond_m3n4o5p6"
content = "Loop increment i += static_cast<T>(N) must not overflow for type T"
formal_spec = "i <= numeric_limits<T>::max() - static_cast<T>(N)"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior due to signed integer overflow"
confidence = 0.85

[[axioms]]
id = "for_loop_untyped_impl_loop_condition_overflow_precond_q7r8s9t0"
content = "Loop condition i + static_cast<T>(N) <= end requires that addition does not overflow"
formal_spec = "i <= numeric_limits<T>::max() - static_cast<T>(N)"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior due to signed integer overflow in comparison"
confidence = 0.85

[[axioms]]
id = "for_loop_untyped_impl_body_callable_precond_u1v2w3x4"
content = "Function body must be callable with arguments (T, ForCtrl&) and expression body(i + static_cast<T>(j), ctrl) must be well-formed"
formal_spec = "callable(body, T, ForCtrl&) && well_formed(body(i + static_cast<T>(j), ctrl))"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error"
confidence = 0.9

[[axioms]]
id = "for_loop_untyped_impl_body_callable_remainder_precond_y5z6a7b8"
content = "Function body must be callable with arguments (T, ForCtrl&) and expression body(i, ctrl) must be well-formed in remainder loop"
formal_spec = "callable(body, T, ForCtrl&) && well_formed(body(i, ctrl))"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error"
confidence = 0.9

[[axioms]]
id = "for_loop_untyped_impl_move_precond_c9d0e1f2"
content = "std::move(ctrl.storage) requires ctrl.storage to be move-constructible, guarded by !ctrl.ok"
formal_spec = "!ctrl.ok => is_move_constructible<decltype(ctrl.storage)>"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error if not move-constructible"
confidence = 0.85

[[axioms]]
id = "for_loop_untyped_impl_move_remainder_precond_g3h4i5j6"
content = "std::move(ctrl.storage) in remainder loop requires ctrl.storage to be move-constructible, guarded by !ctrl.ok"
formal_spec = "!ctrl.ok => is_move_constructible<decltype(ctrl.storage)>"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error if not move-constructible"
confidence = 0.85

[[axioms]]
id = "for_loop_untyped_impl_range_validity_precond_k7l8m9n0"
content = "Range [start, end) must be valid: start <= end for type T with well-defined ordering"
formal_spec = "start <= end && has_less_than_operator<T>"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or infinite loop"
confidence = 0.75

[[axioms]]
id = "for_loop_untyped_impl_type_constraints_precond_o1p2q3r4"
content = "Type T must support arithmetic operations (addition, comparison), copy construction, and conversion from integral types"
formal_spec = "has_addition<T> && has_less_than<T> && has_less_equal<T> && is_copy_constructible<T> && is_convertible<size_t, T>"
layer = "library"
function = "for_loop_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error"
confidence = 0.9

[[axioms]]
id = "for_loop_typed_impl_addition_overflow_guard_a1b2c3d4"
content = "Loop condition check: addition of i + static_cast<T>(N) must not overflow and result must be comparable to end"
formal_spec = "i + static_cast<T>(N) <= end => no_overflow(i + static_cast<T>(N)) && is_valid_comparison(i + static_cast<T>(N), end)"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior (integer overflow)"
confidence = 0.75

[[axioms]]
id = "for_loop_typed_impl_static_cast_representable_e3f4a5b6"
content = "static_cast<T>(N): compile-time constant N must be representable in type T"
formal_spec = "static_cast<T>(N) => N <= numeric_limits<T>::max()"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "unspecified value or undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_typed_impl_body_call_unrolled_precond_c7d8e9f0"
content = "body(i + static_cast<T>(j), ctrl): the addition i + static_cast<T>(j) must not overflow and result must be within [start, end)"
formal_spec = "body(i + static_cast<T>(j), ctrl) => no_overflow(i + static_cast<T>(j)) && i + static_cast<T>(j) < end"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior (integer overflow) or out-of-bounds iteration"
confidence = 0.8

[[axioms]]
id = "for_loop_typed_impl_static_cast_j_representable_a9b0c1d2"
content = "static_cast<T>(j): loop index j (in range [0, N)) must be representable in type T"
formal_spec = "static_cast<T>(j) && j < N => j <= numeric_limits<T>::max()"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "unspecified value or undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_typed_impl_move_ctrl_storage_precond_e3f4g5h6"
content = "std::move(ctrl.storage): ctrl.storage must be in a valid state for move construction (guarded by !ctrl.ok)"
formal_spec = "!ctrl.ok && std::move(ctrl.storage) => is_valid_state(ctrl.storage) && is_move_constructible<decltype(ctrl.storage)>"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or move from invalid state"
confidence = 0.7

[[axioms]]
id = "for_loop_typed_impl_body_call_remainder_precond_i7j8k9l0"
content = "body(i, ctrl): loop index i must be within valid range [start, end)"
formal_spec = "body(i, ctrl) && i < end => start <= i && i < end"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "out-of-bounds iteration"
confidence = 0.9

[[axioms]]
id = "for_loop_typed_impl_move_ctrl_storage_remainder_precond_m1n2o3p4"
content = "std::move(ctrl.storage): ctrl.storage must be in a valid state for move construction in remainder loop (guarded by !ctrl.ok)"
formal_spec = "!ctrl.ok && std::move(ctrl.storage) => is_valid_state(ctrl.storage) && is_move_constructible<decltype(ctrl.storage)>"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or move from invalid state"
confidence = 0.7

[[axioms]]
id = "for_loop_typed_impl_loop_increment_no_overflow_q5r6s7t8"
content = "Loop increment i += static_cast<T>(N): the addition must not cause overflow"
formal_spec = "i += static_cast<T>(N) => no_overflow(i + static_cast<T>(N))"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior (signed integer overflow) or wrap-around (unsigned)"
confidence = 0.8

[[axioms]]
id = "for_loop_typed_impl_remainder_loop_increment_u9v0w1x2"
content = "Remainder loop increment ++i: the increment must not cause overflow and i must remain less than end"
formal_spec = "++i && i < end => no_overflow(i + 1)"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior (signed integer overflow) or wrap-around (unsigned)"
confidence = 0.8

[[axioms]]
id = "for_loop_typed_impl_validate_unroll_factor_y3z4a5b6"
content = "validate_unroll_factor<N>(): template parameter N must satisfy constraints (likely N > 0 and reasonable size)"
formal_spec = "validate_unroll_factor<N>() => N > 0 && N <= implementation_defined_max"
layer = "library"
function = "for_loop_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compile-time error or runtime assertion failure"
confidence = 0.7

[[axioms]]
id = "for_loop_range_impl_array_access_bounds_83_a1b2c3d4"
content = "Array access it[i + j] requires i + j to be within bounds [0, size). Loop guard ensures i + N <= size and j < N, so i + j < size is maintained."
formal_spec = "(i + j >= 0) && (i + j < size) && (i + N <= size) && (j < N) => valid_array_access(it[i + j])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_impl_array_access_bounds_88_e5f6a7b8"
content = "Array access it[i] requires i to be within bounds [0, size). Loop guard ensures i < size is maintained."
formal_spec = "(i >= 0) && (i < size) => valid_array_access(it[i])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_impl_array_access_bounds_95_c9d0e1f2"
content = "Array access it[i + j] requires i + j to be within bounds [0, size). Loop guard ensures i + N <= size and j < N, so i + j < size is maintained."
formal_spec = "(i + j >= 0) && (i + j < size) && (i + N <= size) && (j < N) => valid_array_access(it[i + j])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_impl_array_access_bounds_100_g3h4i5j6"
content = "Array access it[i] requires i to be within bounds [0, size). Loop guard ensures i < size is maintained."
formal_spec = "(i >= 0) && (i < size) => valid_array_access(it[i])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_impl_ranges_begin_valid_74_k7l8m9n0"
content = "std::ranges::begin(range) requires that range is a valid range and returns an iterator that models input_or_output_iterator."
formal_spec = "valid_range(range) => valid_expr(std::ranges::begin(range)) && models_input_or_output_iterator(decltype(std::ranges::begin(range)))"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed or undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_range_impl_ranges_size_valid_75_p1q2r3s4"
content = "std::ranges::size(range) requires that range is not an array of unknown bound and is a sized range."
formal_spec = "!is_array_unknown_bound<Range> && sized_range(range) => valid_expr(std::ranges::size(range))"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.9

[[axioms]]
id = "for_loop_range_impl_iterator_random_access_83_t5u6v7w8"
content = "Iterator subscript operation it[i + j] requires that the iterator returned by std::ranges::begin supports random access (operator[])."
formal_spec = "random_access_iterator(decltype(it)) => valid_expr(it[i + j])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed or undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_range_impl_iterator_random_access_88_x9y0z1a2"
content = "Iterator subscript operation it[i] requires that the iterator returned by std::ranges::begin supports random access (operator[])."
formal_spec = "random_access_iterator(decltype(it)) => valid_expr(it[i])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed or undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_range_impl_iterator_random_access_95_b3c4d5e6"
content = "Iterator subscript operation it[i + j] requires that the iterator returned by std::ranges::begin supports random access (operator[])."
formal_spec = "random_access_iterator(decltype(it)) => valid_expr(it[i + j])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed or undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_range_impl_iterator_random_access_100_f7g8h9i0"
content = "Iterator subscript operation it[i] requires that the iterator returned by std::ranges::begin supports random access (operator[])."
formal_spec = "random_access_iterator(decltype(it)) => valid_expr(it[i])"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed or undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_range_impl_addition_no_overflow_83_j1k2l3m4"
content = "Addition i + j in index calculation must not overflow std::size_t. Loop guards ensure i + N <= size and j < N, so i + j cannot exceed size."
formal_spec = "(i + N <= size) && (j < N) => (i + j <= SIZE_MAX) && no_overflow(i + j)"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "constraint"
on_violation = "undefined behavior (signed overflow) or wraparound (unsigned)"
confidence = 0.75

[[axioms]]
id = "for_loop_range_impl_addition_no_overflow_95_n5o6p7q8"
content = "Addition i + j in index calculation must not overflow std::size_t. Loop guards ensure i + N <= size and j < N, so i + j cannot exceed size."
formal_spec = "(i + N <= size) && (j < N) => (i + j <= SIZE_MAX) && no_overflow(i + j)"
layer = "library"
function = "for_loop_range_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "constraint"
on_violation = "undefined behavior (signed overflow) or wraparound (unsigned)"
confidence = 0.75

[[axioms]]
id = "for_loop_range_untyped_impl_array_access_unrolled_bounds_a1b2c3d4"
content = "Array access it[i + j] requires that i + j is within valid bounds [0, size). The outer loop ensures i + N <= size, and inner loop ensures j < N, so i + j < size is maintained."
formal_spec = "array_access(it, i + j) && loop_invariant(i + N <= size) && loop_invariant(j < N) => (0 <= i + j) && (i + j < size)"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_untyped_impl_array_access_remainder_bounds_e5f6a7b8"
content = "Array access it[i] requires that i is within valid bounds [0, size). The remainder loop ensures i < size."
formal_spec = "array_access(it, i) && loop_invariant(i < size) => (0 <= i) && (i < size)"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_untyped_impl_ranges_begin_valid_iterator_c9d0e1f2"
content = "std::ranges::begin(range) must return a valid iterator that models input_or_output_iterator and supports random access (operator[])."
formal_spec = "valid_expr(std::ranges::begin(range)) => models<input_or_output_iterator>(decltype(it)) && supports_random_access(it)"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed or undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_range_untyped_impl_ranges_size_not_unknown_bound_g3h4i5j6"
content = "std::ranges::size(range) requires that Range is not an array of unknown bound, otherwise the call is ill-formed."
formal_spec = "std::ranges::size(range) && is_array_unknown_bound<Range> => ill_formed"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"

[[axioms]]
id = "for_loop_range_untyped_impl_iterator_subscript_valid_k7l8m9n0"
content = "Iterator subscript operation it[index] requires that the iterator supports random access and the index is within the valid range [0, size)."
formal_spec = "iterator_subscript(it, index) && index >= 0 && index < size => valid_dereference"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_range_untyped_impl_unroll_factor_valid_m1n2o3p4"
content = "validate_unroll_factor<N>() checks that the template parameter N is a valid unroll factor (likely N > 0 and within reasonable bounds)."
formal_spec = "validate_unroll_factor<N>() => N > 0 && N <= max_unroll_factor"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compile-time error or assertion failure"
confidence = 0.85

[[axioms]]
id = "for_loop_range_untyped_impl_move_ctrl_storage_valid_q5r6s7t8"
content = "std::move(ctrl.storage) when !ctrl.ok is guarded by the condition that ctrl has been set to a failure state. The storage must be in a valid state for moving."
formal_spec = "std::move(ctrl.storage) && !ctrl.ok => valid_for_move(ctrl.storage)"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior if storage is not valid"
confidence = 0.75

[[axioms]]
id = "for_loop_range_untyped_impl_addition_no_overflow_u9v0w1x2"
content = "The addition i + j in the unrolled loop must not overflow. Given that i + N <= size and j < N, and size is std::size_t, overflow is prevented by the loop invariants."
formal_spec = "addition(i, j) && i + N <= size && j < N && size <= SIZE_MAX => i + j <= SIZE_MAX"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior (integer overflow)"
confidence = 0.85

[[axioms]]
id = "for_loop_range_untyped_impl_loop_increment_no_overflow_y3z4a5b6"
content = "The loop increment i += N must not cause overflow. The loop condition i + N <= size ensures that incrementing i by N keeps it within valid bounds."
formal_spec = "loop_increment(i, N) && i + N <= size && size <= SIZE_MAX => i_new <= SIZE_MAX"
layer = "library"
function = "for_loop_range_untyped_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior (integer overflow)"
confidence = 0.8

[[axioms]]
id = "for_loop_range_typed_impl_range_begin_valid_iterator_a1b2c3d4"
content = "std::ranges::begin(range) must return a valid iterator that models input_or_output_iterator"
formal_spec = "valid_expr(std::ranges::begin(range)) => models<input_or_output_iterator>(decltype(std::ranges::begin(range)))"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.95

[[axioms]]
id = "for_loop_range_typed_impl_range_size_not_unknown_bound_e5f6g7h8"
content = "std::ranges::size(range) requires that Range is not an array of unknown bound"
formal_spec = "is_array_unknown_bound<Range> => ill_formed(std::ranges::size(range))"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.95

[[axioms]]
id = "for_loop_range_typed_impl_array_access_bounds_inner_i9j0k1l2"
content = "Array access it[i + j] requires that (i + j) is within bounds [0, size] where the loop invariant ensures i + j < size"
formal_spec = "array_access(it, i + j) && iterator_points_to_array_element(it, 0, size) && loop_invariant(i + N <= size && j < N) => (0 <= i + j && i + j < size)"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_range_typed_impl_array_access_bounds_remainder_m3n4o5p6"
content = "Array access it[i] requires that i is within bounds [0, size] where the loop condition ensures i < size"
formal_spec = "array_access(it, i) && iterator_points_to_array_element(it, 0, size) && loop_invariant(i < size) => (0 <= i && i < size)"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_range_typed_impl_iterator_addition_bounds_q7r8s9t0"
content = "The loop invariant i + N <= size ensures that all array accesses it[i + j] for j in [0, N) remain within valid bounds"
formal_spec = "for_loop(i, i + N <= size, i += N) && for_loop(j, j < N, ++j) => (0 <= i + j && i + j < size)"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_range_typed_impl_remainder_loop_bounds_u1v2w3x4"
content = "The remainder loop condition i < size ensures all accesses it[i] are within valid bounds for elements not covered by the unrolled loop"
formal_spec = "for_loop(i, i < size, ++i) && previous_loop_ended_at(i_start) && i_start + N > size => (i_start <= i && i < size)"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_range_typed_impl_size_overflow_check_y5z6a7b8"
content = "The addition i + N in the loop condition must not overflow for size_t operands"
formal_spec = "addition(i, N) && type_of(i) == size_t && type_of(N) == size_t => i + N <= SIZE_MAX"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior (integer overflow)"
confidence = 0.75

[[axioms]]
id = "for_loop_range_typed_impl_iterator_supports_random_access_c9d0e1f2"
content = "The iterator returned by std::ranges::begin must support random access via operator[] for subscript operations it[i + j] and it[i]"
formal_spec = "it = std::ranges::begin(range) && (array_access(it, i + j) || array_access(it, i)) => random_access_iterator(decltype(it))"
layer = "library"
function = "for_loop_range_typed_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or undefined behavior"
confidence = 0.9

[[axioms]]
id = "for_loop_range_ret_simple_impl_array_access_matches_bounds_173a"
content = "Array access matches[j] requires j to be within bounds [0, N). The loop ensures j < N, satisfying this precondition."
formal_spec = "j < N && j >= 0 => valid_array_access(matches, j)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_random_access_it_bounds_173"
content = "Random access iterator operation it[i + j] requires (i + j) to be within range [0, size]. The loop condition i + N <= size and j < N ensure this."
formal_spec = "(i + N <= size) && (j < N) && (i >= 0) && (j >= 0) => (0 <= i + j) && (i + j < size)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_array_access_results_bounds_191a"
content = "Array access results[j] requires j to be within bounds [0, N). The loop ensures j < N, satisfying this precondition."
formal_spec = "j < N && j >= 0 => valid_array_access(results, j)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_random_access_it_bounds_191"
content = "Random access iterator operation it[i + j] requires (i + j) to be within range [0, size]. The loop condition i + N <= size and j < N ensure this."
formal_spec = "(i + N <= size) && (j < N) && (i >= 0) && (j >= 0) => (0 <= i + j) && (i + j < size)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_array_access_results_bounds_196"
content = "Array access results[j] requires j to be within bounds [0, N). The loop guard j < N and additional guard results[j].has_value() ensure safe access."
formal_spec = "j < N && j >= 0 && results[j].has_value() => valid_array_access(results, j)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_random_access_it_bounds_200"
content = "Random access iterator operation it[i] requires i to be within range [0, size]. The loop condition i < size ensures this."
formal_spec = "(i < size) && (i >= 0) => (0 <= i) && (i < size)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_array_access_results_bounds_210a"
content = "Array access results[j] requires j to be within bounds [0, N). The loop ensures j < N, satisfying this precondition."
formal_spec = "j < N && j >= 0 => valid_array_access(results, j)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_random_access_it_bounds_210"
content = "Random access iterator operation it[i + j] requires (i + j) to be within range [0, size]. The loop condition i + N <= size and j < N ensure this."
formal_spec = "(i + N <= size) && (j < N) && (i >= 0) && (j >= 0) => (0 <= i + j) && (i + j < size)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_array_access_results_bounds_215"
content = "Array access results[j] requires j to be within bounds [0, N). The loop guard j < N and additional guard results[j] != end_it ensure safe access."
formal_spec = "j < N && j >= 0 && results[j] != end_it => valid_array_access(results, j)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_random_access_it_bounds_219"
content = "Random access iterator operation it[i] requires i to be within range [0, size]. The loop condition i < size ensures this."
formal_spec = "(i < size) && (i >= 0) => (0 <= i) && (i < size)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior"

[[axioms]]
id = "for_loop_range_ret_simple_impl_ranges_begin_models_iterator_161"
content = "std::ranges::begin(range) must return a type that models input_or_output_iterator. The function relies on random access iterator operations on the result."
formal_spec = "valid_expr(std::ranges::begin(range)) => models_input_or_output_iterator(decltype(it))"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "postcondition"
on_violation = "ill-formed"
confidence = 0.9

[[axioms]]
id = "for_loop_range_ret_simple_impl_ranges_size_not_unknown_bound_163"
content = "std::ranges::size(range) must not be called on an array of unknown bound. The range must be a sized range."
formal_spec = "!is_array_unknown_bound<Range> => valid_expr(std::ranges::size(range))"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.9

[[axioms]]
id = "for_loop_range_ret_simple_impl_body_callable_precond_173"
content = "The body function must be callable with arguments (it[i + j], end_it) where it[i + j] has type range_reference_t<Range> and end_it has type Sentinel. The result type must match R (bool in this branch)."
formal_spec = "valid_expr(body(it[i + j], end_it)) && std::is_same_v<decltype(body(it[i + j], end_it)), bool>"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_body_callable_precond_191"
content = "The body function must be callable with arguments (it[i + j], end_it). The result type must be an optional-like type satisfying is_optional_v<R>."
formal_spec = "valid_expr(body(it[i + j], end_it)) && is_optional_v<decltype(body(it[i + j], end_it))>"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_body_callable_precond_200"
content = "The body function must be callable with arguments (it[i], end_it). The result type must be an optional-like type satisfying is_optional_v<R>."
formal_spec = "valid_expr(body(it[i], end_it)) && is_optional_v<decltype(body(it[i], end_it))>"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_body_callable_precond_210"
content = "The body function must be callable with arguments (it[i + j], end_it). The result type R must be comparable to end_it using operator!=."
formal_spec = "valid_expr(body(it[i + j], end_it)) && valid_expr(decltype(body(it[i + j], end_it)) != end_it)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_body_callable_precond_219"
content = "The body function must be callable with arguments (it[i], end_it). The result type R must be comparable to end_it using operator!=."
formal_spec = "valid_expr(body(it[i], end_it)) && valid_expr(decltype(body(it[i], end_it)) != end_it)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_static_cast_sentinel_to_r_223"
content = "static_cast<R>(end_it) requires that Sentinel type is convertible to R. This conversion must be valid."
formal_spec = "valid_expr(static_cast<R>(end_it)) && std::is_convertible_v<Sentinel, R>"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.9

[[axioms]]
id = "for_loop_range_ret_simple_impl_move_requires_moveconstructible_196"
content = "std::move(results[j]) requires that type R is move-constructible. The return statement relies on move semantics for the optional type."
formal_spec = "std::is_move_constructible_v<R> => valid_expr(std::move(results[j]))"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_move_requires_moveconstructible_215"
content = "std::move(results[j]) requires that type R is move-constructible. The return statement relies on move semantics."
formal_spec = "std::is_move_constructible_v<R> => valid_expr(std::move(results[j]))"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "ill-formed"
confidence = 0.85

[[axioms]]
id = "for_loop_range_ret_simple_impl_unroll_factor_n_validation_159"
content = "validate_unroll_factor<N>() ensures that the template parameter N is a valid unroll factor. This is likely required to be a positive integer."
formal_spec = "N > 0 && valid_unroll_factor(N)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "static_assert or ill-formed"
confidence = 0.75

[[axioms]]
id = "for_loop_range_ret_simple_impl_overflow_check_i_plus_n_loop"
content = "Loop condition i + N <= size implies that i + N does not overflow. Since size is obtained from ranges::size() and i starts at 0 and increments by N while i + N <= size, overflow is prevented by the loop guard."
formal_spec = "(i + N <= size) && (i >= 0) && (N > 0) => no_unsigned_overflow(i + N)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior"
confidence = 0.8

[[axioms]]
id = "for_loop_range_ret_simple_impl_overflow_check_i_plus_j_index"
content = "Index calculation i + j is safe from overflow because i + N <= size and j < N, therefore i + j < i + N <= size."
formal_spec = "(i + N <= size) && (j < N) && (j >= 0) && (i >= 0) => no_unsigned_overflow(i + j)"
layer = "library"
function = "for_loop_range_ret_simple_impl"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "invariant"
on_violation = "undefined behavior"
confidence = 0.85

[[axioms]]
id = "for_loop_body_callable_precond_a1b2c3d4"
content = "The body parameter must be a callable object that can be invoked with appropriate arguments by the loop implementation"
formal_spec = "is_invocable<F, loop_args...> && well_formed(body(loop_args...))"
layer = "library"
function = "for_loop"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or undefined behavior"
confidence = 0.75

[[axioms]]
id = "for_loop_range_valid_precond_e5f6g7h8"
content = "The range [start, end) must form a valid iteration range where start can advance to end"
formal_spec = "is_reachable(start, end) || start >= end"
layer = "library"
function = "for_loop"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or infinite loop"
confidence = 0.85

[[axioms]]
id = "for_loop_forward_preserves_value_category_d9e0f1g2"
content = "std::forward<F>(body) preserves the value category of body (rvalue reference) for perfect forwarding to the implementation"
formal_spec = "is_rvalue_reference<F&&> => is_rvalue_reference<decltype(std::forward<F>(body))>"
layer = "library"
function = "for_loop"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "constraint"
on_violation = "compilation error"

[[axioms]]
id = "for_loop_typed_forward_precond_a1b2c3d4"
content = "The body parameter must be a valid object that can be forwarded; std::forward<F>(body) must be well-formed and produce a valid callable object."
formal_spec = "std::forward<F>(body) => is_valid_object(body) && is_callable(std::forward<F>(body))"
layer = "library"
function = "for_loop_typed"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or compilation error"
confidence = 0.7

[[axioms]]
id = "for_loop_typed_impl_precond_e5f6g7h8"
content = "The range [start, end) must form a valid iteration range, and the forwarded body must be a valid callable that can be invoked for each element in the range."
formal_spec = "detail::for_loop_typed_impl<R, N>(start, end, std::forward<F>(body)) => start <= end && is_callable(std::forward<F>(body))"
layer = "library"
function = "for_loop_typed"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or implementation-defined behavior"
confidence = 0.75

[[axioms]]
id = "for_loop_range_forward_range_precond_a1b2c3d4"
content = "The Range type must satisfy the C++20 range concept requirements, providing valid begin() and end() iterators that denote a valid range."
formal_spec = "for_loop_range(range, body) => valid_range(range) && denotes_range(begin(range), end(range))"
layer = "library"
function = "for_loop_range"
header = "ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior - may result in invalid iterator operations or access violations"
confidence = 0.75

[[axioms]]
id = "for_loop_range_body_callable_precond_e5f6a7b8"
content = "The body parameter F must be a callable object that can be invoked with elements from the range, satisfying invocable requirements."
formal_spec = "for_loop_range(range, body) => is_invocable<F, range_value_t<Range>>"
layer = "library"
function = "for_loop_range"
header = "ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error - body must be invocable with range elements"
confidence = 0.85

[[axioms]]
id = "for_loop_range_forward_validity_precond_c7d8e9f0"
content = "std::forward<Range>(range) requires that range is a valid lvalue or rvalue reference suitable for perfect forwarding, preserving value category."
formal_spec = "std::forward<Range>(range) => is_reference<Range&&> && valid_forwarding_reference(range)"
layer = "library"
function = "for_loop_range"
header = "ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or dangling reference - improper value category forwarding"
confidence = 0.9

[[axioms]]
id = "for_loop_range_forward_body_validity_precond_d8e9f0a1"
content = "std::forward<F>(body) requires that body is a valid lvalue or rvalue reference suitable for perfect forwarding, preserving value category."
formal_spec = "std::forward<F>(body) => is_reference<F&&> && valid_forwarding_reference(body)"
layer = "library"
function = "for_loop_range"
header = "ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or dangling reference - improper value category forwarding"
confidence = 0.9

[[axioms]]
id = "for_loop_range_typed_range_forward_valid_a1f2e3d4"
content = "The range parameter must be valid for perfect forwarding; std::forward<Range>(range) must produce a valid range object that can be iterated over by the implementation function."
formal_spec = "is_valid_range(range) && (is_lvalue_reference<Range> || is_rvalue_reference<Range>)"
layer = "library"
function = "for_loop_range_typed"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or compilation error if range type is not compatible with forward semantics"
confidence = 0.75

[[axioms]]
id = "for_loop_range_typed_body_forward_valid_b2c3d4e5"
content = "The body parameter must be valid for perfect forwarding; std::forward<F>(body) must produce a valid callable object that can be invoked by the implementation function."
formal_spec = "is_callable(body) && (is_lvalue_reference<F> || is_rvalue_reference<F>)"
layer = "library"
function = "for_loop_range_typed"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or compilation error if body type is not compatible with forward semantics"
confidence = 0.75

[[axioms]]
id = "for_loop_range_typed_body_predicate_wellformed_c3d4e5f6"
content = "The body callable must accept elements from the range and produce a well-formed result that models boolean-testable or is compatible with the expected result type R."
formal_spec = "for_all(element, range) => well_formed(body(element)) && compatible_with_result_type<decltype(body(element)), R>"
layer = "library"
function = "for_loop_range_typed"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or undefined behavior if body cannot be invoked with range elements"
confidence = 0.85

[[axioms]]
id = "for_loop_range_typed_range_denotes_valid_range_d4e5f6a7"
content = "The range parameter must denote a valid range with begin and end iterators where [begin, end) is a valid iterator range."
formal_spec = "has_begin_end(range) && valid_iterator_range(begin(range), end(range))"
layer = "library"
function = "for_loop_range_typed"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior if range does not satisfy iterator requirements"
confidence = 0.8

[[axioms]]
id = "for_loop_range_ret_simple_forward_range_valid_a1b2c3d4"
content = "std::forward<Range>(range) requires that range is a valid reference to forward, preserving value category for perfect forwarding to the implementation function."
formal_spec = "std::forward<Range>(range) => is_valid_reference(range) && preserves_value_category<Range>(range)"
layer = "library"
function = "for_loop_range_ret_simple"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior due to invalid reference forwarding"
confidence = 0.7

[[axioms]]
id = "for_loop_range_ret_simple_forward_body_valid_e5f6a7b8"
content = "std::forward<F>(body) requires that body is a valid callable reference to forward, preserving value category for perfect forwarding to the implementation function."
formal_spec = "std::forward<F>(body) => is_valid_reference(body) && preserves_value_category<F>(body) && is_callable<F>"
layer = "library"
function = "for_loop_range_ret_simple"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior due to invalid reference forwarding or non-callable object"
confidence = 0.7

[[axioms]]
id = "for_loop_range_ret_simple_impl_call_requires_valid_args_c9d8e7f6"
content = "Call to detail::for_loop_range_ret_simple_impl<N> requires that the forwarded range supports iteration and the forwarded body is callable with range elements."
formal_spec = "detail::for_loop_range_ret_simple_impl<N>(std::forward<Range>(range), std::forward<F>(body)) => supports_iteration<Range> && is_callable_with_range_elements<F, Range>"
layer = "library"
function = "for_loop_range_ret_simple"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or undefined behavior if range is not iterable or body cannot accept range elements"
confidence = 0.75

[[axioms]]
id = "for_loop_auto_forward_body_perfect_forwarding_a1b2c3d4"
content = "std::forward<F>(body) must preserve the value category of body: forwards as lvalue if body is lvalue, as rvalue if body is rvalue reference"
formal_spec = "std::forward<F>(body) => (is_lvalue_reference<F> => returns_lvalue_reference) && (is_rvalue_reference<F> => returns_rvalue_reference)"
layer = "library"
function = "for_loop_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "constraint"
on_violation = "incorrect value category propagation, potential copy instead of move or incorrect reference binding"

[[axioms]]
id = "for_loop_auto_range_validity_precond_e5f6a7b8"
content = "The range [start, end) must form a valid range where start <= end for the type T, as required by the delegated for_loop function"
formal_spec = "for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)) => start <= end"
layer = "library"
function = "for_loop_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or empty loop depending on for_loop implementation"
confidence = 0.8

[[axioms]]
id = "for_loop_auto_body_callable_precond_c2d3e4f5"
content = "The forwarded body must be callable with the signature expected by for_loop<optimal_N<LT, ElementT>>, typically accepting iteration parameters"
formal_spec = "for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)) => is_invocable<F, loop_iteration_params>"
layer = "library"
function = "for_loop_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or runtime error depending on template instantiation"
confidence = 0.9

[[axioms]]
id = "for_loop_typed_auto_body_forward_valid_f4a7b2c9"
content = "The body parameter must be a valid forwarding reference that can be forwarded using std::forward<F>. The type F must satisfy the requirements for perfect forwarding."
formal_spec = "std::forward<F>(body) => is_valid_forwarding_reference<F&&> && decltype(body) is_assignable_to F"
layer = "library"
function = "for_loop_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "Compilation error if F is not a valid forwarding reference type"
confidence = 0.7

[[axioms]]
id = "for_loop_typed_auto_range_valid_e8c1d5a3"
content = "The start and end parameters must form a valid range where start <= end for the iteration to be well-defined. The type T must be comparable and support the operations required by for_loop_typed."
formal_spec = "for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)) => start <= end && is_integral_or_iterator<T>"
layer = "library"
function = "for_loop_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "Undefined behavior or incorrect iteration if start > end; behavior depends on for_loop_typed implementation"
confidence = 0.75

[[axioms]]
id = "for_loop_typed_auto_body_callable_d2f9a6b4"
content = "The body callable must be invocable with the loop iteration parameter and return a type compatible with R. The expression body(iteration_value) must be well-formed."
formal_spec = "for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)) => is_invocable<F, decltype(iteration_value)> && convertible_to<invoke_result_t<F, decltype(iteration_value)>, R>"
layer = "library"
function = "for_loop_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "Compilation error if body is not invocable with the iteration parameter or return type is incompatible"
confidence = 0.85

[[axioms]]
id = "for_loop_range_auto_forward_range_validity_c4f8e2a1"
content = "std::forward<Range>(range) must produce a valid rvalue reference to Range, preserving the value category of the original range argument for perfect forwarding to for_loop_range."
formal_spec = "std::forward<Range>(range) => is_valid_forward<Range>(range) && preserves_value_category(range)"
layer = "library"
function = "for_loop_range_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior: incorrect forwarding may lead to dangling references or improper move semantics"
confidence = 0.9

[[axioms]]
id = "for_loop_range_auto_forward_body_validity_d5a9f3b2"
content = "std::forward<F>(body) must produce a valid rvalue reference to F, preserving the value category of the original body functor for perfect forwarding to for_loop_range."
formal_spec = "std::forward<F>(body) => is_valid_forward<F>(body) && preserves_value_category(body)"
layer = "library"
function = "for_loop_range_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior: incorrect forwarding may lead to dangling references or improper move semantics"
confidence = 0.9

[[axioms]]
id = "for_loop_range_auto_delegated_preconditions_e6b1c4d3"
content = "The call to for_loop_range<optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body)) inherits all preconditions from for_loop_range, including that range must be a valid range and body must be a callable accepting range elements."
formal_spec = "for_loop_range<optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body)) => valid_range(range) && callable<F, element_type<Range>>"
layer = "library"
function = "for_loop_range_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior or compilation error: delegated function preconditions violated"
confidence = 0.85

[[axioms]]
id = "for_loop_range_typed_auto_forward_range_a1b2c3d4"
content = "std::forward<Range>(range) requires that Range is a valid reference type to preserve value category and avoid dangling references when forwarding the range parameter"
formal_spec = "std::forward<Range>(range) => is_reference<Range> || is_rvalue_reference<Range&&>"
layer = "library"
function = "for_loop_range_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior - may create dangling references or incorrect value category"
confidence = 0.85

[[axioms]]
id = "for_loop_range_typed_auto_forward_body_b2c3d4e5"
content = "std::forward<F>(body) requires that F is a valid reference type to preserve value category and avoid dangling references when forwarding the body functor parameter"
formal_spec = "std::forward<F>(body) => is_reference<F> || is_rvalue_reference<F&&>"
layer = "library"
function = "for_loop_range_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "undefined behavior - may create dangling references or incorrect value category"
confidence = 0.85

[[axioms]]
id = "for_loop_range_typed_auto_delegated_precond_c3d4e5f6"
content = "for_loop_range_typed<R, optimal_N<LT, ElementT>> call requires that the forwarded range is a valid range with accessible begin/end iterators and that body is a callable accepting range elements"
formal_spec = "for_loop_range_typed<R, optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body)) => valid_range(range) && has_begin_end(range) && callable(body, element_type<Range>)"
layer = "library"
function = "for_loop_range_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "precondition"
on_violation = "compilation error or undefined behavior depending on template instantiation constraints"
confidence = 0.75

[[axioms]]
id = "for_loop_range_typed_auto_optimal_n_valid_d4e5f6a7"
content = "optimal_N<LT, ElementT> template parameter requires that LT and ElementT are valid types that allow computation of optimal unroll factor"
formal_spec = "for_loop_range_typed<R, optimal_N<LT, ElementT>>(...) => is_complete_type<LT> && is_complete_type<ElementT> && valid_optimal_n<LT, ElementT>"
layer = "library"
function = "for_loop_range_typed_auto"
header = "../../cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
axiom_type = "constraint"
on_violation = "compilation error - template instantiation failure"
confidence = 0.7

