version = "1.0"
source = "eel.is/c++draft"
extracted_at = "2025-12-30T02:09:16.597755+00:00"

[[axioms]]
id = "cpp20_container_reqmts_value_type_erasable_a1b2c3d4"
content = '''Container value_type T must be Cpp17Erasable from container X.'''
formal_spec = '''container(X) && value_type(X, T) => Cpp17Erasable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/2-3"
tags = ['container', 'requirements', 'precondition', 'erasable']

[[axioms]]
id = "cpp20_container_reqmts_copy_ctor_precondition_b2c3d4e5"
content = '''Copy constructing a container requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''copy_construct(container(X)) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/12"
tags = ['container', 'requirements', 'precondition', 'copy']

[[axioms]]
id = "cpp20_container_reqmts_equality_precondition_c3d4e5f6"
content = '''Container equality comparison requires T to meet Cpp17EqualityComparable requirements.'''
formal_spec = '''equality_compare(container(X, T)) => Cpp17EqualityComparable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/42"
tags = ['container', 'requirements', 'precondition', 'equality']

[[axioms]]
id = "cpp20_container_reqmts_swap_allocator_ub_d4e5f6a7"
content = '''Swapping containers with unequal allocators when propagate_on_container_swap is false is undefined behavior.'''
formal_spec = '''swap(container(a), container(b)) && !propagate_on_container_swap(allocator_type) && a.get_allocator() != b.get_allocator() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/65"
tags = ['container', 'swap', 'allocator', 'undefined-behavior']

[[axioms]]
id = "cpp20_container_reqmts_insert_single_exception_safety_e5f6a7b8"
content = '''If an exception is thrown by insert() or emplace() while inserting a single element, the function has no effects (strong exception guarantee).'''
formal_spec = '''(insert_single(container, elem) || emplace_single(container, args)) && throws_exception => no_effects'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.1"
tags = ['container', 'exception-safety', 'insert', 'emplace']

[[axioms]]
id = "cpp20_container_reqmts_push_exception_safety_f6a7b8c9"
content = '''If an exception is thrown by push_back(), push_front(), emplace_back(), or emplace_front(), the function has no effects (strong exception guarantee).'''
formal_spec = '''(push_back(container) || push_front(container) || emplace_back(container) || emplace_front(container)) && throws_exception => no_effects'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.2"
tags = ['container', 'exception-safety', 'push']

[[axioms]]
id = "cpp20_container_reqmts_erase_nothrow_a7b8c9d0"
content = '''Container erase(), clear(), pop_back(), and pop_front() functions do not throw exceptions.'''
formal_spec = '''(erase(container) || clear(container) || pop_back(container) || pop_front(container)) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.3"
tags = ['container', 'exception-safety', 'erase', 'nothrow']

[[axioms]]
id = "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1"
content = '''No copy constructor or assignment operator of a returned container iterator throws an exception.'''
formal_spec = '''(copy_construct(iterator) || copy_assign(iterator)) && is_container_iterator(iterator) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.4"
tags = ['container', 'iterator', 'exception-safety', 'nothrow']

[[axioms]]
id = "cpp20_container_reqmts_swap_nothrow_c9d0e1f2"
content = '''Container swap() function does not throw an exception.'''
formal_spec = '''swap(container) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.5"
tags = ['container', 'swap', 'exception-safety', 'nothrow']

[[axioms]]
id = "cpp20_container_reqmts_swap_no_invalidate_d0e1f2a3"
content = '''Container swap() does not invalidate any references, pointers, or iterators referring to elements of the swapped containers (end() iterator may be invalidated).'''
formal_spec = '''swap(container(a), container(b)) => valid(element_references(a)) && valid(element_references(b))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.6"
tags = ['container', 'swap', 'iterator-validity']

[[axioms]]
id = "cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4"
content = '''Container allocator_type::value_type must be the same as container value_type.'''
formal_spec = '''allocator_aware_container(X) => allocator_type(X)::value_type == value_type(X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/5"
tags = ['container', 'allocator', 'mandates']

[[axioms]]
id = "cpp20_container_alloc_reqmts_default_ctor_precondition_f2a3b4c5"
content = '''Default constructing an allocator-aware container requires the allocator type to meet Cpp17DefaultConstructible requirements.'''
formal_spec = '''default_construct(allocator_aware_container(X)) => Cpp17DefaultConstructible(allocator_type(X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/8"
tags = ['container', 'allocator', 'precondition', 'default-constructor']

[[axioms]]
id = "cpp20_container_alloc_reqmts_copy_ctor_alloc_precondition_a3b4c5d6"
content = '''Copy constructing an allocator-aware container with a specified allocator requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''copy_construct_with_allocator(allocator_aware_container(X), m) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/13"
tags = ['container', 'allocator', 'precondition', 'copy']

[[axioms]]
id = "cpp20_container_alloc_reqmts_move_ctor_alloc_precondition_b4c5d6e7"
content = '''Move constructing an allocator-aware container with a different allocator requires T to be Cpp17MoveInsertable into X.'''
formal_spec = '''move_construct_with_allocator(allocator_aware_container(X), rv, m) => Cpp17MoveInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/18"
tags = ['container', 'allocator', 'precondition', 'move']

[[axioms]]
id = "cpp20_container_alloc_reqmts_copy_assign_precondition_c5d6e7f8"
content = '''Copy assignment of an allocator-aware container requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.'''
formal_spec = '''copy_assign(allocator_aware_container(X)) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/22"
tags = ['container', 'allocator', 'precondition', 'copy-assignment']

[[axioms]]
id = "cpp20_container_alloc_reqmts_move_assign_precondition_d6e7f8a9"
content = '''Move assignment of an allocator-aware container requires T to be Cpp17MoveInsertable and Cpp17MoveAssignable if propagate_on_container_move_assignment is false.'''
formal_spec = '''move_assign(allocator_aware_container(X)) && !propagate_on_container_move_assignment(allocator_type) => Cpp17MoveInsertable(T, X) && Cpp17MoveAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/26"
tags = ['container', 'allocator', 'precondition', 'move-assignment']

[[axioms]]
id = "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0"
content = '''Implementations must avoid data races when contents of different elements in the same container are modified concurrently (except for vector<bool>).'''
formal_spec = '''container(X) && !is_vector_bool(X) && modify_concurrent(element(i), element(j)) && i != j => no_data_race'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.requirements.dataraces"
source_module = "[container.requirements.dataraces]/2"
tags = ['container', 'concurrency', 'data-race']

[[axioms]]
id = "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1"
content = '''For vector<bool>, modifying different elements concurrently can result in a data race (exception to general container rule).'''
formal_spec = '''is_vector_bool(X) && modify_concurrent(element(i), element(j)) => possible_data_race'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.requirements.dataraces"
source_module = "[container.requirements.dataraces]/3"
tags = ['container', 'concurrency', 'data-race', 'vector-bool']

[[axioms]]
id = "cpp20_sequence_reqmts_n_copies_precondition_a9b0c1d2"
content = '''Constructing a sequence container with n copies of t requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''construct(sequence_container(X), n, t) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/5"
tags = ['sequence-container', 'precondition', 'copy']

[[axioms]]
id = "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3"
content = '''Constructing a sequence container from iterator range [i,j) requires T to be Cpp17EmplaceConstructible from *i.'''
formal_spec = '''construct(sequence_container(X), i, j) => Cpp17EmplaceConstructible(T, X, *i)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/8"
tags = ['sequence-container', 'precondition', 'iterator']
depends_on = ['cpp20_iterator_operations_distance_effects_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_il_precondition_c1d2e3f4"
content = '''Assignment from initializer_list requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.'''
formal_spec = '''assign(sequence_container(X), initializer_list) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/17"
tags = ['sequence-container', 'precondition', 'initializer-list']

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_precondition_d2e3f4a5"
content = '''Calling emplace(p, args) requires T to be Cpp17EmplaceConstructible from args. For vector, inplace_vector, and deque, T must also be Cpp17MoveInsertable and Cpp17MoveAssignable.'''
formal_spec = '''emplace(sequence_container(X), p, args) => Cpp17EmplaceConstructible(T, X, args) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => (Cpp17MoveInsertable(T, X) && Cpp17MoveAssignable(T)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/21"
tags = ['sequence-container', 'emplace', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_copy_precondition_e3f4a5b6"
content = '''Calling insert(p, t) requires T to be Cpp17CopyInsertable. For vector, inplace_vector, and deque, T must also be Cpp17CopyAssignable.'''
formal_spec = '''insert(sequence_container(X), p, t) => Cpp17CopyInsertable(T, X) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17CopyAssignable(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/25"
tags = ['sequence-container', 'insert', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_move_precondition_f4a5b6c7"
content = '''Calling insert(p, rv) requires T to be Cpp17MoveInsertable. For vector, inplace_vector, and deque, T must also be Cpp17MoveAssignable.'''
formal_spec = '''insert(sequence_container(X), p, rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17MoveAssignable(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/29"
tags = ['sequence-container', 'insert', 'precondition', 'move']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_n_precondition_a5b6c7d8"
content = '''Calling insert(p, n, t) requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.'''
formal_spec = '''insert(sequence_container(X), p, n, t) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/33"
tags = ['sequence-container', 'insert', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_range_no_self_b6c7d8e9"
content = '''Calling insert(p, i, j) with iterators i and j that are iterators into the container a is undefined behavior.'''
formal_spec = '''insert(sequence_container(a), p, i, j) && (is_iterator_into(i, a) || is_iterator_into(j, a)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/37"
tags = ['sequence-container', 'insert', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_range_rg_no_overlap_c7d8e9f0"
content = '''Calling insert_range(p, rg) requires that rg and the container a do not overlap.'''
formal_spec = '''insert_range(sequence_container(a), p, rg) && overlaps(rg, a) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/41"
tags = ['sequence-container', 'insert', 'precondition', 'range']

[[axioms]]
id = "cpp20_sequence_reqmts_erase_precondition_d8e9f0a1"
content = '''Calling erase(q) on vector, inplace_vector, and deque requires T to be Cpp17MoveAssignable.'''
formal_spec = '''erase(sequence_container(X), q) && (is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17MoveAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/46"
tags = ['sequence-container', 'erase', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_range_no_overlap_e9f0a1b2"
content = '''Calling assign(i, j) with iterators i and j that are iterators into the container a is undefined behavior.'''
formal_spec = '''assign(sequence_container(a), i, j) && (is_iterator_into(i, a) || is_iterator_into(j, a)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/58"
tags = ['sequence-container', 'assign', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_range_rg_no_overlap_f0a1b2c3"
content = '''Calling assign_range(rg) requires that rg and the container a do not overlap.'''
formal_spec = '''assign_range(sequence_container(a), rg) && overlaps(rg, a) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/62"
tags = ['sequence-container', 'assign', 'precondition', 'range']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_n_no_self_ref_a1b2c3d4"
content = '''Calling assign(n, t) requires that t is not a reference into the container a.'''
formal_spec = '''assign(sequence_container(a), n, t) && is_reference_into(t, a) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/67"
tags = ['sequence-container', 'assign', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_front_precondition_b2c3d4e5"
content = '''Calling front() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(front, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/72"
tags = ['sequence-container', 'front', 'precondition', 'hardened']
function = "front"
header = "<vector>"
signature = '''reference front()'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_back_precondition_c3d4e5f6"
content = '''Calling back() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(back, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/76"
tags = ['sequence-container', 'back', 'precondition', 'hardened']
function = "back"
header = "<vector>"
signature = '''reference back()'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_front_precondition_d4e5f6a7"
content = '''Calling emplace_front(args) requires T to be Cpp17EmplaceConstructible into X from args.'''
formal_spec = '''emplace_front(sequence_container(X), args) => Cpp17EmplaceConstructible(T, X, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/80"
tags = ['sequence-container', 'emplace_front', 'precondition']
function = "emplace_front"
header = "<deque>"
signature = '''reference emplace_front(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_back_precondition_e5f6a7b8"
content = '''Calling emplace_back(args) requires T to be Cpp17EmplaceConstructible into X from args. For vector, T must also be Cpp17MoveInsertable.'''
formal_spec = '''emplace_back(sequence_container(X), args) => Cpp17EmplaceConstructible(T, X, args) && (is_vector(X) => Cpp17MoveInsertable(T, X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/85"
tags = ['sequence-container', 'emplace_back', 'precondition']
function = "emplace_back"
header = "<vector>"
signature = '''reference emplace_back(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_push_front_copy_precondition_f6a7b8c9"
content = '''Calling push_front(t) requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''push_front(sequence_container(X), t) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/90"
tags = ['sequence-container', 'push_front', 'precondition']
function = "push_front"
header = "<deque>"
signature = '''void push_front(const T& t)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_push_front_move_precondition_a7b8c9d0"
content = '''Calling push_front(rv) requires T to be Cpp17MoveInsertable into X.'''
formal_spec = '''push_front(sequence_container(X), rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/94"
tags = ['sequence-container', 'push_front', 'precondition', 'move']
function = "push_front"
header = "<deque>"
signature = '''void push_front(T&& rv)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_push_back_copy_precondition_b8c9d0e1"
content = '''Calling push_back(t) requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''push_back(sequence_container(X), t) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/102"
tags = ['sequence-container', 'push_back', 'precondition']
function = "push_back"
header = "<vector>"
signature = '''void push_back(const T& t)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_push_back_move_precondition_c9d0e1f2"
content = '''Calling push_back(rv) requires T to be Cpp17MoveInsertable into X.'''
formal_spec = '''push_back(sequence_container(X), rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/106"
tags = ['sequence-container', 'push_back', 'precondition', 'move']
function = "push_back"
header = "<vector>"
signature = '''void push_back(T&& rv)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_sequence_reqmts_pop_front_precondition_d0e1f2a3"
content = '''Calling pop_front() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(pop_front, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/114"
tags = ['sequence-container', 'pop_front', 'precondition', 'hardened']
function = "pop_front"
header = "<deque>"
signature = '''void pop_front()'''

[[axioms]]
id = "cpp20_sequence_reqmts_pop_back_precondition_e1f2a3b4"
content = '''Calling pop_back() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(pop_back, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/118"
tags = ['sequence-container', 'pop_back', 'precondition', 'hardened']
function = "pop_back"
header = "<vector>"
signature = '''void pop_back()'''

[[axioms]]
id = "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5"
content = '''Calling operator[](n) on a container requires n < a.size() (hardened precondition).'''
formal_spec = '''call(operator[], container(a), n) && n >= a.size() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/122"
tags = ['sequence-container', 'subscript', 'precondition', 'hardened']
function = "operator[]"
header = "<vector>"
signature = '''reference operator[](size_type n)'''
depends_on = ['c11_c_typing_compatibility_syntax_operation_30a47902', 'cpp20_range_prim_size_result_integer_like_c5e7f9a1', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_sizeof_char_is_one_69c0d34e', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6"
content = '''Calling at(n) throws out_of_range if n >= a.size().'''
formal_spec = '''call(at, container(a), n) && n >= a.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/127"
tags = ['sequence-container', 'at', 'exception']
function = "at"
header = "<vector>"
signature = '''reference at(size_type n)'''
depends_on = ['c11_c_typing_compatibility_syntax_operation_30a47902', 'cpp20_range_prim_size_result_integer_like_c5e7f9a1', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_sizeof_char_is_one_69c0d34e', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_container_opt_reqmts_threeway_precondition_b4c5d6e7"
content = '''Container three-way comparison requires either T models three_way_comparable, or operator< is defined for T and is a total ordering relationship.'''
formal_spec = '''three_way_compare(container(X, T)) => (three_way_comparable(T) || (defined(operator<, T) && total_ordering(operator<, T)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.opt.reqmts"
source_module = "[container.opt.reqmts]/3"
tags = ['container', 'comparison', 'precondition']

[[axioms]]
id = "cpp20_container_node_pair_specialization_ub_c5d6e7f8"
content = '''If a user-defined specialization of pair exists for pair<const Key, T> or pair<Key, T>, where Key is the container's key_type and T is the container's mapped_type, the behavior of operations involving node handles is undefined.'''
formal_spec = '''user_specialization(pair<const Key, T>) || user_specialization(pair<Key, T>) => node_handle_operations_undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.overview"
source_module = "[container.node.overview]/4"
tags = ['container', 'node-handle', 'undefined-behavior', 'pair']

[[axioms]]
id = "cpp20_container_node_move_assign_precondition_d6e7f8a9"
content = '''Node handle move assignment requires either the target is empty, or propagate_on_container_move_assignment is true, or the allocators are equal.'''
formal_spec = '''move_assign(node_handle, nh) && alloc_.has_value() && !propagate_on_container_move_assignment && alloc_ != nh.alloc_ => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.cons"
source_module = "[container.node.cons]/2"
tags = ['container', 'node-handle', 'precondition', 'move-assignment']

[[axioms]]
id = "cpp20_container_node_value_precondition_e7f8a9b0"
content = '''Calling value() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(value, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/1"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::value"
header = "<map>"
signature = '''value_type& value() const'''
depends_on = ['cpp20_range_prim_data_rvalue_non_borrowed_illformed_a9c1d3e5', 'c11_cpp_conversion_syntax_convertType_33986b29', 'cpp20_optional_value_or_mandates_copy_convertible_d31e4bca', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_container_node_key_precondition_f8a9b0c1"
content = '''Calling key() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(key, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/4"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::key"
header = "<map>"
signature = '''key_type& key() const'''
depends_on = ['c11_typing_canonicalization_operation_31fc14ab', 'c11_c_decl_global_syntax_comparison_b1c4e110', 'c11_c_typing_effective_syntax_comparison_5b005edd', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_container_node_mapped_precondition_a9b0c1d2"
content = '''Calling mapped() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(mapped, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/8"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::mapped"
header = "<map>"
signature = '''mapped_type& mapped() const'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_container_node_get_allocator_precondition_b0c1d2e3"
content = '''Calling get_allocator() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(get_allocator, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/11"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::get_allocator"
header = "<map>"
signature = '''allocator_type get_allocator() const'''
depends_on = ['cpp20_allocator_requirements_allocate_at_least_count_geq_n_a9b0c1d2', 'cpp20_allocator_requirements_type_constraint_instantiation_d6e7f8a9', 'cpp20_allocator_requirements_overaligned_instantiation_e7f8a9b0']

[[axioms]]
id = "cpp20_container_node_swap_precondition_c1d2e3f4"
content = '''Swapping node handles requires either both are empty, or propagate_on_container_swap is true, or the allocators are equal.'''
formal_spec = '''swap(node_handle(nh1), node_handle(nh2)) && nh1.alloc_.has_value() && nh2.alloc_.has_value() && !propagate_on_container_swap && nh1.alloc_ != nh2.alloc_ => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.modifiers"
source_module = "[container.node.modifiers]/1"
tags = ['container', 'node-handle', 'precondition', 'swap']
