version = "1.0"
source = "eel.is/c++draft"
extracted_at = "2025-12-27T23:35:50.976952"

[[axioms]]
id = "cpp_stdlib_any_2969dc9a"
content = '''Default constructor creates an any object with no contained value'''
formal_spec = '''postcondition: has_value() == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any()"
header = "<any>"
axiom_type = "postcondition"
on_violation = '''N/A - always satisfied by conforming implementation'''

[[axioms]]
id = "cpp_stdlib_any_aeee95a4"
content = '''Copy constructor creates an empty any if other is empty, otherwise copies the contained value'''
formal_spec = '''if (!other.has_value()) { has_value() == false } else { equivalent to any(in_place_type<T>, any_cast<const T&>(other)) }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(const any&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - implementation defined'''

[[axioms]]
id = "cpp_stdlib_any_1cb5c032"
content = '''Copy constructor may throw exceptions from the contained value's copy constructor'''
formal_spec = '''throws: any exception from T(const T&) where T is contained type'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(const any&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated'''

[[axioms]]
id = "cpp_stdlib_any_6bc5c362"
content = '''Move constructor creates empty any if other is empty, otherwise moves or copies the contained value'''
formal_spec = '''noexcept; if (!other.has_value()) { has_value() == false } else { contains value moved from other }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(any&&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - noexcept'''

[[axioms]]
id = "cpp_stdlib_any_df71cef5"
content = '''Value constructor requires decayed type to be copy constructible and not any or in_place_type_t'''
formal_spec = '''requires: !is_same_v<decay_t<T>, any> && !is_specialization_v<decay_t<T>, in_place_type_t> && is_copy_constructible_v<decay_t<T>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(T&&)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_any_342ffd9e"
content = '''Value type must meet Cpp17CopyConstructible requirements'''
formal_spec = '''precondition: decay_t<T> meets Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(T&&)"
header = "<any>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_5a502632"
content = '''Value constructor direct-initializes contained value with forwarded argument'''
formal_spec = '''effect: contains object of type decay_t<T> direct-initialized with std::forward<T>(value)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(T&&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_b4d0c2d9"
content = '''Value constructor may throw from contained type's constructor'''
formal_spec = '''throws: any exception from decay_t<T> constructor'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(T&&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated'''

[[axioms]]
id = "cpp_stdlib_any_6d9174f9"
content = '''In-place constructor requires copy constructibility and constructibility from args'''
formal_spec = '''requires: is_copy_constructible_v<decay_t<T>> && is_constructible_v<decay_t<T>, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, Args&&...)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_any_342ffd9e"
content = '''Value type must meet Cpp17CopyConstructible requirements'''
formal_spec = '''precondition: decay_t<T> meets Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, Args&&...)"
header = "<any>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_c5b9bfd8"
content = '''After in-place construction, any contains a value of type VT'''
formal_spec = '''postcondition: has_value() == true && type() == typeid(decay_t<T>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, Args&&...)"
header = "<any>"
axiom_type = "postcondition"
on_violation = '''N/A - always satisfied'''

[[axioms]]
id = "cpp_stdlib_any_9f72c8b0"
content = '''In-place constructor may throw from contained type's constructor'''
formal_spec = '''throws: any exception from decay_t<T>(Args...) constructor'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, Args&&...)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated'''

[[axioms]]
id = "cpp_stdlib_any_10a45318"
content = '''In-place initializer_list constructor requires copy constructibility and constructibility from initializer_list and args'''
formal_spec = '''requires: is_copy_constructible_v<decay_t<T>> && is_constructible_v<decay_t<T>, initializer_list<U>&, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_any_342ffd9e"
content = '''Value type must meet Cpp17CopyConstructible requirements'''
formal_spec = '''precondition: decay_t<T> meets Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_cef783db"
content = '''After in-place construction with initializer_list, any contains a value'''
formal_spec = '''postcondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(in_place_type_t<T>, initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "postcondition"
on_violation = '''N/A - always satisfied'''

[[axioms]]
id = "cpp_stdlib_any_690960f6"
content = '''Destructor destroys contained value as if by reset()'''
formal_spec = '''effect: equivalent to reset()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::~any()"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_f8aefbe1"
content = '''Copy assignment copies via any(rhs).swap(*this), provides strong exception guarantee'''
formal_spec = '''effect: any(rhs).swap(*this); no effects if exception thrown'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(const any&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_70cc62a7"
content = '''Copy assignment may throw from contained value's copy constructor'''
formal_spec = '''throws: any exception from copy constructor of contained value'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(const any&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated, strong guarantee (no effects)'''

[[axioms]]
id = "cpp_stdlib_any_94b79833"
content = '''Move assignment moves via any(std::move(rhs)).swap(*this)'''
formal_spec = '''effect: any(std::move(rhs)).swap(*this); noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(any&&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - noexcept'''

[[axioms]]
id = "cpp_stdlib_any_309c2bdc"
content = '''After move assignment, state is equivalent to original state of rhs'''
formal_spec = '''postcondition: state of *this equivalent to original state of rhs'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(any&&)"
header = "<any>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_e699820f"
content = '''Value assignment requires decayed type to not be any and be copy constructible'''
formal_spec = '''requires: !is_same_v<decay_t<T>, any> && is_copy_constructible_v<decay_t<T>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(T&&)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_any_342ffd9e"
content = '''Value type must meet Cpp17CopyConstructible requirements'''
formal_spec = '''precondition: decay_t<T> meets Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(T&&)"
header = "<any>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_c75a6411"
content = '''Value assignment constructs temporary and swaps, provides strong exception guarantee'''
formal_spec = '''effect: any tmp(std::forward<T>(rhs)); tmp.swap(*this); no effects if exception thrown'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(T&&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_5727b48c"
content = '''Value assignment may throw from contained type's constructor'''
formal_spec = '''throws: any exception from decay_t<T> constructor'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::operator=(T&&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated, strong guarantee (no effects)'''

[[axioms]]
id = "cpp_stdlib_any_8cef573c"
content = '''Emplace requires copy constructibility and constructibility from args'''
formal_spec = '''requires: is_copy_constructible_v<decay_t<T>> && is_constructible_v<decay_t<T>, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(Args&&...)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_any_342ffd9e"
content = '''Value type must meet Cpp17CopyConstructible requirements'''
formal_spec = '''precondition: decay_t<T> meets Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(Args&&...)"
header = "<any>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_cc73ded1"
content = '''Emplace calls reset() then direct-initializes new contained value'''
formal_spec = '''effect: reset(); then direct-non-list-initialize contained value of type decay_t<T> with std::forward<Args>(args)...'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(Args&&...)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_4bb89bf3"
content = '''After emplace, any contains a value'''
formal_spec = '''postcondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(Args&&...)"
header = "<any>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_4877b37c"
content = '''Emplace may throw from constructor; if exception thrown, any has no value and previous value is destroyed'''
formal_spec = '''throws: any exception from decay_t<T> constructor; if thrown: has_value() == false && previous value destroyed'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(Args&&...)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated, any left empty (basic guarantee)'''

[[axioms]]
id = "cpp_stdlib_any_a57bf655"
content = '''Emplace with initializer_list requires copy constructibility and constructibility from initializer_list and args'''
formal_spec = '''requires: is_copy_constructible_v<decay_t<T>> && is_constructible_v<decay_t<T>, initializer_list<U>&, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_any_342ffd9e"
content = '''Value type must meet Cpp17CopyConstructible requirements'''
formal_spec = '''precondition: decay_t<T> meets Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_099f543b"
content = '''Emplace with initializer_list may throw from constructor; if exception thrown, any has no value'''
formal_spec = '''throws: any exception from decay_t<T> constructor; if thrown: has_value() == false && previous value destroyed'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::emplace<T>(initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "exception"
on_violation = '''exception propagated, any left empty (basic guarantee)'''

[[axioms]]
id = "cpp_stdlib_any_ee2ce4c2"
content = '''Reset destroys contained value if present'''
formal_spec = '''effect: if (has_value()) { destroy contained value }; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::reset()"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - noexcept'''

[[axioms]]
id = "cpp_stdlib_any_35ba156d"
content = '''After reset, any has no value'''
formal_spec = '''postcondition: has_value() == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::reset()"
header = "<any>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_906e4fe4"
content = '''Swap exchanges states of two any objects'''
formal_spec = '''effect: exchanges states of *this and rhs; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::swap(any&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - noexcept'''

[[axioms]]
id = "cpp_stdlib_any_e501de07"
content = '''has_value returns true if any contains an object'''
formal_spec = '''returns: true if *this contains an object, otherwise false; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::has_value()"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_3c7d889d"
content = '''type returns typeid of contained value or typeid(void) if empty'''
formal_spec = '''returns: has_value() ? typeid(T) : typeid(void) where T is contained type; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::type()"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_0db23f09"
content = '''Non-member swap is equivalent to x.swap(y)'''
formal_spec = '''effect: x.swap(y); noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "swap(any&, any&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - noexcept'''

[[axioms]]
id = "cpp_stdlib_any_f267c220"
content = '''make_any constructs any with in_place_type'''
formal_spec = '''effect: return any(in_place_type<T>, std::forward<Args>(args)...)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "make_any<T>(Args&&...)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_413c3cb9"
content = '''make_any with initializer_list constructs any with in_place_type'''
formal_spec = '''effect: return any(in_place_type<T>, il, std::forward<Args>(args)...)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "make_any<T>(initializer_list<U>, Args&&...)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_any_e3a1b1b4"
content = '''any_cast from const any& requires T to be constructible from const U&'''
formal_spec = '''mandates: is_constructible_v<T, const remove_cvref_t<T>&>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(const any&)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_any_09f796f0"
content = '''any_cast from any& requires T to be constructible from U&'''
formal_spec = '''mandates: is_constructible_v<T, remove_cvref_t<T>&>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any&)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_any_1814dacc"
content = '''any_cast from any&& requires T to be constructible from U'''
formal_spec = '''mandates: is_constructible_v<T, remove_cvref_t<T>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any&&)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_any_6b2a6e63"
content = '''any_cast throws bad_any_cast if type mismatch'''
formal_spec = '''throws: bad_any_cast if operand.type() != typeid(remove_reference_t<T>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(const any&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''throws bad_any_cast'''

[[axioms]]
id = "cpp_stdlib_any_6b2a6e63"
content = '''any_cast throws bad_any_cast if type mismatch'''
formal_spec = '''throws: bad_any_cast if operand.type() != typeid(remove_reference_t<T>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''throws bad_any_cast'''

[[axioms]]
id = "cpp_stdlib_any_6b2a6e63"
content = '''any_cast throws bad_any_cast if type mismatch'''
formal_spec = '''throws: bad_any_cast if operand.type() != typeid(remove_reference_t<T>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any&&)"
header = "<any>"
axiom_type = "exception"
on_violation = '''throws bad_any_cast'''

[[axioms]]
id = "cpp_stdlib_any_621c145e"
content = '''any_cast returns static_cast of dereferenced pointer cast'''
formal_spec = '''returns: static_cast<T>(*any_cast<remove_cvref_t<T>>(&operand))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(const any&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A (throws on type mismatch)'''

[[axioms]]
id = "cpp_stdlib_any_ebb07c3d"
content = '''any_cast from rvalue returns moved value'''
formal_spec = '''returns: static_cast<T>(std::move(*any_cast<remove_cvref_t<T>>(&operand)))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any&&)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A (throws on type mismatch)'''

[[axioms]]
id = "cpp_stdlib_any_d0220de5"
content = '''Pointer any_cast requires T to not be void'''
formal_spec = '''mandates: is_void_v<T> == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(const any*)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_any_d0220de5"
content = '''Pointer any_cast requires T to not be void'''
formal_spec = '''mandates: is_void_v<T> == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any*)"
header = "<any>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_any_5fdd9583"
content = '''Pointer any_cast returns pointer to contained value or nullptr'''
formal_spec = '''returns: (operand != nullptr && operand->type() == typeid(T)) ? pointer_to_contained : nullptr; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(const any*)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - returns nullptr on mismatch'''

[[axioms]]
id = "cpp_stdlib_any_5fdd9583"
content = '''Pointer any_cast returns pointer to contained value or nullptr'''
formal_spec = '''returns: (operand != nullptr && operand->type() == typeid(T)) ? pointer_to_contained : nullptr; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(any*)"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A - returns nullptr on mismatch'''

[[axioms]]
id = "cpp_stdlib_any_a1eed17d"
content = '''Small object optimization only applies to nothrow move constructible types'''
formal_spec = '''invariant: small_object_optimization implies is_nothrow_move_constructible_v<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any"
header = "<any>"
axiom_type = "invariant"
on_violation = '''implementation must use dynamic allocation'''

[[axioms]]
id = "cpp_stdlib_any_91ad39bb"
content = '''Casting to wrong type throws; prefer pointer overload for type checking'''
formal_spec = '''anti_pattern: any_cast<T>(a) when a.type() != typeid(T); prefer any_cast<T>(&a) != nullptr check'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any_cast<T>(const any&)"
header = "<any>"
axiom_type = "anti_pattern"
on_violation = '''throws bad_any_cast'''

[[axioms]]
id = "cpp_stdlib_any_7328cd37"
content = '''Storing move-only types in any is undefined behavior despite compilation'''
formal_spec = '''anti_pattern: any a = std::move(move_only_obj); // UB if type not Cpp17CopyConstructible'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "any::any(T&&)"
header = "<any>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_any_dc3f6071"
content = '''what() returns implementation-defined null-terminated byte string'''
formal_spec = '''returns: implementation-defined ntbs; noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/any"
source_module = "any"
c_standard_refs = ['[any]']
function = "bad_any_cast::what()"
header = "<any>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_optional_1b69916b"
content = '''Default constructor creates an optional that does not contain a value'''
formal_spec = '''postcondition: !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional()"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_e975f0bd"
content = '''Constructor from nullopt creates an optional that does not contain a value'''
formal_spec = '''postcondition: !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(nullopt_t)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_ef3f5043"
content = '''Copy constructor preserves has_value() state from source'''
formal_spec = '''postcondition: rhs.has_value() == this->has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(const optional&)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_f03f5f88"
content = '''Copy constructor direct-non-list-initializes val with rhs.val if rhs contains a value'''
formal_spec = '''effects: if (rhs.has_value()) { direct-non-list-initialize(val, rhs.val); }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(const optional&)"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_e61618fd"
content = '''Copy constructor throws any exception thrown by the selected constructor of T'''
formal_spec = '''throws: T::T(const T&) exceptions'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(const optional&)"
header = "<optional>"
axiom_type = "exception"
on_violation = '''exception propagation'''

[[axioms]]
id = "cpp_stdlib_optional_a31c7bb6"
content = '''Copy constructor is deleted unless is_copy_constructible_v<T> is true'''
formal_spec = '''requires: is_copy_constructible_v<T> || deleted'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(const optional&)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_3459047e"
content = '''Move constructor requires is_move_constructible_v<T> is true'''
formal_spec = '''constraint: is_move_constructible_v<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(optional&&)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_optional_83760623"
content = '''Move constructor preserves has_value() state; rhs.has_value() is unchanged'''
formal_spec = '''postcondition: rhs.has_value() == this->has_value() && rhs.has_value() == old(rhs.has_value())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(optional&&)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_659afe99"
content = '''Move constructor is noexcept if is_nothrow_move_constructible_v<T> is true'''
formal_spec = '''noexcept(is_nothrow_move_constructible_v<T>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(optional&&)"
header = "<optional>"
axiom_type = "exception"
on_violation = '''exception propagation if not noexcept'''

[[axioms]]
id = "cpp_stdlib_optional_e32c568f"
content = '''In-place constructor requires is_constructible_v<T, Args...> is true'''
formal_spec = '''constraint: is_constructible_v<T, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(in_place_t, Args&&...)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_optional_d9542d92"
content = '''In-place constructor creates an optional that contains a value'''
formal_spec = '''postcondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(in_place_t, Args&&...)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_a95b49ec"
content = '''In-place initializer_list constructor requires is_constructible_v<T, initializer_list<U>&, Args...> is true'''
formal_spec = '''constraint: is_constructible_v<T, initializer_list<U>&, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(in_place_t, initializer_list<U>, Args&&...)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_optional_8df03b26"
content = '''In-place initializer_list constructor creates an optional that contains a value'''
formal_spec = '''postcondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(in_place_t, initializer_list<U>, Args&&...)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_e667b987"
content = '''Converting constructor from U requires: is_constructible_v<T, U>, U is not in_place_t, U is not optional, and if T is cv bool, U is not optional specialization'''
formal_spec = '''constraint: is_constructible_v<T, U> && !is_same_v<remove_cvref_t<U>, in_place_t> && !is_same_v<remove_cvref_t<U>, optional> && !(is_bool<T> && is_optional<remove_cvref_t<U>>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(U&&)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_optional_6bbbdfb7"
content = '''Converting constructor creates an optional that contains a value'''
formal_spec = '''postcondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(U&&)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_b35797d9"
content = '''Converting constructor from optional<U> requires is_constructible_v<T, const U&> and (if T is not cv bool) converts-from-any-cvref is false'''
formal_spec = '''constraint: is_constructible_v<T, const U&> && (!is_bool<T> || !converts_from_any_cvref<T, optional<U>>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(const optional<U>&)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_optional_8ca2d75c"
content = '''Converting constructor preserves has_value() state from source'''
formal_spec = '''postcondition: rhs.has_value() == this->has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(const optional<U>&)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_81d6a8ca"
content = '''Converting constructor from optional<U>&& requires is_constructible_v<T, U> and (if T is not cv bool) converts-from-any-cvref is false'''
formal_spec = '''constraint: is_constructible_v<T, U> && (!is_bool<T> || !converts_from_any_cvref<T, optional<U>>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(optional<U>&&)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_optional_63cd927d"
content = '''Converting move constructor preserves has_value() state; rhs.has_value() is unchanged'''
formal_spec = '''postcondition: rhs.has_value() == this->has_value() && rhs.has_value() == old(rhs.has_value())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional(optional<U>&&)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_282aa6ca"
content = '''Destructor calls val.~T() if is_trivially_destructible_v<T> is false and *this contains a value'''
formal_spec = '''effects: if (!is_trivially_destructible_v<T> && has_value()) { val.~T(); }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "~optional()"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_914da1bd"
content = '''T must be a valid contained type: lvalue reference or complete non-array object type, and remove_cvref_t<T> not in_place_t or nullopt_t'''
formal_spec = '''constraint: (is_lvalue_reference_v<T> || (is_object_v<T> && !is_array_v<T>)) && !is_same_v<remove_cvref_t<T>, in_place_t> && !is_same_v<remove_cvref_t<T>, nullopt_t>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_f97690fa"
content = '''If T is an object type, T shall meet the Cpp17Destructible requirements'''
formal_spec = '''requires: is_object_v<T> => Cpp17Destructible<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_54fd6b0a"
content = '''An optional object tracks whether it contains a value; the contained value (if any) is nested within the optional object'''
formal_spec = '''invariant: has_value() <=> val is active'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional"
header = "<optional>"
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_76bd020b"
content = '''Calling operator-> requires that the optional contains a value'''
formal_spec = '''precondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator->"
header = "<optional>"
axiom_type = "precondition"
on_violation = '''undefined behavior (hardened precondition)'''

[[axioms]]
id = "cpp_stdlib_optional_fec693a5"
content = '''Calling operator* requires that the optional contains a value'''
formal_spec = '''precondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator*"
header = "<optional>"
axiom_type = "precondition"
on_violation = '''undefined behavior (hardened precondition)'''

[[axioms]]
id = "cpp_stdlib_optional_0edcf72b"
content = '''Conversion to bool returns true if and only if optional contains a value'''
formal_spec = '''postcondition: returns has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator bool"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_9fcb08b0"
content = '''Calling value() on an optional that does not contain a value throws bad_optional_access'''
formal_spec = '''throws: !has_value() => throw bad_optional_access()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "value"
header = "<optional>"
axiom_type = "exception"
on_violation = '''throws bad_optional_access'''

[[axioms]]
id = "cpp_stdlib_optional_e4d301e9"
content = '''Calling value_or(U&&) on const& optional mandates is_copy_constructible_v<T> && is_convertible_v<U&&, T>'''
formal_spec = '''mandates: is_copy_constructible_v<T> && is_convertible_v<U&&, T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "value_or"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_771d9e04"
content = '''Calling value_or(U&&) on rvalue optional mandates is_move_constructible_v<T> && is_convertible_v<U&&, T>'''
formal_spec = '''mandates: is_move_constructible_v<T> && is_convertible_v<U&&, T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "value_or"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_a842f40a"
content = '''value_or returns the contained value if present, otherwise returns the provided default converted to T'''
formal_spec = '''returns: has_value() ? *(*this) : static_cast<T>(std::forward<U>(v))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "value_or"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_02fab824"
content = '''and_then(F) mandates that invoke_result_t<F, ...> is a specialization of optional'''
formal_spec = '''mandates: is_specialization_of_v<remove_cvref_t<invoke_result_t<F, decltype(*this)>>, optional>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "and_then"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_6af37845"
content = '''and_then(F) invokes f with the contained value if present, otherwise returns empty optional of the result type'''
formal_spec = '''returns: has_value() ? invoke(std::forward<F>(f), *(*this)) : remove_cvref_t<invoke_result_t<F, ...>>{}'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "and_then"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_da1fd008"
content = '''transform(F) mandates that the result type U is a valid contained type for optional'''
formal_spec = '''mandates: is_valid_contained_type<remove_cv_t<invoke_result_t<F, ...>>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "transform"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_b8c96801"
content = '''transform(F) returns optional containing f(*this) if has_value(), otherwise empty optional of result type'''
formal_spec = '''returns: has_value() ? optional<U>(invoke(std::forward<F>(f), *(*this))) : optional<U>{}'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "transform"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_4042f86a"
content = '''or_else(F) mandates that invoke_result_t<F> is the same type as this optional'''
formal_spec = '''mandates: is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "or_else"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_8ceca9ee"
content = '''or_else(F) returns *this if has_value(), otherwise invokes f and returns its result'''
formal_spec = '''returns: has_value() ? std::move(*this) : std::forward<F>(f)()'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "or_else"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_53f5656a"
content = '''reset() destroys the contained value if present and leaves optional in empty state'''
formal_spec = '''effects: if (has_value()) { val.~T(); } postcondition: !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "reset"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_59416ac9"
content = '''emplace(Args...) mandates that is_constructible_v<T, Args...> is true'''
formal_spec = '''mandates: is_constructible_v<T, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "emplace"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_aad4f7df"
content = '''emplace destroys existing value (if any) and constructs new value in-place'''
formal_spec = '''effects: reset(); direct-non-list-initialize(val, std::forward<Args>(args)...)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "emplace"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_f97b9ee5"
content = '''emplace returns reference to newly constructed value'''
formal_spec = '''postcondition: has_value() == true; returns: val'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "emplace"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_f7506311"
content = '''If exception is thrown during emplace, optional does not contain a value and previous value has been destroyed'''
formal_spec = '''exception_guarantee: if (exception_thrown) { !has_value() && old_value_destroyed }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "emplace"
header = "<optional>"
axiom_type = "exception"
on_violation = '''exception propagation, optional left empty'''

[[axioms]]
id = "cpp_stdlib_optional_ade292ae"
content = '''Assignment from nullopt leaves optional without a value'''
formal_spec = '''postcondition: !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator=(nullopt_t)"
header = "<optional>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_fccc7892"
content = '''swap mandates that is_move_constructible_v<T> is true'''
formal_spec = '''mandates: is_move_constructible_v<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "swap"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_optional_789ba9c3"
content = '''swap requires that T meets the Cpp17Swappable requirements'''
formal_spec = '''precondition: Cpp17Swappable<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "swap"
header = "<optional>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_optional_689c9a3a"
content = '''If exception is thrown during swap, has_value() state of both optionals remains unchanged'''
formal_spec = '''exception_guarantee: if (exception_thrown) { this->has_value() == old(this->has_value()) && rhs.has_value() == old(rhs.has_value()) }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "swap"
header = "<optional>"
axiom_type = "exception"
on_violation = '''exception propagation, has_value states preserved'''

[[axioms]]
id = "cpp_stdlib_optional_6b4c1d38"
content = '''begin() returns iterator to contained value if present, otherwise returns end()'''
formal_spec = '''returns: has_value() ? addressof(val) : nullptr (as iterator)'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "begin"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_412a1589"
content = '''end() returns iterator one past the contained value (or same as begin() if empty)'''
formal_spec = '''returns: begin() + has_value()'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "end"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_6acf135f"
content = '''Any operation that initializes or destroys the contained value invalidates all iterators into that optional'''
formal_spec = '''invariant: (initialize_contained_value(opt) || destroy_contained_value(opt)) => invalidates_all_iterators(opt)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "optional iterators"
header = "<optional>"
axiom_type = "invariant"
on_violation = '''undefined behavior if invalidated iterators are used'''

[[axioms]]
id = "cpp_stdlib_optional_7dff35d2"
content = '''Two optionals are equal if both are empty, or both contain values that compare equal'''
formal_spec = '''returns: (!x.has_value() && !y.has_value()) || (x.has_value() && y.has_value() && *x == *y)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator=="
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_55bbd68d"
content = '''Empty optional compares less than engaged optional; two engaged optionals compare their values'''
formal_spec = '''returns: y.has_value() && (!x.has_value() || *x < *y)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator<"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_16649e47"
content = '''optional equals nullopt if and only if it does not contain a value'''
formal_spec = '''returns: !x.has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator==(optional, nullopt_t)"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_ee87f541"
content = '''Three-way comparison with nullopt returns strong_ordering based on has_value()'''
formal_spec = '''returns: x.has_value() <=> false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator<=>(optional, nullopt_t)"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_8c0cb2eb"
content = '''Comparison with T value only participates in overload resolution if U is not derived from optional'''
formal_spec = '''constraint: !is-derived-from-optional<U>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator==(optional<T>, U)"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''overload not considered'''

[[axioms]]
id = "cpp_stdlib_optional_459a806e"
content = '''make_optional creates an optional containing decay_t<T> initialized from the argument'''
formal_spec = '''returns: optional<decay_t<T>>(std::forward<T>(v))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "make_optional(T&&)"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_2fca15b1"
content = '''make_optional with explicit type constructs T in-place from arguments'''
formal_spec = '''returns: optional<T>(in_place, std::forward<Args>(args)...)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "make_optional<T>(Args&&...)"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_67f0a6c8"
content = '''hash<optional<T>> is enabled only if hash<remove_const_t<T>> is enabled'''
formal_spec = '''constraint: hash<remove_const_t<T>> is enabled'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "hash<optional<T>>"
header = "<optional>"
axiom_type = "constraint"
on_violation = '''hash specialization disabled'''

[[axioms]]
id = "cpp_stdlib_optional_6ee09c75"
content = '''hash of engaged optional equals hash of contained value; hash of disengaged optional is unspecified but consistent'''
formal_spec = '''returns: o.has_value() ? hash<remove_const_t<T>>()(*o) : unspecified_but_consistent'''
layer = "cpp_stdlib"
confidence = 0.8
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "hash<optional<T>>"
header = "<optional>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_optional_dc5a057f"
content = '''Dereferencing an empty optional leads to undefined behavior; always check has_value() or use value()/value_or() for safe access'''
formal_spec = '''anti_pattern: *opt without prior check of has_value() or implicit bool conversion'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator*"
header = "<optional>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_optional_941f603d"
content = '''Using operator-> on an empty optional leads to undefined behavior; always check has_value() first'''
formal_spec = '''anti_pattern: opt->member without prior check of has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "operator->"
header = "<optional>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_optional_d06161dc"
content = '''Calling value() without checking has_value() may throw bad_optional_access at runtime; prefer value_or() when a default is acceptable'''
formal_spec = '''anti_pattern: opt.value() in performance-critical code without prior has_value() check'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/optional"
source_module = "optional"
c_standard_refs = ['[optional]']
function = "value"
header = "<optional>"
axiom_type = "anti_pattern"
on_violation = '''throws bad_optional_access'''

[[axioms]]
id = "cpp_stdlib_expected_d7155a39"
content = '''unexpected cannot be instantiated with non-object types, array types, specializations of unexpected, or cv-qualified types'''
formal_spec = '''requires: is_object_v<E> && !is_array_v<E> && !is_specialization_of_unexpected_v<E> && is_same_v<E, remove_cv_t<E>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_3a14f6c8"
content = '''Single-argument constructor requires Err is not unexpected or in_place_t, and E is constructible from Err'''
formal_spec = '''requires: !is_same_v<remove_cvref_t<Err>, unexpected> && !is_same_v<remove_cvref_t<Err>, in_place_t> && is_constructible_v<E, Err>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::unexpected(Err&&)"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_expected_25e768c3"
content = '''Direct-non-list-initializes the stored error with forwarded argument'''
formal_spec = '''effects: unex is direct-non-list-initialized with std::forward<Err>(e)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::unexpected(Err&&)"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_05d103cc"
content = '''Throws any exception thrown by the initialization of the stored error'''
formal_spec = '''throws: any exception thrown by initialization of unex'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::unexpected(Err&&)"
header = "<expected>"
axiom_type = "exception"
on_violation = '''exception propagates'''

[[axioms]]
id = "cpp_stdlib_expected_ff41cd6e"
content = '''In-place constructor requires E is constructible from Args'''
formal_spec = '''requires: is_constructible_v<E, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::unexpected(in_place_t, Args&&...)"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_expected_b058e222"
content = '''In-place constructor with initializer_list requires E is constructible from initializer_list and Args'''
formal_spec = '''requires: is_constructible_v<E, initializer_list<U>&, Args...>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::unexpected(in_place_t, initializer_list<U>, Args&&...)"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_expected_8d456748"
content = '''Returns reference to stored error value'''
formal_spec = '''returns: unex'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::error()"
header = "<expected>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_ff456b72"
content = '''Member swap requires E is swappable'''
formal_spec = '''mandates: is_swappable_v<E>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::swap"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_e047c421"
content = '''Swaps stored error values using ADL swap'''
formal_spec = '''effects: using std::swap; swap(unex, other.unex)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::swap"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_dc4e69f9"
content = '''Equality comparison requires error() == error() is well-formed and convertible to bool'''
formal_spec = '''mandates: x.error() == y.error() is well-formed && is_convertible_v<decltype(x.error() == y.error()), bool>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "unexpected::operator=="
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_164c3395"
content = '''bad_expected_access is thrown when accessing value of expected that contains an error'''
formal_spec = '''thrown when: has_value() == false && value() is called'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "bad_expected_access"
header = "<expected>"
axiom_type = "exception"
on_violation = '''exception propagates'''

[[axioms]]
id = "cpp_stdlib_expected_22503fe7"
content = '''Initializes stored error by moving from argument'''
formal_spec = '''effects: unex is initialized with std::move(e)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "bad_expected_access::bad_expected_access(E)"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_240c1a49"
content = '''T must be void or a complete non-array object type that is not in_place_t, unexpect_t, or unexpected specialization'''
formal_spec = '''requires: is_void_v<remove_cv_t<T>> || (is_object_v<T> && !is_array_v<T> && !is_same_v<remove_cv_t<T>, in_place_t> && !is_same_v<remove_cv_t<T>, unexpect_t> && !is_specialization_of_unexpected_v<remove_cv_t<T>>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_cf727b8b"
content = '''E must be a valid template argument for unexpected'''
formal_spec = '''requires: is_object_v<E> && !is_array_v<E> && !is_specialization_of_unexpected_v<E> && is_same_v<E, remove_cv_t<E>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_30c648e1"
content = '''When T is not cv void, T must meet Cpp17Destructible requirements'''
formal_spec = '''requires: is_void_v<T> || Cpp17Destructible<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_8343eb5f"
content = '''E must meet Cpp17Destructible requirements'''
formal_spec = '''requires: Cpp17Destructible<E>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_c8a9f484"
content = '''Default constructor requires T is default constructible'''
formal_spec = '''requires: is_default_constructible_v<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::expected()"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed (SFINAE)'''

[[axioms]]
id = "cpp_stdlib_expected_031604e8"
content = '''Default constructor value-initializes the stored value'''
formal_spec = '''effects: val is value-initialized'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::expected()"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_00a6d7b1"
content = '''Default constructor results in expected having a value'''
formal_spec = '''postcondition: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::expected()"
header = "<expected>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_b14b6d87"
content = '''Default constructor throws any exception thrown by initialization of val'''
formal_spec = '''throws: any exception thrown by initialization of val'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::expected()"
header = "<expected>"
axiom_type = "exception"
on_violation = '''exception propagates'''

[[axioms]]
id = "cpp_stdlib_expected_12a1eaac"
content = '''Copy constructor preserves has_value state'''
formal_spec = '''postcondition: rhs.has_value() == this->has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::expected(const expected&)"
header = "<expected>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_59789a0c"
content = '''Copy constructor is deleted unless T and E are copy constructible'''
formal_spec = '''defined as deleted unless: is_copy_constructible_v<T> && is_copy_constructible_v<E>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::expected(const expected&)"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_expected_cbc48027"
content = '''Arrow operator requires expected to contain a value'''
formal_spec = '''requires: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::operator->"
header = "<expected>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_b0169f65"
content = '''Dereference operator requires expected to contain a value'''
formal_spec = '''requires: has_value() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::operator*"
header = "<expected>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_f96fc9ee"
content = '''Bool conversion returns whether expected contains a value'''
formal_spec = '''returns: has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::operator bool"
header = "<expected>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_d1f779da"
content = '''value() throws bad_expected_access containing the error when expected does not have a value'''
formal_spec = '''throws: bad_expected_access(error()) when !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::value() const &"
header = "<expected>"
axiom_type = "exception"
on_violation = '''bad_expected_access<E> thrown'''

[[axioms]]
id = "cpp_stdlib_expected_d1f779da"
content = '''value() throws bad_expected_access containing the error when expected does not have a value'''
formal_spec = '''throws: bad_expected_access(error()) when !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::value() &"
header = "<expected>"
axiom_type = "exception"
on_violation = '''bad_expected_access<E> thrown'''

[[axioms]]
id = "cpp_stdlib_expected_d180b2f7"
content = '''value() throws bad_expected_access containing the moved error when expected does not have a value'''
formal_spec = '''throws: bad_expected_access(std::move(error())) when !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::value() const &&"
header = "<expected>"
axiom_type = "exception"
on_violation = '''bad_expected_access<E> thrown'''

[[axioms]]
id = "cpp_stdlib_expected_d180b2f7"
content = '''value() throws bad_expected_access containing the moved error when expected does not have a value'''
formal_spec = '''throws: bad_expected_access(std::move(error())) when !has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::value() &&"
header = "<expected>"
axiom_type = "exception"
on_violation = '''bad_expected_access<E> thrown'''

[[axioms]]
id = "cpp_stdlib_expected_8611bbaf"
content = '''error() requires expected to not contain a value'''
formal_spec = '''requires: has_value() == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::error() const &"
header = "<expected>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_8611bbaf"
content = '''error() requires expected to not contain a value'''
formal_spec = '''requires: has_value() == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::error() &"
header = "<expected>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_8611bbaf"
content = '''error() requires expected to not contain a value'''
formal_spec = '''requires: has_value() == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::error() const &&"
header = "<expected>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_8611bbaf"
content = '''error() requires expected to not contain a value'''
formal_spec = '''requires: has_value() == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::error() &&"
header = "<expected>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_02604f0d"
content = '''value_or returns value if has_value(), otherwise returns the provided default'''
formal_spec = '''returns: has_value() ? **this : static_cast<T>(std::forward<U>(v))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::value_or"
header = "<expected>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_2e53e5aa"
content = '''error_or returns error if !has_value(), otherwise returns the provided default'''
formal_spec = '''returns: has_value() ? std::forward<G>(e) : error()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::error_or"
header = "<expected>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_a89c4144"
content = '''and_then invokes f with value if has_value(), otherwise returns expected containing error'''
formal_spec = '''effects: if has_value() returns invoke(std::forward<F>(f), **this), else returns expected containing error()'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::and_then"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_a35e3544"
content = '''or_else invokes f with error if !has_value(), otherwise returns expected containing value'''
formal_spec = '''effects: if has_value() returns expected containing value, else returns invoke(std::forward<F>(f), error())'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::or_else"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_9f1593b7"
content = '''transform applies f to value if has_value(), wrapping result in expected'''
formal_spec = '''effects: if has_value() returns expected containing invoke(std::forward<F>(f), **this), else returns expected containing error()'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::transform"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_e5ab800b"
content = '''transform_error applies f to error if !has_value(), wrapping result in expected'''
formal_spec = '''effects: if has_value() returns expected containing value, else returns expected containing invoke(std::forward<F>(f), error())'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::transform_error"
header = "<expected>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_893edfd8"
content = '''An expected object always contains either a value of type T or an error of type E, never both, never neither'''
formal_spec = '''invariant: (has_value() && val is valid) || (!has_value() && unex is valid)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected"
header = "<expected>"
axiom_type = "invariant"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_expected_4db91833"
content = '''Dereferencing expected without checking has_value() first is undefined behavior'''
formal_spec = '''anti_pattern: *exp without prior has_value() check'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::operator*"
header = "<expected>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_4e59b6e8"
content = '''Calling error() on expected that contains a value is undefined behavior'''
formal_spec = '''anti_pattern: exp.error() when exp.has_value()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected::error"
header = "<expected>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_expected_3a1f1ab0"
content = '''Partial specialization for void value type exists for expected'''
formal_spec = '''template<class T, class E> requires is_void_v<T> class expected<T, E>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/expected"
source_module = "expected"
c_standard_refs = ['[expected]']
function = "expected<void, E>"
header = "<expected>"
axiom_type = "constraint"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_vector_0144f1dc"
content = '''Vector supports amortized constant time insert and erase at the end; insert and erase in the middle take linear time'''
formal_spec = '''push_back/pop_back: O(1) amortized; insert/erase(middle): O(n)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_1653754e"
content = '''Vector is a contiguous container for element types other than bool'''
formal_spec = '''requires: !std::is_same_v<T, bool> => contiguous_range<vector<T>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector"
header = "<vector>"
axiom_type = "constraint"
on_violation = '''vector<bool> is a specialization with different properties'''

[[axioms]]
id = "cpp_stdlib_vector_4b08cf40"
content = '''An incomplete type T may be used when instantiating vector if the allocator meets completeness requirements, but T must be complete before any member is referenced'''
formal_spec = '''requires: complete(T) before any member access'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector"
header = "<vector>"
axiom_type = "constraint"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_113d1aaa"
content = '''Constructs an empty vector using the specified allocator'''
formal_spec = '''postcondition: empty() == true && get_allocator() == alloc'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(const Allocator&)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_819415ea"
content = '''Default constructor with allocator has constant complexity'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(const Allocator&)"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_630ce79d"
content = '''T must be Cpp17DefaultInsertable into vector'''
formal_spec = '''requires: Cpp17DefaultInsertable<T, vector>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(size_type n, const Allocator&)"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_8d7606de"
content = '''Constructs a vector with n default-inserted elements using the specified allocator'''
formal_spec = '''postcondition: size() == n && all elements are default-inserted'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(size_type n, const Allocator&)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_ad384caf"
content = '''Constructor with count has linear complexity in n'''
formal_spec = '''O(n)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(size_type n, const Allocator&)"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_4929c68c"
content = '''T must be Cpp17CopyInsertable into vector'''
formal_spec = '''requires: Cpp17CopyInsertable<T, vector>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(size_type n, const T& value, const Allocator&)"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_890e099e"
content = '''Constructs a vector with n copies of value using the specified allocator'''
formal_spec = '''postcondition: size() == n && all(elem == value for elem in *this)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(size_type n, const T& value, const Allocator&)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_b0145d41"
content = '''Constructor with count and value has linear complexity in n'''
formal_spec = '''O(n)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(size_type n, const T& value, const Allocator&)"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_35485ebd"
content = '''Constructs a vector equal to the range [first, last) using the specified allocator'''
formal_spec = '''postcondition: *this == vector{first, last}'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(InputIterator first, InputIterator last, const Allocator&)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_02924512"
content = '''Range constructor makes N copy constructor calls with no reallocations for forward iterators; O(N) calls and O(log N) reallocations for input iterators'''
formal_spec = '''ForwardIterator: O(N) copies, 0 reallocations; InputIterator: O(N) copies, O(log N) reallocations'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(InputIterator first, InputIterator last, const Allocator&)"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_53cc430e"
content = '''Constructs a vector with the elements of range rg using the specified allocator'''
formal_spec = '''postcondition: size() == ranges::distance(rg)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(from_range_t, R&& rg, const Allocator&)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_7b34647a"
content = '''Initializes exactly N elements; no reallocations if R models approximately_sized_range with valid hint or forward_range without approximately_sized_range'''
formal_spec = '''O(N) element initialization; 0 reallocations if sized/forward, else O(log N) reallocations'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector(from_range_t, R&& rg, const Allocator&)"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_60466523"
content = '''Returns the total number of elements the vector can hold without requiring reallocation'''
formal_spec = '''returns: capacity() >= size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "capacity"
header = "<vector>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_cfd0ec1b"
content = '''capacity() has constant time complexity'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "capacity"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_19860482"
content = '''T must be Cpp17MoveInsertable into vector'''
formal_spec = '''requires: Cpp17MoveInsertable<T, vector>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "reserve"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_2a8e9ccd"
content = '''After reserve(n), capacity() >= n if reallocation happens; otherwise capacity() unchanged. Reallocation happens iff current capacity < n'''
formal_spec = '''postcondition: (old_capacity < n) ? capacity() >= n : capacity() == old_capacity'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "reserve"
header = "<vector>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_0363aa02"
content = '''Throws length_error if n > max_size()'''
formal_spec = '''throws: length_error if n > max_size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "reserve"
header = "<vector>"
axiom_type = "exception"
on_violation = '''throws std::length_error'''

[[axioms]]
id = "cpp_stdlib_vector_e0ef7af0"
content = '''reserve() has linear complexity in the size of the sequence'''
formal_spec = '''O(size())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "reserve"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_22a997dc"
content = '''reserve() does not change the size of the sequence. Reallocation invalidates all references, pointers, and iterators'''
formal_spec = '''postcondition: size() unchanged; if reallocation: all iterators/references invalidated'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "reserve"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_c6e7af0b"
content = '''No reallocation occurs during insertions after reserve() until size exceeds the reserved capacity'''
formal_spec = '''invariant: after reserve(n), insertions don't reallocate while size() <= capacity()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "reserve"
header = "<vector>"
axiom_type = "invariant"
on_violation = '''N/A - guaranteed behavior'''

[[axioms]]
id = "cpp_stdlib_vector_19860482"
content = '''T must be Cpp17MoveInsertable into vector'''
formal_spec = '''requires: Cpp17MoveInsertable<T, vector>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "shrink_to_fit"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_92e182df"
content = '''shrink_to_fit is a non-binding request to reduce capacity() to size(); it does not increase capacity() but may reduce it'''
formal_spec = '''postcondition: capacity() <= old_capacity && capacity() >= size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "shrink_to_fit"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_d5b646e6"
content = '''If reallocation happens, complexity is linear in the size of the sequence'''
formal_spec = '''O(size()) if reallocation, else O(1)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "shrink_to_fit"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_1b8bf5e1"
content = '''Exchanges the contents and capacity of *this with that of x'''
formal_spec = '''postcondition: *this contains old x contents; x contains old *this contents'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "swap"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_88e26194"
content = '''swap() has constant time complexity'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "swap"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_acca2f74"
content = '''T must be Cpp17MoveInsertable and Cpp17DefaultInsertable into vector'''
formal_spec = '''requires: Cpp17MoveInsertable<T, vector> && Cpp17DefaultInsertable<T, vector>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "resize(size_type)"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_a89a21c6"
content = '''If sz < size(), erases last size() - sz elements; otherwise appends sz - size() default-inserted elements'''
formal_spec = '''postcondition: size() == sz'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "resize(size_type)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_162b022c"
content = '''If an exception is thrown other than by the move constructor of a non-Cpp17CopyInsertable T, there are no effects'''
formal_spec = '''strong exception guarantee (conditional)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "resize(size_type)"
header = "<vector>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_4929c68c"
content = '''T must be Cpp17CopyInsertable into vector'''
formal_spec = '''requires: Cpp17CopyInsertable<T, vector>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "resize(size_type, const T&)"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_1adb516b"
content = '''If sz < size(), erases last size() - sz elements; otherwise appends sz - size() copies of c'''
formal_spec = '''postcondition: size() == sz'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "resize(size_type, const T&)"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_5e0c393e"
content = '''If an exception is thrown, there are no effects (strong exception guarantee)'''
formal_spec = '''strong exception guarantee'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "resize(size_type, const T&)"
header = "<vector>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_083e6a6a"
content = '''Returns a pointer such that [data(), data() + size()) is a valid range; for non-empty vector, data() == addressof(front())'''
formal_spec = '''returns: p where [p, p + size()) is valid; !empty() => p == addressof(front())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "data"
header = "<vector>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_56a8f5d0"
content = '''data() has constant time complexity'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "data"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_0f36cb4e"
content = '''If reallocation happens, linear in resulting vector size; otherwise linear in elements inserted plus distance to end'''
formal_spec = '''O(size()) if reallocation, else O(n + distance(position, end()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "insert"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_0f36cb4e"
content = '''If reallocation happens, linear in resulting vector size; otherwise linear in elements inserted plus distance to end'''
formal_spec = '''O(size()) if reallocation, else O(1 + distance(position, end()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "emplace"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_4aede579"
content = '''If reallocation happens, linear in resulting vector size; otherwise constant (amortized)'''
formal_spec = '''O(1) amortized'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "emplace_back"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_4aede579"
content = '''If reallocation happens, linear in resulting vector size; otherwise constant (amortized)'''
formal_spec = '''O(1) amortized'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "push_back"
header = "<vector>"
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''

[[axioms]]
id = "cpp_stdlib_vector_eac080dd"
content = '''Causes reallocation if new size > old capacity. Reallocation invalidates all references, pointers, and iterators. Without reallocation, iterators before insertion point remain valid; those at or after are invalidated'''
formal_spec = '''if new_size > capacity(): all iterators invalidated; else: iterators in [begin(), position) valid, [position, end()) invalidated'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "insert"
header = "<vector>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_bb98b7df"
content = '''If exception thrown other than by copy/move constructor/assignment of T or InputIterator operations, there are no effects'''
formal_spec = '''strong exception guarantee (conditional on T operations)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "insert"
header = "<vector>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_e9d817b9"
content = '''If exception thrown while inserting single element at end and T is Cpp17CopyInsertable or is_nothrow_move_constructible_v<T>, there are no effects'''
formal_spec = '''strong exception guarantee if Cpp17CopyInsertable<T> || is_nothrow_move_constructible_v<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "push_back"
header = "<vector>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_e9d817b9"
content = '''If exception thrown while inserting single element at end and T is Cpp17CopyInsertable or is_nothrow_move_constructible_v<T>, there are no effects'''
formal_spec = '''strong exception guarantee if Cpp17CopyInsertable<T> || is_nothrow_move_constructible_v<T>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "emplace_back"
header = "<vector>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_vector_cdec2167"
content = '''Container must not be empty when calling front()'''
formal_spec = '''requires: !empty()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "front"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_823ca45f"
content = '''Container must not be empty when calling back()'''
formal_spec = '''requires: !empty()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "back"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_79487c33"
content = '''Container must not be empty when calling pop_back()'''
formal_spec = '''requires: !empty()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "pop_back"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_1401338b"
content = '''Index must be less than size()'''
formal_spec = '''requires: n < size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "operator[]"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_1401338b"
content = '''Index must be less than size()'''
formal_spec = '''requires: n < size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "at"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''throws std::out_of_range'''

[[axioms]]
id = "cpp_stdlib_vector_e9444ebd"
content = '''Throws out_of_range if n >= size()'''
formal_spec = '''throws: out_of_range if n >= size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "at"
header = "<vector>"
axiom_type = "exception"
on_violation = '''throws std::out_of_range'''

[[axioms]]
id = "cpp_stdlib_vector_f6c34195"
content = '''Iterator position must be valid and dereferenceable'''
formal_spec = '''requires: position in [begin(), end()) && position is dereferenceable'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "erase(const_iterator)"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_8f856b3a"
content = '''Range [first, last) must be valid'''
formal_spec = '''requires: [first, last) is valid range in [begin(), end()]'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "erase(const_iterator, const_iterator)"
header = "<vector>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_f0334740"
content = '''Do not hold iterators/pointers/references across insert operations that may cause reallocation'''
formal_spec = '''anti_pattern: auto it = v.begin(); v.push_back(x); *it; // UB if reallocation occurred'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "insert"
header = "<vector>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior (dangling iterator/pointer/reference)'''

[[axioms]]
id = "cpp_stdlib_vector_4ec5541e"
content = '''Do not hold iterators/pointers/references across push_back operations that may cause reallocation'''
formal_spec = '''anti_pattern: auto& ref = v.back(); v.push_back(x); ref; // UB if reallocation occurred'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "push_back"
header = "<vector>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior (dangling reference)'''

[[axioms]]
id = "cpp_stdlib_vector_00d2678c"
content = '''Do not access vector elements with index >= size()'''
formal_spec = '''anti_pattern: vector<int> v(5); v[5]; // UB: index out of bounds'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "operator[]"
header = "<vector>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_63c265c6"
content = '''Do not call front() on an empty vector'''
formal_spec = '''anti_pattern: vector<int> v; v.front(); // UB: empty container'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "front"
header = "<vector>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_a6bd6c36"
content = '''Do not call back() on an empty vector'''
formal_spec = '''anti_pattern: vector<int> v; v.back(); // UB: empty container'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "back"
header = "<vector>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_ff129ccd"
content = '''Do not call pop_back() on an empty vector'''
formal_spec = '''anti_pattern: vector<int> v; v.pop_back(); // UB: empty container'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "pop_back"
header = "<vector>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_vector_0e575b0a"
content = '''size() <= capacity() always holds'''
formal_spec = '''invariant: size() <= capacity()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector"
header = "<vector>"
axiom_type = "invariant"
on_violation = '''N/A - always maintained'''

[[axioms]]
id = "cpp_stdlib_vector_2814fe2b"
content = '''For non-empty vectors, data() points to contiguous storage containing size() elements'''
formal_spec = '''invariant: !empty() => [data(), data() + size()) is valid contiguous range'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/vector"
source_module = "vector"
c_standard_refs = ['[vector]']
function = "vector"
header = "<vector>"
axiom_type = "invariant"
on_violation = '''N/A - always maintained'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_e32a3937"
content = '''Compare must induce a strict weak ordering on the values'''
formal_spec = '''comp(x, x) == false && (comp(a,b) && comp(b,c) => comp(a,c)) && (equiv(a,b) && equiv(b,c) => equiv(a,c)) where equiv(a,b) = !comp(a,b) && !comp(b,a)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_86700ea9"
content = '''For std namespace overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements and *first type must meet Cpp17MoveConstructible and Cpp17MoveAssignable requirements'''
formal_spec = '''requires: Cpp17ValueSwappable<RandomAccessIterator> && Cpp17MoveConstructible<decltype(*first)> && Cpp17MoveAssignable<decltype(*first)>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_81fa2296"
content = '''Sorts the elements in the range [first, last) with respect to comp and proj'''
formal_spec = '''postcondition: is_sorted(first, last, comp)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_2815b741"
content = '''The range [first, last) is sorted with respect to comp'''
formal_spec = '''forall i in [first, last-1): !comp(*(i+1), *i)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_a1377717"
content = '''O(N log N) comparisons and projections where N = last - first'''
formal_spec = '''O(N * log(N)) where N = last - first'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_86700ea9"
content = '''For std namespace overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements and *first type must meet Cpp17MoveConstructible and Cpp17MoveAssignable requirements'''
formal_spec = '''requires: Cpp17ValueSwappable<RandomAccessIterator> && Cpp17MoveConstructible<decltype(*first)> && Cpp17MoveAssignable<decltype(*first)>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "stable_sort"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_81fa2296"
content = '''Sorts the elements in the range [first, last) with respect to comp and proj'''
formal_spec = '''postcondition: is_sorted(first, last, comp)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "stable_sort"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_cd872347"
content = '''Stable sort: relative order of equivalent elements is preserved'''
formal_spec = '''forall a, b where equiv(a, b): if a precedes b before sort, a precedes b after sort'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "stable_sort"
header = "<algorithm>"
axiom_type = "invariant"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_b8d59902"
content = '''N log(N) comparisons if enough extra memory is available, otherwise at most N log(N) comparisons; twice as many projections as comparisons'''
formal_spec = '''O(N * log(N)) with extra memory, O(N * log(N)) otherwise; projections = 2 * comparisons'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "stable_sort"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_0e4c05db"
content = '''[first, middle) and [middle, last) must be valid ranges'''
formal_spec = '''requires: first <= middle <= last'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "partial_sort"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_86700ea9"
content = '''For std namespace overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements and *first type must meet Cpp17MoveConstructible and Cpp17MoveAssignable requirements'''
formal_spec = '''requires: Cpp17ValueSwappable<RandomAccessIterator> && Cpp17MoveConstructible<decltype(*first)> && Cpp17MoveAssignable<decltype(*first)>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "partial_sort"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_8a9c9a8d"
content = '''Places the first (middle - first) smallest elements from [first, last) sorted into [first, middle); remaining elements in [middle, last) are in unspecified order'''
formal_spec = '''postcondition: is_sorted(first, middle, comp) && forall i in [first, middle), j in [middle, last): !comp(*j, *i)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "partial_sort"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_a9b1c877"
content = '''Approximately (last - first) * log(middle - first) comparisons, and twice as many projections'''
formal_spec = '''O((last - first) * log(middle - first)) comparisons; projections = 2 * comparisons'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "partial_sort"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_05b34dbc"
content = '''For ranges overloads: elements must be indirectly copyable from source to result, result must be sortable, and comp must be an indirect strict weak order'''
formal_spec = '''requires: indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> && indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "partial_sort_copy"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_f2004511"
content = '''For ranges overloads, iterator and range must satisfy sortable concept'''
formal_spec = '''requires: sortable<I, Comp, Proj>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_f2004511"
content = '''For ranges overloads, iterator and range must satisfy sortable concept'''
formal_spec = '''requires: sortable<I, Comp, Proj>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "stable_sort"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_18072d2c"
content = '''For ranges overloads, iterator must satisfy sortable concept'''
formal_spec = '''requires: sortable<I, Comp, Proj>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "partial_sort"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_e2b39b02"
content = '''Using a comparison function that is not a strict weak ordering causes undefined behavior'''
formal_spec = '''anti_pattern: comp where comp(x, x) == true OR !(comp(a,b) && comp(b,c) => comp(a,c))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_3f587699"
content = '''Using operator<= instead of operator< as comparator violates strict weak ordering (not irreflexive)'''
formal_spec = '''anti_pattern: [](auto& a, auto& b) { return a <= b; }'''
layer = "cpp_stdlib"
confidence = 0.95
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "sort"
header = "<algorithm>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_8c501e2e"
content = '''Returns last (the end iterator of the sorted range)'''
formal_spec = '''returns: last'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "ranges::sort"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_8c501e2e"
content = '''Returns last (the end iterator of the sorted range)'''
formal_spec = '''returns: last'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "ranges::stable_sort"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_sorting_393afa32"
content = '''Returns last (the end iterator of the input range)'''
formal_spec = '''returns: last'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.sorting"
source_module = "alg.sorting"
c_standard_refs = ['[alg.sorting]']
function = "ranges::partial_sort"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''n/a'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_9fe48006"
content = '''Returns false if predicate is false for some iterator in range, true otherwise'''
formal_spec = '''returns: (i  [first, last): pred(*i)) ? true : false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "all_of"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A - pure function'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d9e2d664"
content = '''At most last - first applications of predicate and any projection'''
formal_spec = '''O(n) where n = last - first'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "all_of"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''N/A - implementation quality'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d839c8a4"
content = '''Iterator must be InputIterator, Predicate must be callable with dereferenced iterator'''
formal_spec = '''requires: input_iterator<I> && indirect_unary_predicate<Pred, projected<I, Proj>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "all_of"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_0481d7b8"
content = '''Returns true if predicate is true for some iterator in range, false otherwise'''
formal_spec = '''returns: (i  [first, last): pred(*i)) ? true : false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "any_of"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A - pure function'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d9e2d664"
content = '''At most last - first applications of predicate and any projection'''
formal_spec = '''O(n) where n = last - first'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "any_of"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''N/A - implementation quality'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d839c8a4"
content = '''Iterator must be InputIterator, Predicate must be callable with dereferenced iterator'''
formal_spec = '''requires: input_iterator<I> && indirect_unary_predicate<Pred, projected<I, Proj>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "any_of"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_19e2ae1c"
content = '''Returns false if predicate is true for some iterator in range, true otherwise'''
formal_spec = '''returns: (i  [first, last): pred(*i)) ? true : false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "none_of"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A - pure function'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d9e2d664"
content = '''At most last - first applications of predicate and any projection'''
formal_spec = '''O(n) where n = last - first'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "none_of"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''N/A - implementation quality'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d839c8a4"
content = '''Iterator must be InputIterator, Predicate must be callable with dereferenced iterator'''
formal_spec = '''requires: input_iterator<I> && indirect_unary_predicate<Pred, projected<I, Proj>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "none_of"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_149f17aa"
content = '''Returns true if value is found in range, equivalent to find != last'''
formal_spec = '''returns: ranges::find(std::move(first), last, value, proj) != last'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::contains"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A - pure function'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d514e436"
content = '''Requires indirect binary predicate with equal_to between projected iterator and value'''
formal_spec = '''requires: indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::contains"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_de1bb0c5"
content = '''Returns true if second range is empty or found as subrange in first range'''
formal_spec = '''returns: first2 == last2 || !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::contains_subrange"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A - pure function'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_96925923"
content = '''Iterators must be forward iterators and indirectly comparable'''
formal_spec = '''requires: forward_iterator<I1> && forward_iterator<I2> && indirectly_comparable<I1, I2, Pred, Proj1, Proj2>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::contains_subrange"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_fd18081b"
content = '''Function must meet Cpp17MoveConstructible requirements'''
formal_spec = '''requires: Cpp17MoveConstructible<Function>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b5f0cc77"
content = '''Applies f to every dereferenced iterator in order from first to last-1'''
formal_spec = '''effects: for each i in [first, last): f(*i), applied in order'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_f00a8ad5"
content = '''Returns the function object f (non-parallel overload)'''
formal_spec = '''returns: f'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b82f8f6e"
content = '''Applies f exactly last - first times'''
formal_spec = '''(n) where n = last - first, exactly n applications'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''N/A - implementation quality'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_6fe6f5b3"
content = '''If f returns a result, the result is ignored'''
formal_spec = '''remarks: return value of f is discarded'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_3ca8e387"
content = '''Function must meet Cpp17CopyConstructible requirements for parallel overload'''
formal_spec = '''requires: Cpp17CopyConstructible<Function>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each (parallel)"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_a20eb260"
content = '''Implementations cannot make arbitrary copies of elements from input sequence'''
formal_spec = '''remarks: no arbitrary element copies permitted'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each (parallel)"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''N/A - implementation constraint'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_71fcd611"
content = '''Returns pair of end iterator and moved function object'''
formal_spec = '''returns: {last, std::move(f)}'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_2836dbbc"
content = '''Calls invoke(f, invoke(proj, *i)) for every iterator in range in order'''
formal_spec = '''effects: for each i in [first, last): invoke(f, invoke(proj, *i)), in order'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b83f17cf"
content = '''Applies f and proj exactly last - first times'''
formal_spec = '''(n) where n = last - first, exactly n applications each'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each"
header = "<algorithm>"
axiom_type = "complexity"
on_violation = '''N/A - implementation quality'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_dca80b48"
content = '''Fun must model copy_constructible for ranges overloads'''
formal_spec = '''requires: copy_constructible<Fun>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_73828325"
content = '''Size type must be convertible to integral type'''
formal_spec = '''mandates: is_convertible_v<Size, integral_type>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b3bc937c"
content = '''n must be non-negative'''
formal_spec = '''requires: n >= 0'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_fd18081b"
content = '''Function must meet Cpp17MoveConstructible requirements'''
formal_spec = '''requires: Cpp17MoveConstructible<Function>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_624f7585"
content = '''Applies f to dereferenced iterators in range [first, first+n) in order'''
formal_spec = '''effects: for each i in [first, first+n): f(*i), applied in order'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b10f3897"
content = '''Returns first + n'''
formal_spec = '''returns: first + n'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_3ca8e387"
content = '''Function must meet Cpp17CopyConstructible requirements for parallel overload'''
formal_spec = '''requires: Cpp17CopyConstructible<Function>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n (parallel)"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b3bc937c"
content = '''n must be non-negative'''
formal_spec = '''requires: n >= 0'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each_n"
header = "<algorithm>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_f019e9dc"
content = '''Calls invoke(f, invoke(proj, *i)) for every iterator in range [first, first+n) in order'''
formal_spec = '''effects: for each i in [first, first+n): invoke(f, invoke(proj, *i)), in order'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each_n"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_33419dcc"
content = '''Returns pair of advanced iterator and moved function object'''
formal_spec = '''returns: {first + n, std::move(f)}'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each_n"
header = "<algorithm>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_2df21f54"
content = '''Fun must model copy_constructible'''
formal_spec = '''requires: copy_constructible<Fun>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each_n"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d9bdec24"
content = '''Empty range returns true (vacuous truth)'''
formal_spec = '''all_of(first, first, pred) == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "all_of"
header = "<algorithm>"
axiom_type = "invariant"
on_violation = '''N/A - definition'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_45b84458"
content = '''Empty range returns false'''
formal_spec = '''any_of(first, first, pred) == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "any_of"
header = "<algorithm>"
axiom_type = "invariant"
on_violation = '''N/A - definition'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_d9bdec24"
content = '''Empty range returns true (vacuous truth)'''
formal_spec = '''none_of(first, first, pred) == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "none_of"
header = "<algorithm>"
axiom_type = "invariant"
on_violation = '''N/A - definition'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_99c2037c"
content = '''Empty needle (second range) always returns true'''
formal_spec = '''contains_subrange(r1, empty_range) == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::contains_subrange"
header = "<algorithm>"
axiom_type = "invariant"
on_violation = '''N/A - definition'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_cab0a615"
content = '''If iterator type is mutable, f can apply non-constant functions through dereferenced iterator'''
formal_spec = '''if mutable_iterator<I>: f may modify *i'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_98f7a646"
content = '''If result of invoke(proj, *i) is a mutable reference, f can apply non-constant functions'''
formal_spec = '''if is_lvalue_reference_v<invoke_result_t<Proj, iter_reference_t<I>>>: f may modify'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_442b3652"
content = '''Parallel overload does not return function object because parallelization doesn't permit efficient state accumulation'''
formal_spec = '''returns: void (not Function)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each (parallel)"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''N/A - by design'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_e5b95d2b"
content = '''Parallel overload returns only iterator, not function, due to parallelization constraints'''
formal_spec = '''returns: I (not for_each_result<I, Fun>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each (parallel)"
header = "<algorithm>"
axiom_type = "constraint"
on_violation = '''N/A - by design'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_0d7142c3"
content = '''f may modify objects via its arguments in parallel execution'''
formal_spec = '''remarks: f may modify objects via arguments per [algorithms.parallel.user]'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "ranges::for_each (parallel)"
header = "<algorithm>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_b7a8b52b"
content = '''Do not rely on return value of function f - it is always ignored'''
formal_spec = '''remarks: return value of f is discarded; use transform or explicit loop if result needed'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each"
header = "<algorithm>"
axiom_type = "anti_pattern"
on_violation = '''silent data loss'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_9ca5de00"
content = '''Do not accumulate state in function for parallel overload - use reduce or transform_reduce instead'''
formal_spec = '''state accumulation in parallel for_each leads to data races'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each (parallel)"
header = "<algorithm>"
axiom_type = "anti_pattern"
on_violation = '''data race / undefined behavior'''

[[axioms]]
id = "cpp_stdlib_alg_nonmodifying_040076b7"
content = '''Passing negative n causes undefined behavior'''
formal_spec = '''requires: n >= 0; negative n is UB'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/alg.nonmodifying"
source_module = "alg.nonmodifying"
c_standard_refs = ['[alg.nonmodifying]']
function = "for_each_n"
header = "<algorithm>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_159293d2"
content = '''For non-recursive mutex types (mutex, timed_mutex, shared_mutex, shared_timed_mutex), the calling thread must not already own the mutex'''
formal_spec = '''requires: !owns_lock() for non-recursive mutex types'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "lock"
header = "<mutex>"
axiom_type = "precondition"
on_violation = '''undefined behavior (may deadlock or throw resource_deadlock_would_occur)'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_3bdfd832"
content = '''Blocks the calling thread until ownership of the mutex can be obtained'''
formal_spec = '''effects: blocks until mutex.owner == current_thread'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "lock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_3e872a07"
content = '''After lock() returns successfully, the calling thread owns the mutex'''
formal_spec = '''ensures: owns_lock() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "lock"
header = "<mutex>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_cad252ac"
content = '''lock() may throw system_error with operation_not_permitted or resource_deadlock_would_occur'''
formal_spec = '''throws: system_error when error_code in {operation_not_permitted, resource_deadlock_would_occur}'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "lock"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''exception thrown'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_159293d2"
content = '''For non-recursive mutex types (mutex, timed_mutex, shared_mutex, shared_timed_mutex), the calling thread must not already own the mutex'''
formal_spec = '''requires: !owns_lock() for non-recursive mutex types'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock"
header = "<mutex>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_8fd83479"
content = '''Attempts to obtain ownership without blocking. May spuriously fail even if mutex is not held by another thread'''
formal_spec = '''effects: non-blocking attempt to acquire; spurious failure permitted'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_d29c825b"
content = '''Returns true if ownership was obtained, false otherwise'''
formal_spec = '''ensures: returns true => owns_lock() == true; returns false => state unchanged'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock"
header = "<mutex>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_5ae26f7f"
content = '''try_lock() does not throw exceptions'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_5acc0f5f"
content = '''The calling thread must own the mutex before calling unlock()'''
formal_spec = '''requires: owns_lock() == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "unlock"
header = "<mutex>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_8857d5c0"
content = '''Releases the calling thread's ownership of the mutex'''
formal_spec = '''effects: owns_lock() := false; synchronizes-with subsequent lock()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "unlock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_f759ba5b"
content = '''unlock() does not throw exceptions'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "unlock"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_746c3b18"
content = '''A mutex must not be destroyed while owned by any thread'''
formal_spec = '''invariant: at destruction => !any_thread_owns()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex"
header = "<mutex>"
axiom_type = "invariant"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_d5aa7083"
content = '''A thread must not terminate while owning a mutex'''
formal_spec = '''invariant: thread_terminates => !owns_lock(mutex)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex"
header = "<mutex>"
axiom_type = "invariant"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_054b7085"
content = '''Calling lock() on a non-recursive mutex already owned by the current thread causes deadlock'''
formal_spec = '''anti_pattern: owns_lock() && lock() => deadlock'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex::lock"
header = "<mutex>"
axiom_type = "anti_pattern"
on_violation = '''deadlock or resource_deadlock_would_occur exception if detected'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_e664183a"
content = '''Mutex types are neither copyable nor movable'''
formal_spec = '''constraint: is_copy_constructible_v<mutex> == false && is_move_constructible_v<mutex> == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex"
header = "<mutex>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_736f6dce"
content = '''If mutex initialization fails, system_error is thrown'''
formal_spec = '''throws: system_error on initialization failure'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex::mutex"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''exception thrown'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_3b6ce241"
content = '''A recursive_mutex must not be destroyed while owned by any thread'''
formal_spec = '''invariant: at destruction => !any_thread_owns()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "recursive_mutex"
header = "<mutex>"
axiom_type = "invariant"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_3a84032a"
content = '''A thread must not terminate while owning a recursive_mutex'''
formal_spec = '''invariant: thread_terminates => !owns_lock(recursive_mutex)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "recursive_mutex"
header = "<mutex>"
axiom_type = "invariant"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_40111187"
content = '''A thread that owns a recursive_mutex may acquire additional levels of ownership by calling lock()'''
formal_spec = '''effects: if owns_lock() then ownership_level++; else acquire_and_own()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "recursive_mutex::lock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_44772e6f"
content = '''If maximum ownership level is reached, additional lock() calls throw system_error'''
formal_spec = '''throws: system_error when ownership_level == max_level'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "recursive_mutex::lock"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''exception thrown'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_ef79add0"
content = '''If maximum ownership level is reached, try_lock() returns false'''
formal_spec = '''ensures: ownership_level == max_level => returns false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "recursive_mutex::try_lock"
header = "<mutex>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_a7c4ff72"
content = '''unlock() must be called once for each successful lock()/try_lock() before another thread can acquire'''
formal_spec = '''invariant: releases_ownership <=> unlock_count == lock_count'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "recursive_mutex"
header = "<mutex>"
axiom_type = "invariant"
on_violation = '''ownership not released'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_bf53cd3a"
content = '''For timed_mutex or shared_timed_mutex, the calling thread must not already own the mutex'''
formal_spec = '''requires: !owns_lock() for non-recursive timed mutex types'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock_for"
header = "<mutex>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_4479a14a"
content = '''Attempts to obtain ownership within the specified relative timeout. If timeout is zero or negative, behaves like try_lock()'''
formal_spec = '''effects: if rel_time <= 0 then try_lock(); else block_until(owns_lock() || elapsed >= rel_time)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock_for"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_d29c825b"
content = '''Returns true if ownership was obtained, false otherwise'''
formal_spec = '''ensures: returns true => owns_lock(); returns false => !owns_lock()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock_for"
header = "<mutex>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_48a9ec48"
content = '''May throw timeout-related exceptions'''
formal_spec = '''throws: timeout-related exceptions'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock_for"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''exception thrown'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_bf53cd3a"
content = '''For timed_mutex or shared_timed_mutex, the calling thread must not already own the mutex'''
formal_spec = '''requires: !owns_lock() for non-recursive timed mutex types'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock_until"
header = "<mutex>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_0b670e69"
content = '''Attempts to obtain ownership until the specified absolute time. If time has passed, behaves like try_lock()'''
formal_spec = '''effects: if now >= abs_time then try_lock(); else block_until(owns_lock() || now >= abs_time)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock_until"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_194a282c"
content = '''Prior unlock() operations on the same mutex synchronize-with this lock() operation'''
formal_spec = '''synchronization: unlock() synchronizes-with lock()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "lock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_189d545a"
content = '''If try_lock() returns true, prior unlock() operations synchronize-with this operation'''
formal_spec = '''synchronization: (try_lock() == true) => unlock() synchronizes-with try_lock()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "try_lock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_62982bc6"
content = '''unlock() synchronizes-with subsequent lock operations that obtain ownership'''
formal_spec = '''synchronization: unlock() synchronizes-with subsequent_lock()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "unlock"
header = "<mutex>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_cf3351be"
content = '''Lock and unlock operations on a single mutex appear to occur in a single total order (atomic-like behavior)'''
formal_spec = '''constraint: exists total_order such that all lock/unlock ops are sequenced'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex"
header = "<mutex>"
axiom_type = "constraint"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_thread_mutex_abc393f6"
content = '''Mutex operations may report resource_unavailable_try_again, operation_not_permitted, or invalid_argument errors'''
formal_spec = '''error_conditions: {resource_unavailable_try_again, operation_not_permitted, invalid_argument}'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.mutex"
source_module = "thread.mutex"
c_standard_refs = ['[thread.mutex]']
function = "mutex"
header = "<mutex>"
axiom_type = "exception"
on_violation = '''system_error thrown'''

[[axioms]]
id = "cpp_stdlib_string_view_9782b45f"
content = '''basic_string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element at position zero'''
formal_spec = '''basic_string_view<charT, traits> represents range [data_, data_ + size_) of const charT'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''N/A - definitional'''

[[axioms]]
id = "cpp_stdlib_string_view_55739fa8"
content = '''The traits type must meet the character traits requirements and traits::char_type must be the same as charT'''
formal_spec = '''requires: is_same_v<traits::char_type, charT> && meets_character_traits_requirements(traits)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_string_view_344bcca6"
content = '''Any operation that invalidates a pointer in the range [str.data(), str.data() + str.size()) invalidates pointers, iterators, and references to elements of str'''
formal_spec = '''invalidates(ptr) where ptr in [data(), data() + size()) => invalidates(all iterators, pointers, references)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''undefined behavior if invalidated iterators/pointers/references are used'''

[[axioms]]
id = "cpp_stdlib_string_view_969fcac1"
content = '''The complexity of basic_string_view member functions is O(1) unless otherwise specified'''
formal_spec = '''complexity(member_function) == O(1) unless specified otherwise'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_string_view_0a36a7dc"
content = '''basic_string_view<charT, traits> is a trivially copyable type'''
formal_spec = '''is_trivially_copyable_v<basic_string_view<charT, traits>> == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_string_view_9d0eb198"
content = '''Default constructor creates an empty string_view with null data pointer'''
formal_spec = '''postcondition: size_ == 0 && data_ == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view()"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_b227295b"
content = '''The range [str, str + traits::length(str)) must be a valid range'''
formal_spec = '''requires: valid_range(str, str + traits::length(str))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(const charT*)"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_d894edc1"
content = '''Constructs a basic_string_view, initializing data_ with str and size_ with traits::length(str)'''
formal_spec = '''effects: data_ = str; size_ = traits::length(str)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(const charT*)"
header = "<string_view>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_854c5c8e"
content = '''Complexity is O(traits::length(str)) - linear in the length of the string'''
formal_spec = '''complexity: O(traits::length(str))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(const charT*)"
header = "<string_view>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_string_view_c0bba7f4"
content = '''The range [str, str + len) must be a valid range'''
formal_spec = '''requires: valid_range(str, str + len)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(const charT*, size_type)"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_0ef4513a"
content = '''Constructs a basic_string_view, initializing data_ with str and size_ with len'''
formal_spec = '''effects: data_ = str; size_ = len'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(const charT*, size_type)"
header = "<string_view>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_5d90ca60"
content = '''It must satisfy contiguous_iterator, End must satisfy sized_sentinel_for<It>, iter_value_t<It> must be charT, and End must not be convertible to size_type'''
formal_spec = '''requires: contiguous_iterator<It> && sized_sentinel_for<End, It> && is_same_v<iter_value_t<It>, charT> && !is_convertible_v<End, size_type>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(It, End)"
header = "<string_view>"
axiom_type = "constraint"
on_violation = '''ill-formed (substitution failure)'''

[[axioms]]
id = "cpp_stdlib_string_view_04465d65"
content = '''The range [begin, end) must be valid, It must model contiguous_iterator, and End must model sized_sentinel_for<It>'''
formal_spec = '''requires: valid_range(begin, end) && models_contiguous_iterator(It) && models_sized_sentinel_for(End, It)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(It, End)"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_fd9e3cb2"
content = '''Initializes data_ with to_address(begin) and size_ with end - begin'''
formal_spec = '''effects: data_ = to_address(begin); size_ = end - begin'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(It, End)"
header = "<string_view>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_28bb2999"
content = '''Throws when and what end - begin throws'''
formal_spec = '''throws: decltype(end - begin) may throw'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(It, End)"
header = "<string_view>"
axiom_type = "exception"
on_violation = '''N/A - exception propagation'''

[[axioms]]
id = "cpp_stdlib_string_view_af19c7da"
content = '''R must be a contiguous_range and sized_range with matching value type, not convertible to const charT*, and not have a conversion operator to basic_string_view'''
formal_spec = '''requires: !is_same_v<remove_cvref_t<R>, basic_string_view> && ranges::contiguous_range<R> && ranges::sized_range<R> && is_same_v<ranges::range_value_t<R>, charT> && !is_convertible_v<R, const charT*> && !has_conversion_to_string_view(R)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(R&&)"
header = "<string_view>"
axiom_type = "constraint"
on_violation = '''ill-formed (substitution failure)'''

[[axioms]]
id = "cpp_stdlib_string_view_262dc896"
content = '''Initializes data_ with ranges::data(r) and size_ with ranges::size(r)'''
formal_spec = '''effects: data_ = ranges::data(r); size_ = ranges::size(r)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(R&&)"
header = "<string_view>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_cf2d11ac"
content = '''Throws any exception thrown by ranges::data(r) and ranges::size(r)'''
formal_spec = '''throws: noexcept(ranges::data(r)) && noexcept(ranges::size(r)) ? nothing : implementation-defined'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(R&&)"
header = "<string_view>"
axiom_type = "exception"
on_violation = '''N/A - exception propagation'''

[[axioms]]
id = "cpp_stdlib_string_view_3042c181"
content = '''Construction of basic_string_view from nullptr_t is explicitly deleted - do not attempt to construct from nullptr'''
formal_spec = '''basic_string_view(nullptr_t) = delete'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view(nullptr_t)"
header = "<string_view>"
axiom_type = "anti_pattern"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_string_view_b73c5c0c"
content = '''const_iterator is a constant Cpp17RandomAccessIterator that models contiguous_iterator and meets constexpr iterator requirements'''
formal_spec = '''Cpp17RandomAccessIterator<const_iterator> && contiguous_iterator<const_iterator> && constexpr_iterator<const_iterator>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "const_iterator"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_string_view_3f11bdce"
content = '''Returns an iterator where addressof(*begin()) == data_ if not empty, otherwise an unspecified value such that [begin(), end()) is valid'''
formal_spec = '''returns: !empty() ? (addressof(*result) == data_) : valid_range(result, end())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "begin"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_f7a23a4e"
content = '''Returns begin() + size()'''
formal_spec = '''returns: begin() + size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "end"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_b82bb381"
content = '''Position must be less than size() when accessing via operator[]'''
formal_spec = '''requires: pos < size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "operator[]"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_b576d948"
content = '''Throws out_of_range if pos >= size()'''
formal_spec = '''throws: out_of_range if pos >= size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "at"
header = "<string_view>"
axiom_type = "exception"
on_violation = '''throws out_of_range'''

[[axioms]]
id = "cpp_stdlib_string_view_cb0348ab"
content = '''The string_view must not be empty when calling front()'''
formal_spec = '''requires: !empty()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "front"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_95648b00"
content = '''The string_view must not be empty when calling back()'''
formal_spec = '''requires: !empty()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "back"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_5b88b80d"
content = '''The data() pointer may not be null-terminated. Passing data() to functions expecting null-terminated strings without checking size() is unsafe'''
formal_spec = '''data() does NOT guarantee: data()[size()] == '\0''''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "data"
header = "<string_view>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior if null-termination assumed'''

[[axioms]]
id = "cpp_stdlib_string_view_439c8969"
content = '''n must be less than or equal to size() when calling remove_prefix(n)'''
formal_spec = '''requires: n <= size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "remove_prefix"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_b689badd"
content = '''Advances the data pointer by n and decreases size by n'''
formal_spec = '''effects: data_ += n; size_ -= n'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "remove_prefix"
header = "<string_view>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_ef085d88"
content = '''n must be less than or equal to size() when calling remove_suffix(n)'''
formal_spec = '''requires: n <= size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "remove_suffix"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_addf7752"
content = '''Decreases size by n without changing data pointer'''
formal_spec = '''effects: size_ -= n'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "remove_suffix"
header = "<string_view>"
axiom_type = "effect"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_19a723f9"
content = '''The range [s, s + rlen) must be valid where rlen = min(n, size() - pos)'''
formal_spec = '''requires: valid_range(s, s + min(n, size() - pos))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "copy"
header = "<string_view>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_string_view_865d48af"
content = '''Throws out_of_range if pos > size()'''
formal_spec = '''throws: out_of_range if pos > size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "copy"
header = "<string_view>"
axiom_type = "exception"
on_violation = '''throws out_of_range'''

[[axioms]]
id = "cpp_stdlib_string_view_865d48af"
content = '''Throws out_of_range if pos > size()'''
formal_spec = '''throws: out_of_range if pos > size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "substr"
header = "<string_view>"
axiom_type = "exception"
on_violation = '''throws out_of_range'''

[[axioms]]
id = "cpp_stdlib_string_view_865d48af"
content = '''Throws out_of_range if pos > size()'''
formal_spec = '''throws: out_of_range if pos > size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "subview"
header = "<string_view>"
axiom_type = "exception"
on_violation = '''throws out_of_range'''

[[axioms]]
id = "cpp_stdlib_string_view_c92a0de3"
content = '''Complexity is O(min(size(), s.size()))'''
formal_spec = '''complexity: O(min(size(), s.size()))'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "compare(basic_string_view)"
header = "<string_view>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_string_view_b79bf597"
content = '''Returns true if the first x.size() characters match x'''
formal_spec = '''returns: size() >= x.size() && compare(0, x.size(), x) == 0'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "starts_with(basic_string_view)"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_cc75eddf"
content = '''Returns true if the last x.size() characters match x'''
formal_spec = '''returns: size() >= x.size() && compare(size() - x.size(), npos, x) == 0'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "ends_with(basic_string_view)"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_115b7a37"
content = '''Returns true if find(x) != npos'''
formal_spec = '''returns: find(x) != npos'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "contains(basic_string_view)"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_93b321f8"
content = '''Returns npos if the substring is not found, otherwise returns the lowest position where the substring starts'''
formal_spec = '''returns: not_found ? npos : lowest_pos where substr(pos, s.size()) == s'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "find"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_0c934b16"
content = '''Returns npos if the substring is not found, otherwise returns the highest position where the substring starts'''
formal_spec = '''returns: not_found ? npos : highest_pos where substr(pos, s.size()) == s'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "rfind"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_f576d96b"
content = '''Find operations have complexity O(size() * s.size()) at most'''
formal_spec = '''complexity: O(size() * s.size())'''
layer = "cpp_stdlib"
confidence = 0.8
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "find"
header = "<string_view>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_string_view_dba48b60"
content = '''Returns a string_view constructed from the literal with the given length'''
formal_spec = '''returns: basic_string_view<charT>{str, len}'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "operator\"\"sv"
header = "<string_view>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_89b521df"
content = '''Hash specializations for string_view types are enabled and satisfy Hash requirements'''
formal_spec = '''hash<string_view>, hash<u8string_view>, hash<u16string_view>, hash<u32string_view>, hash<wstring_view> satisfy Hash requirements'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "hash"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_43ff9d3d"
content = '''basic_string_view is a borrowed range and a view, enabling use in range-based operations without lifetime extension concerns'''
formal_spec = '''ranges::enable_view<basic_string_view<charT, traits>> == true && ranges::enable_borrowed_range<basic_string_view<charT, traits>> == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''N/A - guaranteed'''

[[axioms]]
id = "cpp_stdlib_string_view_b1ea01d1"
content = '''iterator and const_iterator are the same type because basic_string_view refers to a constant sequence'''
formal_spec = '''is_same_v<basic_string_view::iterator, basic_string_view::const_iterator> == true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "invariant"
on_violation = '''N/A - definitional'''

[[axioms]]
id = "cpp_stdlib_string_view_6620def4"
content = '''Storing a string_view beyond the lifetime of the referenced character array leads to dangling references. Do not return string_view pointing to local variables.'''
formal_spec = '''lifetime(data_) must outlive lifetime(string_view)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/string.view"
source_module = "string.view"
c_standard_refs = ['[string.view]']
function = "basic_string_view"
header = "<string_view>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior (dangling reference)'''

[[axioms]]
id = "cpp_stdlib_thread_condition_7f8fb9bb"
content = '''Condition variables permit concurrent invocation of wait, wait_for, wait_until, notify_one and notify_all member functions'''
formal_spec = '''concurrent_safe(wait, wait_for, wait_until, notify_one, notify_all)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable"
header = "<condition_variable>"
axiom_type = "invariant"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c4dbb45f"
content = '''The executions of notify_one and notify_all are atomic'''
formal_spec = '''atomic(notify_one) && atomic(notify_all)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "notify_one"
header = "<condition_variable>"
axiom_type = "invariant"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_dfb5c819"
content = '''Wait executions are performed in three atomic parts: release mutex and enter waiting, unblock, reacquire lock'''
formal_spec = '''atomic_sequence(lock.unlock() && block(*this), unblock, lock.lock())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "wait"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_42ebd895"
content = '''Lock must be locked by calling thread and either no other thread is waiting on cond, or all waiting threads use the same mutex'''
formal_spec = '''requires: lk.owns_lock() && (no_waiters(cond) || all_waiters_same_mutex(cond, lk.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "notify_all_at_thread_exit"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_e0be0bd3"
content = '''Transfers lock ownership to internal storage and schedules cond.notify_all() when current thread exits, after destruction of thread-local objects'''
formal_spec = '''at_thread_exit: sequence(destroy_thread_locals, cond.notify_all(), lk.unlock())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "notify_all_at_thread_exit"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_63c277ca"
content = '''The supplied lock is held until thread exits, which might cause deadlock due to lock ordering issues'''
formal_spec = '''warning: lock_held_until_thread_exit(lk) => potential_deadlock'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "notify_all_at_thread_exit"
header = "<condition_variable>"
axiom_type = "anti_pattern"
on_violation = '''deadlock'''

[[axioms]]
id = "cpp_stdlib_thread_condition_d558ab06"
content = '''Constructor throws system_error with resource_unavailable_try_again if non-memory resource limitation prevents initialization'''
formal_spec = '''throws: system_error(resource_unavailable_try_again) if !can_allocate_resources()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::condition_variable"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''exception thrown'''

[[axioms]]
id = "cpp_stdlib_thread_condition_2a7fa67d"
content = '''There must be no thread blocked on *this when destructor is called'''
formal_spec = '''requires: blocked_threads(*this) == 0'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::~condition_variable"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_854115e7"
content = '''If any threads are blocked waiting for *this, unblocks one of those threads'''
formal_spec = '''if (blocked_threads(*this) > 0) unblock_one(*this)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::notify_one"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_18b36b65"
content = '''Unblocks all threads that are blocked waiting for *this'''
formal_spec = '''unblock_all(*this)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::notify_all"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_13a2541f"
content = '''lock.owns_lock() must be true and lock.mutex() must be locked by calling thread, and either no other thread is waiting or all waiting threads use the same mutex'''
formal_spec = '''requires: lock.owns_lock() && locked_by_current_thread(lock.mutex()) && (no_other_waiters(*this) || all_waiters_same_mutex(*this, lock.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_0afe375f"
content = '''Atomically calls lock.unlock() and blocks on *this, then when unblocked calls lock.lock() and returns. May unblock spuriously.'''
formal_spec = '''atomic(lock.unlock(), block(*this)); on_unblock: lock.lock(); may_unblock_spuriously()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_089520bd"
content = '''lock.owns_lock() is true and lock.mutex() is locked by the calling thread'''
formal_spec = '''ensures: lock.owns_lock() && locked_by_current_thread(lock.mutex())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "postcondition"
on_violation = '''terminate() is called'''

[[axioms]]
id = "cpp_stdlib_thread_condition_31e5297c"
content = '''wait(lock) throws nothing; if postcondition cannot be met (e.g., re-locking throws), terminate() is called'''
formal_spec = '''noexcept; on_postcondition_failure: std::terminate()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''terminate() is called'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c1787645"
content = '''For predicate overload: lock.owns_lock() must be true, lock.mutex() locked by calling thread, and mutex consistency with other waiters'''
formal_spec = '''requires: lock.owns_lock() && locked_by_current_thread(lock.mutex()) && (no_other_waiters(*this) || all_waiters_same_mutex(*this, lock.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_e7ca3864"
content = '''Predicate overload is equivalent to: while (!pred()) wait(lock);'''
formal_spec = '''equivalent: while (!pred()) wait(lock);'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - implementation defined equivalence'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c0994043"
content = '''Predicate overload throws any exception thrown by pred; if postcondition fails, terminate() is called'''
formal_spec = '''throws: exception_from(pred); on_postcondition_failure: std::terminate()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''exception propagated or terminate() called'''

[[axioms]]
id = "cpp_stdlib_thread_condition_769ae7ca"
content = '''lock.owns_lock() must be true and lock.mutex() must be locked by calling thread, with mutex consistency among waiters'''
formal_spec = '''requires: lock.owns_lock() && locked_by_current_thread(lock.mutex()) && (no_other_waiters(*this) || all_waiters_same_mutex(*this, lock.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_3bb7c40f"
content = '''Atomically unlocks and blocks, unblocks on notify_one/notify_all, timeout expiration, or spuriously. If exit via exception, lock.lock() is called first.'''
formal_spec = '''atomic(lock.unlock(), block(*this)); unblocks_on(notify_one, notify_all, timeout(abs_time), spurious); on_exception: lock.lock()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_40d9b9e1"
content = '''Returns cv_status::timeout if timeout expired, otherwise cv_status::no_timeout. lock.owns_lock() is true.'''
formal_spec = '''ensures: lock.owns_lock(); returns: timeout_expired ? cv_status::timeout : cv_status::no_timeout'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "postcondition"
on_violation = '''terminate() is called'''

[[axioms]]
id = "cpp_stdlib_thread_condition_3e7928ff"
content = '''May throw timeout-related exceptions; if postcondition cannot be met, terminate() is called'''
formal_spec = '''throws: timeout_exceptions; on_postcondition_failure: std::terminate()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''exception or terminate()'''

[[axioms]]
id = "cpp_stdlib_thread_condition_769ae7ca"
content = '''lock.owns_lock() must be true and lock.mutex() must be locked by calling thread, with mutex consistency among waiters'''
formal_spec = '''requires: lock.owns_lock() && locked_by_current_thread(lock.mutex()) && (no_other_waiters(*this) || all_waiters_same_mutex(*this, lock.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_2cd70807"
content = '''Equivalent to: return wait_until(lock, chrono::steady_clock::now() + rel_time);'''
formal_spec = '''equivalent: wait_until(lock, chrono::steady_clock::now() + rel_time)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - implementation defined equivalence'''

[[axioms]]
id = "cpp_stdlib_thread_condition_cff213f2"
content = '''Returns cv_status::timeout if relative timeout expired, otherwise cv_status::no_timeout. lock.owns_lock() is true.'''
formal_spec = '''ensures: lock.owns_lock(); returns: timeout_expired ? cv_status::timeout : cv_status::no_timeout'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "postcondition"
on_violation = '''terminate() is called'''

[[axioms]]
id = "cpp_stdlib_thread_condition_3e7928ff"
content = '''May throw timeout-related exceptions; if postcondition cannot be met, terminate() is called'''
formal_spec = '''throws: timeout_exceptions; on_postcondition_failure: std::terminate()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''exception or terminate()'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c9381aa7"
content = '''For predicate overload: lock.owns_lock() must be true and lock.mutex() locked by calling thread with mutex consistency'''
formal_spec = '''requires: lock.owns_lock() && locked_by_current_thread(lock.mutex()) && (no_other_waiters(*this) || all_waiters_same_mutex(*this, lock.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_13f9a447"
content = '''Predicate overload equivalent to: while (!pred()) if (wait_until(lock, abs_time) == cv_status::timeout) return pred(); return true;'''
formal_spec = '''equivalent: while (!pred()) { if (wait_until(lock, abs_time) == cv_status::timeout) return pred(); } return true;'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - implementation defined equivalence'''

[[axioms]]
id = "cpp_stdlib_thread_condition_79e6f5c0"
content = '''Predicate overload: Returns bool indicating whether predicate is true (regardless of timeout). lock.owns_lock() is true.'''
formal_spec = '''ensures: lock.owns_lock(); returns: pred_was_true_at_return (independent of timeout)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "postcondition"
on_violation = '''terminate() is called'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c3b53f94"
content = '''Predicate overload throws timeout-related exceptions or any exception thrown by pred; if postcondition fails, terminate()'''
formal_spec = '''throws: timeout_exceptions || exception_from(pred); on_postcondition_failure: std::terminate()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_until"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''exception or terminate()'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c9381aa7"
content = '''For predicate overload: lock.owns_lock() must be true and lock.mutex() locked by calling thread with mutex consistency'''
formal_spec = '''requires: lock.owns_lock() && locked_by_current_thread(lock.mutex()) && (no_other_waiters(*this) || all_waiters_same_mutex(*this, lock.mutex()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_745857cc"
content = '''Predicate overload equivalent to: return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));'''
formal_spec = '''equivalent: wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - implementation defined equivalence'''

[[axioms]]
id = "cpp_stdlib_thread_condition_2248edf4"
content = '''There is no blocking if pred() is initially true, even if the timeout has already expired'''
formal_spec = '''if (pred()) => no_block()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "invariant"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_c3b53f94"
content = '''Predicate overload throws timeout-related exceptions or any exception thrown by pred; if postcondition fails, terminate()'''
formal_spec = '''throws: timeout_exceptions || exception_from(pred); on_postcondition_failure: std::terminate()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait_for"
header = "<condition_variable>"
axiom_type = "exception"
on_violation = '''exception or terminate()'''

[[axioms]]
id = "cpp_stdlib_thread_condition_36e8deac"
content = '''Template argument Lock must meet Cpp17BasicLockable requirements'''
formal_spec = '''requires: Cpp17BasicLockable<Lock>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable_any"
header = "<condition_variable>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_thread_condition_f629c520"
content = '''Wait functions may unblock spuriously without notification - always use a predicate or check condition in a loop'''
formal_spec = '''warning: wait_may_return_spuriously() => always_check_condition_in_loop()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "anti_pattern"
on_violation = '''race condition / incorrect program behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_4e2553b5"
content = '''Destroying a condition variable while threads are still blocked on it causes undefined behavior. All threads must be notified before destruction.'''
formal_spec = '''warning: destroy_while_threads_waiting(*this) => undefined_behavior'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::~condition_variable"
header = "<condition_variable>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_86d1a466"
content = '''All threads waiting on the same condition_variable must use the same mutex, otherwise behavior is undefined'''
formal_spec = '''warning: different_mutex_per_waiter(*this) => undefined_behavior'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable::wait"
header = "<condition_variable>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_thread_condition_21b85989"
content = '''condition_variable is not copyable or copy-assignable'''
formal_spec = '''condition_variable(const condition_variable&) = delete; operator=(const condition_variable&) = delete;'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable"
header = "<condition_variable>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_thread_condition_914cc474"
content = '''condition_variable_any is not copyable or copy-assignable'''
formal_spec = '''condition_variable_any(const condition_variable_any&) = delete; operator=(const condition_variable_any&) = delete;'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable_any"
header = "<condition_variable>"
axiom_type = "constraint"
on_violation = '''ill-formed'''

[[axioms]]
id = "cpp_stdlib_thread_condition_8895cc85"
content = '''condition_variable is a standard-layout class'''
formal_spec = '''static_assert(std::is_standard_layout_v<condition_variable>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "condition_variable"
header = "<condition_variable>"
axiom_type = "invariant"
on_violation = '''n/a - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_thread_condition_54bfac31"
content = '''notify_one is noexcept - guaranteed not to throw exceptions'''
formal_spec = '''noexcept(notify_one())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "notify_one"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - noexcept guarantee'''

[[axioms]]
id = "cpp_stdlib_thread_condition_3f637d4d"
content = '''notify_all is noexcept - guaranteed not to throw exceptions'''
formal_spec = '''noexcept(notify_all())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/thread.condition"
source_module = "thread.condition"
c_standard_refs = ['[thread.condition]']
function = "notify_all"
header = "<condition_variable>"
axiom_type = "effect"
on_violation = '''n/a - noexcept guarantee'''

[[axioms]]
id = "cpp_stdlib_set_d8250d0d"
content = '''A set contains at most one of each key value (unique keys)'''
formal_spec = '''for all x, y in set: x == y implies &x == &y'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set"
header = "<set>"
axiom_type = "invariant"
on_violation = '''invariant violation - impossible through public API'''

[[axioms]]
id = "cpp_stdlib_set_9bedddcc"
content = '''set provides bidirectional iterators'''
formal_spec = '''iterator models BidirectionalIterator'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set"
header = "<set>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_set_2a367f42"
content = '''set meets all requirements of a container, reversible container, allocator-aware container, and associative container'''
formal_spec = '''set<Key,Compare,Allocator> models Container && ReversibleContainer && AllocatorAwareContainer && AssociativeContainer'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set"
header = "<set>"
axiom_type = "constraint"
on_violation = '''compile error'''

[[axioms]]
id = "cpp_stdlib_set_93497b59"
content = '''For set<Key>, both key_type and value_type are Key'''
formal_spec = '''set<Key>::key_type == Key && set<Key>::value_type == Key'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set"
header = "<set>"
axiom_type = "constraint"
on_violation = '''N/A - definitional'''

[[axioms]]
id = "cpp_stdlib_set_29b48e61"
content = '''The types iterator and const_iterator meet the constexpr iterator requirements'''
formal_spec = '''iterator and const_iterator are usable in constexpr context'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "iterator"
header = "<set>"
axiom_type = "constraint"
on_violation = '''compile error in constexpr context'''

[[axioms]]
id = "cpp_stdlib_set_0024ae4e"
content = '''Constructs an empty set using the specified comparison object and allocator'''
formal_spec = '''postcondition: empty() == true && key_comp() == comp'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set(const Compare&, const Allocator&)"
header = "<set>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_48476cc5"
content = '''Default/comparator constructor has constant complexity'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set(const Compare&, const Allocator&)"
header = "<set>"
axiom_type = "complexity"
on_violation = '''N/A - QoI issue'''

[[axioms]]
id = "cpp_stdlib_set_0980c9b2"
content = '''Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first, last)'''
formal_spec = '''postcondition: contains all unique elements from [first, last)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set(InputIterator, InputIterator, const Compare&, const Allocator&)"
header = "<set>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_74abb96f"
content = '''Range constructor is linear if range is already sorted, otherwise N log N'''
formal_spec = '''O(N) if sorted w.r.t. comp, O(N log N) otherwise, where N = last - first'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set(InputIterator, InputIterator, const Compare&, const Allocator&)"
header = "<set>"
axiom_type = "complexity"
on_violation = '''N/A - QoI issue'''

[[axioms]]
id = "cpp_stdlib_set_c8e2842c"
content = '''Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range rg'''
formal_spec = '''postcondition: contains all unique elements from rg'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "set(from_range_t, R&&, const Compare&, const Allocator&)"
header = "<set>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_1f396f80"
content = '''Erases all elements for which predicate returns true'''
formal_spec = '''for (auto i = c.begin(), last = c.end(); i != last; ) { if (pred(*i)) { i = c.erase(i); } else { ++i; } }'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "erase_if"
header = "<set>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_e37622ee"
content = '''Returns the number of erased elements'''
formal_spec = '''returns: original_size - c.size()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "erase_if"
header = "<set>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_20b64c96"
content = '''Transparent insert requires Compare::is_transparent to be a valid type'''
formal_spec = '''requires: Compare::is_transparent is valid and denotes a type'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "constraint"
on_violation = '''compile error - overload not available'''

[[axioms]]
id = "cpp_stdlib_set_c1f43596"
content = '''Transparent hint insert requires K&& is not convertible to iterator or const_iterator'''
formal_spec = '''requires: is_convertible_v<K&&, const_iterator> == false && is_convertible_v<K&&, iterator> == false'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(const_iterator, K&&)"
header = "<set>"
axiom_type = "constraint"
on_violation = '''compile error - overload not available'''

[[axioms]]
id = "cpp_stdlib_set_af63c184"
content = '''value_type must be EmplaceConstructible from the forwarded argument'''
formal_spec = '''requires: value_type is Cpp17EmplaceConstructible into set from std::forward<K>(x)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_set_4ab10743"
content = '''If set already contains an equivalent element, there is no effect; otherwise constructs and inserts the element'''
formal_spec = '''if exists(e in *this: equiv(e, x)) then no-op else insert(value_type(std::forward<K>(x)))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_97d57af4"
content = '''The constructed value must have the same equivalence class as the lookup key'''
formal_spec = '''let r = equal_range(x); let u = value_type(std::forward<K>(x)); requires: equal_range(u) == r'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_set_ba714fd8"
content = '''Returns pair with iterator to equivalent element and bool indicating if insertion occurred'''
formal_spec = '''returns: pair<iterator, bool> where second == true iff insertion took place, first points to equivalent element'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "postcondition"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_5d43a4dd"
content = '''Transparent insert has logarithmic complexity'''
formal_spec = '''O(log n)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "complexity"
on_violation = '''N/A - QoI issue'''

[[axioms]]
id = "cpp_stdlib_set_72e45bf4"
content = '''Move assignment is noexcept if allocator is always equal and Compare is nothrow move assignable'''
formal_spec = '''noexcept(allocator_traits<Allocator>::is_always_equal::value && is_nothrow_move_assignable_v<Compare>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "operator=(set&&)"
header = "<set>"
axiom_type = "exception"
on_violation = '''may throw'''

[[axioms]]
id = "cpp_stdlib_set_d19d6ca1"
content = '''swap is noexcept if allocator is always equal and Compare is nothrow swappable'''
formal_spec = '''noexcept(allocator_traits<Allocator>::is_always_equal::value && is_nothrow_swappable_v<Compare>)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "swap"
header = "<set>"
axiom_type = "exception"
on_violation = '''may throw'''

[[axioms]]
id = "cpp_stdlib_set_12fe3f7c"
content = '''begin() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "begin"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_c2b6dbac"
content = '''end() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "end"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_78878f08"
content = '''rbegin() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "rbegin"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_26c76338"
content = '''rend() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "rend"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_b438ba91"
content = '''cbegin() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "cbegin"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_c7d5e293"
content = '''cend() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "cend"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_5debe0ee"
content = '''crbegin() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "crbegin"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_848c3ef2"
content = '''crend() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "crend"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_374a3823"
content = '''empty() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "empty"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_06524a55"
content = '''size() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "size"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_f8c0d6af"
content = '''max_size() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "max_size"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_74364b69"
content = '''clear() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "clear"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_0e4dbc0c"
content = '''get_allocator() is noexcept'''
formal_spec = '''noexcept'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "get_allocator"
header = "<set>"
axiom_type = "exception"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_set_e3dcedf8"
content = '''Constructing a value from K&& that has different equivalence than the lookup on K causes undefined behavior'''
formal_spec = '''avoid: insert(k) where value_type(k) has different equivalence class than k under the comparator'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "insert(K&&)"
header = "<set>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_set_b2f10e96"
content = '''Iterator erase is constrained when iterator and const_iterator are the same type'''
formal_spec = '''requires: !same_as<iterator, const_iterator>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/set"
source_module = "set"
c_standard_refs = ['[set]']
function = "erase(iterator)"
header = "<set>"
axiom_type = "constraint"
on_violation = '''overload not available'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_b4a50f6c"
content = '''unique_ptr has strict ownership semantics - it owns and manages another object through a pointer and disposes of it when destroyed'''
formal_spec = '''invariant: owns(u.p) && will_dispose(u.p, u.d) when ~u()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "invariant"
on_violation = '''resource leak or double-free'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_7f8a14e6"
content = '''unique_ptr is MoveConstructible and MoveAssignable but not CopyConstructible nor CopyAssignable'''
formal_spec = '''requires: is_move_constructible_v<unique_ptr<T,D>> && is_move_assignable_v<unique_ptr<T,D>> && !is_copy_constructible_v<unique_ptr<T,D>> && !is_copy_assignable_v<unique_ptr<T,D>>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_89ca428d"
content = '''Template parameter T may be an incomplete type'''
formal_spec = '''permits: incomplete_type(T)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''N/A - this is a permission, not a requirement'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_52c0a192"
content = '''A program that instantiates unique_ptr<T, D> is ill-formed if T* is an invalid type'''
formal_spec = '''requires: valid_pointer_type(T*)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (ill-formed)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_91127dd3"
content = '''Cannot instantiate unique_ptr with reference types or function types with cv-qualifiers'''
formal_spec = '''ill-formed: unique_ptr<T&, D>, unique_ptr<int() const, D>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "anti_pattern"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_aceb8488"
content = '''Deleter D must be a function object type, lvalue reference to function, or lvalue reference to function object type where d(ptr) disposes of the pointer'''
formal_spec = '''requires: is_invocable_v<D&, pointer> && disposes_pointer(d(ptr))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error or undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_18469a7d"
content = '''If deleter type D is not a reference type, D must meet Cpp17Destructible requirements'''
formal_spec = '''requires: is_reference_v<D> || Cpp17Destructible<D>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_e9532933"
content = '''The pointer type must meet Cpp17NullablePointer requirements'''
formal_spec = '''requires: Cpp17NullablePointer<unique_ptr<T,D>::pointer>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_66a824af"
content = '''Converting constructor requires U* to be implicitly convertible to T*'''
formal_spec = '''requires: is_convertible_v<U*, T*>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "default_delete<T>::default_delete(const default_delete<U>&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_c02cf14d"
content = '''T must be a complete type when calling operator()'''
formal_spec = '''mandates: complete_type(T)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "default_delete<T>::operator()"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (ill-formed)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_954394db"
content = '''Calls delete on the pointer'''
formal_spec = '''effect: delete ptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "default_delete<T>::operator()"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_227a22ad"
content = '''Converting constructor for array specialization requires U(*)[] to be convertible to T(*)[]'''
formal_spec = '''requires: is_convertible_v<U(*)[], T(*)[]>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "default_delete<T[]>::default_delete(const default_delete<U[]>&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_e9b77e15"
content = '''Array operator() requires U(*)[] convertible to T(*)[] and U must be complete'''
formal_spec = '''requires: is_convertible_v<U(*)[], T(*)[]> && complete_type(U)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "default_delete<T[]>::operator()"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_2913e1d6"
content = '''Calls delete[] on the pointer'''
formal_spec = '''effect: delete[] ptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "default_delete<T[]>::operator()"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_902841fc"
content = '''Default constructor requires deleter is not a pointer type and is default constructible'''
formal_spec = '''requires: !is_pointer_v<deleter_type> && is_default_constructible_v<deleter_type>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr()"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_9d49d2b3"
content = '''D must meet Cpp17DefaultConstructible requirements and construction must not throw'''
formal_spec = '''requires: Cpp17DefaultConstructible<D> && noexcept(D())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr()"
header = "<memory>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_e20f67cd"
content = '''After default construction, get() returns nullptr'''
formal_spec = '''ensures: get() == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr()"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_696b4499"
content = '''Pointer constructor requires deleter is not a pointer type and is default constructible'''
formal_spec = '''requires: !is_pointer_v<deleter_type> && is_default_constructible_v<deleter_type>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_22b9e36b"
content = '''After pointer construction, get() returns the passed pointer'''
formal_spec = '''ensures: get() == p'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer)"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_daf17545"
content = '''Constructor with lvalue deleter requires D is constructible from the deleter argument'''
formal_spec = '''requires: is_constructible_v<D, const D&>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer, const D&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_9e170ccd"
content = '''If D is not a reference type, D must meet Cpp17CopyConstructible and not throw on construction'''
formal_spec = '''requires: is_reference_v<D> || (Cpp17CopyConstructible<D> && noexcept(D(d)))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer, const D&)"
header = "<memory>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_a7a55599"
content = '''If D is a reference type, the rvalue deleter constructor is deleted'''
formal_spec = '''deleted_if: is_reference_v<D>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer, remove_reference_t<D>&&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_0e8eb5c0"
content = '''Cannot combine rvalue deleter object with reference deleter type'''
formal_spec = '''ill-formed: unique_ptr<T, const D&>(new T, D())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer, D&&)"
header = "<memory>"
axiom_type = "anti_pattern"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_e3e9992c"
content = '''Move constructor requires D is move constructible'''
formal_spec = '''requires: is_move_constructible_v<D>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(unique_ptr&&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_8b256b97"
content = '''After move construction, get() returns what u.get() returned before, and u.get() == nullptr'''
formal_spec = '''ensures: get() == old(u.get()) && u.get() == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(unique_ptr&&)"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_8900e52f"
content = '''Converting move constructor requires: U::pointer convertible to pointer, U is not an array type, and deleter types are compatible'''
formal_spec = '''requires: is_convertible_v<unique_ptr<U,E>::pointer, pointer> && !is_array_v<U> && ((is_reference_v<D> && is_same_v<E, D>) || (!is_reference_v<D> && is_convertible_v<E, D>))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(unique_ptr<U, E>&&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_8e7bbaae"
content = '''After converting move construction, u.get() == nullptr'''
formal_spec = '''ensures: u.get() == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(unique_ptr<U, E>&&)"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_815d5a5e"
content = '''Destructor calls get_deleter()(get()) if get() is non-null'''
formal_spec = '''effect: if (get()) get_deleter()(get())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::~unique_ptr"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_e775f23e"
content = '''The deleter invocation must not throw an exception'''
formal_spec = '''requires: noexcept(get_deleter()(get()))'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::~unique_ptr"
header = "<memory>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_c87565e2"
content = '''When using default_delete, T must be a complete type at destruction'''
formal_spec = '''requires: complete_type(T) when using default_delete<T>'''
layer = "cpp_stdlib"
confidence = 0.95
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::~unique_ptr"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_45ed09e7"
content = '''Move assignment requires D is move assignable'''
formal_spec = '''requires: is_move_assignable_v<D>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(unique_ptr&&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_40e4b7b0"
content = '''Move assignment calls reset(u.release()) then moves the deleter'''
formal_spec = '''effect: reset(u.release()); get_deleter() = std::forward<D>(u.get_deleter())'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(unique_ptr&&)"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_b52a30da"
content = '''After move assignment, u.get() == nullptr (unless self-assignment)'''
formal_spec = '''ensures: (this != &u) implies u.get() == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(unique_ptr&&)"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_7b1a806b"
content = '''Converting move assignment requires compatible pointer types, U is not array, and deleter is assignable'''
formal_spec = '''requires: is_convertible_v<unique_ptr<U,E>::pointer, pointer> && !is_array_v<U> && is_assignable_v<D&, E&&>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(unique_ptr<U, E>&&)"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (constraint not satisfied)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_88b5c04a"
content = '''After converting move assignment, u.get() == nullptr'''
formal_spec = '''ensures: u.get() == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(unique_ptr<U, E>&&)"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_a2f5714e"
content = '''Assigning nullptr is equivalent to reset()'''
formal_spec = '''effect: reset()'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(nullptr_t)"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_4d010eef"
content = '''After nullptr assignment, get() == nullptr'''
formal_spec = '''ensures: get() == nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(nullptr_t)"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_536f08cc"
content = '''Dereferencing must not create a dangling reference'''
formal_spec = '''mandates: !reference_converts_from_temporary_v<add_lvalue_reference_t<T>, decltype(*declval<pointer>())>'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator*"
header = "<memory>"
axiom_type = "constraint"
on_violation = '''compilation error (ill-formed)'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_51d6adbb"
content = '''The stored pointer must not be null when dereferencing'''
formal_spec = '''requires: get() != nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator*"
header = "<memory>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_c253759c"
content = '''The stored pointer must not be null when using arrow operator (implied)'''
formal_spec = '''requires: get() != nullptr'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator->"
header = "<memory>"
axiom_type = "precondition"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_c6d7908e"
content = '''Returns the stored pointer'''
formal_spec = '''returns: stored_pointer'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::get"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_82ff35ef"
content = '''Returns true if the stored pointer is not null'''
formal_spec = '''returns: get() != nullptr'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator bool"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_95d6077d"
content = '''After release(), get() returns nullptr and caller owns the formerly-managed object'''
formal_spec = '''ensures: get() == nullptr && returns old_pointer'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::release"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_0766cf77"
content = '''reset() disposes of the old managed object (if any) and takes ownership of the new pointer'''
formal_spec = '''effect: old = get(); set_pointer(p); if (old) get_deleter()(old)'''
layer = "cpp_stdlib"
confidence = 0.95
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::reset"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_f0aa2ae5"
content = '''After reset(p), get() returns p'''
formal_spec = '''ensures: get() == p'''
layer = "cpp_stdlib"
confidence = 0.95
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::reset"
header = "<memory>"
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_82f381e0"
content = '''Swaps the stored pointers and deleters of two unique_ptrs'''
formal_spec = '''effect: swap(this->ptr, u.ptr); swap(this->deleter, u.deleter)'''
layer = "cpp_stdlib"
confidence = 0.95
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::swap"
header = "<memory>"
axiom_type = "effect"
on_violation = '''N/A'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_c10b1f3e"
content = '''Default construction is constant time'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 0.8
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr()"
header = "<memory>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_5ab8a6b8"
content = '''Destruction is O(1) plus the cost of the deleter invocation'''
formal_spec = '''O(1) + deleter_cost'''
layer = "cpp_stdlib"
confidence = 0.8
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::~unique_ptr"
header = "<memory>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_ec98abbd"
content = '''get() is constant time'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::get"
header = "<memory>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_cb2756fc"
content = '''release() is constant time'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::release"
header = "<memory>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_250c5ff8"
content = '''reset() is constant time plus deleter invocation'''
formal_spec = '''O(1) + deleter_cost'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::reset"
header = "<memory>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_34b44bfd"
content = '''swap() is constant time'''
formal_spec = '''O(1)'''
layer = "cpp_stdlib"
confidence = 0.9
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::swap"
header = "<memory>"
axiom_type = "complexity"
on_violation = '''N/A - quality of implementation'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_5c46ecc3"
content = '''Default constructor is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr()"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_adf617f1"
content = '''Pointer constructor is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(pointer)"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_d1ab1862"
content = '''Move constructor is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::unique_ptr(unique_ptr&&)"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_3c5b7f6a"
content = '''Move assignment is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator=(unique_ptr&&)"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_f42e33c7"
content = '''release() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::release"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_22203e78"
content = '''reset() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::reset"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_d84e4faa"
content = '''swap() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::swap"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_d4dbdac4"
content = '''get() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::get"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_2dfc3708"
content = '''operator->() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator->"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_10a0333c"
content = '''operator bool() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator bool"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_63c98ca5"
content = '''get_deleter() is noexcept'''
formal_spec = '''noexcept: true'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::get_deleter"
header = "<memory>"
axiom_type = "exception"
on_violation = '''N/A - guaranteed by signature'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_475f799b"
content = '''Do not copy unique_ptr - it has deleted copy constructor and copy assignment'''
formal_spec = '''deleted: unique_ptr(const unique_ptr&), operator=(const unique_ptr&)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr"
header = "<memory>"
axiom_type = "anti_pattern"
on_violation = '''compilation error'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_5aa1f3d4"
content = '''Do not dereference a null unique_ptr'''
formal_spec = '''anti_pattern: *unique_ptr<T>() or *unique_ptr<T>(nullptr)'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::operator*"
header = "<memory>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''

[[axioms]]
id = "cpp_stdlib_unique_ptr_09f11f59"
content = '''Do not use a deleter that throws exceptions'''
formal_spec = '''anti_pattern: deleter that throws'''
layer = "cpp_stdlib"
confidence = 1.0
source_file = "eel.is/c++draft/unique.ptr"
source_module = "unique.ptr"
c_standard_refs = ['[unique.ptr]']
function = "unique_ptr::~unique_ptr"
header = "<memory>"
axiom_type = "anti_pattern"
on_violation = '''undefined behavior'''
