version = "1.0"
source = "eel.is/c++draft"
extracted_at = "2025-12-30T02:09:16.597755+00:00"
[[axioms]]
id = "cpp20_container_reqmts_value_type_erasable_a1b2c3d4"
content = "Container value_type T must be Cpp17Erasable from container X."
formal_spec = "container(X) && value_type(X, T) => Cpp17Erasable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/2-3"
tags = [ "container", "requirements", "precondition", "erasable",]

[[axioms]]
id = "cpp20_container_reqmts_copy_ctor_precondition_b2c3d4e5"
content = "Copy constructing a container requires T to be Cpp17CopyInsertable into X."
formal_spec = "copy_construct(container(X)) => Cpp17CopyInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/12"
tags = [ "container", "requirements", "precondition", "copy",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_container_reqmts_equality_precondition_c3d4e5f6"
content = "Container equality comparison requires T to meet Cpp17EqualityComparable requirements."
formal_spec = "equality_compare(container(X, T)) => Cpp17EqualityComparable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/42"
tags = [ "container", "requirements", "precondition", "equality",]

[[axioms]]
id = "cpp20_container_reqmts_swap_allocator_ub_d4e5f6a7"
content = "Swapping containers with unequal allocators when propagate_on_container_swap is false is undefined behavior."
formal_spec = "swap(container(a), container(b)) && !propagate_on_container_swap(allocator_type) && a.get_allocator() != b.get_allocator() => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/65"
tags = [ "container", "swap", "allocator", "undefined-behavior",]

[[axioms]]
id = "cpp20_container_reqmts_insert_single_exception_safety_e5f6a7b8"
content = "If an exception is thrown by insert() or emplace() while inserting a single element, the function has no effects (strong exception guarantee)."
formal_spec = "(insert_single(container, elem) || emplace_single(container, args)) && throws_exception => no_effects"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.1"
tags = [ "container", "exception-safety", "insert", "emplace",]
depends_on = [ "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_container_reqmts_push_exception_safety_f6a7b8c9"
content = "If an exception is thrown by push_back(), push_front(), emplace_back(), or emplace_front(), the function has no effects (strong exception guarantee)."
formal_spec = "(push_back(container) || push_front(container) || emplace_back(container) || emplace_front(container)) && throws_exception => no_effects"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.2"
tags = [ "container", "exception-safety", "push",]
depends_on = [ "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_container_reqmts_erase_nothrow_a7b8c9d0"
content = "Container erase(), clear(), pop_back(), and pop_front() functions do not throw exceptions."
formal_spec = "(erase(container) || clear(container) || pop_back(container) || pop_front(container)) => nothrow"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.3"
tags = [ "container", "exception-safety", "erase", "nothrow",]

[[axioms]]
id = "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1"
content = "No copy constructor or assignment operator of a returned container iterator throws an exception."
formal_spec = "(copy_construct(iterator) || copy_assign(iterator)) && is_container_iterator(iterator) => nothrow"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.4"
tags = [ "container", "iterator", "exception-safety", "nothrow",]
depends_on = [ "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_iterator_operations_prev_effect_d6a0b3c8", "c11_cpp_translation_name_syntax_operation_018c4422", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_container_reqmts_swap_nothrow_c9d0e1f2"
content = "Container swap() function does not throw an exception."
formal_spec = "swap(container) => nothrow"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.5"
tags = [ "container", "swap", "exception-safety", "nothrow",]
depends_on = [ "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_container_reqmts_swap_no_invalidate_d0e1f2a3"
content = "Container swap() does not invalidate any references, pointers, or iterators referring to elements of the swapped containers (end() iterator may be invalidated)."
formal_spec = "swap(container(a), container(b)) => valid(element_references(a)) && valid(element_references(b))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.6"
tags = [ "container", "swap", "iterator-validity",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4"
content = "Container allocator_type::value_type must be the same as container value_type."
formal_spec = "allocator_aware_container(X) => allocator_type(X)::value_type == value_type(X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/5"
tags = [ "container", "allocator", "mandates",]

[[axioms]]
id = "cpp20_container_alloc_reqmts_default_ctor_precondition_f2a3b4c5"
content = "Default constructing an allocator-aware container requires the allocator type to meet Cpp17DefaultConstructible requirements."
formal_spec = "default_construct(allocator_aware_container(X)) => Cpp17DefaultConstructible(allocator_type(X))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/8"
tags = [ "container", "allocator", "precondition", "default-constructor",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_container_alloc_reqmts_copy_ctor_alloc_precondition_a3b4c5d6"
content = "Copy constructing an allocator-aware container with a specified allocator requires T to be Cpp17CopyInsertable into X."
formal_spec = "copy_construct_with_allocator(allocator_aware_container(X), m) => Cpp17CopyInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/13"
tags = [ "container", "allocator", "precondition", "copy",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_container_alloc_reqmts_move_ctor_alloc_precondition_b4c5d6e7"
content = "Move constructing an allocator-aware container with a different allocator requires T to be Cpp17MoveInsertable into X."
formal_spec = "move_construct_with_allocator(allocator_aware_container(X), rv, m) => Cpp17MoveInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/18"
tags = [ "container", "allocator", "precondition", "move",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_container_alloc_reqmts_copy_assign_precondition_c5d6e7f8"
content = "Copy assignment of an allocator-aware container requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable."
formal_spec = "copy_assign(allocator_aware_container(X)) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/22"
tags = [ "container", "allocator", "precondition", "copy-assignment",]
depends_on = [ "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4",]

[[axioms]]
id = "cpp20_container_alloc_reqmts_move_assign_precondition_d6e7f8a9"
content = "Move assignment of an allocator-aware container requires T to be Cpp17MoveInsertable and Cpp17MoveAssignable if propagate_on_container_move_assignment is false."
formal_spec = "move_assign(allocator_aware_container(X)) && !propagate_on_container_move_assignment(allocator_type) => Cpp17MoveInsertable(T, X) && Cpp17MoveAssignable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/26"
tags = [ "container", "allocator", "precondition", "move-assignment",]
depends_on = [ "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3",]

[[axioms]]
id = "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0"
content = "Implementations must avoid data races when contents of different elements in the same container are modified concurrently (except for vector<bool>)."
formal_spec = "container(X) && !is_vector_bool(X) && modify_concurrent(element(i), element(j)) && i != j => no_data_race"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.requirements.dataraces"
source_module = "[container.requirements.dataraces]/2"
tags = [ "container", "concurrency", "data-race",]

[[axioms]]
id = "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1"
content = "For vector<bool>, modifying different elements concurrently can result in a data race (exception to general container rule)."
formal_spec = "is_vector_bool(X) && modify_concurrent(element(i), element(j)) => possible_data_race"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.requirements.dataraces"
source_module = "[container.requirements.dataraces]/3"
tags = [ "container", "concurrency", "data-race", "vector-bool",]
depends_on = [ "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_sequence_reqmts_n_copies_precondition_a9b0c1d2"
content = "Constructing a sequence container with n copies of t requires T to be Cpp17CopyInsertable into X."
formal_spec = "construct(sequence_container(X), n, t) => Cpp17CopyInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/5"
tags = [ "sequence-container", "precondition", "copy",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3"
content = "Constructing a sequence container from iterator range [i,j) requires T to be Cpp17EmplaceConstructible from *i."
formal_spec = "construct(sequence_container(X), i, j) => Cpp17EmplaceConstructible(T, X, *i)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/8"
tags = [ "sequence-container", "precondition", "iterator",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_iterator_operations_prev_effect_d6a0b3c8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_sequence_reqmts_assign_il_precondition_c1d2e3f4"
content = "Assignment from initializer_list requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable."
formal_spec = "assign(sequence_container(X), initializer_list) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/17"
tags = [ "sequence-container", "precondition", "initializer-list",]
depends_on = [ "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a",]

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_precondition_d2e3f4a5"
content = "Calling emplace(p, args) requires T to be Cpp17EmplaceConstructible from args. For vector, inplace_vector, and deque, T must also be Cpp17MoveInsertable and Cpp17MoveAssignable."
formal_spec = "emplace(sequence_container(X), p, args) => Cpp17EmplaceConstructible(T, X, args) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => (Cpp17MoveInsertable(T, X) && Cpp17MoveAssignable(T)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/21"
tags = [ "sequence-container", "emplace", "precondition",]

[[axioms]]
id = "cpp20_sequence_reqmts_insert_copy_precondition_e3f4a5b6"
content = "Calling insert(p, t) requires T to be Cpp17CopyInsertable. For vector, inplace_vector, and deque, T must also be Cpp17CopyAssignable."
formal_spec = "insert(sequence_container(X), p, t) => Cpp17CopyInsertable(T, X) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17CopyAssignable(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/25"
tags = [ "sequence-container", "insert", "precondition",]

[[axioms]]
id = "cpp20_sequence_reqmts_insert_move_precondition_f4a5b6c7"
content = "Calling insert(p, rv) requires T to be Cpp17MoveInsertable. For vector, inplace_vector, and deque, T must also be Cpp17MoveAssignable."
formal_spec = "insert(sequence_container(X), p, rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17MoveAssignable(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/29"
tags = [ "sequence-container", "insert", "precondition", "move",]

[[axioms]]
id = "cpp20_sequence_reqmts_insert_n_precondition_a5b6c7d8"
content = "Calling insert(p, n, t) requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable."
formal_spec = "insert(sequence_container(X), p, n, t) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/33"
tags = [ "sequence-container", "insert", "precondition",]

[[axioms]]
id = "cpp20_sequence_reqmts_insert_range_no_self_b6c7d8e9"
content = "Calling insert(p, i, j) with iterators i and j that are iterators into the container a is undefined behavior."
formal_spec = "insert(sequence_container(a), p, i, j) && (is_iterator_into(i, a) || is_iterator_into(j, a)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/37"
tags = [ "sequence-container", "insert", "precondition", "iterator",]

[[axioms]]
id = "cpp20_sequence_reqmts_insert_range_rg_no_overlap_c7d8e9f0"
content = "Calling insert_range(p, rg) requires that rg and the container a do not overlap."
formal_spec = "insert_range(sequence_container(a), p, rg) && overlaps(rg, a) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/41"
tags = [ "sequence-container", "insert", "precondition", "range",]

[[axioms]]
id = "cpp20_sequence_reqmts_erase_precondition_d8e9f0a1"
content = "Calling erase(q) on vector, inplace_vector, and deque requires T to be Cpp17MoveAssignable."
formal_spec = "erase(sequence_container(X), q) && (is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17MoveAssignable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/46"
tags = [ "sequence-container", "erase", "precondition",]

[[axioms]]
id = "cpp20_sequence_reqmts_assign_range_no_overlap_e9f0a1b2"
content = "Calling assign(i, j) with iterators i and j that are iterators into the container a is undefined behavior."
formal_spec = "assign(sequence_container(a), i, j) && (is_iterator_into(i, a) || is_iterator_into(j, a)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/58"
tags = [ "sequence-container", "assign", "precondition", "iterator",]

[[axioms]]
id = "cpp20_sequence_reqmts_assign_range_rg_no_overlap_f0a1b2c3"
content = "Calling assign_range(rg) requires that rg and the container a do not overlap."
formal_spec = "assign_range(sequence_container(a), rg) && overlaps(rg, a) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/62"
tags = [ "sequence-container", "assign", "precondition", "range",]

[[axioms]]
id = "cpp20_sequence_reqmts_assign_n_no_self_ref_a1b2c3d4"
content = "Calling assign(n, t) requires that t is not a reference into the container a."
formal_spec = "assign(sequence_container(a), n, t) && is_reference_into(t, a) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/67"
tags = [ "sequence-container", "assign", "precondition",]
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_front_precondition_b2c3d4e5"
content = "Calling front() on a container requires the container to be non-empty (hardened precondition)."
formal_spec = "call(front, container(a)) && a.empty() => hardened_precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/72"
tags = [ "sequence-container", "front", "precondition", "hardened",]
function = "front"
header = "<vector>"
signature = "reference front()"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_back_precondition_c3d4e5f6"
content = "Calling back() on a container requires the container to be non-empty (hardened precondition)."
formal_spec = "call(back, container(a)) && a.empty() => hardened_precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/76"
tags = [ "sequence-container", "back", "precondition", "hardened",]
function = "back"
header = "<vector>"
signature = "reference back()"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_front_precondition_d4e5f6a7"
content = "Calling emplace_front(args) requires T to be Cpp17EmplaceConstructible into X from args."
formal_spec = "emplace_front(sequence_container(X), args) => Cpp17EmplaceConstructible(T, X, args)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/80"
tags = [ "sequence-container", "emplace_front", "precondition",]
function = "emplace_front"
header = "<deque>"
signature = "reference emplace_front(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_back_precondition_e5f6a7b8"
content = "Calling emplace_back(args) requires T to be Cpp17EmplaceConstructible into X from args. For vector, T must also be Cpp17MoveInsertable."
formal_spec = "emplace_back(sequence_container(X), args) => Cpp17EmplaceConstructible(T, X, args) && (is_vector(X) => Cpp17MoveInsertable(T, X))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/85"
tags = [ "sequence-container", "emplace_back", "precondition",]
function = "emplace_back"
header = "<vector>"
signature = "reference emplace_back(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_push_front_copy_precondition_f6a7b8c9"
content = "Calling push_front(t) requires T to be Cpp17CopyInsertable into X."
formal_spec = "push_front(sequence_container(X), t) => Cpp17CopyInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/90"
tags = [ "sequence-container", "push_front", "precondition",]
function = "push_front"
header = "<deque>"
signature = "void push_front(const T& t)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_push_front_move_precondition_a7b8c9d0"
content = "Calling push_front(rv) requires T to be Cpp17MoveInsertable into X."
formal_spec = "push_front(sequence_container(X), rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/94"
tags = [ "sequence-container", "push_front", "precondition", "move",]
function = "push_front"
header = "<deque>"
signature = "void push_front(T&& rv)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_push_back_copy_precondition_b8c9d0e1"
content = "Calling push_back(t) requires T to be Cpp17CopyInsertable into X."
formal_spec = "push_back(sequence_container(X), t) => Cpp17CopyInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/102"
tags = [ "sequence-container", "push_back", "precondition",]
function = "push_back"
header = "<vector>"
signature = "void push_back(const T& t)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_push_back_move_precondition_c9d0e1f2"
content = "Calling push_back(rv) requires T to be Cpp17MoveInsertable into X."
formal_spec = "push_back(sequence_container(X), rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/106"
tags = [ "sequence-container", "push_back", "precondition", "move",]
function = "push_back"
header = "<vector>"
signature = "void push_back(T&& rv)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_sequence_reqmts_pop_front_precondition_d0e1f2a3"
content = "Calling pop_front() on a container requires the container to be non-empty (hardened precondition)."
formal_spec = "call(pop_front, container(a)) && a.empty() => hardened_precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/114"
tags = [ "sequence-container", "pop_front", "precondition", "hardened",]
function = "pop_front"
header = "<deque>"
signature = "void pop_front()"

[[axioms]]
id = "cpp20_sequence_reqmts_pop_back_precondition_e1f2a3b4"
content = "Calling pop_back() on a container requires the container to be non-empty (hardened precondition)."
formal_spec = "call(pop_back, container(a)) && a.empty() => hardened_precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/118"
tags = [ "sequence-container", "pop_back", "precondition", "hardened",]
function = "pop_back"
header = "<vector>"
signature = "void pop_back()"

[[axioms]]
id = "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5"
content = "Calling operator[](n) on a container requires n < a.size() (hardened precondition)."
formal_spec = "call(operator[], container(a), n) && n >= a.size() => hardened_precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/122"
tags = [ "sequence-container", "subscript", "precondition", "hardened",]
function = "operator[]"
header = "<vector>"
signature = "reference operator[](size_type n)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_range_access_size_returns_integer_like_a8b1c5d9", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6"
content = "Calling at(n) throws out_of_range if n >= a.size()."
formal_spec = "call(at, container(a), n) && n >= a.size() => throws(out_of_range)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/127"
tags = [ "sequence-container", "at", "exception",]
function = "at"
header = "<vector>"
signature = "reference at(size_type n)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4", "cpp20_range_access_size_returns_integer_like_a8b1c5d9",]

[[axioms]]
id = "cpp20_container_opt_reqmts_threeway_precondition_b4c5d6e7"
content = "Container three-way comparison requires either T models three_way_comparable, or operator< is defined for T and is a total ordering relationship."
formal_spec = "three_way_compare(container(X, T)) => (three_way_comparable(T) || (defined(operator<, T) && total_ordering(operator<, T)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.opt.reqmts"
source_module = "[container.opt.reqmts]/3"
tags = [ "container", "comparison", "precondition",]
depends_on = [ "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_container_node_pair_specialization_ub_c5d6e7f8"
content = "If a user-defined specialization of pair exists for pair<const Key, T> or pair<Key, T>, where Key is the container's key_type and T is the container's mapped_type, the behavior of operations involving node handles is undefined."
formal_spec = "user_specialization(pair<const Key, T>) || user_specialization(pair<Key, T>) => node_handle_operations_undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.overview"
source_module = "[container.node.overview]/4"
tags = [ "container", "node-handle", "undefined-behavior", "pair",]

[[axioms]]
id = "cpp20_container_node_move_assign_precondition_d6e7f8a9"
content = "Node handle move assignment requires either the target is empty, or propagate_on_container_move_assignment is true, or the allocators are equal."
formal_spec = "move_assign(node_handle, nh) && alloc_.has_value() && !propagate_on_container_move_assignment && alloc_ != nh.alloc_ => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.cons"
source_module = "[container.node.cons]/2"
tags = [ "container", "node-handle", "precondition", "move-assignment",]
depends_on = [ "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3",]

[[axioms]]
id = "cpp20_container_node_value_precondition_e7f8a9b0"
content = "Calling value() on a node handle requires the node handle to be non-empty."
formal_spec = "call(value, node_handle(nh)) && nh.empty() => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/1"
tags = [ "container", "node-handle", "precondition",]
function = "node_handle::value"
header = "<map>"
signature = "value_type& value() const"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_value_type_constraint_e5f6a7b8", "c11_c_conversion_syntax_operation_c943b988",]

[[axioms]]
id = "cpp20_container_node_key_precondition_f8a9b0c1"
content = "Calling key() on a node handle requires the node handle to be non-empty."
formal_spec = "call(key, node_handle(nh)) && nh.empty() => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/4"
tags = [ "container", "node-handle", "precondition",]
function = "node_handle::key"
header = "<map>"
signature = "key_type& key() const"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "c11_c_typing_effective_syntax_comparison_5b005edd", "c11_cpp_typing_sorts_operation_720193ca", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "c11_c_decl_global_syntax_comparison_232484e5",]

[[axioms]]
id = "cpp20_container_node_mapped_precondition_a9b0c1d2"
content = "Calling mapped() on a node handle requires the node handle to be non-empty."
formal_spec = "call(mapped, node_handle(nh)) && nh.empty() => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/8"
tags = [ "container", "node-handle", "precondition",]
function = "node_handle::mapped"
header = "<map>"
signature = "mapped_type& mapped() const"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_container_node_get_allocator_precondition_b0c1d2e3"
content = "Calling get_allocator() on a node handle requires the node handle to be non-empty."
formal_spec = "call(get_allocator, node_handle(nh)) && nh.empty() => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/11"
tags = [ "container", "node-handle", "precondition",]
function = "node_handle::get_allocator"
header = "<map>"
signature = "allocator_type get_allocator() const"
depends_on = [ "cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4",]

[[axioms]]
id = "cpp20_container_node_swap_precondition_c1d2e3f4"
content = "Swapping node handles requires either both are empty, or propagate_on_container_swap is true, or the allocators are equal."
formal_spec = "swap(node_handle(nh1), node_handle(nh2)) && nh1.alloc_.has_value() && nh2.alloc_.has_value() && !propagate_on_container_swap && nh1.alloc_ != nh2.alloc_ => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.modifiers"
source_module = "[container.node.modifiers]/1"
tags = [ "container", "node-handle", "precondition", "swap",]

[[axioms]]
id = "cpp20_forward_rvalue_overload_mandates_a3b7c9d1"
content = "The second overload of std::forward (taking remove_reference_t<T>&&) requires that is_lvalue_reference_v<T> is false. Attempting to forward an rvalue as an lvalue reference is ill-formed."
formal_spec = "call(std::forward<T>, remove_reference_t<T>&&) && is_lvalue_reference_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/2"
tags = [ "forwarding", "move_semantics", "mandates", "type_constraint",]
function = "std::forward"
header = "<utility>"
signature = "template<class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept"
depends_on = [ "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_basic_lval_temp_materialization_b4e9f1c5", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a",]

[[axioms]]
id = "cpp20_forward_lvalue_overload_returns_f2e8a1c4"
content = "The first overload of std::forward (taking remove_reference_t<T>&) returns static_cast<T&&>(t), preserving the value category of the original expression."
formal_spec = "call(std::forward<T>, remove_reference_t<T>&) => static_cast<T&&>(t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/3"
tags = [ "forwarding", "move_semantics", "perfect_forwarding",]
function = "std::forward"
header = "<utility>"
signature = "template<class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_forward_rvalue_overload_returns_b5d9e3f7"
content = "The second overload of std::forward (taking remove_reference_t<T>&&) returns static_cast<T&&>(t), enabling forwarding of rvalues."
formal_spec = "call(std::forward<T>, remove_reference_t<T>&&) && !is_lvalue_reference_v<T> => static_cast<T&&>(t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/3"
tags = [ "forwarding", "move_semantics", "perfect_forwarding",]
function = "std::forward"
header = "<utility>"
signature = "template<class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_forward_like_mandates_referenceable_c7a2b4e6"
content = "std::forward_like requires that T is a referenceable type. A type is referenceable if it can have a reference formed to it (not void, not a function type with cv-qualifiers or ref-qualifiers)."
formal_spec = "call(std::forward_like<T>, U&&) && !is_referenceable_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/5"
tags = [ "forwarding", "mandates", "type_constraint", "forward_like",]
function = "std::forward_like"
header = "<utility>"
signature = "template<class T, class U> constexpr auto forward_like(U&& x) noexcept -> see below"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_forward_like_return_type_d8f1c3a9"
content = "std::forward_like<T>(x) returns static_cast<V>(x) where V is computed as OVERRIDE_REF(T&&, COPY_CONST(remove_reference_t<T>, remove_reference_t<U>)), propagating const-ness and reference category from T to U."
formal_spec = "let COPY_CONST(A, B) = is_const_v<A> ? const B : B; let OVERRIDE_REF(A, B) = is_rvalue_reference_v<A> ? remove_reference_t<B>&& : B&; let V = OVERRIDE_REF(T&&, COPY_CONST(remove_reference_t<T>, remove_reference_t<U>)); forward_like<T>(x) => static_cast<V>(x)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "forward"
source_module = "[forward]/6-7"
tags = [ "forwarding", "forward_like", "const_propagation", "reference_propagation",]
function = "std::forward_like"
header = "<utility>"
signature = "template<class T, class U> constexpr auto forward_like(U&& x) noexcept -> V"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_move_returns_rvalue_ref_e4b6d2a8"
content = "std::move(t) returns static_cast<remove_reference_t<T>&&>(t), unconditionally casting t to an rvalue reference to enable move semantics."
formal_spec = "call(std::move<T>, T&&) => static_cast<remove_reference_t<T>&&>(t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/10"
tags = [ "move_semantics", "rvalue_reference", "cast",]
function = "std::move"
header = "<utility>"
signature = "template<class T> constexpr remove_reference_t<T>&& move(T&& t) noexcept"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_move_if_noexcept_conditional_f9c5a1b3"
content = "std::move_if_noexcept(x) returns a const lvalue reference if the type is not nothrow move constructible but is copy constructible; otherwise returns an rvalue reference. This enables strong exception safety when moving could throw."
formal_spec = "move_if_noexcept(x) => (!is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>) ? const T& : T&&"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/11-12"
tags = [ "move_semantics", "exception_safety", "conditional_move",]
function = "std::move_if_noexcept"
header = "<utility>"
signature = "template<class T> constexpr conditional_t<!is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>, const T&, T&&> move_if_noexcept(T& x) noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_basic_lval_temp_materialization_b4e9f1c5", "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_forward_signal_safe_a2d4f6c8"
content = "All functions specified in [forward] (std::forward, std::forward_like, std::move, std::move_if_noexcept) are signal-safe and may be called from signal handlers."
formal_spec = "is_signal_safe(std::forward) && is_signal_safe(std::forward_like) && is_signal_safe(std::move) && is_signal_safe(std::move_if_noexcept)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/1"
tags = [ "signal_safety", "async_signal_safe",]
function = "std::forward"
header = "<utility>"
signature = "template<class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1"
content = "The template std::swap(T&, T&) requires is_move_constructible_v<T> to be true."
formal_spec = "call(swap(a, b)) => is_move_constructible_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/1"
tags = [ "swap", "constraint", "type_traits", "move_constructible",]
function = "std::swap"
header = "<utility>"
signature = "template<class T> constexpr void swap(T& a, T& b) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2"
content = "The template std::swap(T&, T&) requires is_move_assignable_v<T> to be true."
formal_spec = "call(swap(a, b)) => is_move_assignable_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/1"
tags = [ "swap", "constraint", "type_traits", "move_assignable",]
function = "std::swap"
header = "<utility>"
signature = "template<class T> constexpr void swap(T& a, T& b) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_precond_cpp17moveconstructible_b5c9d3e7"
content = "Calling std::swap(T&, T&) requires that type T meets the Cpp17MoveConstructible requirements."
formal_spec = "call(swap(a, b)) => meets_cpp17_move_constructible<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/2"
tags = [ "swap", "precondition", "named_requirements", "move_constructible",]
function = "std::swap"
header = "<utility>"
signature = "template<class T> constexpr void swap(T& a, T& b) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_precond_cpp17moveassignable_f6g0h4i8"
content = "Calling std::swap(T&, T&) requires that type T meets the Cpp17MoveAssignable requirements."
formal_spec = "call(swap(a, b)) => meets_cpp17_move_assignable<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/2"
tags = [ "swap", "precondition", "named_requirements", "move_assignable",]
function = "std::swap"
header = "<utility>"
signature = "template<class T> constexpr void swap(T& a, T& b) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_effect_exchange_values_c7d1e5f9"
content = "std::swap(T&, T&) exchanges the values stored in the two locations."
formal_spec = "pre(a == A && b == B) && call(swap(a, b)) => post(a == B && b == A)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/3"
tags = [ "swap", "effect", "exchange",]
function = "std::swap"
header = "<utility>"
signature = "template<class T> constexpr void swap(T& a, T& b) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_noexcept_spec_g8h2i6j0"
content = "The noexcept specification of std::swap(T&, T&) is equivalent to is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>."
formal_spec = "noexcept(swap(a, b)) == (is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/4"
tags = [ "swap", "noexcept", "exception_specification",]
function = "std::swap"
header = "<utility>"
signature = "template<class T> constexpr void swap(T& a, T& b) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_any_reset_noexcept_b7c8d9e0", "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6",]

[[axioms]]
id = "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1"
content = "The array overload of std::swap requires is_swappable_v<T> to be true."
formal_spec = "call(swap(a[N], b[N])) => is_swappable_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/5"
tags = [ "swap", "constraint", "array", "type_traits", "swappable",]
function = "std::swap"
header = "<utility>"
signature = "template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)"
depends_on = [ "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a",]

[[axioms]]
id = "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2"
content = "Calling std::swap on arrays requires that a[i] is swappable with b[i] for all i in the range [0, N)."
formal_spec = "call(swap(a[N], b[N])) => forall(i in [0, N): is_swappable_with(a[i], b[i]))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/6"
tags = [ "swap", "precondition", "array", "swappable",]
function = "std::swap"
header = "<utility>"
signature = "template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)"
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_utility_swap_array_effect_swap_ranges_s1t5u9v3"
content = "std::swap on arrays has the effect of calling swap_ranges(a, a+N, b)."
formal_spec = "call(swap(a[N], b[N])) => effect_equivalent(swap_ranges(a, a+N, b))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/7"
tags = [ "swap", "effect", "array", "swap_ranges",]
function = "std::swap"
header = "<utility>"
signature = "template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"
content = "The noexcept specification of std::swap for arrays is is_nothrow_swappable_v<T>."
formal_spec = "noexcept(swap(a[N], b[N])) == is_nothrow_swappable_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/5"
tags = [ "swap", "noexcept", "array", "exception_specification",]
function = "std::swap"
header = "<utility>"
signature = "template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)"
depends_on = [ "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_any_reset_noexcept_b7c8d9e0", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r",]

[[axioms]]
id = "cpp20_declval_odr_use_forbidden_7c8e3f2a"
content = "The function template std::declval shall not be odr-used. It is only valid as an unevaluated operand."
formal_spec = "odr_used(declval<T>()) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "declval"
source_module = "[declval]/2"
tags = [ "unevaluated", "odr-use", "template", "metaprogramming",]
function = "std::declval"
header = "<utility>"
signature = "template<class T> add_rvalue_reference_t<T> declval() noexcept"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2",]

[[axioms]]
id = "cpp20_declval_incomplete_type_allowed_b5a9d4c1"
content = "The template parameter T of std::declval may be an incomplete type."
formal_spec = "declval<T>() => allows(incomplete_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "declval"
source_module = "[declval]/3"
tags = [ "incomplete-type", "template", "metaprogramming", "type-traits",]
function = "std::declval"
header = "<utility>"
signature = "template<class T> add_rvalue_reference_t<T> declval() noexcept"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0",]

[[axioms]]
id = "cpp20_variant_no_args_illformed_a1b2c3d4"
content = "A program that instantiates the definition of variant with no template arguments is ill-formed."
formal_spec = "sizeof...(Types) == 0 && instantiate(variant<Types...>) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/3"
tags = [ "variant", "template", "constraint", "ill-formed",]
header = "<variant>"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2",]

[[axioms]]
id = "cpp20_variant_explicit_specialization_illformed_e5f6g7h8"
content = "If a program declares an explicit or partial specialization of variant, the program is ill-formed, no diagnostic required."
formal_spec = "(explicit_specialization(variant) || partial_specialization(variant)) => ill_formed_ndr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/4"
tags = [ "variant", "specialization", "ill-formed", "ndr",]
header = "<variant>"

[[axioms]]
id = "cpp20_variant_types_destructible_i9j0k1l2"
content = "All types in the variant Types parameter pack shall meet the Cpp17Destructible requirements."
formal_spec = "forall Ti in Types: meets_cpp17_destructible(Ti)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/2"
tags = [ "variant", "constraint", "destructible",]
header = "<variant>"

[[axioms]]
id = "cpp20_variant_get_index_precondition_m3n4o5p6"
content = "Calling GET<I>(v) requires that v.index() is I."
formal_spec = "call(GET<I>, v) => precondition(v.index() == I)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/4"
tags = [ "variant", "precondition", "get", "access",]
function = "GET"
header = "<variant>"
signature = "variant_alternative_t<I, variant<Types...>>& GET(variant<Types...>& v)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0"
content = "Calling std::get<I>(v) throws bad_variant_access if v.index() is not I."
formal_spec = "call(get<I>, v) && v.index() != I => throws(bad_variant_access)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/7"
tags = [ "variant", "exception", "get", "access",]
function = "std::get"
header = "<variant>"
signature = "variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_variant_bad_variant_access_u1v2w3x4",]

[[axioms]]
id = "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8"
content = "Calling std::get<T>(v) throws bad_variant_access if v does not hold a value of type T."
formal_spec = "call(get<T>, v) && !holds_alternative<T>(v) => throws(bad_variant_access)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/9"
tags = [ "variant", "exception", "get", "access",]
function = "std::get"
header = "<variant>"
signature = "T& get(variant<Types...>& v)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0", "cpp20_variant_bad_variant_access_u1v2w3x4",]

[[axioms]]
id = "cpp20_variant_bad_variant_access_u1v2w3x4"
content = "Objects of type bad_variant_access are thrown to report invalid accesses to the value of a variant object."
formal_spec = "invalid_variant_access => throws(bad_variant_access)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.bad.access"
source_module = "[variant.bad.access]/1"
tags = [ "variant", "exception", "bad_variant_access",]
header = "<variant>"
depends_on = [ "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0",]

[[axioms]]
id = "cpp20_variant_get_index_mandates_c9d0e1f2"
content = "std::get<I> mandates that I is less than sizeof...(Types)."
formal_spec = "call(get<I>, variant<Types...>) => mandates(I < sizeof...(Types))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/6"
tags = [ "variant", "mandates", "get", "constraint",]
function = "std::get"
header = "<variant>"
signature = "variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_get_type_mandates_unique_g3h4i5j6"
content = "std::get<T> mandates that the type T occurs exactly once in Types."
formal_spec = "call(get<T>, variant<Types...>) => mandates(count(T, Types) == 1)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/8"
tags = [ "variant", "mandates", "get", "constraint",]
function = "std::get"
header = "<variant>"
signature = "T& get(variant<Types...>& v)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_holds_alternative_mandates_k7l8m9n0"
content = "holds_alternative<T> mandates that the type T occurs exactly once in Types."
formal_spec = "call(holds_alternative<T>, variant<Types...>) => mandates(count(T, Types) == 1)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/1"
tags = [ "variant", "mandates", "holds_alternative", "constraint",]
function = "std::holds_alternative"
header = "<variant>"
signature = "bool holds_alternative(const variant<Types...>& v) noexcept"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_alternative_mandates_o1p2q3r4"
content = "variant_alternative<I, variant<Types...>>::type mandates that I is less than sizeof...(Types)."
formal_spec = "variant_alternative<I, variant<Types...>> => mandates(I < sizeof...(Types))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.helper"
source_module = "[variant.helper]/4"
tags = [ "variant", "mandates", "variant_alternative", "constraint",]
header = "<variant>"

[[axioms]]
id = "cpp20_variant_emplace_mandates_s5t6u7v8"
content = "emplace<I>(...) mandates that I is less than sizeof...(Types)."
formal_spec = "call(emplace<I>, variant<Types...>) => mandates(I < sizeof...(Types))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/5"
tags = [ "variant", "mandates", "emplace", "constraint",]
function = "std::variant::emplace"
header = "<variant>"
signature = "variant_alternative_t<I, variant<Types...>>& emplace(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_emplace_valueless_w9x0y1z2"
content = "If an exception is thrown during the initialization of the contained value in emplace, the variant is permitted to not hold a value (become valueless_by_exception)."
formal_spec = "call(emplace<I>, v, args...) && throws_during_init => permitted(v.valueless_by_exception())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/11"
tags = [ "variant", "exception", "emplace", "valueless",]
function = "std::variant::emplace"
header = "<variant>"
signature = "variant_alternative_t<I, variant<Types...>>& emplace(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r",]

[[axioms]]
id = "cpp20_variant_swap_precondition_swappable_a3b4c5d6"
content = "Each Ti must meet the Cpp17Swappable requirements for variant::swap."
formal_spec = "call(swap, variant<Types...>&, variant<Types...>&) => precondition(forall Ti in Types: cpp17_swappable(Ti))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.swap"
source_module = "[variant.swap]/2"
tags = [ "variant", "precondition", "swap", "swappable",]
function = "std::variant::swap"
header = "<variant>"
signature = "void swap(variant& rhs) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_swap_mandates_move_constructible_e7f8g9h0"
content = "variant::swap mandates that is_move_constructible_v<Ti> is true for all i."
formal_spec = "call(swap, variant<Types...>&) => mandates(forall Ti in Types: is_move_constructible_v<Ti>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.swap"
source_module = "[variant.swap]/1"
tags = [ "variant", "mandates", "swap", "move_constructible",]
function = "std::variant::swap"
header = "<variant>"
signature = "void swap(variant& rhs) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4"
content = "std::visit throws bad_variant_access if any variant argument is valueless_by_exception."
formal_spec = "call(visit, vis, vars...) && (exists v in vars: v.valueless_by_exception()) => throws(bad_variant_access)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.visit"
source_module = "[variant.visit]/7"
tags = [ "variant", "exception", "visit", "valueless",]
function = "std::visit"
header = "<variant>"
signature = "see below visit(Visitor&& vis, Variants&&... vars)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0", "cpp20_variant_bad_variant_access_u1v2w3x4",]

[[axioms]]
id = "cpp20_variant_visit_mandates_valid_expression_m5n6o7p8"
content = "For each valid pack m, e(m) must be a valid expression and all such expressions must be of the same type and value category."
formal_spec = "call(visit, vis, vars...) => mandates(forall valid m: valid_expr(e(m)) && same_type_and_category(all e(m)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.visit"
source_module = "[variant.visit]/5"
tags = [ "variant", "mandates", "visit", "constraint",]
function = "std::visit"
header = "<variant>"
signature = "see below visit(Visitor&& vis, Variants&&... vars)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2"
content = "Constructor with in_place_type_t<T> requires exactly one occurrence of T in Types."
formal_spec = "call(variant, in_place_type_t<T>, args...) => constraint(count(T, Types) == 1)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/20"
tags = [ "variant", "constraint", "constructor", "in_place",]
function = "std::variant::variant"
header = "<variant>"
signature = "variant(in_place_type_t<T>, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6"
content = "Constructor with in_place_index_t<I> requires I to be less than sizeof...(Types)."
formal_spec = "call(variant, in_place_index_t<I>, args...) => constraint(I < sizeof...(Types))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/30"
tags = [ "variant", "constraint", "constructor", "in_place",]
function = "std::variant::variant"
header = "<variant>"
signature = "variant(in_place_index_t<I>, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_variant_move_assign_exception_valueless_y7z8a9b0"
content = "If an exception is thrown during the call to Tj's move construction in move assignment, the variant will hold no value."
formal_spec = "move_assign(v, rhs) && throws_during_move_construct(Tj) => v.valueless_by_exception()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/10.1"
tags = [ "variant", "exception", "assignment", "valueless",]
function = "std::variant::operator="
header = "<variant>"
signature = "variant& operator=(variant&& rhs) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4"
content = "If an exception is thrown during the initialization of the contained value in converting assignment, the variant object is permitted to not hold a value."
formal_spec = "converting_assign(v, t) && throws_during_init => permitted(v.valueless_by_exception())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/16.2"
tags = [ "variant", "exception", "assignment", "valueless",]
function = "std::variant::operator="
header = "<variant>"
signature = "variant& operator=(T&& t) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r",]

[[axioms]]
id = "cpp20_variant_index_valueless_returns_npos_g5h6i7j8"
content = "If valueless_by_exception() is true, index() returns variant_npos."
formal_spec = "v.valueless_by_exception() => v.index() == variant_npos"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.status"
source_module = "[variant.status]/3"
tags = [ "variant", "valueless", "index", "npos",]
function = "std::variant::index"
header = "<variant>"
signature = "size_t index() const noexcept"

[[axioms]]
id = "cpp20_variant_valueless_by_exception_k9l0m1n2"
content = "valueless_by_exception() returns false if and only if the variant holds a value."
formal_spec = "v.valueless_by_exception() == false <=> v.holds_value()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.status"
source_module = "[variant.status]/1"
tags = [ "variant", "valueless", "status",]
function = "std::variant::valueless_by_exception"
header = "<variant>"
signature = "bool valueless_by_exception() const noexcept"

[[axioms]]
id = "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"
content = "get_if returns nullptr if v is nullptr or if v->index() != I."
formal_spec = "(v == nullptr || v->index() != I) => get_if<I>(v) == nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/11"
tags = [ "variant", "get_if", "nullptr", "access",]
function = "std::get_if"
header = "<variant>"
signature = "add_pointer_t<variant_alternative_t<I, variant<Types...>>> get_if(variant<Types...>* v) noexcept"
depends_on = [ "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_variant_get_if_mandates_index_s7t8u9v0"
content = "get_if<I> mandates that I is less than sizeof...(Types)."
formal_spec = "call(get_if<I>, variant<Types...>*) => mandates(I < sizeof...(Types))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/10"
tags = [ "variant", "mandates", "get_if", "constraint",]
function = "std::get_if"
header = "<variant>"
signature = "add_pointer_t<variant_alternative_t<I, variant<Types...>>> get_if(variant<Types...>* v) noexcept"
depends_on = [ "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_variant_get_if_type_mandates_unique_w1x2y3z4"
content = "get_if<T> mandates that the type T occurs exactly once in Types."
formal_spec = "call(get_if<T>, variant<Types...>*) => mandates(count(T, Types) == 1)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/12"
tags = [ "variant", "mandates", "get_if", "constraint",]
function = "std::get_if"
header = "<variant>"
signature = "add_pointer_t<T> get_if(variant<Types...>* v) noexcept"
depends_on = [ "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_variant_emplace_type_unique_a5b6c7d8"
content = "emplace<T>(...) requires T to occur exactly once in Types."
formal_spec = "call(emplace<T>, variant<Types...>) => constraint(count(T, Types) == 1)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/1"
tags = [ "variant", "constraint", "emplace",]
function = "std::variant::emplace"
header = "<variant>"
signature = "T& emplace(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_hash_enabled_condition_e9f0g1h2"
content = "The specialization hash<variant<Types...>> is enabled if and only if every specialization in hash<remove_const_t<Types>>... is enabled."
formal_spec = "enabled(hash<variant<Types...>>) <=> forall Ti in Types: enabled(hash<remove_const_t<Ti>>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.hash"
source_module = "[variant.hash]/1"
tags = [ "variant", "hash", "constraint",]
header = "<variant>"

[[axioms]]
id = "cpp20_variant_dtor_destroys_value_i3j4k5l6"
content = "The variant destructor destroys the currently contained value if valueless_by_exception() is false."
formal_spec = "!v.valueless_by_exception() && destruct(v) => destroy(contained_value(v))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.dtor"
source_module = "[variant.dtor]/1"
tags = [ "variant", "destructor", "lifetime",]
function = "std::variant::~variant"
header = "<variant>"
signature = "~variant()"
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_class_dtor_member_destruction_order_a7e4c9d2",]

[[axioms]]
id = "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0"
content = "Converting constructor is ill-formed if the expression FUN(forward<T>(t)) is not well-formed (e.g., ambiguous overload)."
formal_spec = "!well_formed(FUN(forward<T>(t))) => ill_formed(variant(t))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/15.5"
tags = [ "variant", "constraint", "constructor", "ambiguous",]
function = "std::variant::variant"
header = "<variant>"
signature = "variant(T&& t) noexcept(see below)"
depends_on = [ "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4"
content = "Converting assignment is ill-formed if the expression FUN(forward<T>(t)) is not well-formed (e.g., ambiguous overload)."
formal_spec = "!well_formed(FUN(forward<T>(t))) => ill_formed(v = t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/12.3"
tags = [ "variant", "constraint", "assignment", "ambiguous",]
function = "std::variant::operator="
header = "<variant>"
signature = "variant& operator=(T&& t) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d", "cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_relops_valueless_equal_u5v6w7x8"
content = "Two valueless variants compare equal."
formal_spec = "v.valueless_by_exception() && w.valueless_by_exception() => (v == w) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.relops"
source_module = "[variant.relops]/2"
tags = [ "variant", "comparison", "valueless", "equality",]
function = "operator=="
header = "<variant>"
signature = "bool operator==(const variant<Types...>& v, const variant<Types...>& w)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_relops_valueless_less_y9z0a1b2"
content = "A valueless variant is less than a non-valueless variant."
formal_spec = "v.valueless_by_exception() && !w.valueless_by_exception() => (v < w) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.relops"
source_module = "[variant.relops]/6"
tags = [ "variant", "comparison", "valueless", "ordering",]
function = "operator<"
header = "<variant>"
signature = "bool operator<(const variant<Types...>& v, const variant<Types...>& w)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_spaceship_valueless_ordering_c3d4e5f6"
content = "In three-way comparison, two valueless variants yield strong_ordering::equal, valueless < non-valueless yields strong_ordering::less, non-valueless > valueless yields strong_ordering::greater."
formal_spec = "v.valueless_by_exception() && w.valueless_by_exception() => (v <=> w) == strong_ordering::equal && v.valueless_by_exception() && !w.valueless_by_exception() => (v <=> w) == strong_ordering::less"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.relops"
source_module = "[variant.relops]/13"
tags = [ "variant", "comparison", "spaceship", "valueless",]
function = "operator<=>"
header = "<variant>"
signature = "common_comparison_category_t<compare_three_way_result_t<Types>...> operator<=>(const variant<Types...>& v, const variant<Types...>& w)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0"
content = "The copy constructor is defined as deleted unless is_copy_constructible_v<Ti> is true for all i."
formal_spec = "!(forall Ti in Types: is_copy_constructible_v<Ti>) => deleted(variant(const variant&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/9"
tags = [ "variant", "constraint", "constructor", "copy", "deleted",]
function = "std::variant::variant"
header = "<variant>"
signature = "variant(const variant& w) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"
content = "The copy assignment operator is defined as deleted unless is_copy_constructible_v<Ti> && is_copy_assignable_v<Ti> is true for all i."
formal_spec = "!(forall Ti in Types: is_copy_constructible_v<Ti> && is_copy_assignable_v<Ti>) => deleted(variant::operator=(const variant&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/5"
tags = [ "variant", "constraint", "assignment", "copy", "deleted",]
function = "std::variant::operator="
header = "<variant>"
signature = "variant& operator=(const variant& rhs)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_variant_swap_specialized_constraints_o5p6q7r8"
content = "The specialized swap for variant requires is_move_constructible_v<Ti> && is_swappable_v<Ti> is true for all i."
formal_spec = "call(swap, variant<Types...>&, variant<Types...>&) => constraint(forall Ti in Types: is_move_constructible_v<Ti> && is_swappable_v<Ti>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.specalg"
source_module = "[variant.specalg]/1"
tags = [ "variant", "constraint", "swap",]
function = "std::swap"
header = "<variant>"
signature = "void swap(variant<Types...>& v, variant<Types...>& w) noexcept(see below)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_expected_unexpected_illformed_type_a1b2c3d4"
content = "A program that instantiates the definition of unexpected for a non-object type, an array type, a specialization of unexpected, or a cv-qualified type is ill-formed."
formal_spec = "instantiate(unexpected<E>) && (is_non_object_type(E) || is_array_type(E) || is_specialization_of(E, unexpected) || is_cv_qualified(E)) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.general"
source_module = "[expected.un.general]/2"
tags = [ "type_constraint", "unexpected", "ill-formed",]
header = "<expected>"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_expected_value_type_constraint_e5f6a7b8"
content = "A type T is a valid value type for expected if remove_cv_t<T> is void or a complete non-array object type that is not in_place_t, unexpect_t, or a specialization of unexpected."
formal_spec = "valid_value_type(T) <=> (is_void(remove_cv_t<T>) || (is_complete_object_type(T) && !is_array_type(T) && !is_same(remove_cv_t<T>, in_place_t) && !is_same(remove_cv_t<T>, unexpect_t) && !is_specialization_of(remove_cv_t<T>, unexpected)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/2"
tags = [ "type_constraint", "expected", "value_type",]
header = "<expected>"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_expected_error_type_constraint_c9d0e1f2"
content = "A program that instantiates the definition of expected<T, E> with a type for the E parameter that is not a valid template argument for unexpected is ill-formed."
formal_spec = "instantiate(expected<T, E>) && !valid_unexpected_arg(E) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/2"
tags = [ "type_constraint", "expected", "error_type", "ill-formed",]
header = "<expected>"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0",]

[[axioms]]
id = "cpp20_expected_t_destructible_a3b4c5d6"
content = "When T is not cv void, T shall meet the Cpp17Destructible requirements."
formal_spec = "instantiate(expected<T, E>) && !is_void(T) => Cpp17Destructible(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/3"
tags = [ "type_constraint", "expected", "destructible",]
header = "<expected>"

[[axioms]]
id = "cpp20_expected_e_destructible_e7f8a9b0"
content = "E shall meet the Cpp17Destructible requirements."
formal_spec = "instantiate(expected<T, E>) => Cpp17Destructible(E)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/3"
tags = [ "type_constraint", "expected", "error_type", "destructible",]
header = "<expected>"

[[axioms]]
id = "cpp20_expected_arrow_precondition_c1d2e3f4"
content = "Calling operator->() on expected requires has_value() to be true."
formal_spec = "call(expected<T,E>::operator->()) => precondition(has_value() == true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/1"
tags = [ "precondition", "expected", "observer", "hardened",]
function = "std::expected::operator->"
header = "<expected>"
signature = "constexpr const T* std::expected<T, E>::operator->() const noexcept"
depends_on = [ "cpp20_const_pointer_cast_mandates_7a8b9c0d", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_expected_deref_precondition_a5b6c7d8"
content = "Calling operator*() on expected requires has_value() to be true."
formal_spec = "call(expected<T,E>::operator*()) => precondition(has_value() == true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/3"
tags = [ "precondition", "expected", "observer", "hardened",]
function = "std::expected::operator*"
header = "<expected>"
signature = "constexpr const T& std::expected<T, E>::operator*() const& noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_expected_deref_rvalue_precondition_e9f0a1b2"
content = "Calling operator*() rvalue overloads on expected requires has_value() to be true."
formal_spec = "call(expected<T,E>::operator*() &&) || call(expected<T,E>::operator*() const&&) => precondition(has_value() == true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/5"
tags = [ "precondition", "expected", "observer", "hardened",]
function = "std::expected::operator*"
header = "<expected>"
signature = "constexpr T&& std::expected<T, E>::operator*() && noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_expected_value_throws_bad_access_c3d4e5f6"
content = "Calling value() on expected when has_value() is false throws bad_expected_access with the error."
formal_spec = "!has_value() && call(expected<T,E>::value()) => throws(bad_expected_access<E>(error()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/10"
tags = [ "exception", "expected", "observer", "bad_expected_access",]
function = "std::expected::value"
header = "<expected>"
signature = "constexpr const T& std::expected<T, E>::value() const&"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"
content = "Calling value() rvalue overloads on expected when has_value() is false throws bad_expected_access with moved error."
formal_spec = "!has_value() && (call(expected<T,E>::value() &&) || call(expected<T,E>::value() const&&)) => throws(bad_expected_access<E>(std::move(error())))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/13"
tags = [ "exception", "expected", "observer", "bad_expected_access",]
function = "std::expected::value"
header = "<expected>"
signature = "constexpr T&& std::expected<T, E>::value() &&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_error_precondition_e1f2a3b4"
content = "Calling error() on expected requires has_value() to be false."
formal_spec = "call(expected<T,E>::error()) => precondition(has_value() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/14"
tags = [ "precondition", "expected", "observer", "hardened",]
function = "std::expected::error"
header = "<expected>"
signature = "constexpr const E& std::expected<T, E>::error() const& noexcept"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_error_rvalue_precondition_c5d6e7f8"
content = "Calling error() rvalue overloads on expected requires has_value() to be false."
formal_spec = "call(expected<T,E>::error() &&) || call(expected<T,E>::error() const&&) => precondition(has_value() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/16"
tags = [ "precondition", "expected", "observer", "hardened",]
function = "std::expected::error"
header = "<expected>"
signature = "constexpr E&& std::expected<T, E>::error() && noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_and_then_mandates_a9b0c1d2"
content = "For and_then, the result type U must be a specialization of expected and U::error_type must be same as E."
formal_spec = "call(expected<T,E>::and_then(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F, val>>, expected) && is_same_v<typename U::error_type, E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/3"
tags = [ "mandates", "expected", "monadic", "and_then",]
function = "std::expected::and_then"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::and_then(F&& f) &"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_or_else_mandates_e3f4a5b6"
content = "For or_else, the result type G must be a specialization of expected and G::value_type must be same as T."
formal_spec = "call(expected<T,E>::or_else(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F, error()>>, expected) && is_same_v<typename G::value_type, T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/11"
tags = [ "mandates", "expected", "monadic", "or_else",]
function = "std::expected::or_else"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::or_else(F&& f) &"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_transform_mandates_c7d8e9f0"
content = "For transform, the result type U must be a valid value type for expected."
formal_spec = "call(expected<T,E>::transform(F)) => mandates(valid_value_type(remove_cv_t<invoke_result_t<F, val>>))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/19"
tags = [ "mandates", "expected", "monadic", "transform",]
function = "std::expected::transform"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::transform(F&& f) &"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_transform_error_mandates_a1b2c3d4"
content = "For transform_error, the result type G must be a valid template argument for unexpected."
formal_spec = "call(expected<T,E>::transform_error(F)) => mandates(valid_unexpected_arg(remove_cv_t<invoke_result_t<F, error()>>))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/27"
tags = [ "mandates", "expected", "monadic", "transform_error",]
function = "std::expected::transform_error"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::transform_error(F&& f) &"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2",]

[[axioms]]
id = "cpp20_unexpected_swap_mandates_e5f6a7b8"
content = "Calling swap on unexpected mandates that is_swappable_v<E> is true."
formal_spec = "call(unexpected<E>::swap(other)) => mandates(is_swappable_v<E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.swap"
source_module = "[expected.un.swap]/1"
tags = [ "mandates", "unexpected", "swap",]
function = "std::unexpected::swap"
header = "<expected>"
signature = "constexpr void std::unexpected<E>::swap(unexpected& other) noexcept(is_nothrow_swappable_v<E>)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_error_type_constraint_c9d0e1f2", "cpp20_expected_unexpected_illformed_type_a1b2c3d4",]

[[axioms]]
id = "cpp20_unexpected_equality_mandates_c9d0e1f2"
content = "The expression x.error() == y.error() must be well-formed and its result convertible to bool for unexpected equality comparison."
formal_spec = "call(operator==(unexpected<E1>, unexpected<E2>)) => mandates(well_formed(x.error() == y.error()) && is_convertible_v<decltype(x.error() == y.error()), bool>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.eq"
source_module = "[expected.un.eq]/1"
tags = [ "mandates", "unexpected", "equality",]
function = "operator=="
header = "<expected>"
signature = "template<class E2> friend constexpr bool operator==(const unexpected& x, const unexpected<E2>& y)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_expected_void_e_destructible_a3b4c5d6"
content = "For expected<void, E>, E shall meet the requirements of Cpp17Destructible."
formal_spec = "instantiate(expected<void, E>) => Cpp17Destructible(E)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.general"
source_module = "[expected.void.general]/3"
tags = [ "type_constraint", "expected", "void", "destructible",]
header = "<expected>"

[[axioms]]
id = "cpp20_expected_void_error_precondition_e7f8a9b0"
content = "Calling error() on expected<void, E> requires has_value() to be false."
formal_spec = "call(expected<void,E>::error()) => precondition(has_value() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/5"
tags = [ "precondition", "expected", "void", "observer", "hardened",]
function = "std::expected<void,E>::error"
header = "<expected>"
signature = "constexpr const E& std::expected<T, E>::error() const& noexcept"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4"
content = "Calling error() rvalue overloads on expected<void, E> requires has_value() to be false."
formal_spec = "call(expected<void,E>::error() &&) || call(expected<void,E>::error() const&&) => precondition(has_value() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/7"
tags = [ "precondition", "expected", "void", "observer", "hardened",]
function = "std::expected<void,E>::error"
header = "<expected>"
signature = "constexpr E&& std::expected<T, E>::error() && noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_void_value_throws_bad_access_a5b6c7d8"
content = "Calling value() on expected<void, E> when has_value() is false throws bad_expected_access with the error."
formal_spec = "!has_value() && call(expected<void,E>::value()) => throws(bad_expected_access<E>(error()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/4"
tags = [ "exception", "expected", "void", "observer", "bad_expected_access",]
function = "std::expected<void,E>::value"
header = "<expected>"
signature = "constexpr void std::expected<T, E>::value() const&"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_copy_ctor_deleted_e9f0a1b2"
content = "The copy constructor of expected is defined as deleted unless both T and E are copy constructible."
formal_spec = "!is_copy_constructible_v<T> || !is_copy_constructible_v<E> => deleted(expected<T,E>::expected(const expected&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.cons"
source_module = "[expected.object.cons]/9"
tags = [ "constraint", "expected", "constructor", "deleted",]
function = "std::expected::expected"
header = "<expected>"
signature = "constexpr std::expected<T, E>::expected(const expected& rhs)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_copy_assign_deleted_c3d4e5f6"
content = "The copy assignment operator of expected is defined as deleted unless T and E are copy assignable, copy constructible, and at least one of T or E is nothrow move constructible."
formal_spec = "(!is_copy_assignable_v<T> || !is_copy_constructible_v<T> || !is_copy_assignable_v<E> || !is_copy_constructible_v<E> || (!is_nothrow_move_constructible_v<T> && !is_nothrow_move_constructible_v<E>)) => deleted(expected<T,E>::operator=(const expected&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.assign"
source_module = "[expected.object.assign]/4"
tags = [ "constraint", "expected", "assignment", "deleted",]
function = "std::expected::operator="
header = "<expected>"
signature = "constexpr std::expected<T, E>& std::expected<T, E>::operator=(const expected& rhs)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "c11_cpp_translation_name_syntax_operation_018c4422", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"
content = "The copy constructor of expected<void, E> is defined as deleted unless E is copy constructible."
formal_spec = "!is_copy_constructible_v<E> => deleted(expected<void,E>::expected(const expected&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.cons"
source_module = "[expected.void.cons]/5"
tags = [ "constraint", "expected", "void", "constructor", "deleted",]
function = "std::expected<void,E>::expected"
header = "<expected>"
signature = "constexpr std::expected<T, E>::expected(const expected& rhs)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8",]

[[axioms]]
id = "cpp20_expected_void_copy_assign_deleted_e1f2a3b4"
content = "The copy assignment operator of expected<void, E> is defined as deleted unless E is copy assignable and copy constructible."
formal_spec = "(!is_copy_assignable_v<E> || !is_copy_constructible_v<E>) => deleted(expected<void,E>::operator=(const expected&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.assign"
source_module = "[expected.void.assign]/3"
tags = [ "constraint", "expected", "void", "assignment", "deleted",]
function = "std::expected<void,E>::operator="
header = "<expected>"
signature = "constexpr std::expected<T, E>& std::expected<T, E>::operator=(const expected& rhs)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "c11_cpp_translation_name_syntax_operation_018c4422", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_value_mandates_copy_e_c5d6e7f8"
content = "Calling value() on expected mandates that E is copy constructible."
formal_spec = "call(expected<T,E>::value() const&) || call(expected<T,E>::value() &) => mandates(is_copy_constructible_v<E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/8"
tags = [ "mandates", "expected", "observer", "value",]
function = "std::expected::value"
header = "<expected>"
signature = "constexpr const T& std::expected<T, E>::value() const&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_value_rvalue_mandates_a9b0c1d2"
content = "Calling value() rvalue overloads on expected mandates that E is copy constructible and constructible from decltype(std::move(error()))."
formal_spec = "call(expected<T,E>::value() &&) || call(expected<T,E>::value() const&&) => mandates(is_copy_constructible_v<E> && is_constructible_v<E, decltype(std::move(error()))>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/11"
tags = [ "mandates", "expected", "observer", "value",]
function = "std::expected::value"
header = "<expected>"
signature = "constexpr T&& std::expected<T, E>::value() &&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_value_or_mandates_e3f4a5b6"
content = "Calling value_or() const& mandates that T is copy constructible and U is convertible to T."
formal_spec = "call(expected<T,E>::value_or(U&&) const&) => mandates(is_copy_constructible_v<T> && is_convertible_v<U, T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/18"
tags = [ "mandates", "expected", "observer", "value_or",]
function = "std::expected::value_or"
header = "<expected>"
signature = "template<class U = remove_cv_t<T>> constexpr T std::expected<T, E>::value_or(U&& v) const&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0"
content = "Calling value_or() && mandates that T is move constructible and U is convertible to T."
formal_spec = "call(expected<T,E>::value_or(U&&) &&) => mandates(is_move_constructible_v<T> && is_convertible_v<U, T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/20"
tags = [ "mandates", "expected", "observer", "value_or",]
function = "std::expected::value_or"
header = "<expected>"
signature = "template<class U = remove_cv_t<T>> constexpr T std::expected<T, E>::value_or(U&& v) &&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_error_or_mandates_a1b2c3d4"
content = "Calling error_or() const& mandates that E is copy constructible and G is convertible to E."
formal_spec = "call(expected<T,E>::error_or(G&&) const&) => mandates(is_copy_constructible_v<E> && is_convertible_v<G, E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/22"
tags = [ "mandates", "expected", "observer", "error_or",]
function = "std::expected::error_or"
header = "<expected>"
signature = "template<class G = E> constexpr E std::expected<T, E>::error_or(G&& e) const&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8"
content = "Calling error_or() && mandates that E is move constructible and G is convertible to E."
formal_spec = "call(expected<T,E>::error_or(G&&) &&) => mandates(is_move_constructible_v<E> && is_convertible_v<G, E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/24"
tags = [ "mandates", "expected", "observer", "error_or",]
function = "std::expected::error_or"
header = "<expected>"
signature = "template<class G = E> constexpr E std::expected<T, E>::error_or(G&& e) &&"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_bad_expected_access_exception_purpose_c9d0e1f2"
content = "The class template bad_expected_access defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of an expected<T, E> object for which has_value() is false."
formal_spec = "!has_value() && access_value(expected<T,E>) => may_throw(bad_expected_access<E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.bad"
source_module = "[expected.bad]/1"
tags = [ "exception", "bad_expected_access", "expected",]
header = "<expected>"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_basic_life_end_without_destructor_9c0d1e2f", "cpp20_class_dtor_trivial_conditions_a9d6e5b8",]

[[axioms]]
id = "cpp20_expected_void_and_then_mandates_a3b4c5d6"
content = "For and_then on expected<void, E>, the result type U must be a specialization of expected and U::error_type must be same as E."
formal_spec = "call(expected<void,E>::and_then(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F>>, expected) && is_same_v<typename U::error_type, E>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/3"
tags = [ "mandates", "expected", "void", "monadic", "and_then",]
function = "std::expected<void,E>::and_then"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::and_then(F&& f) &"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_void_or_else_mandates_e7f8a9b0"
content = "For or_else on expected<void, E>, the result type G must be a specialization of expected and G::value_type must be void."
formal_spec = "call(expected<void,E>::or_else(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F, error()>>, expected) && is_void_v<typename G::value_type>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/11"
tags = [ "mandates", "expected", "void", "monadic", "or_else",]
function = "std::expected<void,E>::or_else"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::or_else(F&& f) &"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_void_transform_mandates_c1d2e3f4"
content = "For transform on expected<void, E>, the result type U must be a valid value type for expected."
formal_spec = "call(expected<void,E>::transform(F)) => mandates(valid_value_type(remove_cv_t<invoke_result_t<F>>))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/19"
tags = [ "mandates", "expected", "void", "monadic", "transform",]
function = "std::expected<void,E>::transform"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::transform(F&& f) &"
depends_on = [ "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2",]

[[axioms]]
id = "cpp20_expected_void_transform_error_mandates_a5b6c7d8"
content = "For transform_error on expected<void, E>, the result type G must be a valid template argument for unexpected."
formal_spec = "call(expected<void,E>::transform_error(F)) => mandates(valid_unexpected_arg(remove_cv_t<invoke_result_t<F, error()>>))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/27"
tags = [ "mandates", "expected", "void", "monadic", "transform_error",]
function = "std::expected<void,E>::transform_error"
header = "<expected>"
signature = "template<class F> constexpr auto std::expected<T, E>::transform_error(F&& f) &"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_expected_copy_assign_deleted_c3d4e5f6", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_expected_copy_ctor_deleted_e9f0a1b2", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2",]

[[axioms]]
id = "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9"
content = "Calling std::advance with a negative distance n requires the iterator to be a bidirectional iterator."
formal_spec = "n < 0 && !models<Cpp17BidirectionalIterator>(InputIterator) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/2"
tags = [ "iterator", "precondition", "bidirectional",]
function = "std::advance"
header = "<iterator>"
signature = "template<class InputIterator, class Distance> constexpr void advance(InputIterator& i, Distance n)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_iterator_operations_distance_reachable_precondition_b4e8d1f6"
content = "Calling std::distance requires that last is reachable from first, or for random access iterators, first is reachable from last."
formal_spec = "(!reachable(first, last) && !(models<Cpp17RandomAccessIterator>(InputIterator) && reachable(last, first))) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/4"
tags = [ "iterator", "precondition", "reachability",]
function = "std::distance"
header = "<iterator>"
signature = "template<class InputIterator> constexpr typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last)"
depends_on = [ "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0",]

[[axioms]]
id = "cpp20_iterator_operations_next_effect_c5f9a2b7"
content = "std::next advances a copy of the iterator by n positions and returns the result."
formal_spec = "next(x, n) == (advance(copy(x), n), copy(x))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/6"
tags = [ "iterator", "effect",]
function = "std::next"
header = "<iterator>"
signature = "template<class InputIterator> constexpr InputIterator next(InputIterator x, typename iterator_traits<InputIterator>::difference_type n = 1)"
depends_on = [ "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_iterator_operations_prev_effect_d6a0b3c8"
content = "std::prev retreats a copy of the iterator by n positions and returns the result."
formal_spec = "prev(x, n) == (advance(copy(x), -n), copy(x))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/7"
tags = [ "iterator", "effect", "bidirectional",]
function = "std::prev"
header = "<iterator>"
signature = "template<class BidirectionalIterator> constexpr BidirectionalIterator prev(BidirectionalIterator x, typename iterator_traits<BidirectionalIterator>::difference_type n = 1)"
depends_on = [ "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "cpp20_iterator_operations_next_effect_c5f9a2b7",]

[[axioms]]
id = "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9"
content = "std::prev requires a bidirectional iterator because it calls advance with a negative value (-n)."
formal_spec = "call(prev, x, n) => models<Cpp17BidirectionalIterator>(BidirectionalIterator) && n >= 0"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/7"
tags = [ "iterator", "precondition", "bidirectional",]
function = "std::prev"
header = "<iterator>"
signature = "template<class BidirectionalIterator> constexpr BidirectionalIterator prev(BidirectionalIterator x, typename iterator_traits<BidirectionalIterator>::difference_type n = 1)"
depends_on = [ "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_no_data_race_modify_a3b7c9d1"
content = "Algorithms shall not modify objects referenced through an iterator argument unless the specification requires such modification, for purposes of determining the existence of data races."
formal_spec = "algorithm(iter_args...) && !specification_requires_modification(iter_arg) => !modifies(object_referenced_by(iter_arg))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/3"
tags = [ "concurrency", "data-race", "iterator", "modification",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_mutable_iterator_required_e5f2a8b4"
content = "If an algorithm's Effects element specifies that a value pointed to by any iterator passed as argument is modified, then the type of that argument shall meet the requirements of a mutable iterator."
formal_spec = "algorithm_effects_modifies_value(iter) => meets_mutable_iterator_requirements(decltype(iter))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.1"
tags = [ "iterator", "mutable", "constraint", "modification",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"
content = "If an algorithm's template parameter is named InputIterator, InputIterator1, or InputIterator2, the template argument shall meet the Cpp17InputIterator requirements."
formal_spec = "template_param_name(param) in {\"InputIterator\", \"InputIterator1\", \"InputIterator2\"} => meets_cpp17_input_iterator_requirements(template_arg(param))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.2"
tags = [ "iterator", "input-iterator", "constraint", "template",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4",]

[[axioms]]
id = "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"
content = "If an algorithm's template parameter is named OutputIterator, OutputIterator1, or OutputIterator2, the template argument shall meet the Cpp17OutputIterator requirements."
formal_spec = "template_param_name(param) in {\"OutputIterator\", \"OutputIterator1\", \"OutputIterator2\"} => meets_cpp17_output_iterator_requirements(template_arg(param))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.3"
tags = [ "iterator", "output-iterator", "constraint", "template",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0",]

[[axioms]]
id = "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8"
content = "If an algorithm's template parameter is named ForwardIterator, ForwardIterator1, ForwardIterator2, or NoThrowForwardIterator, the template argument shall meet the Cpp17ForwardIterator requirements if it is required to be a mutable iterator, or model forward_iterator otherwise."
formal_spec = "template_param_name(param) in {\"ForwardIterator\", \"ForwardIterator1\", \"ForwardIterator2\", \"NoThrowForwardIterator\"} => (requires_mutable_iterator(param) ? meets_cpp17_forward_iterator_requirements(template_arg(param)) : models_forward_iterator(template_arg(param)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.4"
tags = [ "iterator", "forward-iterator", "constraint", "template",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2"
content = "If an algorithm's template parameter is named NoThrowForwardIterator, the template argument is required to have the property that no exceptions are thrown from increment, assignment, or comparison of, or indirection through, valid iterators."
formal_spec = "template_param_name(param) == \"NoThrowForwardIterator\" => noexcept(++valid_iter) && noexcept(valid_iter = other) && noexcept(valid_iter == other) && noexcept(*valid_iter)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.5"
tags = [ "iterator", "forward-iterator", "noexcept", "constraint", "exception",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0",]

[[axioms]]
id = "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6"
content = "If an algorithm's template parameter is named BidirectionalIterator, BidirectionalIterator1, or BidirectionalIterator2, the template argument shall meet the Cpp17BidirectionalIterator requirements if it is required to be a mutable iterator, or model bidirectional_iterator otherwise."
formal_spec = "template_param_name(param) in {\"BidirectionalIterator\", \"BidirectionalIterator1\", \"BidirectionalIterator2\"} => (requires_mutable_iterator(param) ? meets_cpp17_bidirectional_iterator_requirements(template_arg(param)) : models_bidirectional_iterator(template_arg(param)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.6"
tags = [ "iterator", "bidirectional-iterator", "constraint", "template",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0"
content = "If an algorithm's template parameter is named RandomAccessIterator, RandomAccessIterator1, or RandomAccessIterator2, the template argument shall meet the Cpp17RandomAccessIterator requirements if it is required to be a mutable iterator, or model random_access_iterator otherwise."
formal_spec = "template_param_name(param) in {\"RandomAccessIterator\", \"RandomAccessIterator1\", \"RandomAccessIterator2\"} => (requires_mutable_iterator(param) ? meets_cpp17_random_access_iterator_requirements(template_arg(param)) : models_random_access_iterator(template_arg(param)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.7"
tags = [ "iterator", "random-access-iterator", "constraint", "template",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_wellformed_c1d2e3f4"
content = "When Predicate pred is an algorithm argument and first is its iterator argument with value type T, the expression pred(*first) shall be well-formed and the type decltype(pred(*first)) shall model boolean-testable."
formal_spec = "algorithm_takes_predicate(pred) && iterator_arg(first) && value_type(first) == T => well_formed(pred(*first)) && models_boolean_testable(decltype(pred(*first)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = [ "predicate", "callable", "constraint", "boolean-testable",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_no_nonconst_apply_g5h6i7j8"
content = "The Predicate function object shall not apply any non-constant function through its argument."
formal_spec = "is_predicate(pred) && applies_through_arg(pred, func) => is_const_function(func)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = [ "predicate", "callable", "const-correctness", "constraint",]

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_glvalue_equivalence_k9l0m1n2"
content = "Given a glvalue u of type (possibly const) T that designates the same object as *first, pred(u) shall be a valid expression that is equal to pred(*first)."
formal_spec = "is_predicate(pred) && glvalue(u, T) && designates_same_object(u, *first) => valid_expression(pred(u)) && pred(u) == pred(*first)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = [ "predicate", "callable", "equivalence", "constraint",]
depends_on = [ "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a",]

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_wellformed_o3p4q5r6"
content = "If an algorithm takes BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments with respective value types T1 and T2, the expression binary_pred(*first1, *first2) shall be well-formed and the type decltype(binary_pred(*first1, *first2)) shall model boolean-testable."
formal_spec = "algorithm_takes_binary_predicate(binary_pred) && iterator_args(first1, first2) && value_type(first1) == T1 && value_type(first2) == T2 => well_formed(binary_pred(*first1, *first2)) && models_boolean_testable(decltype(binary_pred(*first1, *first2)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = [ "binary-predicate", "callable", "constraint", "boolean-testable",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_value_wellformed_s7t8u9v0"
content = "When T value is part of the signature, the expression binary_pred(*first1, value) shall be well-formed and the type decltype(binary_pred(*first1, value)) shall model boolean-testable."
formal_spec = "algorithm_takes_binary_predicate(binary_pred) && signature_has_value(T) => well_formed(binary_pred(*first1, value)) && models_boolean_testable(decltype(binary_pred(*first1, value)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = [ "binary-predicate", "callable", "constraint", "boolean-testable",]

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_no_nonconst_apply_w1x2y3z4"
content = "The BinaryPredicate function object shall not apply any non-constant function through any of its arguments."
formal_spec = "is_binary_predicate(binary_pred) && applies_through_arg(binary_pred, func, any_arg) => is_const_function(func)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = [ "binary-predicate", "callable", "const-correctness", "constraint",]

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_glvalue_equivalence_a5b6c7d8"
content = "Given glvalues u of type (possibly const) T1 designating the same object as *first1, and v of type (possibly const) T2 designating the same object as *first2, binary_pred(u, *first2), binary_pred(*first1, v), and binary_pred(u, v) shall each be a valid expression equal to binary_pred(*first1, *first2)."
formal_spec = "is_binary_predicate(binary_pred) && glvalue(u, T1) && designates_same_object(u, *first1) && glvalue(v, T2) && designates_same_object(v, *first2) => valid_expression(binary_pred(u, *first2)) && binary_pred(u, *first2) == binary_pred(*first1, *first2) && valid_expression(binary_pred(*first1, v)) && binary_pred(*first1, v) == binary_pred(*first1, *first2) && valid_expression(binary_pred(u, v)) && binary_pred(u, v) == binary_pred(*first1, *first2)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = [ "binary-predicate", "callable", "equivalence", "constraint",]

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_value_glvalue_equiv_e9f0a1b2"
content = "Given a glvalue u of type (possibly const) T1 designating the same object as *first1, binary_pred(u, value) shall be a valid expression that is equal to binary_pred(*first1, value)."
formal_spec = "is_binary_predicate(binary_pred) && glvalue(u, T1) && designates_same_object(u, *first1) && signature_has_value(T) => valid_expression(binary_pred(u, value)) && binary_pred(u, value) == binary_pred(*first1, value)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = [ "binary-predicate", "callable", "equivalence", "constraint",]
depends_on = [ "cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2", "cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a",]

[[axioms]]
id = "cpp20_algorithms_requirements_condition_boolean_result_c3d4e5f6"
content = "When the description of an algorithm gives an expression such as *first == value for a condition, the expression shall evaluate to either true or false in boolean contexts."
formal_spec = "algorithm_condition_expression(expr) => evaluates_to_bool(expr) && (expr == true || expr == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/10"
tags = [ "condition", "boolean", "constraint", "expression",]

[[axioms]]
id = "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0"
content = "The well-formedness and behavior of a call to an algorithm with an explicitly-specified template argument list is unspecified, except where explicitly stated otherwise."
formal_spec = "algorithm_call_with_explicit_template_args(algo, args...) && !explicitly_specified_behavior(algo) => unspecified_wellformedness(call) && unspecified_behavior(call)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/15"
tags = [ "template", "unspecified", "constraint", "well-formedness",]
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4", "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0",]

[[axioms]]
id = "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4"
content = "Overloads of algorithms that take range arguments behave as if a corresponding iterator argument is initialized with ranges::begin(r)."
formal_spec = "algorithm_takes_range(algo, r) => iterator_arg_initialized_as(ranges::begin(r))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/14.1"
tags = [ "range", "dispatch", "iterator", "begin",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_ranges_dispatch_end_o5p6q7r8"
content = "Overloads of algorithms that take range arguments behave as if a corresponding sentinel argument is initialized with ranges::end(r), or ranges::next(ranges::begin(r), ranges::end(r)) if the type of r models forward_range and computing ranges::next meets the specified complexity requirements."
formal_spec = "algorithm_takes_range(algo, r) => sentinel_arg_initialized_as(models_forward_range(r) && complexity_requirements_met(ranges::next) ? ranges::next(ranges::begin(r), ranges::end(r)) : ranges::end(r))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/14.2"
tags = [ "range", "dispatch", "sentinel", "end",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_algorithms_requirements_integer_like_difference_type_cast_s9t0u1v2"
content = "Given an iterator a whose difference type is D, and an expression n of integer-like type other than cv D, the semantics of a+n and a-n are, respectively, those of a+D(n) and a-D(n)."
formal_spec = "difference_type(a) == D && integer_like(n) && !same_type(remove_cv(decltype(n)), D) => semantics(a + n) == semantics(a + D(n)) && semantics(a - n) == semantics(a - D(n))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/12"
tags = [ "iterator", "arithmetic", "difference-type", "conversion",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6"
content = "In algorithm return values, when a sentinel value s denoting the end of a range [i, s) is returned where an iterator is expected, the semantics are as if the sentinel is converted into an iterator using ranges::next(i, s)."
formal_spec = "algorithm_returns_iterator(algo) && sentinel_denotes_end(s, range(i, s)) => return_semantics(s) == return_semantics(ranges::next(i, s))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/13"
tags = [ "sentinel", "iterator", "conversion", "return-value",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_range_access_begin_rvalue_non_borrowed_illformed_a3b7c1d9"
content = "Calling ranges::begin on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::begin(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.1"
tags = [ "ranges", "begin", "borrowed_range", "ill-formed",]
function = "ranges::begin"
header = "<ranges>"
signature = "auto ranges::begin(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_begin_incomplete_array_ndr_e5f2a8c4"
content = "Calling ranges::begin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required."
formal_spec = "is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::begin(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.2"
tags = [ "ranges", "begin", "array", "incomplete_type", "ill-formed", "ndr",]
function = "ranges::begin"
header = "<ranges>"
signature = "auto ranges::begin(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_end_rvalue_non_borrowed_illformed_b4c8d2e6"
content = "Calling ranges::end on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::end(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.1"
tags = [ "ranges", "end", "borrowed_range", "ill-formed",]
function = "ranges::end"
header = "<ranges>"
signature = "auto ranges::end(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_end_incomplete_array_ndr_c6d9e3f7"
content = "Calling ranges::end on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required."
formal_spec = "is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::end(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.2"
tags = [ "ranges", "end", "array", "incomplete_type", "ill-formed", "ndr",]
function = "ranges::end"
header = "<ranges>"
signature = "auto ranges::end(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_end_unknown_bound_array_illformed_d7e0f4a8"
content = "Calling ranges::end on an array of unknown bound is ill-formed."
formal_spec = "is_array_type(T) && is_unknown_bound_array(T) => ill_formed(ranges::end(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.3"
tags = [ "ranges", "end", "array", "unknown_bound", "ill-formed",]
function = "ranges::end"
header = "<ranges>"
signature = "auto ranges::end(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_cbegin_rvalue_non_borrowed_illformed_e8f1a5b9"
content = "Calling ranges::cbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::cbegin(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cbegin"
source_module = "[range.access.cbegin]/1.1"
tags = [ "ranges", "cbegin", "borrowed_range", "ill-formed",]
function = "ranges::cbegin"
header = "<ranges>"
signature = "auto ranges::cbegin(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_cend_rvalue_non_borrowed_illformed_f9a2b6c0"
content = "Calling ranges::cend on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::cend(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cend"
source_module = "[range.access.cend]/1.1"
tags = [ "ranges", "cend", "borrowed_range", "ill-formed",]
function = "ranges::cend"
header = "<ranges>"
signature = "auto ranges::cend(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_rbegin_rvalue_non_borrowed_illformed_a0b3c7d1"
content = "Calling ranges::rbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::rbegin(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.1"
tags = [ "ranges", "rbegin", "borrowed_range", "ill-formed",]
function = "ranges::rbegin"
header = "<ranges>"
signature = "auto ranges::rbegin(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_rbegin_incomplete_array_ndr_b1c4d8e2"
content = "Calling ranges::rbegin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required."
formal_spec = "is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::rbegin(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.2"
tags = [ "ranges", "rbegin", "array", "incomplete_type", "ill-formed", "ndr",]
function = "ranges::rbegin"
header = "<ranges>"
signature = "auto ranges::rbegin(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_rend_rvalue_non_borrowed_illformed_c2d5e9f3"
content = "Calling ranges::rend on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::rend(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.1"
tags = [ "ranges", "rend", "borrowed_range", "ill-formed",]
function = "ranges::rend"
header = "<ranges>"
signature = "auto ranges::rend(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_rend_incomplete_array_ndr_d3e6f0a4"
content = "Calling ranges::rend on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required."
formal_spec = "is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::rend(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.2"
tags = [ "ranges", "rend", "array", "incomplete_type", "ill-formed", "ndr",]
function = "ranges::rend"
header = "<ranges>"
signature = "auto ranges::rend(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_crbegin_rvalue_non_borrowed_illformed_e4f7a1b5"
content = "Calling ranges::crbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::crbegin(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crbegin"
source_module = "[range.access.crbegin]/1.1"
tags = [ "ranges", "crbegin", "borrowed_range", "ill-formed",]
function = "ranges::crbegin"
header = "<ranges>"
signature = "auto ranges::crbegin(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_crend_rvalue_non_borrowed_illformed_f5a8b2c6"
content = "Calling ranges::crend on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::crend(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crend"
source_module = "[range.access.crend]/1.1"
tags = [ "ranges", "crend", "borrowed_range", "ill-formed",]
function = "ranges::crend"
header = "<ranges>"
signature = "auto ranges::crend(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_size_unknown_bound_array_illformed_a6b9c3d7"
content = "Calling ranges::size on an array of unknown bound is ill-formed."
formal_spec = "is_unknown_bound_array(T) => ill_formed(ranges::size(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.1"
tags = [ "ranges", "size", "array", "unknown_bound", "ill-formed",]
function = "ranges::size"
header = "<ranges>"
signature = "auto ranges::size(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_ssize_requires_valid_size_b7c0d4e8"
content = "Calling ranges::ssize requires ranges::size to be a valid expression; if ranges::size(t) is ill-formed, ranges::ssize(E) is also ill-formed."
formal_spec = "ill_formed(ranges::size(t)) => ill_formed(ranges::ssize(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.ssize"
source_module = "[range.prim.ssize]/2"
tags = [ "ranges", "ssize", "size", "ill-formed",]
function = "ranges::ssize"
header = "<ranges>"
signature = "auto ranges::ssize(E)"

[[axioms]]
id = "cpp20_range_access_empty_unknown_bound_array_illformed_c8d1e5f9"
content = "Calling ranges::empty on an array of unknown bound is ill-formed."
formal_spec = "is_unknown_bound_array(T) => ill_formed(ranges::empty(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/2.1"
tags = [ "ranges", "empty", "array", "unknown_bound", "ill-formed",]
function = "ranges::empty"
header = "<ranges>"
signature = "bool ranges::empty(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_data_rvalue_non_borrowed_illformed_d9e2f6a0"
content = "Calling ranges::data on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::data(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.1"
tags = [ "ranges", "data", "borrowed_range", "ill-formed",]
function = "ranges::data"
header = "<ranges>"
signature = "auto ranges::data(E)"
depends_on = [ "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_access_data_incomplete_array_ndr_e0f3a7b1"
content = "Calling ranges::data on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required."
formal_spec = "is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::data(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.2"
tags = [ "ranges", "data", "array", "incomplete_type", "ill-formed", "ndr",]
function = "ranges::data"
header = "<ranges>"
signature = "auto ranges::data(E)"
depends_on = [ "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2", "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1", "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4",]

[[axioms]]
id = "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2"
content = "Calling ranges::cdata on an rvalue of a type where enable_borrowed_range is false is ill-formed."
formal_spec = "is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::cdata(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.cdata"
source_module = "[range.prim.cdata]/1.1"
tags = [ "ranges", "cdata", "borrowed_range", "ill-formed",]
function = "ranges::cdata"
header = "<ranges>"
signature = "const auto* ranges::cdata(E)"
depends_on = [ "cpp20_const_pointer_cast_mandates_7a8b9c0d", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489",]

[[axioms]]
id = "cpp20_range_access_begin_models_input_or_output_iterator_a2b5c9d3"
content = "Whenever ranges::begin(E) is a valid expression, its type models input_or_output_iterator."
formal_spec = "valid_expr(ranges::begin(E)) => models<input_or_output_iterator>(decltype(ranges::begin(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/4"
tags = [ "ranges", "begin", "iterator", "concept", "postcondition",]
function = "ranges::begin"
header = "<ranges>"
signature = "auto ranges::begin(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_end_models_sentinel_for_b3c6d0e4"
content = "Whenever ranges::end(E) is a valid expression, the types S and I of ranges::end(E) and ranges::begin(E) model sentinel_for<S, I>."
formal_spec = "valid_expr(ranges::end(E)) && valid_expr(ranges::begin(E)) => models<sentinel_for>(decltype(ranges::end(E)), decltype(ranges::begin(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/4"
tags = [ "ranges", "end", "sentinel", "concept", "postcondition",]
function = "ranges::end"
header = "<ranges>"
signature = "auto ranges::end(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_cbegin_models_constant_iterator_c4d7e1f5"
content = "Whenever ranges::cbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator."
formal_spec = "valid_expr(ranges::cbegin(E)) => models<input_or_output_iterator>(decltype(ranges::cbegin(E))) && models<constant_iterator>(decltype(ranges::cbegin(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cbegin"
source_module = "[range.access.cbegin]/2"
tags = [ "ranges", "cbegin", "iterator", "constant_iterator", "concept", "postcondition",]
function = "ranges::cbegin"
header = "<ranges>"
signature = "auto ranges::cbegin(E)"
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_range_access_rbegin_models_input_or_output_iterator_d5e8f2a6"
content = "Whenever ranges::rbegin(E) is a valid expression, its type models input_or_output_iterator."
formal_spec = "valid_expr(ranges::rbegin(E)) => models<input_or_output_iterator>(decltype(ranges::rbegin(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/4"
tags = [ "ranges", "rbegin", "iterator", "concept", "postcondition",]
function = "ranges::rbegin"
header = "<ranges>"
signature = "auto ranges::rbegin(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_rend_models_sentinel_for_e6f9a3b7"
content = "Whenever ranges::rend(E) is a valid expression, the types S and I of ranges::rend(E) and ranges::rbegin(E) model sentinel_for<S, I>."
formal_spec = "valid_expr(ranges::rend(E)) && valid_expr(ranges::rbegin(E)) => models<sentinel_for>(decltype(ranges::rend(E)), decltype(ranges::rbegin(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/4"
tags = [ "ranges", "rend", "sentinel", "concept", "postcondition",]
function = "ranges::rend"
header = "<ranges>"
signature = "auto ranges::rend(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_crbegin_models_constant_iterator_f7a0b4c8"
content = "Whenever ranges::crbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator."
formal_spec = "valid_expr(ranges::crbegin(E)) => models<input_or_output_iterator>(decltype(ranges::crbegin(E))) && models<constant_iterator>(decltype(ranges::crbegin(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crbegin"
source_module = "[range.access.crbegin]/2"
tags = [ "ranges", "crbegin", "iterator", "constant_iterator", "concept", "postcondition",]
function = "ranges::crbegin"
header = "<ranges>"
signature = "auto ranges::crbegin(E)"
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_range_access_size_returns_integer_like_a8b1c5d9"
content = "Whenever ranges::size(E) is a valid expression, its type is integer-like."
formal_spec = "valid_expr(ranges::size(E)) => is_integer_like(decltype(ranges::size(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/4"
tags = [ "ranges", "size", "integer_like", "postcondition",]
function = "ranges::size"
header = "<ranges>"
signature = "auto ranges::size(E)"

[[axioms]]
id = "cpp20_range_access_reserve_hint_returns_integer_like_b9c2d6e0"
content = "Whenever ranges::reserve_hint(E) is a valid expression, its type is integer-like."
formal_spec = "valid_expr(ranges::reserve_hint(E)) => is_integer_like(decltype(ranges::reserve_hint(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size.hint"
source_module = "[range.prim.size.hint]/2"
tags = [ "ranges", "reserve_hint", "integer_like", "postcondition",]
function = "ranges::reserve_hint"
header = "<ranges>"
signature = "auto ranges::reserve_hint(E)"

[[axioms]]
id = "cpp20_range_access_empty_returns_bool_c0d3e7f1"
content = "Whenever ranges::empty(E) is a valid expression, it has type bool."
formal_spec = "valid_expr(ranges::empty(E)) => is_same<decltype(ranges::empty(E)), bool>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/4"
tags = [ "ranges", "empty", "bool", "postcondition",]
function = "ranges::empty"
header = "<ranges>"
signature = "bool ranges::empty(E)"

[[axioms]]
id = "cpp20_range_access_data_returns_pointer_to_object_d1e4f8a2"
content = "Whenever ranges::data(E) is a valid expression, it has pointer to object type."
formal_spec = "valid_expr(ranges::data(E)) => is_pointer_to_object(decltype(ranges::data(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/4"
tags = [ "ranges", "data", "pointer", "postcondition",]
function = "ranges::data"
header = "<ranges>"
signature = "auto ranges::data(E)"
depends_on = [ "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_range_access_cdata_returns_pointer_to_const_object_e2f5a9b3"
content = "Whenever ranges::cdata(E) is a valid expression, it has pointer to constant object type."
formal_spec = "valid_expr(ranges::cdata(E)) => is_pointer_to_const_object(decltype(ranges::cdata(E)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.cdata"
source_module = "[range.prim.cdata]/2"
tags = [ "ranges", "cdata", "pointer", "const", "postcondition",]
function = "ranges::cdata"
header = "<ranges>"
signature = "const auto* ranges::cdata(E)"
depends_on = [ "cpp20_const_pointer_cast_mandates_7a8b9c0d", "c11_cpp_translation_name_syntax_operation_95efc489", "c11_cpp_translation_expr_cast_operation_d3b83600", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_range_access_begin_member_models_iterator_f3a6b0c4"
content = "For ranges::begin to use t.begin(), the expression auto(t.begin()) must be valid and its type must model input_or_output_iterator."
formal_spec = "!is_array_type(T) && valid_expr(auto(t.begin())) && models<input_or_output_iterator>(decltype(auto(t.begin()))) => ranges::begin(E) == auto(t.begin())"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.4"
tags = [ "ranges", "begin", "member", "iterator", "constraint",]
function = "ranges::begin"
header = "<ranges>"
signature = "auto ranges::begin(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_end_member_models_sentinel_a4b7c1d5"
content = "For ranges::end to use t.end(), the expression auto(t.end()) must be valid and its type must model sentinel_for<iterator_t<T>>."
formal_spec = "!is_array_type(T) && valid_expr(auto(t.end())) && models<sentinel_for>(decltype(auto(t.end())), iterator_t<T>) => ranges::end(E) == auto(t.end())"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.end"
source_module = "[range.access.end]/2.5"
tags = [ "ranges", "end", "member", "sentinel", "constraint",]
function = "ranges::end"
header = "<ranges>"
signature = "auto ranges::end(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_size_disable_sized_range_constraint_b5c8d2e6"
content = "For ranges::size to use t.size(), disable_sized_range<remove_cv_t<T>> must be false."
formal_spec = "disable_sized_range<remove_cv_t<T>> => !use_member_size(ranges::size(E))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.3"
tags = [ "ranges", "size", "disable_sized_range", "constraint",]
function = "ranges::size"
header = "<ranges>"
signature = "auto ranges::size(E)"

[[axioms]]
id = "cpp20_range_access_rbegin_fallback_bidirectional_c6d9e3f7"
content = "For ranges::rbegin to fall back to make_reverse_iterator(ranges::end(t)), both ranges::begin(t) and ranges::end(t) must be valid expressions of the same type which models bidirectional_iterator."
formal_spec = "valid_expr(ranges::begin(t)) && valid_expr(ranges::end(t)) && same_type(decltype(ranges::begin(t)), decltype(ranges::end(t))) && models<bidirectional_iterator>(decltype(ranges::begin(t))) => ranges::rbegin(E) == make_reverse_iterator(ranges::end(t))"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.5"
tags = [ "ranges", "rbegin", "reverse_iterator", "bidirectional", "fallback",]
function = "ranges::rbegin"
header = "<ranges>"
signature = "auto ranges::rbegin(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_rend_fallback_bidirectional_d7e0f4a8"
content = "For ranges::rend to fall back to make_reverse_iterator(ranges::begin(t)), both ranges::begin(t) and ranges::end(t) must be valid expressions of the same type which models bidirectional_iterator."
formal_spec = "valid_expr(ranges::begin(t)) && valid_expr(ranges::end(t)) && same_type(decltype(ranges::begin(t)), decltype(ranges::end(t))) && models<bidirectional_iterator>(decltype(ranges::begin(t))) => ranges::rend(E) == make_reverse_iterator(ranges::begin(t))"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.5"
tags = [ "ranges", "rend", "reverse_iterator", "bidirectional", "fallback",]
function = "ranges::rend"
header = "<ranges>"
signature = "auto ranges::rend(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_size_fallback_sized_sentinel_e8f1a5b9"
content = "For ranges::size to use ranges::end(t) - ranges::begin(t), the iterator types must model both sized_sentinel_for and forward_iterator."
formal_spec = "valid_expr(to_unsigned_like(ranges::end(t) - ranges::begin(t))) && models<sized_sentinel_for>(decltype(ranges::end(t)), decltype(ranges::begin(t))) && models<forward_iterator>(decltype(ranges::begin(t))) => ranges::size(E) == to_unsigned_like(ranges::end(t) - ranges::begin(t))"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.5"
tags = [ "ranges", "size", "sized_sentinel", "forward_iterator", "fallback",]
function = "ranges::size"
header = "<ranges>"
signature = "auto ranges::size(E)"
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_range_access_empty_fallback_forward_iterator_f9a2b6c0"
content = "For ranges::empty to use ranges::begin(t) == ranges::end(t), the type of ranges::begin(t) must model forward_iterator."
formal_spec = "valid_expr(bool(ranges::begin(t) == ranges::end(t))) && models<forward_iterator>(decltype(ranges::begin(t))) => ranges::empty(E) == bool(ranges::begin(t) == ranges::end(t))"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/2.4"
tags = [ "ranges", "empty", "forward_iterator", "fallback",]
function = "ranges::empty"
header = "<ranges>"
signature = "bool ranges::empty(E)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_range_access_data_contiguous_iterator_a0b3c7d1"
content = "For ranges::data to use to_address(ranges::begin(t)), the type of ranges::begin(t) must model contiguous_iterator."
formal_spec = "valid_expr(ranges::begin(t)) && models<contiguous_iterator>(decltype(ranges::begin(t))) => ranges::data(E) == to_address(ranges::begin(t))"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.4"
tags = [ "ranges", "data", "contiguous_iterator", "to_address",]
function = "ranges::data"
header = "<ranges>"
signature = "auto ranges::data(E)"
depends_on = [ "cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0", "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_thread_condition_condvar_dtor_precond_no_blocked_a1b2c3d4"
content = "Destroying a condition_variable requires that no thread is blocked on it."
formal_spec = "destroy(cv) && exists_thread(t, blocked_on(t, cv)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/4"
tags = [ "concurrency", "condition_variable", "destructor", "precondition",]
function = "std::condition_variable::~condition_variable"
header = "<condition_variable>"
signature = "~condition_variable()"
depends_on = [ "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8"
content = "Undefined behavior ensues if a thread waits on a condition_variable once the destructor has been started."
formal_spec = "dtor_started(cv) && wait_on(thread, cv) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/4"
tags = [ "concurrency", "condition_variable", "destructor", "lifetime", "undefined_behavior",]
function = "std::condition_variable::~condition_variable"
header = "<condition_variable>"
signature = "~condition_variable()"
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2"
content = "Calling wait() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread."
formal_spec = "call(wait, cv, lock) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/7"
tags = [ "concurrency", "condition_variable", "wait", "precondition", "mutex",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "void condition_variable::wait(unique_lock<mutex>& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6"
content = "When multiple threads wait on a condition_variable, either no other thread is waiting or all waiting threads must use lock arguments where lock.mutex() returns the same value."
formal_spec = "concurrent_wait(cv, locks) => (count(locks) <= 1 || forall(l1, l2 in locks, l1.mutex() == l2.mutex()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/7"
tags = [ "concurrency", "condition_variable", "wait", "precondition", "mutex",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "void condition_variable::wait(unique_lock<mutex>& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0"
content = "After wait() returns, lock.owns_lock() is true and lock.mutex() is locked by the calling thread."
formal_spec = "returns(wait, cv, lock) => postcond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/9"
tags = [ "concurrency", "condition_variable", "wait", "postcondition", "mutex",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "void condition_variable::wait(unique_lock<mutex>& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_relock_fail_terminate_c1d2e3f4"
content = "If wait() fails to meet the postcondition (e.g., re-locking mutex throws), terminate() is invoked."
formal_spec = "call(wait, cv, lock) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/11"
tags = [ "concurrency", "condition_variable", "wait", "terminate", "exception",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "void condition_variable::wait(unique_lock<mutex>& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8"
content = "Calling wait() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread."
formal_spec = "call(wait, cv, lock, pred) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/12"
tags = [ "concurrency", "condition_variable", "wait", "predicate", "precondition",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "template<class Predicate> void condition_variable::wait(unique_lock<mutex>& lock, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_pred_terminate_e9f0a1b2"
content = "If wait() with predicate fails to meet the postcondition, terminate() is invoked."
formal_spec = "call(wait, cv, lock, pred) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/16"
tags = [ "concurrency", "condition_variable", "wait", "predicate", "terminate",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "template<class Predicate> void condition_variable::wait(unique_lock<mutex>& lock, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6"
content = "Calling wait_until() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread."
formal_spec = "call(wait_until, cv, lock, abs_time) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/17"
tags = [ "concurrency", "condition_variable", "wait_until", "precondition", "timeout",]
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = "template<class Clock, class Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0"
content = "If wait_until() exits via an exception, lock.lock() is called prior to exiting the function."
formal_spec = "call(wait_until, cv, lock, abs_time) && throws_exception(e) => before_exit(lock.lock())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/18.4"
tags = [ "concurrency", "condition_variable", "wait_until", "exception", "mutex",]
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = "template<class Clock, class Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_terminate_e1f2a3b4"
content = "If wait_until() fails to meet the postcondition, terminate() is invoked."
formal_spec = "call(wait_until, cv, lock, abs_time) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/22"
tags = [ "concurrency", "condition_variable", "wait_until", "terminate",]
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = "template<class Clock, class Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8"
content = "Calling wait_for() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread."
formal_spec = "call(wait_for, cv, lock, rel_time) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/23"
tags = [ "concurrency", "condition_variable", "wait_for", "precondition", "timeout",]
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = "template<class Rep, class Period> cv_status condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_terminate_a9b0c1d2"
content = "If wait_for() fails to meet the postcondition, terminate is invoked."
formal_spec = "call(wait_for, cv, lock, rel_time) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/28"
tags = [ "concurrency", "condition_variable", "wait_for", "terminate",]
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = "template<class Rep, class Period> cv_status condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6"
content = "Calling wait_until() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread."
formal_spec = "call(wait_until, cv, lock, abs_time, pred) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/29"
tags = [ "concurrency", "condition_variable", "wait_until", "predicate", "precondition",]
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = "template<class Clock, class Duration, class Predicate> bool condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_pred_terminate_c7d8e9f0"
content = "If wait_until() with predicate fails to meet the postcondition, terminate() is invoked."
formal_spec = "call(wait_until, cv, lock, abs_time, pred) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/34"
tags = [ "concurrency", "condition_variable", "wait_until", "predicate", "terminate",]
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = "template<class Clock, class Duration, class Predicate> bool condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4"
content = "Calling wait_for() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread."
formal_spec = "call(wait_for, cv, lock, rel_time, pred) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/35"
tags = [ "concurrency", "condition_variable", "wait_for", "predicate", "precondition",]
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = "template<class Rep, class Period, class Predicate> bool condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_pred_terminate_e5f6a7b8"
content = "If wait_for() with predicate fails to meet the postcondition, terminate() is invoked."
formal_spec = "call(wait_for, cv, lock, rel_time, pred) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/41"
tags = [ "concurrency", "condition_variable", "wait_for", "predicate", "terminate",]
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = "template<class Rep, class Period, class Predicate> bool condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_dtor_precond_no_blocked_c9d0e1f2"
content = "Destroying a condition_variable_any requires that no thread is blocked on it."
formal_spec = "destroy(cv_any) && exists_thread(t, blocked_on(t, cv_any)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/4"
tags = [ "concurrency", "condition_variable_any", "destructor", "precondition",]
function = "std::condition_variable_any::~condition_variable_any"
header = "<condition_variable>"
signature = "~condition_variable_any()"
depends_on = [ "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6"
content = "Undefined behavior ensues if a thread waits on a condition_variable_any once the destructor has been started."
formal_spec = "dtor_started(cv_any) && wait_on(thread, cv_any) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/4"
tags = [ "concurrency", "condition_variable_any", "destructor", "lifetime", "undefined_behavior",]
function = "std::condition_variable_any::~condition_variable_any"
header = "<condition_variable>"
signature = "~condition_variable_any()"
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_lock_requirement_e7f8a9b0"
content = "Template arguments for Lock in condition_variable_any shall meet the Cpp17BasicLockable requirements."
formal_spec = "use(condition_variable_any, Lock) => requires(Lock, Cpp17BasicLockable)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/1"
tags = [ "concurrency", "condition_variable_any", "requirements", "lockable",]
function = "std::condition_variable_any"
header = "<condition_variable>"
signature = "class condition_variable_any"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4"
content = "After wait() returns on condition_variable_any, lock is locked by the calling thread."
formal_spec = "returns(wait, cv_any, lock) => postcond(locked_by(lock, calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/2"
tags = [ "concurrency", "condition_variable_any", "wait", "postcondition",]
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = "template<class Lock> void condition_variable_any::wait(Lock& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_relock_fail_terminate_a5b6c7d8"
content = "If wait() on condition_variable_any fails to meet the postcondition, terminate() is invoked."
formal_spec = "call(wait, cv_any, lock) && !postcond_met(locked_by(lock, calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/4"
tags = [ "concurrency", "condition_variable_any", "wait", "terminate",]
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = "template<class Lock> void condition_variable_any::wait(Lock& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2"
content = "If wait_until() on condition_variable_any exits via an exception, lock.lock() is called prior to exiting the function."
formal_spec = "call(wait_until, cv_any, lock, abs_time) && throws_exception(e) => before_exit(lock.lock())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/6.4"
tags = [ "concurrency", "condition_variable_any", "wait_until", "exception",]
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = "template<class Lock, class Clock, class Duration> cv_status condition_variable_any::wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_until_terminate_c3d4e5f6"
content = "If wait_until() on condition_variable_any fails to meet the postcondition, terminate() is invoked."
formal_spec = "call(wait_until, cv_any, lock, abs_time) && !postcond_met(locked_by(lock, calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/10"
tags = [ "concurrency", "condition_variable_any", "wait_until", "terminate",]
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = "template<class Lock, class Clock, class Duration> cv_status condition_variable_any::wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_for_terminate_a7b8c9d0"
content = "If wait_for() on condition_variable_any fails to meet the postcondition, terminate is invoked."
formal_spec = "call(wait_for, cv_any, lock, rel_time) && !postcond_met(locked_by(lock, calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/15"
tags = [ "concurrency", "condition_variable_any", "wait_for", "terminate",]
function = "std::condition_variable_any::wait_for"
header = "<condition_variable>"
signature = "template<class Lock, class Rep, class Period> cv_status condition_variable_any::wait_for(Lock& lock, chrono::duration<Rep, Period> rel_time)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4"
content = "After interruptible wait() returns on condition_variable_any, lock is locked by the calling thread."
formal_spec = "returns(wait, cv_any, lock, stoken, pred) => postcond(locked_by(lock, calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/4"
tags = [ "concurrency", "condition_variable_any", "wait", "interruptible", "postcondition",]
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = "template<class Lock, class Predicate> bool condition_variable_any::wait(Lock& lock, stop_token stoken, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_terminate_c5d6e7f8"
content = "If interruptible wait() on condition_variable_any fails to meet the postcondition, terminate is called."
formal_spec = "call(wait, cv_any, lock, stoken, pred) && !postcond_met(locked_by(lock, calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/6"
tags = [ "concurrency", "condition_variable_any", "wait", "interruptible", "terminate",]
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = "template<class Lock, class Predicate> bool condition_variable_any::wait(Lock& lock, stop_token stoken, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2"
content = "After interruptible wait_until() returns on condition_variable_any, lock is locked by the calling thread."
formal_spec = "returns(wait_until, cv_any, lock, stoken, abs_time, pred) => postcond(locked_by(lock, calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/10"
tags = [ "concurrency", "condition_variable_any", "wait_until", "interruptible", "postcondition",]
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = "template<class Lock, class Clock, class Duration, class Predicate> bool condition_variable_any::wait_until(Lock& lock, stop_token stoken, chrono::time_point<Clock, Duration> abs_time, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_until_terminate_e3f4a5b6"
content = "If interruptible wait_until() on condition_variable_any fails to meet the postcondition, terminate is called."
formal_spec = "call(wait_until, cv_any, lock, stoken, abs_time, pred) && !postcond_met(locked_by(lock, calling_thread)) => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/12"
tags = [ "concurrency", "condition_variable_any", "wait_until", "interruptible", "terminate",]
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = "template<class Lock, class Clock, class Duration, class Predicate> bool condition_variable_any::wait_until(Lock& lock, stop_token stoken, chrono::time_point<Clock, Duration> abs_time, Predicate pred)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0"
content = "notify_all_at_thread_exit() requires lk to be locked by the calling thread."
formal_spec = "call(notify_all_at_thread_exit, cond, lk) => precond(locked_by(lk, calling_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/1"
tags = [ "concurrency", "condition_variable", "notify", "precondition",]
function = "std::notify_all_at_thread_exit"
header = "<condition_variable>"
signature = "void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4"
content = "notify_all_at_thread_exit() requires either no other thread waiting on cond, or lk.mutex() returns the same value for all concurrently waiting threads."
formal_spec = "call(notify_all_at_thread_exit, cond, lk) => precond(no_other_waiters(cond) || same_mutex_for_all_waiters(cond, lk.mutex()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/1"
tags = [ "concurrency", "condition_variable", "notify", "precondition", "mutex",]
function = "std::notify_all_at_thread_exit"
header = "<condition_variable>"
signature = "void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8"
content = "The implied lk.unlock() call from notify_all_at_thread_exit is sequenced after the destruction of all objects with thread storage duration associated with the current thread."
formal_spec = "call(notify_all_at_thread_exit, cond, lk) => sequenced_after(implied_unlock(lk), destroy_all_thread_local_objects(current_thread))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/3"
tags = [ "concurrency", "condition_variable", "notify", "synchronization", "thread_local",]
function = "std::notify_all_at_thread_exit"
header = "<condition_variable>"
signature = "void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2", "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_basic_stc_static_program_duration_a3b4c5d6", "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "cpp20_intro_races_object_value_visibility_a3b7c9e1",]

[[axioms]]
id = "cpp20_thread_condition_atomic_notify_c9d0e1f2"
content = "The executions of notify_one and notify_all are atomic."
formal_spec = "execution(notify_one) => atomic && execution(notify_all) => atomic"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/3"
tags = [ "concurrency", "condition_variable", "notify", "atomicity",]
function = "std::condition_variable::notify_one"
header = "<condition_variable>"
signature = "void condition_variable::notify_one() noexcept"
depends_on = [ "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "cpp20_atomics_order_timely_visibility_2f8a3b4c",]

[[axioms]]
id = "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6"
content = "The executions of wait, wait_for, and wait_until are performed in three atomic parts: (1) release of mutex and entry into waiting state, (2) unblocking of wait, and (3) reacquisition of lock."
formal_spec = "execution(wait | wait_for | wait_until) => atomic_parts(release_mutex_and_wait, unblock, reacquire_lock)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/3"
tags = [ "concurrency", "condition_variable", "wait", "atomicity",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "void condition_variable::wait(unique_lock<mutex>& lock)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1", "cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f", "cpp20_atomics_order_timely_visibility_2f8a3b4c", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6",]

[[axioms]]
id = "cpp20_thread_condition_spurious_wakeup_e7f8a9b0"
content = "A condition_variable wait function may unblock spuriously (without notification or timeout)."
formal_spec = "blocking(wait, cv) => may_unblock_spuriously()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/8.3"
tags = [ "concurrency", "condition_variable", "wait", "spurious_wakeup",]
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = "void condition_variable::wait(unique_lock<mutex>& lock)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_thread_condition_concurrent_permitted_c1d2e3f4"
content = "Condition variables permit concurrent invocation of wait, wait_for, wait_until, notify_one and notify_all member functions."
formal_spec = "concurrent_call(cv, {wait, wait_for, wait_until, notify_one, notify_all}) => permitted"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/2"
tags = [ "concurrency", "condition_variable", "thread_safety",]
function = "std::condition_variable"
header = "<condition_variable>"
signature = "class condition_variable"

[[axioms]]
id = "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8"
content = "Condition variable construction and destruction need not be synchronized."
formal_spec = "construction(cv) || destruction(cv) => no_synchronization_required"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/5"
tags = [ "concurrency", "condition_variable", "constructor", "destructor", "synchronization",]
function = "std::condition_variable"
header = "<condition_variable>"
signature = "class condition_variable"
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_intro_races_sync_op_categories_c5a7b9d3", "cpp20_intro_races_fence_categories_d6b8c0e4", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_range_begin_end_denotes_range_a3b4c5d6"
content = "For a type T modeling range, [ranges::begin(t), ranges::end(t)) must denote a valid range as defined in [iterator.requirements.general]."
formal_spec = "models<range>(T) && is_lvalue_ref<decltype((t))> => denotes_range(ranges::begin(t), ranges::end(t))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.1"
tags = [ "range", "iterator", "sentinel", "concept",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_range_range_begin_end_amortized_constant_7e8f9a0b"
content = "For a type T modeling range, both ranges::begin(t) and ranges::end(t) must be amortized constant time and non-modifying."
formal_spec = "models<range>(T) => amortized_O1(ranges::begin(t)) && amortized_O1(ranges::end(t)) && non_modifying(ranges::begin(t)) && non_modifying(ranges::end(t))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.2"
tags = [ "range", "complexity", "concept",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_range_range_begin_equality_preserving_c1d2e3f4"
content = "For a type T modeling range, if ranges::begin(t) returns a type modeling forward_iterator, then ranges::begin(t) must be equality-preserving."
formal_spec = "models<range>(T) && models<forward_iterator>(decltype(ranges::begin(t))) => equality_preserving(ranges::begin(t))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.3"
tags = [ "range", "iterator", "forward_iterator", "equality_preserving", "concept",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d"
content = "A type T models borrowed_range only if the validity of iterators obtained from a variable u of type U (where U is remove_reference_t<T> if T is rvalue reference, otherwise T) is not tied to the lifetime of that variable."
formal_spec = "models<borrowed_range>(T) => !tied_to_lifetime(iterators_from(u), u) where U = (is_rvalue_reference_v<T> ? remove_reference_t<T> : T)"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/4"
tags = [ "range", "borrowed_range", "iterator", "lifetime", "concept",]
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4",]

[[axioms]]
id = "cpp20_range_enable_borrowed_range_specialization_e9f0a1b2"
content = "Users may specialize enable_borrowed_range for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions and have type const bool."
formal_spec = "user_specialization(enable_borrowed_range<T>) => is_cv_unqualified(T) && program_defined_type(T) && usable_in_constant_expr(enable_borrowed_range<T>) && same_as<decltype(enable_borrowed_range<T>), const bool>"
layer = "cpp20_language"
confidence = 0.9
source_file = "range.range"
source_module = "[range.range]/6"
tags = [ "range", "borrowed_range", "specialization", "constraint",]

[[axioms]]
id = "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"
content = "For a type T modeling approximately_sized_range, ranges::reserve_hint(t) must be amortized O(1), must not modify t, and must return a non-negative value representable in range_difference_t<T>."
formal_spec = "models<approximately_sized_range>(T) => amortized_O1(ranges::reserve_hint(t)) && non_modifying(ranges::reserve_hint(t)) && ranges::reserve_hint(t) >= 0 && representable_in<range_difference_t<T>>(ranges::reserve_hint(t))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.1"
tags = [ "range", "approximately_sized_range", "complexity", "concept",]

[[axioms]]
id = "cpp20_range_approximately_sized_forward_reserve_hint_g7h8i9j0"
content = "For a type T modeling approximately_sized_range, if iterator_t<T> models forward_iterator, ranges::reserve_hint(t) is well-defined regardless of the evaluation of ranges::begin(t)."
formal_spec = "models<approximately_sized_range>(T) && models<forward_iterator>(iterator_t<T>) => well_defined_independent_of_begin(ranges::reserve_hint(t))"
layer = "cpp20_language"
confidence = 0.9
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.2"
tags = [ "range", "approximately_sized_range", "forward_iterator", "concept",]

[[axioms]]
id = "cpp20_range_approximately_sized_non_forward_reserve_hint_k1l2m3n4"
content = "For an approximately_sized_range whose iterator type does not model forward_iterator, ranges::reserve_hint(t) may only be well-defined if evaluated before the first call to ranges::begin(t)."
formal_spec = "models<approximately_sized_range>(T) && !models<forward_iterator>(iterator_t<T>) => may_require(call_order(ranges::reserve_hint(t)) < call_order(ranges::begin(t)))"
layer = "cpp20_language"
confidence = 0.85
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.2 Note 1"
tags = [ "range", "approximately_sized_range", "input_iterator", "ordering", "concept",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_range_sized_size_O1_o5p6q7r8"
content = "For a type T modeling sized_range, ranges::size(t) must be amortized O(1), must not modify t, and must equal ranges::distance(ranges::begin(t), ranges::end(t))."
formal_spec = "models<sized_range>(T) => amortized_O1(ranges::size(t)) && non_modifying(ranges::size(t)) && ranges::size(t) == ranges::distance(ranges::begin(t), ranges::end(t))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.sized"
source_module = "[range.sized]/2.1"
tags = [ "range", "sized_range", "complexity", "concept",]

[[axioms]]
id = "cpp20_range_sized_forward_size_s9t0u1v2"
content = "For a type T modeling sized_range, if iterator_t<T> models forward_iterator, ranges::size(t) is well-defined regardless of the evaluation of ranges::begin(t)."
formal_spec = "models<sized_range>(T) && models<forward_iterator>(iterator_t<T>) => well_defined_independent_of_begin(ranges::size(t))"
layer = "cpp20_language"
confidence = 0.9
source_file = "range.sized"
source_module = "[range.sized]/2.2"
tags = [ "range", "sized_range", "forward_iterator", "concept",]

[[axioms]]
id = "cpp20_range_sized_non_forward_size_w3x4y5z6"
content = "For a sized_range whose iterator type does not model forward_iterator, ranges::size(t) may only be well-defined if evaluated before the first call to ranges::begin(t)."
formal_spec = "models<sized_range>(T) && !models<forward_iterator>(iterator_t<T>) => may_require(call_order(ranges::size(t)) < call_order(ranges::begin(t)))"
layer = "cpp20_language"
confidence = 0.85
source_file = "range.sized"
source_module = "[range.sized]/2.2 Note 1"
tags = [ "range", "sized_range", "input_iterator", "ordering", "concept",]
depends_on = [ "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_range_disable_sized_range_specialization_a7b8c9d0"
content = "Users may specialize disable_sized_range for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions and have type const bool."
formal_spec = "user_specialization(disable_sized_range<T>) => is_cv_unqualified(T) && program_defined_type(T) && usable_in_constant_expr(disable_sized_range<T>) && same_as<decltype(disable_sized_range<T>), const bool>"
layer = "cpp20_language"
confidence = 0.9
source_file = "range.sized"
source_module = "[range.sized]/3"
tags = [ "range", "sized_range", "specialization", "constraint",]

[[axioms]]
id = "cpp20_range_view_O1_move_construction_e1f2a3b4"
content = "A type T models view only if T has O(1) move construction."
formal_spec = "models<view>(T) => O1(move_construction(T))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.1"
tags = [ "range", "view", "move", "complexity", "concept",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_view_move_assignment_complexity_c5d6e7f8"
content = "A type T models view only if move assignment of an object of type T is no more complex than destruction followed by move construction."
formal_spec = "models<view>(T) => complexity(move_assignment(T)) <= complexity(destruction(T)) + complexity(move_construction(T))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.2"
tags = [ "range", "view", "move", "complexity", "concept",]
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_view_copy_destruction_linear_g9h0i1j2"
content = "For a type T modeling view, if N copies and/or moves are made from an object of type T that contained M elements, then those N objects have O(N+M) destruction."
formal_spec = "models<view>(T) && copies_or_moves(obj, N) && elements(obj) == M => O(N + M)(total_destruction_of_N_objects)"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.3"
tags = [ "range", "view", "destruction", "complexity", "concept",]
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_class_dtor_member_destruction_order_a7e4c9d2",]

[[axioms]]
id = "cpp20_range_view_O1_copy_construction_k3l4m5n6"
content = "A type T models view only if copy_constructible<T> is false, or T has O(1) copy construction."
formal_spec = "models<view>(T) => !copy_constructible<T> || O1(copy_construction(T))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.4"
tags = [ "range", "view", "copy", "complexity", "concept",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_view_copy_assignment_complexity_o7p8q9r0"
content = "A type T models view only if copyable<T> is false, or copy assignment of an object of type T is no more complex than destruction followed by copy construction."
formal_spec = "models<view>(T) => !copyable<T> || complexity(copy_assignment(T)) <= complexity(destruction(T)) + complexity(copy_construction(T))"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.5"
tags = [ "range", "view", "copy", "complexity", "concept",]
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_class_dtor_member_destruction_order_a7e4c9d2", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_view_moved_from_O1_destruction_s1t2u3v4"
content = "The constraints on copying and moving for view imply that a moved-from object of type T has O(1) destruction."
formal_spec = "models<view>(T) && moved_from(obj) => O1(destruction(obj))"
layer = "cpp20_language"
confidence = 0.9
source_file = "range.view"
source_module = "[range.view]/3 Note 1"
tags = [ "range", "view", "move", "destruction", "complexity", "concept",]
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_class_dtor_member_destruction_order_a7e4c9d2",]

[[axioms]]
id = "cpp20_range_enable_view_specialization_w5x6y7z8"
content = "Users may specialize enable_view to true for cv-unqualified program-defined types that model view, and false for types that do not. Such specializations shall be usable in constant expressions and have type const bool."
formal_spec = "user_specialization(enable_view<T>) => is_cv_unqualified(T) && program_defined_type(T) && usable_in_constant_expr(enable_view<T>) && same_as<decltype(enable_view<T>), const bool> && (enable_view<T> == true => models<view>(T))"
layer = "cpp20_language"
confidence = 0.9
source_file = "range.view"
source_module = "[range.view]/7"
tags = [ "range", "view", "specialization", "constraint",]

[[axioms]]
id = "cpp20_range_contiguous_data_address_a9b0c1d2"
content = "A type T models contiguous_range only if to_address(ranges::begin(t)) == ranges::data(t) is true."
formal_spec = "models<contiguous_range>(T) => to_address(ranges::begin(t)) == ranges::data(t)"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/3"
tags = [ "range", "contiguous_range", "pointer", "concept",]
depends_on = [ "cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_viewable_range_view_constructible_e3f4a5b6"
content = "For a type T satisfying viewable_range where remove_cvref_t<T> is a view, T must be constructible_from<remove_cvref_t<T>, T>."
formal_spec = "models<viewable_range>(T) && view<remove_cvref_t<T>> => constructible_from<remove_cvref_t<T>, T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/6"
tags = [ "range", "viewable_range", "view", "constructible", "concept",]
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0"
content = "For a type T satisfying viewable_range where remove_cvref_t<T> is not a view, T must be an lvalue reference, or (movable<remove_reference_t<T>> and not a specialization of initializer_list)."
formal_spec = "models<viewable_range>(T) && !view<remove_cvref_t<T>> => is_lvalue_reference_v<T> || (movable<remove_reference_t<T>> && !is_initializer_list<T>)"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/6"
tags = [ "range", "viewable_range", "lvalue", "movable", "initializer_list", "concept",]
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_lval_temp_materialization_b4e9f1c5", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b",]

[[axioms]]
id = "cpp20_range_constant_range_non_modifiable_a1b2c3d4"
content = "The constant_range concept specifies the requirements of a range type whose elements are not modifiable, requiring input_range and constant-iterator for iterator_t."
formal_spec = "constant_range<T> <=> input_range<T> && constant_iterator<iterator_t<T>>"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/7"
tags = [ "range", "constant_range", "const", "iterator", "concept",]
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_concept_same_definition_symmetric_a7c3e1f2", "cpp20_concept_same_reflexive_e8a4c7d9", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_range_common_range_same_iterator_sentinel_e5f6a7b8"
content = "The common_range concept requires that ranges::begin and ranges::end return objects of the same type."
formal_spec = "common_range<T> <=> range<T> && same_as<iterator_t<T>, sentinel_t<T>>"
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/4"
tags = [ "range", "common_range", "iterator", "sentinel", "concept",]
depends_on = [ "cpp20_concept_same_definition_symmetric_a7c3e1f2", "cpp20_concept_same_reflexive_e8a4c7d9",]

[[axioms]]
id = "cpp20_format_string_invalid_format_3a8f2b1c"
content = "A format string that does not conform to the format string grammar for the given arguments is ill-formed."
formal_spec = "!is_format_string_for(fmt, args) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/2"
tags = [ "format", "format_string", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_string_arg_id_out_of_bounds_7c9d4e5f"
content = "If there is no argument with the index arg-id in args, the string is not a format string for args."
formal_spec = "arg_id >= sizeof...(args) => !is_format_string_for(fmt, args)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/2"
tags = [ "format", "format_string", "constraint", "argument_index",]
header = "<format>"

[[axioms]]
id = "cpp20_format_string_mixed_indexing_f4a5b6c7"
content = "A format string cannot contain a mixture of automatic and manual argument indexing."
formal_spec = "(has_automatic_indexing(fmt) && has_manual_indexing(fmt)) => !is_format_string_for(fmt, args)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/4"
tags = [ "format", "format_string", "constraint", "argument_index",]
header = "<format>"

[[axioms]]
id = "cpp20_format_string_invalid_format_spec_d8e9f0a1"
content = "If format-spec does not conform to the format specifications for the argument type referred to by arg-id, the string is not a format string for args."
formal_spec = "!conforms_to_format_spec(format_spec, arg_type(arg_id)) => !is_format_string_for(fmt, args)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/5"
tags = [ "format", "format_string", "constraint", "format_spec",]
header = "<format>"

[[axioms]]
id = "cpp20_format_sign_option_constraint_b2c3d4e5"
content = "The sign option is only valid for arithmetic types other than charT and bool or when an integer presentation type is specified."
formal_spec = "has_sign_option(format_spec) && !(is_arithmetic(T) && !is_same(T, charT) && !is_same(T, bool)) && !has_integer_presentation_type(format_spec) => invalid_format_spec"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/5"
tags = [ "format", "format_spec", "sign", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_alternate_form_constraint_a1b2c3d4"
content = "The # option (alternate form) is valid for arithmetic types other than charT and bool or when an integer presentation type is specified, and not otherwise."
formal_spec = "has_alternate_form(format_spec) && !(is_arithmetic(T) && !is_same(T, charT) && !is_same(T, bool)) && !has_integer_presentation_type(format_spec) => invalid_format_spec"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/7"
tags = [ "format", "format_spec", "alternate_form", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_zero_option_constraint_e5f6a7b8"
content = "The 0 option is valid for arithmetic types other than charT and bool, pointer types, or when an integer presentation type is specified."
formal_spec = "has_zero_option(format_spec) && !(is_arithmetic(T) && !is_same(T, charT) && !is_same(T, bool)) && !is_pointer(T) && !has_integer_presentation_type(format_spec) => invalid_format_spec"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/8"
tags = [ "format", "format_spec", "zero_padding", "constraint",]
header = "<format>"
depends_on = [ "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_format_width_negative_throws_c9d0e1f2"
content = "If the value of a dynamic width argument is negative, an exception of type format_error is thrown."
formal_spec = "is_dynamic_width(format_spec) && get_width_arg_value(args) < 0 => throws(format_error)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = [ "format", "format_spec", "width", "exception",]
header = "<format>"
depends_on = [ "cpp20_format_err_report_throws_format_error_a7b8c9d0", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_format_precision_negative_throws_f3a4b5c6"
content = "If the value of a dynamic precision argument is negative, an exception of type format_error is thrown."
formal_spec = "is_dynamic_precision(format_spec) && get_precision_arg_value(args) < 0 => throws(format_error)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = [ "format", "format_spec", "precision", "exception",]
header = "<format>"
depends_on = [ "cpp20_format_err_report_throws_format_error_a7b8c9d0", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_except_throw_destruction_ordering_d5e1c7b9",]

[[axioms]]
id = "cpp20_format_width_precision_type_constraint_d7e8f9a0"
content = "The dynamic width or precision option is valid only if the corresponding formatting argument is of standard signed or unsigned integer type."
formal_spec = "(is_dynamic_width(format_spec) || is_dynamic_precision(format_spec)) && !is_standard_integer_type(arg_type(width_arg_id)) => invalid_format_spec"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = [ "format", "format_spec", "width", "precision", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_precision_valid_types_b1c2d3e4"
content = "The precision option is valid for floating-point and string types only."
formal_spec = "has_precision(format_spec) && !is_floating_point(T) && !is_string_type(T) => invalid_format_spec"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/15"
tags = [ "format", "format_spec", "precision", "constraint",]
header = "<format>"
depends_on = [ "c11_cpp_conversion_syntax_convertType_7e132831",]

[[axioms]]
id = "cpp20_format_locale_option_constraint_a5b6c7d8"
content = "The L option is only valid for arithmetic types."
formal_spec = "has_locale_option(format_spec) && !is_arithmetic(T) => invalid_format_spec"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/17"
tags = [ "format", "format_spec", "locale", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_locale_not_constexpr_e9f0a1b2"
content = "A call to format on a given formatter specialization is not a constant subexpression if the locale-specific form is specified."
formal_spec = "has_locale_option(format_spec) => !is_constant_subexpression(format_call)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/17"
tags = [ "format", "format_spec", "locale", "constexpr", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_c_type_throws_out_of_range_c3d4e5f6"
content = "The c type presentation for integers throws format_error if value is not in the range of representable values for charT."
formal_spec = "type_option == 'c' && !in_range<charT>(value) => throws(format_error)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/21 Table 107"
tags = [ "format", "format_spec", "type", "exception", "character",]
header = "<format>"
depends_on = [ "cpp20_format_err_report_throws_format_error_a7b8c9d0", "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_format_err_report_throws_format_error_a7b8c9d0"
content = "Formatting functions throw format_error if an argument fmt is passed that is not a format string for args."
formal_spec = "!is_format_string_for(fmt, args) => throws(format_error)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.err.report"
source_module = "[format.err.report]/1"
tags = [ "format", "exception", "format_error",]
function = "std::format"
header = "<format>"
signature = "template<class... Args> string format(format_string<Args...> fmt, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_format_err_report_propagates_exceptions_e1f2a3b4"
content = "Formatting functions propagate exceptions thrown by operations of formatter specializations and iterators."
formal_spec = "throws_from_formatter_or_iterator(op) => propagates_exception(format_call)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.err.report"
source_module = "[format.err.report]/1"
tags = [ "format", "exception", "propagation",]
header = "<format>"

[[axioms]]
id = "cpp20_basic_format_string_consteval_invalid_b5c6d7e8"
content = "A call to basic_format_string consteval constructor is not a core constant expression unless there exist args of types Args such that str is a format string for args."
formal_spec = "!exists_args_for_format_string(str, Args...) => !is_core_constant_expression(basic_format_string(s))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.fmt.string"
source_module = "[format.fmt.string]/3"
tags = [ "format", "basic_format_string", "consteval", "constraint",]
function = "std::basic_format_string::basic_format_string"
header = "<format>"
signature = "template<class T> consteval basic_format_string(const T& s)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_format_functions_constexpr_requirement_f9a0b1c2"
content = "A call to any formatting function is a constant subexpression only if each of the used formatter specializations is a constexpr-enabled specialization."
formal_spec = "!all_constexpr_enabled_formatters(Args...) => !is_constant_subexpression(format_call)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/1"
tags = [ "format", "constexpr", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_vformat_to_precondition_output_iterator_c3d4e5f6"
content = "vformat_to requires that Out models output_iterator<const charT&>."
formal_spec = "!models<Out, output_iterator<const charT&>> => precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/15"
tags = [ "format", "vformat_to", "precondition", "iterator",]
function = "std::vformat_to"
header = "<format>"
signature = "template<class Out> Out vformat_to(Out out, string_view fmt, format_args args)"
depends_on = [ "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8",]

[[axioms]]
id = "cpp20_format_to_n_precondition_output_iterator_a7b8c9d0"
content = "format_to_n requires that Out models output_iterator<const charT&> and formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements for each Ti in Args."
formal_spec = "(!models<Out, output_iterator<const charT&>> || !all_basic_formatter_requirements(Args...)) => precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/21"
tags = [ "format", "format_to_n", "precondition", "iterator", "formatter",]
function = "std::format_to_n"
header = "<format>"
signature = "template<class Out, class... Args> format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n, format_string<Args...> fmt, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4"
content = "formatted_size requires that formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements for each Ti in Args."
formal_spec = "!all_basic_formatter_requirements(Args...) => precondition_violation"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/26"
tags = [ "format", "formatted_size", "precondition", "formatter",]
function = "std::formatted_size"
header = "<format>"
signature = "template<class... Args> size_t formatted_size(format_string<Args...> fmt, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8"
content = "The parse member function of a formatter throws format_error unless the whole range is parsed or the unmatched character is }."
formal_spec = "!parsed_successfully(format_spec) && unmatched_char != '}' => throws(format_error)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "formatter.requirements"
source_module = "[formatter.requirements] Table 112"
tags = [ "format", "formatter", "parse", "exception",]
function = "formatter::parse"
header = "<format>"
signature = "PC::iterator formatter<T, charT>::parse(basic_format_parse_context<charT>& pc)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_iterator_operations_next_effect_c5f9a2b7", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6", "cpp20_format_err_report_throws_format_error_a7b8c9d0", "cpp20_iterator_operations_prev_effect_d6a0b3c8",]

[[axioms]]
id = "cpp20_formatter_disabled_not_constructible_f9a0b1c2"
content = "If F is a disabled specialization of formatter, is_default_constructible_v<F>, is_copy_constructible_v<F>, is_move_constructible_v<F>, is_copy_assignable_v<F>, and is_move_assignable_v<F> are all false."
formal_spec = "is_disabled_formatter<F> => (!is_default_constructible_v<F> && !is_copy_constructible_v<F> && !is_move_constructible_v<F> && !is_copy_assignable_v<F> && !is_move_assignable_v<F>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.spec"
source_module = "[format.formatter.spec]/7"
tags = [ "format", "formatter", "disabled", "type_traits",]
header = "<format>"

[[axioms]]
id = "cpp20_formatter_enabled_meets_basic_formatter_c3d4e5f6"
content = "An enabled specialization formatter<T, charT> meets the BasicFormatter requirements."
formal_spec = "is_enabled_formatter<formatter<T, charT>> => meets_basic_formatter_requirements<formatter<T, charT>>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.spec"
source_module = "[format.formatter.spec]/8"
tags = [ "format", "formatter", "enabled", "requirements",]
header = "<format>"

[[axioms]]
id = "cpp20_formattable_concept_requirements_a7b8c9d0"
content = "A type T and a character type charT model formattable if formatter<remove_cvref_t<T>, charT> meets the BasicFormatter requirements and, if remove_reference_t<T> is const-qualified, the Formatter requirements."
formal_spec = "formattable<T, charT> <=> (meets_basic_formatter_requirements<formatter<remove_cvref_t<T>, charT>> && (is_const<remove_reference_t<T>> => meets_formatter_requirements<formatter<remove_cvref_t<T>, charT>>))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formattable"
source_module = "[format.formattable]/2"
tags = [ "format", "formattable", "concept", "requirements",]
header = "<format>"

[[axioms]]
id = "cpp20_enable_nonlocking_formatter_specialization_e1f2a3b4"
content = "User specializations of enable_nonlocking_formatter_optimization shall be usable in constant expressions and have type const bool."
formal_spec = "is_user_specialization(enable_nonlocking_formatter_optimization<T>) => (is_constexpr(enable_nonlocking_formatter_optimization<T>) && is_same<decltype(enable_nonlocking_formatter_optimization<T>), const bool>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.locking"
source_module = "[format.formatter.locking]/1"
tags = [ "format", "formatter", "locking", "specialization", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_fill_char_utf_scalar_b5c6d7e8"
content = "For a format specification in UTF-8, UTF-16, or UTF-32, the fill character corresponds to a single Unicode scalar value."
formal_spec = "is_utf_encoding(charT) => is_single_unicode_scalar_value(fill_char)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/3"
tags = [ "format", "format_spec", "fill", "unicode", "constraint",]
header = "<format>"

[[axioms]]
id = "cpp20_format_range_disabled_constraint_f9a0b1c2"
content = "A formatter specialization for ranges is only enabled if format_kind<R> is not range_format::disabled and the range element type is formattable."
formal_spec = "(format_kind<R> == range_format::disabled || !formattable<ranges::range_reference_t<R>, charT>) => !is_enabled_formatter<formatter<R, charT>>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.syn"
source_module = "[format.syn]"
tags = [ "format", "range", "formatter", "constraint",]
header = "<format>"
depends_on = [ "cpp20_range_sized_size_O1_o5p6q7r8", "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6",]

[[axioms]]
id = "cpp20_range_formatter_constraint_same_as_c3d4e5f6"
content = "range_formatter requires same_as<remove_cvref_t<T>, T> and formattable<T, charT>."
formal_spec = "!same_as<remove_cvref_t<T>, T> || !formattable<T, charT> => constraint_violation(range_formatter<T, charT>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.syn"
source_module = "[format.syn]"
tags = [ "format", "range_formatter", "constraint",]
header = "<format>"
depends_on = [ "cpp20_concept_same_definition_symmetric_a7c3e1f2",]

[[axioms]]
id = "cpp20_format_parse_context_check_dynamic_spec_a7b8c9d0"
content = "The check_dynamic_spec member function of basic_format_parse_context validates that the argument at the specified index is one of the specified types."
formal_spec = "!is_one_of_types<Ts...>(arg_type(arg_id)) => throws(format_error)"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "format.parse.ctx"
source_module = "[format.parse.ctx]"
tags = [ "format", "parse_context", "dynamic_spec", "constraint",]
function = "std::basic_format_parse_context::check_dynamic_spec"
header = "<format>"
signature = "template<class... Ts> constexpr void check_dynamic_spec(size_t id)"
depends_on = [ "cpp20_format_err_report_throws_format_error_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4"
content = "Objects of type bad_any_cast are thrown by a failed any_cast operation."
formal_spec = "any_cast_fails(operand, T) => throws(bad_any_cast)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.bad.any.cast"
source_module = "[any.bad.any.cast]/1"
tags = [ "exception", "any", "type_erasure", "cast",]
function = "bad_any_cast"
header = "<any>"
signature = "class bad_any_cast : public bad_cast"
depends_on = [ "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8",]

[[axioms]]
id = "cpp20_any_small_object_optimization_constraint_e5f6a7b8"
content = "Small-object optimization for std::any shall only be applied to types T for which is_nothrow_move_constructible_v<T> is true."
formal_spec = "small_object_optimization_applied(any, T) => is_nothrow_move_constructible_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.class.general"
source_module = "[any.class.general]/3"
tags = [ "any", "optimization", "move_constructible", "implementation",]

[[axioms]]
id = "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2"
content = "The template constructor any(T&& value) requires that decay_t<T> meets the Cpp17CopyConstructible requirements."
formal_spec = "call(any::any<T>, value) => Cpp17CopyConstructible(decay_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/7"
tags = [ "any", "constructor", "precondition", "copy_constructible",]
function = "std::any::any"
header = "<any>"
signature = "template<class T> any(T&& value)"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6"
content = "The in-place constructor any(in_place_type_t<T>, Args&&...) requires that decay_t<T> meets the Cpp17CopyConstructible requirements."
formal_spec = "call(any::any<T, Args...>, in_place_type_t<T>, args...) => Cpp17CopyConstructible(decay_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/12"
tags = [ "any", "constructor", "precondition", "in_place", "copy_constructible",]
function = "std::any::any"
header = "<any>"
signature = "template<class T, class... Args> explicit any(in_place_type_t<T>, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0"
content = "The in-place constructor with initializer_list any(in_place_type_t<T>, initializer_list<U>, Args&&...) requires that decay_t<T> meets the Cpp17CopyConstructible requirements."
formal_spec = "call(any::any<T, U, Args...>, in_place_type_t<T>, il, args...) => Cpp17CopyConstructible(decay_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/18"
tags = [ "any", "constructor", "precondition", "in_place", "initializer_list", "copy_constructible",]
function = "std::any::any"
header = "<any>"
signature = "template<class T, class U, class... Args> explicit any(in_place_type_t<T>, initializer_list<U> il, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4"
content = "The template assignment operator any::operator=(T&&) requires that decay_t<T> meets the Cpp17CopyConstructible requirements."
formal_spec = "call(any::operator=<T>, rhs) => Cpp17CopyConstructible(decay_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/9"
tags = [ "any", "assignment", "precondition", "copy_constructible",]
function = "std::any::operator="
header = "<any>"
signature = "template<class T> any& operator=(T&& rhs)"
depends_on = [ "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_any_emplace_precondition_copyconstruct_f5a6b7c8"
content = "The emplace member function requires that decay_t<T> meets the Cpp17CopyConstructible requirements."
formal_spec = "call(any::emplace<T, Args...>, args...) => Cpp17CopyConstructible(decay_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/3"
tags = [ "any", "emplace", "precondition", "copy_constructible",]
function = "std::any::emplace"
header = "<any>"
signature = "template<class T, class... Args> decay_t<T>& emplace(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_any_emplace_initlist_precondition_copyconstruct_d9e0f1a2"
content = "The emplace member function with initializer_list requires that decay_t<T> meets the Cpp17CopyConstructible requirements."
formal_spec = "call(any::emplace<T, U, Args...>, il, args...) => Cpp17CopyConstructible(decay_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/11"
tags = [ "any", "emplace", "precondition", "initializer_list", "copy_constructible",]
function = "std::any::emplace"
header = "<any>"
signature = "template<class T, class U, class... Args> decay_t<T>& emplace(initializer_list<U> il, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a",]

[[axioms]]
id = "cpp20_any_emplace_exception_state_b3c4d5e6"
content = "If an exception is thrown during emplace's call to VT's constructor, the any object does not contain a value, and any previously contained value has been destroyed."
formal_spec = "call(any::emplace<T>, args...) && throws_exception(VT_constructor) => !has_value(*this) && destroyed(previous_value)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/8"
tags = [ "any", "emplace", "exception", "state",]
function = "std::any::emplace"
header = "<any>"
signature = "template<class T, class... Args> decay_t<T>& emplace(Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_emplace_initlist_exception_state_f7a8b9c0"
content = "If an exception is thrown during emplace with initializer_list's call to VT's constructor, the any object does not contain a value, and any previously contained value has been destroyed."
formal_spec = "call(any::emplace<T, U>, il, args...) && throws_exception(VT_constructor) => !has_value(*this) && destroyed(previous_value)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/16"
tags = [ "any", "emplace", "exception", "initializer_list", "state",]
function = "std::any::emplace"
header = "<any>"
signature = "template<class T, class U, class... Args> decay_t<T>& emplace(initializer_list<U> il, Args&&... args)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_basic_life_vacuous_initialization_def_7c4e5d6a", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4"
content = "any_cast for reference types throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>)."
formal_spec = "call(any_cast<T>, operand) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = [ "any", "any_cast", "exception", "bad_any_cast", "type_check",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T any_cast(const any& operand)"
depends_on = [ "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4",]

[[axioms]]
id = "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8"
content = "any_cast for lvalue reference throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>)."
formal_spec = "call(any_cast<T>, operand) && is_lvalue_reference(any&) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = [ "any", "any_cast", "exception", "bad_any_cast", "type_check",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T any_cast(any& operand)"
depends_on = [ "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "cpp20_basic_lval_temp_materialization_b4e9f1c5", "cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b", "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4",]

[[axioms]]
id = "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2"
content = "any_cast for rvalue reference throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>)."
formal_spec = "call(any_cast<T>, operand) && is_rvalue_reference(any&&) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = [ "any", "any_cast", "exception", "bad_any_cast", "type_check",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T any_cast(any&& operand)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4", "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0", "extract_constraint_type_r_moveable_f6c8d2e4", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8", "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4",]

[[axioms]]
id = "cpp20_any_cast_const_ref_mandates_constructible_d3e4f5a6"
content = "any_cast<T>(const any&) mandates that is_constructible_v<T, const U&> is true where U is remove_cvref_t<T>."
formal_spec = "call(any_cast<T>, const any&) => is_constructible_v<T, const remove_cvref_t<T>&> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = [ "any", "any_cast", "mandates", "constructible",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T any_cast(const any& operand)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_any_cast_lvalue_ref_mandates_constructible_b7c8d9e0"
content = "any_cast<T>(any&) mandates that is_constructible_v<T, U&> is true where U is remove_cvref_t<T>."
formal_spec = "call(any_cast<T>, any&) => is_constructible_v<T, remove_cvref_t<T>&> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = [ "any", "any_cast", "mandates", "constructible",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T any_cast(any& operand)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_any_cast_rvalue_ref_mandates_constructible_f1a2b3c4"
content = "any_cast<T>(any&&) mandates that is_constructible_v<T, U> is true where U is remove_cvref_t<T>."
formal_spec = "call(any_cast<T>, any&&) => is_constructible_v<T, remove_cvref_t<T>> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = [ "any", "any_cast", "mandates", "constructible",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T any_cast(any&& operand)"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_any_cast_pointer_mandates_not_void_d5e6f7a8"
content = "any_cast<T>(const any*) and any_cast<T>(any*) mandate that is_void_v<T> is false."
formal_spec = "call(any_cast<T>, any*) => is_void_v<T> == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/9"
tags = [ "any", "any_cast", "mandates", "void", "pointer",]
function = "any_cast"
header = "<any>"
signature = "template<class T> const T* any_cast(const any* operand) noexcept"
depends_on = [ "cpp20_const_pointer_cast_mandates_7a8b9c0d", "c11_cpp_translation_name_syntax_operation_95efc489", "c11_cpp_translation_expr_cast_operation_d3b83600", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2",]

[[axioms]]
id = "cpp20_any_cast_pointer_returns_nullptr_type_mismatch_b9c0d1e2"
content = "any_cast<T>(any*) returns nullptr if operand is nullptr or if operand->type() != typeid(T)."
formal_spec = "call(any_cast<T>, operand) && (operand == nullptr || operand->type() != typeid(T)) => result == nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/10"
tags = [ "any", "any_cast", "pointer", "nullptr", "type_check",]
function = "any_cast"
header = "<any>"
signature = "template<class T> T* any_cast(any* operand) noexcept"
depends_on = [ "cpp20_variant_get_if_returns_nullptr_o3p4q5r6", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5", "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489",]

[[axioms]]
id = "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6"
content = "any_cast<T>(const any*) returns nullptr if operand is nullptr or if operand->type() != typeid(T)."
formal_spec = "call(any_cast<T>, const any* operand) && (operand == nullptr || operand->type() != typeid(T)) => result == nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/10"
tags = [ "any", "any_cast", "pointer", "nullptr", "type_check", "const",]
function = "any_cast"
header = "<any>"
signature = "template<class T> const T* any_cast(const any* operand) noexcept"
depends_on = [ "cpp20_const_pointer_cast_mandates_7a8b9c0d", "cpp20_variant_get_if_returns_nullptr_o3p4q5r6", "cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2", "cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5", "c11_cpp_translation_expr_cast_operation_d3b83600", "c11_cpp_translation_name_syntax_operation_95efc489",]

[[axioms]]
id = "cpp20_any_type_returns_void_when_empty_d7e8f9a0"
content = "any::type() returns typeid(void) if the any object has no contained value."
formal_spec = "!has_value() => type() == typeid(void)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.observers"
source_module = "[any.observers]/2"
tags = [ "any", "type", "observer", "empty",]
function = "std::any::type"
header = "<any>"
signature = "const type_info& type() const noexcept"
depends_on = [ "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7",]

[[axioms]]
id = "cpp20_any_has_value_returns_true_when_contains_b1c2d3e4"
content = "any::has_value() returns true if the any object contains an object, otherwise false."
formal_spec = "has_value() == true <=> contains_object(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.observers"
source_module = "[any.observers]/1"
tags = [ "any", "has_value", "observer",]
function = "std::any::has_value"
header = "<any>"
signature = "bool has_value() const noexcept"

[[axioms]]
id = "cpp20_any_reset_destroys_contained_value_f5a6b7c8"
content = "any::reset() destroys the contained value if has_value() is true."
formal_spec = "has_value() && call(reset) => destroyed(contained_value) && !has_value()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/17"
tags = [ "any", "reset", "destructor", "lifetime",]
function = "std::any::reset"
header = "<any>"
signature = "void reset() noexcept"
depends_on = [ "cpp20_basic_life_end_without_destructor_9c0d1e2f",]

[[axioms]]
id = "cpp20_any_destructor_calls_reset_d9e0f1a2"
content = "The any destructor has the effect of calling reset()."
formal_spec = "call(any::~any) => equivalent_to(call(reset))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/22"
tags = [ "any", "destructor", "reset", "lifetime",]
function = "std::any::~any"
header = "<any>"
signature = "~any()"
depends_on = [ "cpp20_class_dtor_defaulted_constexpr_b3e7f2c4", "cpp20_class_dtor_member_destruction_order_a7e4c9d2",]

[[axioms]]
id = "cpp20_any_copy_assignment_exception_safety_b3c4d5e6"
content = "any::operator=(const any&) has no effects if an exception is thrown during copy construction."
formal_spec = "call(any::operator=, const any& rhs) && throws_exception(copy_ctor) => no_effect(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/1"
tags = [ "any", "assignment", "exception_safety", "strong_guarantee",]
function = "std::any::operator="
header = "<any>"
signature = "any& operator=(const any& rhs)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "c11_cpp_translation_name_syntax_operation_018c4422", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_template_assignment_exception_safety_f7a8b9c0"
content = "any::operator=(T&&) has no effects if an exception is thrown during construction."
formal_spec = "call(any::operator=<T>, rhs) && throws_exception(VT_ctor) => no_effect(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/10"
tags = [ "any", "assignment", "exception_safety", "strong_guarantee", "template",]
function = "std::any::operator="
header = "<any>"
signature = "template<class T> any& operator=(T&& rhs)"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_except_throw_destruction_ordering_d5e1c7b9", "cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "c11_cpp_translation_name_syntax_operation_018c4422", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_default_ctor_postcondition_no_value_d1e2f3a4"
content = "After default construction, any::has_value() is false."
formal_spec = "call(any::any()) => !has_value()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/1"
tags = [ "any", "constructor", "default", "postcondition",]
function = "std::any::any"
header = "<any>"
signature = "constexpr any() noexcept"
depends_on = [ "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_move_ctor_noexcept_b5c6d7e8"
content = "The move constructor any(any&&) is noexcept."
formal_spec = "noexcept(any::any(any&&)) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/4"
tags = [ "any", "constructor", "move", "noexcept",]
function = "std::any::any"
header = "<any>"
signature = "any(any&& other) noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_any_reset_noexcept_b7c8d9e0", "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8", "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0",]

[[axioms]]
id = "cpp20_any_move_assignment_noexcept_f9a0b1c2"
content = "The move assignment operator any::operator=(any&&) is noexcept."
formal_spec = "noexcept(any::operator=(any&&)) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/4"
tags = [ "any", "assignment", "move", "noexcept",]
function = "std::any::operator="
header = "<any>"
signature = "any& operator=(any&& rhs) noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6", "cpp20_any_reset_noexcept_b7c8d9e0", "cpp20_weak_ptr_assignment_move_effect_c0e4a8f3", "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6", "c11_cpp_translation_name_syntax_operation_018c4422",]

[[axioms]]
id = "cpp20_any_swap_noexcept_d3e4f5a6"
content = "The swap member function any::swap(any&) is noexcept."
formal_spec = "noexcept(any::swap(any&)) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/19"
tags = [ "any", "swap", "noexcept",]
function = "std::any::swap"
header = "<any>"
signature = "void swap(any& rhs) noexcept"
depends_on = [ "cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7", "cpp20_any_reset_noexcept_b7c8d9e0", "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r", "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6",]

[[axioms]]
id = "cpp20_any_reset_noexcept_b7c8d9e0"
content = "The reset member function any::reset() is noexcept."
formal_spec = "noexcept(any::reset()) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/17"
tags = [ "any", "reset", "noexcept",]
function = "std::any::reset"
header = "<any>"
signature = "void reset() noexcept"
depends_on = [ "cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8", "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6",]

[[axioms]]
id = "cpp20_bit_cast_constraint_sizeof_equality_a7f3e9d1"
content = "bit_cast requires that sizeof(To) == sizeof(From) is true."
formal_spec = "template<class To, class From> bit_cast(const From& from) => requires(sizeof(To) == sizeof(From))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/1.1"
tags = [ "constraint", "size", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_constraint_to_trivially_copyable_b8e4f2c6"
content = "bit_cast requires that To is trivially copyable (is_trivially_copyable_v<To> is true)."
formal_spec = "template<class To, class From> bit_cast(const From& from) => requires(is_trivially_copyable_v<To>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/1.2"
tags = [ "constraint", "trivially-copyable", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_constraint_from_trivially_copyable_c9d5a3e7"
content = "bit_cast requires that From is trivially copyable (is_trivially_copyable_v<From> is true)."
formal_spec = "template<class To, class From> bit_cast(const From& from) => requires(is_trivially_copyable_v<From>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/1.3"
tags = [ "constraint", "trivially-copyable", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_mandate_no_consteval_only_types_d2f6b8a4"
content = "bit_cast mandates that neither To nor From are consteval-only types."
formal_spec = "template<class To, class From> bit_cast(const From& from) => mandates(!is_consteval_only<To> && !is_consteval_only<From>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/2"
tags = [ "mandate", "consteval", "type-constraint",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_constexpr_condition_no_union_e3a7c9f5"
content = "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_union_v<T> is false."
formal_spec = "constexpr_eligible(bit_cast) => forall T in {To, From, subobjects(To), subobjects(From)}: !is_union_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/3.1"
tags = [ "constexpr", "union", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_constexpr_condition_no_pointer_f4b8d0a6"
content = "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_pointer_v<T> is false."
formal_spec = "constexpr_eligible(bit_cast) => forall T in {To, From, subobjects(To), subobjects(From)}: !is_pointer_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/3.2"
tags = [ "constexpr", "pointer", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_bit_cast_constexpr_condition_no_member_pointer_a5c9e1b7"
content = "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_member_pointer_v<T> is false."
formal_spec = "constexpr_eligible(bit_cast) => forall T in {To, From, subobjects(To), subobjects(From)}: !is_member_pointer_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/3.3"
tags = [ "constexpr", "member-pointer", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_constexpr_condition_no_volatile_b6d0f2c8"
content = "bit_cast is constant evaluation eligible when To, From, and all subobjects satisfy: is_volatile_v<T> is false."
formal_spec = "constexpr_eligible(bit_cast) => forall T in {To, From, subobjects(To), subobjects(From)}: !is_volatile_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/3.4"
tags = [ "constexpr", "volatile", "type-trait",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_constexpr_condition_no_reference_members_c7e1a3d9"
content = "bit_cast is constant evaluation eligible when To, From, and all subobjects have no non-static data members of reference type."
formal_spec = "constexpr_eligible(bit_cast) => forall T in {To, From, subobjects(To), subobjects(From)}: !has_reference_nsdm(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/3.5"
tags = [ "constexpr", "reference", "member",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"
depends_on = [ "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_bit_cast_ub_no_valid_value_for_representation_d8f2b4e0"
content = "If there is no value of the result object's type corresponding to the value representation produced by bit_cast, the behavior is undefined."
formal_spec = "bit_cast(from) && !exists_value(To, value_representation(result)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4"
tags = [ "undefined-behavior", "value-representation", "type-safety",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_ub_indeterminate_bit_non_uchar_e9a3c5f1"
content = "If a bit in the value representation of the result is indeterminate and the smallest enclosing object is not of unsigned ordinary character type or std::byte, the behavior is undefined."
formal_spec = "bit_in_result(b) && indeterminate(b) && !is_unsigned_char(smallest_enclosing(b)) && !is_byte(smallest_enclosing(b)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4.2"
tags = [ "undefined-behavior", "indeterminate-value", "bit-representation",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_erroneous_bit_non_uchar_f0b4d6a2"
content = "If a bit in the value representation of the result is erroneous and the smallest enclosing object is not of unsigned ordinary character type or std::byte, the behavior is erroneous."
formal_spec = "bit_in_result(b) && erroneous(b) && !is_unsigned_char(smallest_enclosing(b)) && !is_byte(smallest_enclosing(b)) => erroneous_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4.3"
tags = [ "erroneous-behavior", "erroneous-value", "bit-representation",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_indeterminate_from_non_lifetime_a1c5e7b3"
content = "A bit in the value representation of the bit_cast result is indeterminate if it corresponds to a bit for which the smallest enclosing object in from is not within its lifetime."
formal_spec = "bit_cast(from) && bit_corresponds(result_bit, from_bit) && !in_lifetime(smallest_enclosing(from_bit)) => indeterminate(result_bit)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4"
tags = [ "indeterminate-value", "lifetime", "bit-representation",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"
depends_on = [ "extract_precond_object_lifetime_started_b8c2d4e6",]

[[axioms]]
id = "cpp20_bit_cast_indeterminate_from_indeterminate_value_b2d6f8c4"
content = "A bit in the value representation of the bit_cast result is indeterminate if it corresponds to a bit for which the smallest enclosing object in from has an indeterminate value."
formal_spec = "bit_cast(from) && bit_corresponds(result_bit, from_bit) && indeterminate_value(smallest_enclosing(from_bit)) => indeterminate(result_bit)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4"
tags = [ "indeterminate-value", "bit-representation", "propagation",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_erroneous_from_erroneous_value_c3e7a9d5"
content = "A bit in the value representation of the bit_cast result is erroneous if it corresponds to a bit for which the smallest enclosing object in from has an erroneous value."
formal_spec = "bit_cast(from) && bit_corresponds(result_bit, from_bit) && erroneous_value(smallest_enclosing(from_bit)) => erroneous(result_bit)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4"
tags = [ "erroneous-value", "bit-representation", "propagation",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_uchar_indeterminate_value_d4f8b0e6"
content = "If the smallest enclosing object containing an indeterminate or erroneous bit is of unsigned ordinary character type or std::byte, and any bit in its value representation is indeterminate, the object has an indeterminate value."
formal_spec = "smallest_enclosing(b) == u && (is_unsigned_char(u) || is_byte(u)) && exists bit in u: indeterminate(bit) => indeterminate_value(u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4.1"
tags = [ "indeterminate-value", "unsigned-char", "byte",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_cast_uchar_erroneous_value_e5a9c1f7"
content = "If the smallest enclosing object containing an indeterminate or erroneous bit is of unsigned ordinary character type or std::byte, and no bit is indeterminate but some are erroneous, the object has an erroneous value."
formal_spec = "smallest_enclosing(b) == u && (is_unsigned_char(u) || is_byte(u)) && !exists bit in u: indeterminate(bit) && exists bit in u: erroneous(bit) => erroneous_value(u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.cast"
source_module = "[bit.cast]/4.1"
tags = [ "erroneous-value", "unsigned-char", "byte",]
function = "std::bit_cast"
header = "<bit>"
signature = "template<class To, class From> constexpr To bit_cast(const From& from) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_has_single_bit_constraint_unsigned_a1f3e7d2"
content = "has_single_bit requires T to be an unsigned integer type."
formal_spec = "is_unsigned_integer_type(T) || ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/1"
tags = [ "constraint", "type_requirement", "unsigned_integer",]
function = "std::has_single_bit"
header = "<bit>"
signature = "bool has_single_bit<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_has_single_bit_return_power_of_two_b8c4d9f1"
content = "has_single_bit returns true if and only if x is an integral power of two."
formal_spec = "has_single_bit(x) <=> exists k. (x == 2^k && k >= 0)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/2"
tags = [ "semantics", "power_of_two", "return_value",]
function = "std::has_single_bit"
header = "<bit>"
signature = "bool has_single_bit<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_bit_ceil_constraint_unsigned_c7d2e8f5"
content = "bit_ceil requires T to be an unsigned integer type."
formal_spec = "is_unsigned_integer_type(T) || ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/4"
tags = [ "constraint", "type_requirement", "unsigned_integer",]
function = "std::bit_ceil"
header = "<bit>"
signature = "T bit_ceil<T>(T x)"

[[axioms]]
id = "cpp20_bit_pow_two_bit_ceil_precondition_representable_d3e9f1a7"
content = "bit_ceil requires that N (the smallest power of 2 >= x) is representable as a value of type T."
formal_spec = "N = min{2^k : 2^k >= x} => N <= numeric_limits<T>::max() || precondition_violated"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/5"
tags = [ "precondition", "overflow", "representability",]
function = "std::bit_ceil"
header = "<bit>"
signature = "T bit_ceil<T>(T x)"

[[axioms]]
id = "cpp20_bit_pow_two_bit_ceil_return_smallest_power_e4f1a2b8"
content = "bit_ceil returns N, the smallest power of 2 greater than or equal to x."
formal_spec = "bit_ceil(x) == min{2^k : 2^k >= x && k >= 0}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/6"
tags = [ "semantics", "return_value", "power_of_two",]
function = "std::bit_ceil"
header = "<bit>"
signature = "T bit_ceil<T>(T x)"

[[axioms]]
id = "cpp20_bit_pow_two_bit_ceil_throws_nothing_f5a7b3c9"
content = "bit_ceil throws nothing."
formal_spec = "noexcept(bit_ceil(x)) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/7"
tags = [ "exception", "noexcept",]
function = "std::bit_ceil"
header = "<bit>"
signature = "T bit_ceil<T>(T x)"

[[axioms]]
id = "cpp20_bit_pow_two_bit_ceil_constexpr_precondition_violation_a6b8c4d1"
content = "A bit_ceil function call that violates the precondition (N not representable) is not a core constant expression."
formal_spec = "constexpr_context && (N > numeric_limits<T>::max()) => !core_constant_expression"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/8"
tags = [ "constexpr", "precondition", "constant_expression",]
function = "std::bit_ceil"
header = "<bit>"
signature = "constexpr T bit_ceil<T>(T x)"

[[axioms]]
id = "cpp20_bit_pow_two_bit_floor_constraint_unsigned_b7c9d5e2"
content = "bit_floor requires T to be an unsigned integer type."
formal_spec = "is_unsigned_integer_type(T) || ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/9"
tags = [ "constraint", "type_requirement", "unsigned_integer",]
function = "std::bit_floor"
header = "<bit>"
signature = "T bit_floor<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_bit_floor_return_zero_c8d4e1f7"
content = "bit_floor returns 0 if x == 0."
formal_spec = "x == 0 => bit_floor(x) == 0"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/10"
tags = [ "semantics", "return_value", "edge_case",]
function = "std::bit_floor"
header = "<bit>"
signature = "T bit_floor<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_bit_floor_return_maximal_power_d9e5f2a8"
content = "bit_floor returns the maximal value y such that has_single_bit(y) is true and y <= x, when x != 0."
formal_spec = "x != 0 => bit_floor(x) == max{y : has_single_bit(y) && y <= x}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/10"
tags = [ "semantics", "return_value", "power_of_two",]
function = "std::bit_floor"
header = "<bit>"
signature = "T bit_floor<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_bit_width_constraint_unsigned_e1f6a3b9"
content = "bit_width requires T to be an unsigned integer type."
formal_spec = "is_unsigned_integer_type(T) || ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/11"
tags = [ "constraint", "type_requirement", "unsigned_integer",]
function = "std::bit_width"
header = "<bit>"
signature = "int bit_width<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_bit_width_return_zero_f2a7b4c1"
content = "bit_width returns 0 if x == 0."
formal_spec = "x == 0 => bit_width(x) == 0"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/12"
tags = [ "semantics", "return_value", "edge_case",]
function = "std::bit_width"
header = "<bit>"
signature = "int bit_width<T>(T x) noexcept"

[[axioms]]
id = "cpp20_bit_pow_two_bit_width_return_log2_plus_one_a3b8c5d2"
content = "bit_width returns one plus the base-2 logarithm of x with fractional part discarded, when x != 0."
formal_spec = "x != 0 => bit_width(x) == floor(log2(x)) + 1"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "bit.pow.two"
source_module = "[bit.pow.two]/12"
tags = [ "semantics", "return_value", "logarithm",]
function = "std::bit_width"
header = "<bit>"
signature = "int bit_width<T>(T x) noexcept"

[[axioms]]
id = "cpp20_func_invoke_constraint_is_invocable_a7f3d2e1"
content = "std::invoke requires is_invocable_v<F, Args...> to be true"
formal_spec = "invoke(f, args...) => is_invocable_v<F, Args...> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/1"
tags = [ "invoke", "constraints", "invocable",]
function = "std::invoke"
header = "<functional>"
signature = "invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) noexcept(is_nothrow_invocable_v<F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_effect_forward_f_b8c4d9e2"
content = "std::invoke perfectly forwards f using std::forward<F>(f)"
formal_spec = "invoke(f, args...) => INVOKE(std::forward<F>(f), std::forward<Args>(args)...)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/2"
tags = [ "invoke", "forwarding", "perfect-forwarding",]
function = "std::invoke"
header = "<functional>"
signature = "invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) noexcept(is_nothrow_invocable_v<F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_effect_forward_args_c9d5e0f3"
content = "std::invoke perfectly forwards each argument using std::forward<Args>(args)..."
formal_spec = "invoke(f, args...) => INVOKE(std::forward<F>(f), std::forward<Args>(args)...)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/2"
tags = [ "invoke", "forwarding", "perfect-forwarding", "variadic",]
function = "std::invoke"
header = "<functional>"
signature = "invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) noexcept(is_nothrow_invocable_v<F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_noexcept_conditional_d0e6f1a4"
content = "std::invoke is noexcept if and only if is_nothrow_invocable_v<F, Args...> is true"
formal_spec = "noexcept(invoke(f, args...)) <=> is_nothrow_invocable_v<F, Args...>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/1"
tags = [ "invoke", "noexcept", "exception-safety",]
function = "std::invoke"
header = "<functional>"
signature = "invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) noexcept(is_nothrow_invocable_v<F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_r_constraint_is_invocable_r_e1f7a2b5"
content = "std::invoke_r requires is_invocable_r_v<R, F, Args...> to be true"
formal_spec = "invoke_r<R>(f, args...) => is_invocable_r_v<R, F, Args...> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/3"
tags = [ "invoke", "invoke_r", "constraints", "invocable",]
function = "std::invoke_r"
header = "<functional>"
signature = "R invoke_r(F&& f, Args&&... args) noexcept(is_nothrow_invocable_r_v<R, F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_r_effect_forward_f_f2a8b3c6"
content = "std::invoke_r perfectly forwards f using std::forward<F>(f)"
formal_spec = "invoke_r<R>(f, args...) => INVOKE<R>(std::forward<F>(f), std::forward<Args>(args)...)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/4"
tags = [ "invoke", "invoke_r", "forwarding", "perfect-forwarding",]
function = "std::invoke_r"
header = "<functional>"
signature = "R invoke_r(F&& f, Args&&... args) noexcept(is_nothrow_invocable_r_v<R, F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_r_effect_forward_args_a3b9c4d7"
content = "std::invoke_r perfectly forwards each argument using std::forward<Args>(args)..."
formal_spec = "invoke_r<R>(f, args...) => INVOKE<R>(std::forward<F>(f), std::forward<Args>(args)...)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/4"
tags = [ "invoke", "invoke_r", "forwarding", "perfect-forwarding", "variadic",]
function = "std::invoke_r"
header = "<functional>"
signature = "R invoke_r(F&& f, Args&&... args) noexcept(is_nothrow_invocable_r_v<R, F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_r_noexcept_conditional_b4c0d5e8"
content = "std::invoke_r is noexcept if and only if is_nothrow_invocable_r_v<R, F, Args...> is true"
formal_spec = "noexcept(invoke_r<R>(f, args...)) <=> is_nothrow_invocable_r_v<R, F, Args...>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/3"
tags = [ "invoke", "invoke_r", "noexcept", "exception-safety",]
function = "std::invoke_r"
header = "<functional>"
signature = "R invoke_r(F&& f, Args&&... args) noexcept(is_nothrow_invocable_r_v<R, F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_r_effect_explicit_result_type_c5d1e6f9"
content = "std::invoke_r explicitly converts or casts the result to type R as specified by INVOKE<R>"
formal_spec = "invoke_r<R>(f, args...) => result_type == R"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/4"
tags = [ "invoke", "invoke_r", "type-conversion", "return-type",]
function = "std::invoke_r"
header = "<functional>"
signature = "R invoke_r(F&& f, Args&&... args) noexcept(is_nothrow_invocable_r_v<R, F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_constraint_f_forwarding_ref_d6e2f7a0"
content = "The F&& parameter in std::invoke is a forwarding reference accepting both lvalue and rvalue callables"
formal_spec = "invoke(F&& f, ...) => accepts_lvalue(f) && accepts_rvalue(f)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/1"
tags = [ "invoke", "forwarding-reference", "perfect-forwarding",]
function = "std::invoke"
header = "<functional>"
signature = "invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) noexcept(is_nothrow_invocable_v<F, Args...>)"

[[axioms]]
id = "cpp20_func_invoke_r_constraint_f_forwarding_ref_e7f3a8b1"
content = "The F&& parameter in std::invoke_r is a forwarding reference accepting both lvalue and rvalue callables"
formal_spec = "invoke_r<R>(F&& f, ...) => accepts_lvalue(f) && accepts_rvalue(f)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/3"
tags = [ "invoke", "invoke_r", "forwarding-reference", "perfect-forwarding",]
function = "std::invoke_r"
header = "<functional>"
signature = "R invoke_r(F&& f, Args&&... args) noexcept(is_nothrow_invocable_r_v<R, F, Args...>)"

[[axioms]]
id = "cpp20_concepts_syn_same_as_symmetric_a7f3d9e1"
content = "The same_as concept requires symmetry: same_as<T,U> implies same_as<U,T>"
formal_spec = "same_as<T,U> <=> same_as<U,T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "type-traits", "symmetry",]

[[axioms]]
id = "cpp20_concepts_syn_derived_from_constraint_b8e4c2f6"
content = "The derived_from concept requires that Derived is unambiguously derived from Base"
formal_spec = "derived_from<Derived, Base> => is_base_of_v<Base, Derived> && is_convertible_v<const volatile Derived*, const volatile Base*>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "inheritance", "derivation",]

[[axioms]]
id = "cpp20_concepts_syn_convertible_to_explicit_implicit_c9d5e7a2"
content = "The convertible_to concept requires both implicit and explicit conversion from From to To"
formal_spec = "convertible_to<From, To> => is_convertible_v<From, To> && requires(From (&f)()) { static_cast<To>(f()); }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "conversion", "type-traits",]

[[axioms]]
id = "cpp20_concepts_syn_common_reference_with_symmetric_d3f8a1b7"
content = "The common_reference_with concept requires symmetry and that both types are convertible to the common reference type"
formal_spec = "common_reference_with<T,U> <=> common_reference_with<U,T> && convertible_to<T, common_reference_t<T,U>> && convertible_to<U, common_reference_t<T,U>>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "type-traits", "common-reference",]

[[axioms]]
id = "cpp20_concepts_syn_common_with_symmetric_e4a9c2d8"
content = "The common_with concept requires symmetry and that both types are convertible to the common type"
formal_spec = "common_with<T,U> <=> common_with<U,T> && convertible_to<T, common_type_t<T,U>> && convertible_to<U, common_type_t<T,U>>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "type-traits", "common-type",]

[[axioms]]
id = "cpp20_concepts_syn_integral_arithmetic_f5b1d3e9"
content = "The integral concept requires that T is an integral type excluding bool"
formal_spec = "integral<T> => is_integral_v<T> && !same_as<remove_cv_t<T>, bool>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "arithmetic", "integral",]

[[axioms]]
id = "cpp20_concepts_syn_signed_integral_constraint_a6c2e4f0"
content = "The signed_integral concept requires that T is an integral type and is signed"
formal_spec = "signed_integral<T> => integral<T> && is_signed_v<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "arithmetic", "signed", "integral",]

[[axioms]]
id = "cpp20_concepts_syn_unsigned_integral_constraint_b7d3f5a1"
content = "The unsigned_integral concept requires that T is an integral type and is unsigned"
formal_spec = "unsigned_integral<T> => integral<T> && !is_signed_v<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "arithmetic", "unsigned", "integral",]

[[axioms]]
id = "cpp20_concepts_syn_floating_point_constraint_c8e4a6b2"
content = "The floating_point concept requires that T is a floating-point type"
formal_spec = "floating_point<T> => is_floating_point_v<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "arithmetic", "floating-point",]

[[axioms]]
id = "cpp20_concepts_syn_assignable_from_constraint_d9f5b7c3"
content = "The assignable_from concept requires that LHS is assignable from RHS and returns an lvalue reference to LHS"
formal_spec = "assignable_from<LHS, RHS> => is_lvalue_reference_v<LHS> && common_reference_with<const remove_reference_t<LHS>&, const remove_reference_t<RHS>&> && requires(LHS lhs, RHS&& rhs) { { lhs = forward<RHS>(rhs) } -> same_as<LHS>; }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "assignment", "lvalue-reference",]

[[axioms]]
id = "cpp20_concepts_syn_swappable_adl_constraint_e0a6c8d4"
content = "The swappable concept requires that objects of type T can be swapped using ranges::swap"
formal_spec = "swappable<T> => requires(T& a, T& b) { ranges::swap(a, b); }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "swap", "adl",]

[[axioms]]
id = "cpp20_concepts_syn_swappable_with_symmetric_f1b7d9e5"
content = "The swappable_with concept requires symmetry and that objects of types T and U can be swapped with each other"
formal_spec = "swappable_with<T,U> <=> swappable_with<U,T> && common_reference_with<T, U> && requires(T&& t, U&& u) { ranges::swap(forward<T>(t), forward<U>(u)); ranges::swap(forward<U>(u), forward<T>(t)); }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "swap", "symmetric",]

[[axioms]]
id = "cpp20_concepts_syn_destructible_constraint_a2c8e0f6"
content = "The destructible concept requires that T is destructible and is not an array type, reference type, or function type"
formal_spec = "destructible<T> => is_nothrow_destructible_v<T> && is_object_v<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "destructor", "nothrow",]

[[axioms]]
id = "cpp20_concepts_syn_constructible_from_constraint_b3d9f1a7"
content = "The constructible_from concept requires that T can be constructed from the argument types Args..."
formal_spec = "constructible_from<T, Args...> => destructible<T> && is_constructible_v<T, Args...>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "constructor", "variadic",]

[[axioms]]
id = "cpp20_concepts_syn_default_initializable_constraint_c4e0a2b8"
content = "The default_initializable concept requires that T can be default-initialized and is destructible"
formal_spec = "default_initializable<T> => constructible_from<T> && requires { T{}; } && requires { ::new T; }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "default-initialization", "constructor",]

[[axioms]]
id = "cpp20_concepts_syn_move_constructible_constraint_d5f1b3c9"
content = "The move_constructible concept requires that T can be constructed from an rvalue of type T"
formal_spec = "move_constructible<T> => constructible_from<T, T> && convertible_to<T, T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "move-constructor", "rvalue",]

[[axioms]]
id = "cpp20_concepts_syn_copy_constructible_constraint_e6a2c4d0"
content = "The copy_constructible concept requires that T can be constructed from lvalue and const lvalue references"
formal_spec = "copy_constructible<T> => move_constructible<T> && constructible_from<T, T&> && convertible_to<T&, T> && constructible_from<T, const T&> && convertible_to<const T&, T> && constructible_from<T, const T> && convertible_to<const T, T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "copy-constructor", "lvalue",]

[[axioms]]
id = "cpp20_concepts_syn_equality_comparable_constraint_f7b3d5e1"
content = "The equality_comparable concept requires that objects of type T can be compared for equality using == and !="
formal_spec = "equality_comparable<T> => requires(const remove_reference_t<T>& a, const remove_reference_t<T>& b) { { a == b } -> convertible_to<bool>; { a != b } -> convertible_to<bool>; }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "equality", "comparison",]

[[axioms]]
id = "cpp20_concepts_syn_equality_comparable_with_symmetric_a8c4e6f2"
content = "The equality_comparable_with concept requires that objects of types T and U can be compared for equality and the concept is symmetric"
formal_spec = "equality_comparable_with<T,U> <=> equality_comparable_with<U,T> && equality_comparable<T> && equality_comparable<U> && common_reference_with<const remove_reference_t<T>&, const remove_reference_t<U>&>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "equality", "symmetric", "comparison",]

[[axioms]]
id = "cpp20_concepts_syn_totally_ordered_constraint_b9d5f7a3"
content = "The totally_ordered concept requires that objects of type T can be compared using <, >, <=, >= operators"
formal_spec = "totally_ordered<T> => equality_comparable<T> && requires(const remove_reference_t<T>& a, const remove_reference_t<T>& b) { { a < b } -> convertible_to<bool>; { a > b } -> convertible_to<bool>; { a <= b } -> convertible_to<bool>; { a >= b } -> convertible_to<bool>; }"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "ordering", "comparison",]

[[axioms]]
id = "cpp20_concepts_syn_totally_ordered_with_symmetric_c0e6a8b4"
content = "The totally_ordered_with concept requires symmetric total ordering between types T and U"
formal_spec = "totally_ordered_with<T,U> <=> totally_ordered_with<U,T> && totally_ordered<T> && totally_ordered<U> && equality_comparable_with<T,U> && common_reference_with<const remove_reference_t<T>&, const remove_reference_t<U>&>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "ordering", "symmetric", "comparison",]

[[axioms]]
id = "cpp20_concepts_syn_movable_constraint_d1f7b9c5"
content = "The movable concept requires that T is move-constructible, assignable from rvalue, and swappable"
formal_spec = "movable<T> => is_object_v<T> && move_constructible<T> && assignable_from<T&, T> && swappable<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "movable", "object",]

[[axioms]]
id = "cpp20_concepts_syn_copyable_constraint_e2a8c0d6"
content = "The copyable concept requires that T is copy-constructible, movable, and assignable from lvalue reference"
formal_spec = "copyable<T> => copy_constructible<T> && movable<T> && assignable_from<T&, T&> && assignable_from<T&, const T&> && assignable_from<T&, const T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "copyable", "object",]

[[axioms]]
id = "cpp20_concepts_syn_semiregular_constraint_f3b9d1e7"
content = "The semiregular concept requires that T is copyable and default-initializable"
formal_spec = "semiregular<T> => copyable<T> && default_initializable<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "semiregular", "object",]

[[axioms]]
id = "cpp20_concepts_syn_regular_constraint_a4c0e2f8"
content = "The regular concept requires that T is semiregular and equality-comparable"
formal_spec = "regular<T> => semiregular<T> && equality_comparable<T>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "regular", "object",]

[[axioms]]
id = "cpp20_concepts_syn_invocable_constraint_b5d1f3a9"
content = "The invocable concept requires that F can be invoked with arguments Args... using std::invoke"
formal_spec = "invocable<F, Args...> => requires(F&& f, Args&&... args) { invoke(forward<F>(f), forward<Args>(args)...); }"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "invocable", "callable", "invoke",]

[[axioms]]
id = "cpp20_concepts_syn_regular_invocable_constraint_c6e2a4b0"
content = "The regular_invocable concept requires that F is invocable with Args... and does not modify arguments or have observable side effects"
formal_spec = "regular_invocable<F, Args...> => invocable<F, Args...>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "invocable", "regular", "pure",]

[[axioms]]
id = "cpp20_concepts_syn_predicate_constraint_d7f3b5c1"
content = "The predicate concept requires that F is a regular invocable that returns a boolean"
formal_spec = "predicate<F, Args...> => regular_invocable<F, Args...> && requires(F&& f, Args&&... args) { { invoke(forward<F>(f), forward<Args>(args)...) } -> convertible_to<bool>; }"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "predicate", "boolean", "callable",]

[[axioms]]
id = "cpp20_concepts_syn_relation_constraint_e8a4c6d2"
content = "The relation concept requires that R is a binary predicate on types T and U"
formal_spec = "relation<R, T, U> => predicate<R, T, T> && predicate<R, U, U> && predicate<R, T, U> && predicate<R, U, T>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "relation", "predicate", "binary",]

[[axioms]]
id = "cpp20_concepts_syn_equivalence_relation_constraint_f9b5d7e3"
content = "The equivalence_relation concept requires that R is a relation that is reflexive, symmetric, and transitive"
formal_spec = "equivalence_relation<R, T, U> => relation<R, T, U>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "equivalence", "relation", "reflexive", "symmetric", "transitive",]

[[axioms]]
id = "cpp20_concepts_syn_strict_weak_order_constraint_a0c6e8f4"
content = "The strict_weak_order concept requires that R is a relation that defines a strict weak ordering"
formal_spec = "strict_weak_order<R, T, U> => relation<R, T, U>"
layer = "cpp20_language"
confidence = 0.85
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "strict-weak-order", "relation", "ordering",]

[[axioms]]
id = "cpp20_concepts_syn_ranges_swap_customization_b1d7f9a5"
content = "The ranges::swap customization point object is declared in an inline unspecified namespace to enable ADL"
formal_spec = "namespace ranges { inline namespace unspecified { inline constexpr unspecified swap = unspecified; } }"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "ranges", "swap", "adl", "customization-point",]

[[axioms]]
id = "cpp20_concepts_syn_concept_requires_boolean_c2e8a0b6"
content = "All concepts in the concepts library require constraint expressions that are valid boolean expressions"
formal_spec = "forall concept C: requires_clause(C) => convertible_to<decltype(constraint_expr), bool>"
layer = "cpp20_language"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "concepts", "constraints", "boolean",]

[[axioms]]
id = "cpp20_concepts_syn_freestanding_all_concepts_d3f9b1c7"
content = "All entities declared in the <concepts> header are freestanding and available in freestanding implementations"
formal_spec = "freestanding(<concepts>) => all_entities_available"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "concepts.syn"
source_module = "[concepts.syn]/18.3"
tags = [ "freestanding", "concepts", "header",]

[[axioms]]
id = "cpp20_meta_unary_prop_implicit_instantiation_precond_7f8a9b0c"
content = "Instantiating any class template X declared in meta.unary.prop with a template-argument that is a class template specialization requires that the argument is a complete type if and only if the semantics of X require that the argument is a complete type."
formal_spec = "instantiate(X<TemplateSpec>) && requires_complete_type(semantics(X)) => complete_type(TemplateSpec)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/3"
tags = [ "metaprogramming", "type_traits", "template_instantiation", "completeness",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_is_trivially_copyable_precond_complete_d4e5f6a7"
content = "For is_trivially_copyable<T>, remove_all_extents_t<T> shall be a complete type or cv void."
formal_spec = "use(is_trivially_copyable<T>) => complete_type(remove_all_extents_t<T>) || is_cv_void(remove_all_extents_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_trivially_copyable"
header = "<type_traits>"
signature = "struct is_trivially_copyable<T>"

[[axioms]]
id = "cpp20_is_standard_layout_precond_complete_b8c9d0e1"
content = "For is_standard_layout<T>, remove_all_extents_t<T> shall be a complete type or cv void."
formal_spec = "use(is_standard_layout<T>) => complete_type(remove_all_extents_t<T>) || is_cv_void(remove_all_extents_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_standard_layout"
header = "<type_traits>"
signature = "struct is_standard_layout<T>"

[[axioms]]
id = "cpp20_is_empty_precond_complete_f2a3b4c5"
content = "For is_empty<T>, if T is a non-union class type, T shall be a complete type."
formal_spec = "use(is_empty<T>) && non_union_class_type(T) => complete_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_empty"
header = "<type_traits>"
signature = "struct is_empty<T>"

[[axioms]]
id = "cpp20_is_polymorphic_precond_complete_a5b6c7d8"
content = "For is_polymorphic<T>, if T is a non-union class type, T shall be a complete type."
formal_spec = "use(is_polymorphic<T>) && non_union_class_type(T) => complete_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_polymorphic"
header = "<type_traits>"
signature = "struct is_polymorphic<T>"

[[axioms]]
id = "cpp20_is_abstract_precond_complete_e9f0a1b2"
content = "For is_abstract<T>, if T is a non-union class type, T shall be a complete type."
formal_spec = "use(is_abstract<T>) && non_union_class_type(T) => complete_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_abstract"
header = "<type_traits>"
signature = "struct is_abstract<T>"

[[axioms]]
id = "cpp20_is_final_precond_complete_c3d4e5f6"
content = "For is_final<T>, if T is a class type, T shall be a complete type."
formal_spec = "use(is_final<T>) && class_type(T) => complete_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_final"
header = "<type_traits>"
signature = "struct is_final<T>"

[[axioms]]
id = "cpp20_is_aggregate_precond_complete_a7b8c9d0"
content = "For is_aggregate<T>, T shall be an array type, a complete type, or cv void."
formal_spec = "use(is_aggregate<T>) => array_type(T) || complete_type(T) || is_cv_void(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_aggregate"
header = "<type_traits>"
signature = "struct is_aggregate<T>"

[[axioms]]
id = "cpp20_is_consteval_only_precond_complete_b1c2d3e4"
content = "For is_consteval_only<T>, remove_all_extents_t<T> shall be a complete type or cv void."
formal_spec = "use(is_consteval_only<T>) => complete_type(remove_all_extents_t<T>) || is_cv_void(remove_all_extents_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "is_consteval_only"
header = "<type_traits>"
signature = "struct is_consteval_only<T>"

[[axioms]]
id = "cpp20_is_constructible_precond_complete_f5a6b7c8"
content = "For is_constructible<T, Args...>, T and all types in the template parameter pack Args shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_constructible<T, Args...>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && forall(U in Args: complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction",]
function = "is_constructible"
header = "<type_traits>"
signature = "struct is_constructible<T, Args...>"

[[axioms]]
id = "cpp20_is_constructible_function_void_false_d9e0f1a2"
content = "For is_constructible<T, Args...>, if T is a function type or cv void type, is_constructible_v<T, Args...> is false."
formal_spec = "(function_type(T) || is_cv_void(T)) => is_constructible_v<T, Args...> == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "constraint", "construction",]
function = "is_constructible"
header = "<type_traits>"
signature = "struct is_constructible<T, Args...>"

[[axioms]]
id = "cpp20_is_default_constructible_precond_complete_c7d8e9f0"
content = "For is_default_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_default_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction",]
function = "is_default_constructible"
header = "<type_traits>"
signature = "struct is_default_constructible<T>"

[[axioms]]
id = "cpp20_is_copy_constructible_precond_complete_a1b2c3d4"
content = "For is_copy_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_copy_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction",]
function = "is_copy_constructible"
header = "<type_traits>"
signature = "struct is_copy_constructible<T>"

[[axioms]]
id = "cpp20_is_move_constructible_precond_complete_e5f6a7b8"
content = "For is_move_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_move_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction",]
function = "is_move_constructible"
header = "<type_traits>"
signature = "struct is_move_constructible<T>"

[[axioms]]
id = "cpp20_is_assignable_precond_complete_b9c0d1e2"
content = "For is_assignable<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_assignable<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment",]
function = "is_assignable"
header = "<type_traits>"
signature = "struct is_assignable<T, U>"

[[axioms]]
id = "cpp20_is_assignable_immediate_context_f3a4b5c6"
content = "For is_assignable<T, U>, only the validity of the immediate context of the assignment expression declval<T>()=declval<U>() is considered. Side effects like template instantiation can make the program ill-formed."
formal_spec = "is_assignable<T, U> considers only immediate_context(declval<T>()=declval<U>()) && side_effects_outside_immediate_context() => may_be_ill_formed"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "immediate_context", "assignment",]
function = "is_assignable"
header = "<type_traits>"
signature = "struct is_assignable<T, U>"

[[axioms]]
id = "cpp20_is_copy_assignable_precond_complete_d7e8f9a0"
content = "For is_copy_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_copy_assignable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment",]
function = "is_copy_assignable"
header = "<type_traits>"
signature = "struct is_copy_assignable<T>"

[[axioms]]
id = "cpp20_is_move_assignable_precond_complete_a1b2c3d4"
content = "For is_move_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_move_assignable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment",]
function = "is_move_assignable"
header = "<type_traits>"
signature = "struct is_move_assignable<T>"

[[axioms]]
id = "cpp20_is_swappable_with_precond_complete_e5f6a7b8"
content = "For is_swappable_with<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_swappable_with<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "swap",]
function = "is_swappable_with"
header = "<type_traits>"
signature = "struct is_swappable_with<T, U>"

[[axioms]]
id = "cpp20_is_swappable_with_immediate_context_c9d0e1f2"
content = "For is_swappable_with<T, U>, only the validity of the immediate context of the swap expressions is considered. Side effects like template instantiation can make the program ill-formed."
formal_spec = "is_swappable_with<T, U> considers only immediate_context(swap(declval<T>(), declval<U>())) && side_effects_outside_immediate_context() => may_be_ill_formed"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "immediate_context", "swap",]
function = "is_swappable_with"
header = "<type_traits>"
signature = "struct is_swappable_with<T, U>"

[[axioms]]
id = "cpp20_is_swappable_precond_complete_a3b4c5d6"
content = "For is_swappable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_swappable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "swap",]
function = "is_swappable"
header = "<type_traits>"
signature = "struct is_swappable<T>"

[[axioms]]
id = "cpp20_is_destructible_precond_complete_f7a8b9c0"
content = "For is_destructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_destructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "destructor",]
function = "is_destructible"
header = "<type_traits>"
signature = "struct is_destructible<T>"

[[axioms]]
id = "cpp20_is_trivially_constructible_precond_complete_d1e2f3a4"
content = "For is_trivially_constructible<T, Args...>, T and all types in the template parameter pack Args shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_trivially_constructible<T, Args...>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && forall(U in Args: complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "trivial",]
function = "is_trivially_constructible"
header = "<type_traits>"
signature = "struct is_trivially_constructible<T, Args...>"

[[axioms]]
id = "cpp20_is_trivially_default_constructible_precond_b5c6d7e8"
content = "For is_trivially_default_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_trivially_default_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "trivial",]
function = "is_trivially_default_constructible"
header = "<type_traits>"
signature = "struct is_trivially_default_constructible<T>"

[[axioms]]
id = "cpp20_is_trivially_copy_constructible_precond_f9a0b1c2"
content = "For is_trivially_copy_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_trivially_copy_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "trivial",]
function = "is_trivially_copy_constructible"
header = "<type_traits>"
signature = "struct is_trivially_copy_constructible<T>"

[[axioms]]
id = "cpp20_is_trivially_move_constructible_precond_c3d4e5f6"
content = "For is_trivially_move_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_trivially_move_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "trivial",]
function = "is_trivially_move_constructible"
header = "<type_traits>"
signature = "struct is_trivially_move_constructible<T>"

[[axioms]]
id = "cpp20_is_trivially_assignable_precond_complete_a7b8c9d0"
content = "For is_trivially_assignable<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_trivially_assignable<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment", "trivial",]
function = "is_trivially_assignable"
header = "<type_traits>"
signature = "struct is_trivially_assignable<T, U>"

[[axioms]]
id = "cpp20_is_trivially_copy_assignable_precond_e1f2a3b4"
content = "For is_trivially_copy_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_trivially_copy_assignable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment", "trivial",]
function = "is_trivially_copy_assignable"
header = "<type_traits>"
signature = "struct is_trivially_copy_assignable<T>"

[[axioms]]
id = "cpp20_is_trivially_move_assignable_precond_c5d6e7f8"
content = "For is_trivially_move_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_trivially_move_assignable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment", "trivial",]
function = "is_trivially_move_assignable"
header = "<type_traits>"
signature = "struct is_trivially_move_assignable<T>"

[[axioms]]
id = "cpp20_is_trivially_destructible_precond_complete_a9b0c1d2"
content = "For is_trivially_destructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_trivially_destructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "destructor", "trivial",]
function = "is_trivially_destructible"
header = "<type_traits>"
signature = "struct is_trivially_destructible<T>"

[[axioms]]
id = "cpp20_is_nothrow_constructible_precond_complete_f3a4b5c6"
content = "For is_nothrow_constructible<T, Args...>, T and all types in the template parameter pack Args shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_nothrow_constructible<T, Args...>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && forall(U in Args: complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "noexcept",]
function = "is_nothrow_constructible"
header = "<type_traits>"
signature = "struct is_nothrow_constructible<T, Args...>"

[[axioms]]
id = "cpp20_is_nothrow_default_constructible_precond_d7e8f9a0"
content = "For is_nothrow_default_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_default_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "noexcept",]
function = "is_nothrow_default_constructible"
header = "<type_traits>"
signature = "struct is_nothrow_default_constructible<T>"

[[axioms]]
id = "cpp20_is_nothrow_copy_constructible_precond_b1c2d3e4"
content = "For is_nothrow_copy_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_copy_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "noexcept",]
function = "is_nothrow_copy_constructible"
header = "<type_traits>"
signature = "struct is_nothrow_copy_constructible<T>"

[[axioms]]
id = "cpp20_is_nothrow_move_constructible_precond_e5f6a7b8"
content = "For is_nothrow_move_constructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_move_constructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "construction", "noexcept",]
function = "is_nothrow_move_constructible"
header = "<type_traits>"
signature = "struct is_nothrow_move_constructible<T>"

[[axioms]]
id = "cpp20_is_nothrow_assignable_precond_complete_c9d0e1f2"
content = "For is_nothrow_assignable<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_nothrow_assignable<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment", "noexcept",]
function = "is_nothrow_assignable"
header = "<type_traits>"
signature = "struct is_nothrow_assignable<T, U>"

[[axioms]]
id = "cpp20_is_nothrow_copy_assignable_precond_a3b4c5d6"
content = "For is_nothrow_copy_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_copy_assignable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment", "noexcept",]
function = "is_nothrow_copy_assignable"
header = "<type_traits>"
signature = "struct is_nothrow_copy_assignable<T>"

[[axioms]]
id = "cpp20_is_nothrow_move_assignable_precond_f7a8b9c0"
content = "For is_nothrow_move_assignable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_move_assignable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "assignment", "noexcept",]
function = "is_nothrow_move_assignable"
header = "<type_traits>"
signature = "struct is_nothrow_move_assignable<T>"

[[axioms]]
id = "cpp20_is_nothrow_swappable_with_precond_complete_d1e2f3a4"
content = "For is_nothrow_swappable_with<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(is_nothrow_swappable_with<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "swap", "noexcept",]
function = "is_nothrow_swappable_with"
header = "<type_traits>"
signature = "struct is_nothrow_swappable_with<T, U>"

[[axioms]]
id = "cpp20_is_nothrow_swappable_precond_complete_b5c6d7e8"
content = "For is_nothrow_swappable<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_swappable<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "swap", "noexcept",]
function = "is_nothrow_swappable"
header = "<type_traits>"
signature = "struct is_nothrow_swappable<T>"

[[axioms]]
id = "cpp20_is_nothrow_destructible_precond_complete_f9a0b1c2"
content = "For is_nothrow_destructible<T>, T shall be a complete type, cv void, or an array of unknown bound."
formal_spec = "use(is_nothrow_destructible<T>) => complete_type(T) || is_cv_void(T) || array_unknown_bound(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "destructor", "noexcept",]
function = "is_nothrow_destructible"
header = "<type_traits>"
signature = "struct is_nothrow_destructible<T>"

[[axioms]]
id = "cpp20_is_implicit_lifetime_precond_complete_c3d4e5f6"
content = "For is_implicit_lifetime<T>, T shall be an array type, a complete type, or cv void."
formal_spec = "use(is_implicit_lifetime<T>) => array_type(T) || complete_type(T) || is_cv_void(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "lifetime",]
function = "is_implicit_lifetime"
header = "<type_traits>"
signature = "struct is_implicit_lifetime<T>"

[[axioms]]
id = "cpp20_has_virtual_destructor_precond_complete_a7b8c9d0"
content = "For has_virtual_destructor<T>, if T is a non-union class type, T shall be a complete type."
formal_spec = "use(has_virtual_destructor<T>) && non_union_class_type(T) => complete_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "destructor", "virtual",]
function = "has_virtual_destructor"
header = "<type_traits>"
signature = "struct has_virtual_destructor<T>"

[[axioms]]
id = "cpp20_has_unique_object_representations_precond_e1f2a3b4"
content = "For has_unique_object_representations<T>, remove_all_extents_t<T> shall be a complete type or cv void."
formal_spec = "use(has_unique_object_representations<T>) => complete_type(remove_all_extents_t<T>) || is_cv_void(remove_all_extents_t<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness",]
function = "has_unique_object_representations"
header = "<type_traits>"
signature = "struct has_unique_object_representations<T>"

[[axioms]]
id = "cpp20_reference_constructs_from_temporary_precond_c5d6e7f8"
content = "For reference_constructs_from_temporary<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(reference_constructs_from_temporary<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "reference", "temporary",]
function = "reference_constructs_from_temporary"
header = "<type_traits>"
signature = "struct reference_constructs_from_temporary<T, U>"

[[axioms]]
id = "cpp20_reference_constructs_from_temporary_immediate_a9b0c1d2"
content = "For reference_constructs_from_temporary<T, U>, only the validity of the immediate context of the variable initialization T t(VAL<U>) is considered. Side effects can make the program ill-formed."
formal_spec = "reference_constructs_from_temporary<T, U> considers only immediate_context(T t(VAL<U>)) && side_effects_outside_immediate_context() => may_be_ill_formed"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "immediate_context", "reference", "temporary",]
function = "reference_constructs_from_temporary"
header = "<type_traits>"
signature = "struct reference_constructs_from_temporary<T, U>"

[[axioms]]
id = "cpp20_reference_converts_from_temporary_precond_f3a4b5c6"
content = "For reference_converts_from_temporary<T, U>, T and U shall be complete types, cv void, or arrays of unknown bound."
formal_spec = "use(reference_converts_from_temporary<T, U>) => (complete_type(T) || is_cv_void(T) || array_unknown_bound(T)) && (complete_type(U) || is_cv_void(U) || array_unknown_bound(U))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "precondition", "completeness", "reference", "temporary",]
function = "reference_converts_from_temporary"
header = "<type_traits>"
signature = "struct reference_converts_from_temporary<T, U>"

[[axioms]]
id = "cpp20_reference_converts_from_temporary_immediate_d7e8f9a0"
content = "For reference_converts_from_temporary<T, U>, only the validity of the immediate context of the variable initialization T t=VAL<U> is considered. Side effects can make the program ill-formed."
formal_spec = "reference_converts_from_temporary<T, U> considers only immediate_context(T t=VAL<U>) && side_effects_outside_immediate_context() => may_be_ill_formed"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop] Table 54"
tags = [ "metaprogramming", "type_traits", "immediate_context", "reference", "temporary",]
function = "reference_converts_from_temporary"
header = "<type_traits>"
signature = "struct reference_converts_from_temporary<T, U>"

[[axioms]]
id = "cpp20_is_constructible_definition_well_formed_b1c2d3e4"
content = "The predicate condition for is_constructible<T, Args...> is satisfied if and only if the variable definition T t(declval<Args>()...) would be well-formed, considering only the immediate context."
formal_spec = "is_constructible_v<T, Args...> == true <=> well_formed_in_immediate_context(T t(declval<Args>()...))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/9"
tags = [ "metaprogramming", "type_traits", "construction", "immediate_context",]
function = "is_constructible"
header = "<type_traits>"
signature = "struct is_constructible<T, Args...>"

[[axioms]]
id = "cpp20_is_constructible_not_function_declaration_e5f6a7b8"
content = "In the definition of is_constructible, the tokens T t(declval<Args>()...) are never interpreted as a function declaration."
formal_spec = "in_context(is_constructible<T, Args...>): T t(declval<Args>()...) != function_declaration"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/9"
tags = [ "metaprogramming", "type_traits", "construction", "parsing",]
function = "is_constructible"
header = "<type_traits>"
signature = "struct is_constructible<T, Args...>"

[[axioms]]
id = "cpp20_has_unique_object_representations_trivially_copyable_c9d0e1f2"
content = "The predicate has_unique_object_representations<T> is satisfied only if T is trivially copyable."
formal_spec = "has_unique_object_representations_v<T> == true => trivially_copyable(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/10"
tags = [ "metaprogramming", "type_traits", "trivial", "object_representation",]
function = "has_unique_object_representations"
header = "<type_traits>"
signature = "struct has_unique_object_representations<T>"

[[axioms]]
id = "cpp20_has_unique_object_representations_same_value_a3b4c5d6"
content = "The predicate has_unique_object_representations<T> is satisfied only if any two objects of type T with the same value have the same object representation."
formal_spec = "has_unique_object_representations_v<T> == true => forall(obj1, obj2 of type T: same_value(obj1, obj2) => same_object_representation(obj1, obj2))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/10"
tags = [ "metaprogramming", "type_traits", "object_representation", "equality",]
function = "has_unique_object_representations"
header = "<type_traits>"
signature = "struct has_unique_object_representations<T>"

[[axioms]]
id = "cpp20_has_unique_object_representations_impl_defined_f7a8b9c0"
content = "The set of scalar types for which has_unique_object_representations holds is implementation-defined."
formal_spec = "scalar_type(T) => has_unique_object_representations_v<T> == implementation_defined"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/10"
tags = [ "metaprogramming", "type_traits", "implementation_defined", "scalar",]
function = "has_unique_object_representations"
header = "<type_traits>"
signature = "struct has_unique_object_representations<T>"

[[axioms]]
id = "cpp20_has_unique_object_representations_padding_false_d1e2f3a4"
content = "If a type has padding bits, has_unique_object_representations does not hold for that type."
formal_spec = "has_padding_bits(T) => has_unique_object_representations_v<T> == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.prop"
source_module = "[meta.unary.prop]/10"
tags = [ "metaprogramming", "type_traits", "padding", "object_representation",]
function = "has_unique_object_representations"
header = "<type_traits>"
signature = "struct has_unique_object_representations<T>"

[[axioms]]
id = "cpp20_meta_unary_cat_cv_qualification_invariance_7a3f9e2d"
content = "For any given type T, applying a primary type category template to T and to cv T shall yield the same result."
formal_spec = "forall T, forall primary_type_category C: C<T>::value == C<cv T>::value where cv in {const, volatile, const volatile}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat]/2"
tags = [ "type_traits", "cv_qualification", "invariant",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_mutual_exclusion_8b4c1f5e"
content = "For any given type T, exactly one of the primary type categories has a value member that evaluates to true."
formal_spec = "forall T: exists_unique C in primary_type_categories: C<T>::value == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat]/3"
tags = [ "type_traits", "mutual_exclusion", "invariant",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_void_condition_9c5d2a6f"
content = "std::is_void<T>::value is true if and only if T is void."
formal_spec = "is_void<T>::value == true <==> T == void"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "void", "primary_category",]
function = "std::is_void"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_null_pointer_condition_0d6e3b7a"
content = "std::is_null_pointer<T>::value is true if and only if T is nullptr_t."
formal_spec = "is_null_pointer<T>::value == true <==> T == nullptr_t"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "nullptr", "primary_category",]
function = "std::is_null_pointer"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_integral_condition_1e7f4c8b"
content = "std::is_integral<T>::value is true if and only if T is an integral type."
formal_spec = "is_integral<T>::value == true <==> is_integral_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "integral", "primary_category",]
c_standard_refs = [ "6.2.5",]
function = "std::is_integral"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_floating_point_condition_2f8a5d9c"
content = "std::is_floating_point<T>::value is true if and only if T is a floating-point type."
formal_spec = "is_floating_point<T>::value == true <==> is_floating_point_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "floating_point", "primary_category",]
c_standard_refs = [ "6.2.5",]
function = "std::is_floating_point"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_array_condition_3a9b6e0d"
content = "std::is_array<T>::value is true if and only if T is an array type of known or unknown extent."
formal_spec = "is_array<T>::value == true <==> (is_array_known_bound(T) || is_array_unknown_bound(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "array", "primary_category",]
function = "std::is_array"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_array_excludes_std_array_4b0c7f1e"
content = "Class template std::array is not considered an array type for std::is_array."
formal_spec = "forall T, N: is_array<std::array<T, N>>::value == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "array", "std_array", "exclusion",]
function = "std::is_array"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_pointer_condition_5c1d8a2f"
content = "std::is_pointer<T>::value is true if and only if T is a pointer type."
formal_spec = "is_pointer<T>::value == true <==> is_pointer_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "pointer", "primary_category",]
function = "std::is_pointer"
header = "<type_traits>"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_meta_unary_cat_is_pointer_includes_function_ptr_6d2e9b3a"
content = "std::is_pointer includes pointers to functions but not pointers to non-static members."
formal_spec = "is_pointer<T>::value == true ==> (is_object_pointer(T) || is_function_pointer(T)) && !is_member_pointer(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "pointer", "function_pointer", "member_pointer",]
function = "std::is_pointer"
header = "<type_traits>"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_meta_unary_cat_is_lvalue_reference_condition_7e3f0c4b"
content = "std::is_lvalue_reference<T>::value is true if and only if T is an lvalue reference type."
formal_spec = "is_lvalue_reference<T>::value == true <==> is_lvalue_reference_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "lvalue_reference", "primary_category",]
function = "std::is_lvalue_reference"
header = "<type_traits>"
depends_on = [ "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6",]

[[axioms]]
id = "cpp20_meta_unary_cat_is_rvalue_reference_condition_8f4a1d5c"
content = "std::is_rvalue_reference<T>::value is true if and only if T is an rvalue reference type."
formal_spec = "is_rvalue_reference<T>::value == true <==> is_rvalue_reference_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "rvalue_reference", "primary_category",]
function = "std::is_rvalue_reference"
header = "<type_traits>"
depends_on = [ "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_meta_unary_cat_is_member_object_pointer_condition_9a5b2e6d"
content = "std::is_member_object_pointer<T>::value is true if and only if T is a pointer to data member."
formal_spec = "is_member_object_pointer<T>::value == true <==> is_member_data_pointer(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "member_pointer", "data_member", "primary_category",]
function = "std::is_member_object_pointer"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_member_function_pointer_condition_0b6c3f7e"
content = "std::is_member_function_pointer<T>::value is true if and only if T is a pointer to member function."
formal_spec = "is_member_function_pointer<T>::value == true <==> is_member_function_pointer_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "member_pointer", "member_function", "primary_category",]
function = "std::is_member_function_pointer"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_enum_condition_1c7d4a8f"
content = "std::is_enum<T>::value is true if and only if T is an enumeration type."
formal_spec = "is_enum<T>::value == true <==> is_enumeration_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "enum", "primary_category",]
function = "std::is_enum"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_union_condition_2d8e5b9a"
content = "std::is_union<T>::value is true if and only if T is a union type."
formal_spec = "is_union<T>::value == true <==> is_union_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "union", "primary_category",]
function = "std::is_union"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_class_condition_3e9f6c0b"
content = "std::is_class<T>::value is true if and only if T is a non-union class type."
formal_spec = "is_class<T>::value == true <==> (is_class_type(T) && !is_union_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "class", "primary_category",]
function = "std::is_class"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_function_condition_4f0a7d1c"
content = "std::is_function<T>::value is true if and only if T is a function type."
formal_spec = "is_function<T>::value == true <==> is_function_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "function", "primary_category",]
function = "std::is_function"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_unary_cat_is_reflection_condition_5a1b8e2d"
content = "std::is_reflection<T>::value is true if and only if T is std::meta::info."
formal_spec = "is_reflection<T>::value == true <==> T == std::meta::info"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.unary.cat"
source_module = "[meta.unary.cat] Table 52"
tags = [ "type_traits", "reflection", "primary_category",]
function = "std::is_reflection"
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_const_top_level_only_7a3f2b1e"
content = "remove_const only removes top-level const-qualifier from T, not const qualifiers from pointer or reference targets."
formal_spec = "remove_const_t<const T> == T && remove_const_t<const T*> == const T* && remove_const_t<T* const> == T*"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Table57"
tags = [ "type-traits", "cv-qualifiers", "const", "metaprogramming",]
function = "std::remove_const"
header = "<type_traits>"
signature = "typename std::remove_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_const_example_volatile_preserved_4d8e9c2a"
content = "remove_const_t<const volatile int> preserves volatile qualifier and evaluates to volatile int."
formal_spec = "is_same_v<remove_const_t<const volatile int>, volatile int> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Example1"
tags = [ "type-traits", "cv-qualifiers", "const", "volatile", "metaprogramming",]
function = "std::remove_const"
header = "<type_traits>"
signature = "typename std::remove_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_const_pointer_target_unchanged_6f1a4b7c"
content = "remove_const_t<const int*> does not remove const from pointed-to type, evaluates to const int*."
formal_spec = "is_same_v<remove_const_t<const int*>, const int*> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Example1"
tags = [ "type-traits", "cv-qualifiers", "const", "pointer", "metaprogramming",]
function = "std::remove_const"
header = "<type_traits>"
signature = "typename std::remove_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_volatile_top_level_only_9b2c5d8e"
content = "remove_volatile only removes top-level volatile-qualifier from T, not volatile qualifiers from pointer or reference targets."
formal_spec = "remove_volatile_t<volatile T> == T && remove_volatile_t<volatile T*> == volatile T* && remove_volatile_t<T* volatile> == T*"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Table57"
tags = [ "type-traits", "cv-qualifiers", "volatile", "metaprogramming",]
function = "std::remove_volatile"
header = "<type_traits>"
signature = "typename std::remove_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_volatile_example_const_preserved_3e7f1a9d"
content = "remove_volatile_t<const volatile int> preserves const qualifier and evaluates to const int."
formal_spec = "is_same_v<remove_volatile_t<const volatile int>, const int> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Example2"
tags = [ "type-traits", "cv-qualifiers", "volatile", "const", "metaprogramming",]
function = "std::remove_volatile"
header = "<type_traits>"
signature = "typename std::remove_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_volatile_pointer_target_unchanged_8c4d2e6f"
content = "remove_volatile_t<volatile int*> does not remove volatile from pointed-to type, evaluates to volatile int*."
formal_spec = "is_same_v<remove_volatile_t<volatile int*>, volatile int*> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Example2"
tags = [ "type-traits", "cv-qualifiers", "volatile", "pointer", "metaprogramming",]
function = "std::remove_volatile"
header = "<type_traits>"
signature = "typename std::remove_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_cv_removes_both_qualifiers_5a9b3c7d"
content = "remove_cv removes both top-level const and volatile qualifiers from T."
formal_spec = "remove_cv_t<const volatile T> == T && is_same_v<remove_cv_t<T>, remove_const_t<remove_volatile_t<T>>> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Table57"
tags = [ "type-traits", "cv-qualifiers", "const", "volatile", "metaprogramming",]
function = "std::remove_cv"
header = "<type_traits>"
signature = "typename std::remove_cv<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_cv_example_int_unqualified_2f8a4b6c"
content = "remove_cv_t<const volatile int> removes both qualifiers and evaluates to int."
formal_spec = "is_same_v<remove_cv_t<const volatile int>, int> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Example3"
tags = [ "type-traits", "cv-qualifiers", "const", "volatile", "metaprogramming",]
function = "std::remove_cv"
header = "<type_traits>"
signature = "typename std::remove_cv<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_remove_cv_pointer_target_unchanged_7d3e9f1a"
content = "remove_cv_t<const volatile int*> does not remove qualifiers from pointed-to type, evaluates to const volatile int*."
formal_spec = "is_same_v<remove_cv_t<const volatile int*>, const volatile int*> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Example3"
tags = [ "type-traits", "cv-qualifiers", "const", "volatile", "pointer", "metaprogramming",]
function = "std::remove_cv"
header = "<type_traits>"
signature = "typename std::remove_cv<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_const_denotes_const_t_4b7c2e8f"
content = "add_const<T>::type denotes const T."
formal_spec = "is_same_v<typename add_const<T>::type, const T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Table57"
tags = [ "type-traits", "cv-qualifiers", "const", "metaprogramming",]
function = "std::add_const"
header = "<type_traits>"
signature = "typename std::add_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_const_no_effect_reference_9e1f5a3b"
content = "add_const has no effect when T is a reference type."
formal_spec = "is_reference_v<T> == true => is_same_v<add_const_t<T>, T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Note1"
tags = [ "type-traits", "cv-qualifiers", "const", "reference", "metaprogramming",]
function = "std::add_const"
header = "<type_traits>"
signature = "typename std::add_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_const_no_effect_function_6c8d2a4e"
content = "add_const has no effect when T is a function type."
formal_spec = "is_function_v<T> == true => is_same_v<add_const_t<T>, T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Note1"
tags = [ "type-traits", "cv-qualifiers", "const", "function", "metaprogramming",]
function = "std::add_const"
header = "<type_traits>"
signature = "typename std::add_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_const_no_effect_already_const_3f9a7b2c"
content = "add_const has no effect when T is already a top-level const-qualified type."
formal_spec = "is_const_v<T> == true => is_same_v<add_const_t<T>, T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Note1"
tags = [ "type-traits", "cv-qualifiers", "const", "metaprogramming",]
function = "std::add_const"
header = "<type_traits>"
signature = "typename std::add_const<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_volatile_denotes_volatile_t_8a4b6c1d"
content = "add_volatile<T>::type denotes volatile T."
formal_spec = "is_same_v<typename add_volatile<T>::type, volatile T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Table57"
tags = [ "type-traits", "cv-qualifiers", "volatile", "metaprogramming",]
function = "std::add_volatile"
header = "<type_traits>"
signature = "typename std::add_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_volatile_no_effect_reference_2e7f9a3b"
content = "add_volatile has no effect when T is a reference type."
formal_spec = "is_reference_v<T> == true => is_same_v<add_volatile_t<T>, T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Note2"
tags = [ "type-traits", "cv-qualifiers", "volatile", "reference", "metaprogramming",]
function = "std::add_volatile"
header = "<type_traits>"
signature = "typename std::add_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_volatile_no_effect_function_5c1d8a6e"
content = "add_volatile has no effect when T is a function type."
formal_spec = "is_function_v<T> == true => is_same_v<add_volatile_t<T>, T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Note2"
tags = [ "type-traits", "cv-qualifiers", "volatile", "function", "metaprogramming",]
function = "std::add_volatile"
header = "<type_traits>"
signature = "typename std::add_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_volatile_no_effect_already_volatile_9b3c7e2f"
content = "add_volatile has no effect when T is already a top-level volatile-qualified type."
formal_spec = "is_volatile_v<T> == true => is_same_v<add_volatile_t<T>, T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Note2"
tags = [ "type-traits", "cv-qualifiers", "volatile", "metaprogramming",]
function = "std::add_volatile"
header = "<type_traits>"
signature = "typename std::add_volatile<T>::type"

[[axioms]]
id = "cpp20_meta_trans_cv_add_cv_composition_6d2e8f4a"
content = "add_cv<T>::type is equivalent to add_const_t<add_volatile_t<T>>."
formal_spec = "is_same_v<typename add_cv<T>::type, add_const_t<add_volatile_t<T>>> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.cv"
source_module = "[meta.trans.cv]/Table57"
tags = [ "type-traits", "cv-qualifiers", "const", "volatile", "metaprogramming",]
function = "std::add_cv"
header = "<type_traits>"
signature = "typename std::add_cv<T>::type"

[[axioms]]
id = "cpp20_meta_trans_ref_remove_reference_ref_type_f4a8b2c1"
content = "If T has type \"reference to T1\", then remove_reference<T>::type denotes T1."
formal_spec = "is_reference<T> && underlying_type(T) == T1 => remove_reference<T>::type == T1"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58"
tags = [ "type_traits", "reference", "metaprogramming",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_trans_ref_remove_reference_nonref_type_d7e3a9b5"
content = "If T is not a reference type, then remove_reference<T>::type denotes T."
formal_spec = "!is_reference<T> => remove_reference<T>::type == T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58"
tags = [ "type_traits", "reference", "metaprogramming",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_trans_ref_add_lvalue_reference_referenceable_c2d8f4a1"
content = "If T is a referenceable type, then add_lvalue_reference<T>::type denotes T&."
formal_spec = "is_referenceable(T) => add_lvalue_reference<T>::type == T&"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58"
tags = [ "type_traits", "reference", "metaprogramming", "lvalue_reference",]
header = "<type_traits>"
depends_on = [ "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6", "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4",]

[[axioms]]
id = "cpp20_meta_trans_ref_add_lvalue_reference_nonreferenceable_a9b3e7f2"
content = "If T is not a referenceable type, then add_lvalue_reference<T>::type denotes T."
formal_spec = "!is_referenceable(T) => add_lvalue_reference<T>::type == T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58"
tags = [ "type_traits", "reference", "metaprogramming", "lvalue_reference",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_trans_ref_add_lvalue_reference_collapse_semantics_e5f1a8c4"
content = "add_lvalue_reference reflects reference collapsing semantics as specified in [dcl.ref]."
formal_spec = "add_lvalue_reference<T>::type follows reference_collapsing_rules([dcl.ref])"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58/Note1"
tags = [ "type_traits", "reference", "reference_collapsing", "metaprogramming",]
header = "<type_traits>"
depends_on = [ "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6",]

[[axioms]]
id = "cpp20_meta_trans_ref_add_rvalue_reference_referenceable_b8d2f5a3"
content = "If T is a referenceable type, then add_rvalue_reference<T>::type denotes T&&."
formal_spec = "is_referenceable(T) => add_rvalue_reference<T>::type == T&&"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58"
tags = [ "type_traits", "reference", "metaprogramming", "rvalue_reference",]
header = "<type_traits>"
depends_on = [ "extract_effect_perfect_forward_rvalue_c7b4d9e2", "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_meta_trans_ref_add_rvalue_reference_nonreferenceable_d3e7a2f9"
content = "If T is not a referenceable type, then add_rvalue_reference<T>::type denotes T."
formal_spec = "!is_referenceable(T) => add_rvalue_reference<T>::type == T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58"
tags = [ "type_traits", "reference", "metaprogramming", "rvalue_reference",]
header = "<type_traits>"

[[axioms]]
id = "cpp20_meta_trans_ref_add_rvalue_reference_collapse_semantics_f7a4b9e1"
content = "add_rvalue_reference reflects reference collapsing semantics as specified in [dcl.ref]."
formal_spec = "add_rvalue_reference<T>::type follows reference_collapsing_rules([dcl.ref])"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58/Note2"
tags = [ "type_traits", "reference", "reference_collapsing", "metaprogramming",]
header = "<type_traits>"
depends_on = [ "extract_effect_perfect_forward_rvalue_c7b4d9e2",]

[[axioms]]
id = "cpp20_meta_trans_ref_add_rvalue_reference_lvalue_ref_not_rvalue_c5d9e2f8"
content = "When T is a reference type T1&, add_rvalue_reference_t<T> is not an rvalue reference due to reference collapsing."
formal_spec = "T == T1& => add_rvalue_reference_t<T> == T1& && !is_rvalue_reference<add_rvalue_reference_t<T>>"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.trans.ref"
source_module = "[meta.trans.ref]/Table58/Note2"
tags = [ "type_traits", "reference", "reference_collapsing", "lvalue_reference", "rvalue_reference",]
header = "<type_traits>"
depends_on = [ "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6", "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4",]

[[axioms]]
id = "cpp20_meta_trans_ptr_remove_pointer_cv_qualified_a8f3d2e1"
content = "If T has type \"(possibly cv-qualified) pointer to T1\" then remove_pointer<T>::type denotes T1."
formal_spec = "is_pointer_type(T) && pointee_type(T) = T1 => remove_pointer<T>::type == T1"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ptr"
source_module = "[meta.trans.ptr]/Table61"
tags = [ "metaprogramming", "type-traits", "pointer", "transformation",]
function = "std::remove_pointer"
header = "<type_traits>"
signature = "typename std::remove_pointer<T>::type"

[[axioms]]
id = "cpp20_meta_trans_ptr_remove_pointer_non_pointer_b7c9e4f2"
content = "If T is not a pointer type, then remove_pointer<T>::type denotes T unchanged."
formal_spec = "!is_pointer_type(T) => remove_pointer<T>::type == T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ptr"
source_module = "[meta.trans.ptr]/Table61"
tags = [ "metaprogramming", "type-traits", "pointer", "transformation",]
function = "std::remove_pointer"
header = "<type_traits>"
signature = "typename std::remove_pointer<T>::type"

[[axioms]]
id = "cpp20_meta_trans_ptr_add_pointer_referenceable_c5d8a1e7"
content = "If T is a referenceable type or a cv void type, then add_pointer<T>::type denotes remove_reference_t<T>*."
formal_spec = "(is_referenceable(T) || is_cv_void(T)) => add_pointer<T>::type == remove_reference_t<T>*"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ptr"
source_module = "[meta.trans.ptr]/Table61"
tags = [ "metaprogramming", "type-traits", "pointer", "transformation", "referenceable",]
function = "std::add_pointer"
header = "<type_traits>"
signature = "typename std::add_pointer<T>::type"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_meta_trans_ptr_add_pointer_non_referenceable_d9e2f4a6"
content = "If T is not a referenceable type and not a cv void type, then add_pointer<T>::type denotes T unchanged."
formal_spec = "(!is_referenceable(T) && !is_cv_void(T)) => add_pointer<T>::type == T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.ptr"
source_module = "[meta.trans.ptr]/Table61"
tags = [ "metaprogramming", "type-traits", "pointer", "transformation", "referenceable",]
function = "std::add_pointer"
header = "<type_traits>"
signature = "typename std::add_pointer<T>::type"

[[axioms]]
id = "cpp20_meta_trans_ptr_add_pointer_reference_removal_e3f7b9c2"
content = "add_pointer first removes any reference from T (via remove_reference_t) before adding pointer, so reference types become pointer-to-referred-type."
formal_spec = "is_reference(T) && referred_type(T) = U => add_pointer<T>::type == U*"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "meta.trans.ptr"
source_module = "[meta.trans.ptr]/Table61"
tags = [ "metaprogramming", "type-traits", "pointer", "reference", "transformation",]
function = "std::add_pointer"
header = "<type_traits>"
signature = "typename std::add_pointer<T>::type"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1", "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4",]

[[axioms]]
id = "cpp20_meta_trans_other_type_identity_typedef_8a3f2b1c"
content = "The member typedef type of type_identity<T> denotes T exactly."
formal_spec = "type_identity<T>::type === T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "identity",]
function = "std::type_identity"
header = "<type_traits>"
signature = "template<class T> struct type_identity { using type = T; }"

[[axioms]]
id = "cpp20_meta_trans_other_remove_cvref_typedef_c4d9e2f1"
content = "The member typedef type of remove_cvref<T> denotes remove_cv_t<remove_reference_t<T>>."
formal_spec = "remove_cvref<T>::type === remove_cv_t<remove_reference_t<T>>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "cv_qualifiers", "references",]
function = "std::remove_cvref"
header = "<type_traits>"
signature = "template<class T> struct remove_cvref { using type = remove_cv_t<remove_reference_t<T>>; }"

[[axioms]]
id = "cpp20_meta_trans_other_decay_array_case_f7a8b3c2"
content = "For decay<T>, let U = remove_reference_t<T>. If is_array_v<U> is true, the member typedef type denotes remove_extent_t<U>*."
formal_spec = "U = remove_reference_t<T> && is_array_v<U> => decay<T>::type === remove_extent_t<U>*"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "decay", "array_to_pointer",]
function = "std::decay"
header = "<type_traits>"
signature = "template<class T> struct decay { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_decay_function_case_b2c5d8e1"
content = "For decay<T>, let U = remove_reference_t<T>. If is_function_v<U> is true, the member typedef type denotes add_pointer_t<U>."
formal_spec = "U = remove_reference_t<T> && is_function_v<U> => decay<T>::type === add_pointer_t<U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "decay", "function_to_pointer",]
function = "std::decay"
header = "<type_traits>"
signature = "template<class T> struct decay { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_decay_default_case_e9f1a4b7"
content = "For decay<T>, let U = remove_reference_t<T>. If is_array_v<U> and is_function_v<U> are both false, the member typedef type denotes remove_cv_t<U>."
formal_spec = "U = remove_reference_t<T> && !is_array_v<U> && !is_function_v<U> => decay<T>::type === remove_cv_t<U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "decay", "cv_qualifiers",]
function = "std::decay"
header = "<type_traits>"
signature = "template<class T> struct decay { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_enable_if_true_case_a5b6c7d8"
content = "For enable_if<B, T>, if B is true, the member typedef type denotes T."
formal_spec = "B == true => enable_if<B, T>::type === T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "enable_if", "sfinae",]
function = "std::enable_if"
header = "<type_traits>"
signature = "template<bool B, class T = void> struct enable_if { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_enable_if_false_case_d3e4f5a6"
content = "For enable_if<B, T>, if B is false, there shall be no member type."
formal_spec = "B == false => !has_member(enable_if<B, T>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "enable_if", "sfinae",]
function = "std::enable_if"
header = "<type_traits>"
signature = "template<bool B, class T = void> struct enable_if { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_conditional_true_case_f8a9b1c2"
content = "For conditional<B, T, F>, if B is true, the member typedef type denotes T."
formal_spec = "B == true => conditional<B, T, F>::type === T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "conditional",]
function = "std::conditional"
header = "<type_traits>"
signature = "template<bool B, class T, class F> struct conditional { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_conditional_false_case_c7d8e9f0"
content = "For conditional<B, T, F>, if B is false, the member typedef type denotes F."
formal_spec = "B == false => conditional<B, T, F>::type === F"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "conditional",]
function = "std::conditional"
header = "<type_traits>"
signature = "template<bool B, class T, class F> struct conditional { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_completeness_b4c5d6e7"
content = "Each type in the template parameter pack T of common_type shall be complete, cv void, or an array of unknown bound."
formal_spec = "forall Ti in T: is_complete(Ti) || is_cv_void(Ti) || is_array_unknown_bound(Ti)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "common_type", "completeness",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_basic_common_reference_no_default_e2f3a4b5"
content = "Unless basic_common_reference trait is specialized, there shall be no member type."
formal_spec = "!is_specialized(basic_common_reference<T, U, TQual, UQual>) => !has_member(basic_common_reference<T, U, TQual, UQual>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "common_reference", "customization",]
function = "std::basic_common_reference"
header = "<type_traits>"
signature = "template<class T, class U, template<class> class TQual, template<class> class UQual> struct basic_common_reference { /* no default member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_completeness_a7b8c9d0"
content = "Each type in the parameter pack T of common_reference shall be complete or cv void."
formal_spec = "forall Ti in T: is_complete(Ti) || is_cv_void(Ti)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "common_reference", "completeness",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_underlying_type_enum_case_f5a6b7c8"
content = "For underlying_type<T>, if T is an enumeration type, the member typedef type denotes the underlying type of T."
formal_spec = "is_enum_v<T> && !is_incomplete_enum(T) => underlying_type<T>::type === underlying_type_of(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "underlying_type", "enums",]
function = "std::underlying_type"
header = "<type_traits>"
signature = "template<class T> struct underlying_type { using type = /* underlying type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_underlying_type_non_enum_case_d9e0f1a2"
content = "For underlying_type<T>, if T is not an enumeration type, there is no member type."
formal_spec = "!is_enum_v<T> => !has_member(underlying_type<T>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "underlying_type", "enums",]
function = "std::underlying_type"
header = "<type_traits>"
signature = "template<class T> struct underlying_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_underlying_type_mandate_complete_b3c4d5e6"
content = "For underlying_type<T>, T must not be an incomplete enumeration type (Mandates)."
formal_spec = "is_enum_v<T> => !is_incomplete_enum(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "underlying_type", "enums", "mandates",]
function = "std::underlying_type"
header = "<type_traits>"
signature = "template<class T> struct underlying_type { /* requires T not incomplete enum */; }"

[[axioms]]
id = "cpp20_meta_trans_other_invoke_result_well_formed_case_a8b9c0d1"
content = "For invoke_result<Fn, ArgTypes...>, if INVOKE(declval<Fn>(), declval<ArgTypes>()...) is well-formed when treated as unevaluated operand, the member typedef type denotes decltype(INVOKE(declval<Fn>(), declval<ArgTypes>()...))."
formal_spec = "is_well_formed(INVOKE(declval<Fn>(), declval<ArgTypes>()...)) => invoke_result<Fn, ArgTypes...>::type === decltype(INVOKE(declval<Fn>(), declval<ArgTypes>()...))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "invoke_result", "invoke",]
function = "std::invoke_result"
header = "<type_traits>"
signature = "template<class Fn, class... ArgTypes> struct invoke_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_invoke_result_ill_formed_case_e2f3a4b5"
content = "For invoke_result<Fn, ArgTypes...>, if INVOKE(declval<Fn>(), declval<ArgTypes>()...) is not well-formed, there shall be no member type."
formal_spec = "!is_well_formed(INVOKE(declval<Fn>(), declval<ArgTypes>()...)) => !has_member(invoke_result<Fn, ArgTypes...>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "invoke_result", "invoke", "sfinae",]
function = "std::invoke_result"
header = "<type_traits>"
signature = "template<class Fn, class... ArgTypes> struct invoke_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_invoke_result_access_checking_c7d8e9f0"
content = "For invoke_result<Fn, ArgTypes...>, access checking is performed as if in a context unrelated to Fn and ArgTypes."
formal_spec = "access_check_context(invoke_result<Fn, ArgTypes...>) == unrelated_to(Fn, ArgTypes...)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "invoke_result", "access_control",]
function = "std::invoke_result"
header = "<type_traits>"
signature = "template<class Fn, class... ArgTypes> struct invoke_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_invoke_result_immediate_context_a5b6c7d8"
content = "For invoke_result<Fn, ArgTypes...>, only the validity of the immediate context of the INVOKE expression is considered."
formal_spec = "validity_check(invoke_result) == immediate_context_only(INVOKE(declval<Fn>(), declval<ArgTypes>()...))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "invoke_result", "sfinae", "immediate_context",]
function = "std::invoke_result"
header = "<type_traits>"
signature = "template<class Fn, class... ArgTypes> struct invoke_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_invoke_result_precond_complete_f9a0b1c2"
content = "Precondition for invoke_result<Fn, ArgTypes...>: Fn and all types in the template parameter pack ArgTypes are complete types, cv void, or arrays of unknown bound."
formal_spec = "is_complete(Fn) || is_cv_void(Fn) || is_array_unknown_bound(Fn)) && forall Ti in ArgTypes: (is_complete(Ti) || is_cv_void(Ti) || is_array_unknown_bound(Ti))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "invoke_result", "preconditions", "completeness",]
function = "std::invoke_result"
header = "<type_traits>"
signature = "template<class Fn, class... ArgTypes> struct invoke_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_apply_result_well_formed_case_d3e4f5a6"
content = "For apply_result<Fn, Tuple>, if tuple-like<Tuple> is true and INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...) is well-formed when treated as unevaluated operand, the member typedef type denotes decltype(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...))."
formal_spec = "tuple_like<Tuple> && is_well_formed(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...)) => apply_result<Fn, Tuple>::type === decltype(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "apply_result", "invoke", "tuple",]
function = "std::apply_result"
header = "<type_traits>"
signature = "template<class Fn, class Tuple> struct apply_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_apply_result_ill_formed_case_b7c8d9e0"
content = "For apply_result<Fn, Tuple>, if tuple-like<Tuple> is false or INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...) is not well-formed, there shall be no member type."
formal_spec = "(!tuple_like<Tuple> || !is_well_formed(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...))) => !has_member(apply_result<Fn, Tuple>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "apply_result", "invoke", "tuple", "sfinae",]
function = "std::apply_result"
header = "<type_traits>"
signature = "template<class Fn, class Tuple> struct apply_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_apply_result_access_checking_f1a2b3c4"
content = "For apply_result<Fn, Tuple>, access checking is performed as if in a context unrelated to Fn and Tuple."
formal_spec = "access_check_context(apply_result<Fn, Tuple>) == unrelated_to(Fn, Tuple)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "apply_result", "access_control",]
function = "std::apply_result"
header = "<type_traits>"
signature = "template<class Fn, class Tuple> struct apply_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_apply_result_immediate_context_e5f6a7b8"
content = "For apply_result<Fn, Tuple>, only the validity of the immediate context of the INVOKE expression is considered."
formal_spec = "validity_check(apply_result) == immediate_context_only(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "apply_result", "sfinae", "immediate_context",]
function = "std::apply_result"
header = "<type_traits>"
signature = "template<class Fn, class Tuple> struct apply_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_apply_result_precond_complete_c9d0e1f2"
content = "Precondition for apply_result<Fn, Tuple>: Fn and Tuple are complete types, cv void, or arrays of unknown bound."
formal_spec = "(is_complete(Fn) || is_cv_void(Fn) || is_array_unknown_bound(Fn)) && (is_complete(Tuple) || is_cv_void(Tuple) || is_array_unknown_bound(Tuple))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "apply_result", "preconditions", "completeness",]
function = "std::apply_result"
header = "<type_traits>"
signature = "template<class Fn, class Tuple> struct apply_result { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_unwrap_reference_wrapper_case_a3b4c5d6"
content = "For unwrap_reference<T>, if T is a specialization reference_wrapper<X> for some type X, the member typedef type denotes X&."
formal_spec = "is_specialization_of<T, reference_wrapper> => unwrap_reference<T>::type === X& where T == reference_wrapper<X>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "unwrap_reference", "reference_wrapper",]
function = "std::unwrap_reference"
header = "<type_traits>"
signature = "template<class T> struct unwrap_reference { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_unwrap_reference_non_wrapper_case_e7f8a9b0"
content = "For unwrap_reference<T>, if T is not a specialization of reference_wrapper, the member typedef type denotes T."
formal_spec = "!is_specialization_of<T, reference_wrapper> => unwrap_reference<T>::type === T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "unwrap_reference",]
function = "std::unwrap_reference"
header = "<type_traits>"
signature = "template<class T> struct unwrap_reference { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_unwrap_ref_decay_typedef_c1d2e3f4"
content = "The member typedef type of unwrap_ref_decay<T> denotes unwrap_reference_t<decay_t<T>>."
formal_spec = "unwrap_ref_decay<T>::type === unwrap_reference_t<decay_t<T>>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/Table62"
tags = [ "type_traits", "metaprogramming", "unwrap_ref_decay", "decay",]
function = "std::unwrap_ref_decay"
header = "<type_traits>"
signature = "template<class T> struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<T>>; }"

[[axioms]]
id = "cpp20_meta_trans_other_unwrap_functional_header_b5c6d7e8"
content = "The templates unwrap_reference, unwrap_ref_decay, unwrap_reference_t, and unwrap_ref_decay_t are available when the header <functional> is included, in addition to <type_traits>."
formal_spec = "includes(<functional>) => has_template(unwrap_reference) && has_template(unwrap_ref_decay) && has_alias(unwrap_reference_t) && has_alias(unwrap_ref_decay_t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/2"
tags = [ "type_traits", "metaprogramming", "unwrap_reference", "headers", "functional",]
function = "std::unwrap_reference"
header = "<functional>"
signature = "template<class T> struct unwrap_reference { using type = /* conditional */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_zero_args_f9a0b1c2"
content = "For common_type applied to zero types (sizeof...(T) == 0), there shall be no member type."
formal_spec = "sizeof...(T) == 0 => !has_member(common_type<T...>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/4.1"
tags = [ "type_traits", "metaprogramming", "common_type",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* no member type when empty */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_one_arg_d3e4f5a6"
content = "For common_type applied to one type T0 (sizeof...(T) == 1), the member typedef type shall denote the same type as common_type_t<T0, T0>, or there shall be no member type if that is ill-formed."
formal_spec = "sizeof...(T) == 1 => (common_type<T0>::type === common_type_t<T0, T0> || !has_member(common_type<T0>, type))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/4.2"
tags = [ "type_traits", "metaprogramming", "common_type",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_two_args_decay_differs_b7c8d9e0"
content = "For common_type applied to two types T1 and T2, if is_same_v<T1, D1> is false or is_same_v<T2, D2> is false (where D1 = decay_t<T1>, D2 = decay_t<T2>), let C denote the same type as common_type_t<D1, D2>, and the member type shall denote C if well-formed, otherwise no member type."
formal_spec = "sizeof...(T) == 2 && (!is_same_v<T1, decay_t<T1>> || !is_same_v<T2, decay_t<T2>>) => (common_type<T1, T2>::type === common_type_t<decay_t<T1>, decay_t<T2>> || !has_member(common_type<T1, T2>, type))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/4.3.1"
tags = [ "type_traits", "metaprogramming", "common_type", "decay",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_two_args_ternary_f1a2b3c4"
content = "For common_type applied to two already-decayed types D1 and D2, if decay_t<decltype(false ? declval<D1>() : declval<D2>())> denotes a valid type, let C denote that type, and the member type shall denote C."
formal_spec = "sizeof...(T) == 2 && is_same_v<T1, decay_t<T1>> && is_same_v<T2, decay_t<T2>> && is_valid(decay_t<decltype(false ? declval<T1>() : declval<T2>())>) => common_type<T1, T2>::type === decay_t<decltype(false ? declval<T1>() : declval<T2>())>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/4.3.3"
tags = [ "type_traits", "metaprogramming", "common_type", "ternary_operator",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_two_args_cond_res_e5f6a7b8"
content = "For common_type applied to two already-decayed types D1 and D2, if the ternary operator approach does not apply and COND-RES(CREF(D1), CREF(D2)) denotes a type, let C denote decay_t<COND-RES(CREF(D1), CREF(D2))>, and the member type shall denote C."
formal_spec = "sizeof...(T) == 2 && is_same_v<T1, decay_t<T1>> && is_same_v<T2, decay_t<T2>> && !is_valid(decay_t<decltype(false ? declval<T1>() : declval<T2>())>) && is_valid(COND-RES(CREF(T1), CREF(T2))) => common_type<T1, T2>::type === decay_t<COND-RES(CREF(T1), CREF(T2))>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/4.3.4"
tags = [ "type_traits", "metaprogramming", "common_type", "cond_res",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_multiple_args_c9d0e1f2"
content = "For common_type applied to more than two types (sizeof...(T) > 2), let T1, T2, and R denote the first, second, and remaining types. Let C denote common_type_t<T1, T2>. If C is well-formed, the member type shall denote common_type_t<C, R...> if well-formed, otherwise no member type. If C is ill-formed, there shall be no member type."
formal_spec = "sizeof...(T) > 2 => (is_valid(common_type_t<T1, T2>) => (common_type<T...>::type === common_type_t<common_type_t<T1, T2>, R...> || !has_member(common_type<T...>, type))) && (!is_valid(common_type_t<T1, T2>) => !has_member(common_type<T...>, type))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/4.4"
tags = [ "type_traits", "metaprogramming", "common_type", "recursion",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_specialization_allowed_a7b8c9d0"
content = "A program may specialize common_type<T1, T2> for types T1 and T2 such that is_same_v<T1, decay_t<T1>> and is_same_v<T2, decay_t<T2>> are each true."
formal_spec = "is_same_v<T1, decay_t<T1>> && is_same_v<T2, decay_t<T2>> => may_specialize(common_type<T1, T2>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/5"
tags = [ "type_traits", "metaprogramming", "common_type", "specialization", "customization",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* customizable via specialization */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_spec_cv_unqualified_f5a6b7c8"
content = "A specialization of common_type<T1, T2>, if it has a member named type, the qualified-id common_type<T1, T2>::type shall denote a cv-unqualified non-reference type to which each of T1 and T2 is explicitly convertible."
formal_spec = "has_member(common_type<T1, T2>, type) => is_cv_unqualified(common_type<T1, T2>::type) && !is_reference(common_type<T1, T2>::type) && is_explicitly_convertible(T1, common_type<T1, T2>::type) && is_explicitly_convertible(T2, common_type<T1, T2>::type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/5"
tags = [ "type_traits", "metaprogramming", "common_type", "specialization", "constraints",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* specialization constraints */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_type_spec_symmetric_d9e0f1a2"
content = "A specialization of common_type<T1, T2> must ensure that common_type_t<T1, T2> denotes the same type as common_type_t<T2, T1>."
formal_spec = "common_type_t<T1, T2> === common_type_t<T2, T1>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/5"
tags = [ "type_traits", "metaprogramming", "common_type", "specialization", "symmetry",]
function = "std::common_type"
header = "<type_traits>"
signature = "template<class... T> struct common_type { /* specialization symmetry requirement */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_zero_args_b3c4d5e6"
content = "For common_reference applied to zero types (sizeof...(T) == 0), there shall be no member type."
formal_spec = "sizeof...(T) == 0 => !has_member(common_reference<T...>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.1"
tags = [ "type_traits", "metaprogramming", "common_reference",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* no member type when empty */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_one_arg_a8b9c0d1"
content = "For common_reference applied to one type T0 (sizeof...(T) == 1), the member typedef type shall denote the same type as T0."
formal_spec = "sizeof...(T) == 1 => common_reference<T0>::type === T0"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.2"
tags = [ "type_traits", "metaprogramming", "common_reference",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* identity for single type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_two_args_common_ref_e2f3a4b5"
content = "For common_reference applied to two reference types T1 and T2, let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is well-formed, and is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> && is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is true, then the member typedef type denotes R."
formal_spec = "sizeof...(T) == 2 && is_reference(T1) && is_reference(T2) && is_well_formed(COMMON-REF(T1, T2)) && is_convertible_v<add_pointer_t<T1>, add_pointer_t<COMMON-REF(T1, T2)>> && is_convertible_v<add_pointer_t<T2>, add_pointer_t<COMMON-REF(T1, T2)>> => common_reference<T1, T2>::type === COMMON-REF(T1, T2)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.3.1"
tags = [ "type_traits", "metaprogramming", "common_reference", "references",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_two_args_basic_c7d8e9f0"
content = "For common_reference applied to two types T1 and T2, if the COMMON-REF approach does not apply and basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, XREF(T1), XREF(T2)>::type is well-formed, then the member typedef type denotes that type."
formal_spec = "sizeof...(T) == 2 && !applies(COMMON-REF) && is_well_formed(basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, XREF(T1), XREF(T2)>::type) => common_reference<T1, T2>::type === basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, XREF(T1), XREF(T2)>::type"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.3.2"
tags = [ "type_traits", "metaprogramming", "common_reference", "basic_common_reference",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_two_args_cond_res_a5b6c7d8"
content = "For common_reference applied to two types T1 and T2, if previous approaches do not apply and COND-RES(T1, T2) is well-formed, then the member typedef type denotes that type."
formal_spec = "sizeof...(T) == 2 && !applies(COMMON-REF) && !applies(basic_common_reference) && is_well_formed(COND-RES(T1, T2)) => common_reference<T1, T2>::type === COND-RES(T1, T2)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.3.3"
tags = [ "type_traits", "metaprogramming", "common_reference", "cond_res",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_two_args_common_type_f9a0b1c2"
content = "For common_reference applied to two types T1 and T2, if previous approaches do not apply and common_type_t<T1, T2> is well-formed, then the member typedef type denotes that type."
formal_spec = "sizeof...(T) == 2 && !applies(COMMON-REF) && !applies(basic_common_reference) && !applies(COND-RES) && is_well_formed(common_type_t<T1, T2>) => common_reference<T1, T2>::type === common_type_t<T1, T2>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.3.4"
tags = [ "type_traits", "metaprogramming", "common_reference", "common_type",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_two_args_no_type_d3e4f5a6"
content = "For common_reference applied to two types T1 and T2, if none of the specified approaches apply, there shall be no member type."
formal_spec = "sizeof...(T) == 2 && !applies(COMMON-REF) && !applies(basic_common_reference) && !applies(COND-RES) && !applies(common_type) => !has_member(common_reference<T1, T2>, type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.3.5"
tags = [ "type_traits", "metaprogramming", "common_reference",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_common_reference_multiple_args_b7c8d9e0"
content = "For common_reference applied to more than two types (sizeof...(T) > 2), let T1, T2, and Rest denote the first, second, and remaining types. Let C denote common_reference_t<T1, T2>. If C is well-formed, the member typedef type shall denote common_reference_t<C, Rest...> if well-formed, otherwise no member type. If C is ill-formed, there shall be no member type."
formal_spec = "sizeof...(T) > 2 => (is_valid(common_reference_t<T1, T2>) => (common_reference<T...>::type === common_reference_t<common_reference_t<T1, T2>, Rest...> || !has_member(common_reference<T...>, type))) && (!is_valid(common_reference_t<T1, T2>) => !has_member(common_reference<T...>, type))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/6.4"
tags = [ "type_traits", "metaprogramming", "common_reference", "recursion",]
function = "std::common_reference"
header = "<type_traits>"
signature = "template<class... T> struct common_reference { /* conditional member type */; }"

[[axioms]]
id = "cpp20_meta_trans_other_basic_common_reference_specialization_allowed_f1a2b3c4"
content = "A program may partially specialize basic_common_reference<T, U, TQual, UQual> for types T and U such that is_same_v<T, decay_t<T>> and is_same_v<U, decay_t<U>> are each true."
formal_spec = "is_same_v<T, decay_t<T>> && is_same_v<U, decay_t<U>> => may_partially_specialize(basic_common_reference<T, U, TQual, UQual>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/7"
tags = [ "type_traits", "metaprogramming", "basic_common_reference", "specialization", "customization",]
function = "std::basic_common_reference"
header = "<type_traits>"
signature = "template<class T, class U, template<class> class TQual, template<class> class UQual> struct basic_common_reference { /* customizable via specialization */; }"

[[axioms]]
id = "cpp20_meta_trans_other_basic_common_reference_spec_convertible_e5f6a7b8"
content = "A specialization of basic_common_reference<T, U, TQual, UQual>, if it has a member named type, the qualified-id basic_common_reference<T, U, TQual, UQual>::type shall denote a type to which each of TQual<T> and UQual<U> is convertible."
formal_spec = "has_member(basic_common_reference<T, U, TQual, UQual>, type) => is_convertible(TQual<T>, basic_common_reference<T, U, TQual, UQual>::type) && is_convertible(UQual<U>, basic_common_reference<T, U, TQual, UQual>::type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/7"
tags = [ "type_traits", "metaprogramming", "basic_common_reference", "specialization", "constraints",]
function = "std::basic_common_reference"
header = "<type_traits>"
signature = "template<class T, class U, template<class> class TQual, template<class> class UQual> struct basic_common_reference { /* specialization constraints */; }"

[[axioms]]
id = "cpp20_meta_trans_other_basic_common_reference_spec_symmetric_c9d0e1f2"
content = "A specialization of basic_common_reference<T, U, TQual, UQual> must ensure that basic_common_reference<T, U, TQual, UQual>::type denotes the same type as basic_common_reference<U, T, UQual, TQual>::type."
formal_spec = "basic_common_reference<T, U, TQual, UQual>::type === basic_common_reference<U, T, UQual, TQual>::type"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "meta.trans.other"
source_module = "[meta.trans.other]/7"
tags = [ "type_traits", "metaprogramming", "basic_common_reference", "specialization", "symmetry",]
function = "std::basic_common_reference"
header = "<type_traits>"
signature = "template<class T, class U, template<class> class TQual, template<class> class UQual> struct basic_common_reference { /* specialization symmetry requirement */; }"

[[axioms]]
id = "cpp20_cmp_concept_compares_as_requirement_e7f3a2d1"
content = "For types T and Cat to satisfy compares-as<T, Cat>, common_comparison_category_t<T, Cat> must be the same type as Cat"
formal_spec = "compares-as<T, Cat>  same_as<common_comparison_category_t<T, Cat>, Cat>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]"
tags = [ "concepts", "comparison", "three_way_comparable", "type_traits",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_same_domain_a4b7c9e2"
content = "For T and U to model partially-ordered-with<T, U>, all comparison operations (t<u, t<=u, t>u, t>=u, u<t, u<=t, u>t, u>=t) must have the same domain"
formal_spec = "partially-ordered-with<T, U>  same_domain(t<u, t<=u, t>u, t>=u, u<t, u<=t, u>t, u>=t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/1.1"
tags = [ "concepts", "comparison", "partial_order", "domain",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_less_gt_symmetry_d2f8a1c5"
content = "For T and U to model partially-ordered-with<T, U>, bool(t<u) must equal bool(u>t)"
formal_spec = "partially-ordered-with<T, U>  bool(t<u) == bool(u>t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/1.2"
tags = [ "concepts", "comparison", "partial_order", "symmetry",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_gt_less_symmetry_b9e3f7a4"
content = "For T and U to model partially-ordered-with<T, U>, bool(u<t) must equal bool(t>u)"
formal_spec = "partially-ordered-with<T, U>  bool(u<t) == bool(t>u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/1.3"
tags = [ "concepts", "comparison", "partial_order", "symmetry",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_le_ge_symmetry_c5a2d8f1"
content = "For T and U to model partially-ordered-with<T, U>, bool(t<=u) must equal bool(u>=t)"
formal_spec = "partially-ordered-with<T, U>  bool(t<=u) == bool(u>=t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/1.4"
tags = [ "concepts", "comparison", "partial_order", "symmetry",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_ge_le_symmetry_f1d9a3b7"
content = "For T and U to model partially-ordered-with<T, U>, bool(u<=t) must equal bool(t>=u)"
formal_spec = "partially-ordered-with<T, U>  bool(u<=t) == bool(t>=u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/1.5"
tags = [ "concepts", "comparison", "partial_order", "symmetry",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_eq_consistency_a7c2f4d9"
content = "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b==0) must equal bool(a==b)"
formal_spec = "three_way_comparable<T, Cat>  (a<=>b==0) == bool(a==b)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.1"
tags = [ "concepts", "comparison", "three_way_comparable", "equality", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_neq_consistency_e3b8d1a6"
content = "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b!=0) must equal bool(a!=b)"
formal_spec = "three_way_comparable<T, Cat>  (a<=>b!=0) == bool(a!=b)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.2"
tags = [ "concepts", "comparison", "three_way_comparable", "inequality", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_symmetry_d9a5f2c8"
content = "For T and Cat to model three_way_comparable<T, Cat>, ((a<=>b)<=>0) and (0<=>(b<=>a)) must be equal"
formal_spec = "three_way_comparable<T, Cat>  ((a<=>b)<=>0) == (0<=>(b<=>a))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.3"
tags = [ "concepts", "comparison", "three_way_comparable", "symmetry", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_less_consistency_b4d7f3a1"
content = "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b<0) must equal bool(a<b)"
formal_spec = "three_way_comparable<T, Cat>  (a<=>b<0) == bool(a<b)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.4"
tags = [ "concepts", "comparison", "three_way_comparable", "less_than", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_gt_consistency_c8a2d5f9"
content = "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b>0) must equal bool(a>b)"
formal_spec = "three_way_comparable<T, Cat>  (a<=>b>0) == bool(a>b)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.5"
tags = [ "concepts", "comparison", "three_way_comparable", "greater_than", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_le_consistency_f2b9a4d7"
content = "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b<=0) must equal bool(a<=b)"
formal_spec = "three_way_comparable<T, Cat>  (a<=>b<=0) == bool(a<=b)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.6"
tags = [ "concepts", "comparison", "three_way_comparable", "less_equal", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_spaceship_ge_consistency_a1d8c3f5"
content = "For T and Cat to model three_way_comparable<T, Cat>, (a<=>b>=0) must equal bool(a>=b)"
formal_spec = "three_way_comparable<T, Cat>  (a<=>b>=0) == bool(a>=b)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.7"
tags = [ "concepts", "comparison", "three_way_comparable", "greater_equal", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_strong_totally_ordered_e5f1a9c2"
content = "For T and Cat to model three_way_comparable<T, Cat>, if Cat is convertible to strong_ordering, then T must model totally_ordered"
formal_spec = "three_way_comparable<T, Cat>  convertible_to<Cat, strong_ordering>  totally_ordered<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.8"
tags = [ "concepts", "comparison", "three_way_comparable", "strong_ordering", "totally_ordered",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_same_domain_d7a3f8b4"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, t<=>u and u<=>t must have the same domain"
formal_spec = "three_way_comparable_with<T, U, Cat>  same_domain(t<=>u, u<=>t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.1"
tags = [ "concepts", "comparison", "three_way_comparable_with", "domain", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_symmetry_c9d2a7f1"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, ((t<=>u)<=>0) and (0<=>(u<=>t)) must be equal"
formal_spec = "three_way_comparable_with<T, U, Cat>  ((t<=>u)<=>0) == (0<=>(u<=>t))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.2"
tags = [ "concepts", "comparison", "three_way_comparable_with", "symmetry", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_eq_consistency_b3f5d8a2"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u==0) must equal bool(t==u)"
formal_spec = "three_way_comparable_with<T, U, Cat>  (t<=>u==0) == bool(t==u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.3"
tags = [ "concepts", "comparison", "three_way_comparable_with", "equality", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_neq_consistency_a8c4f1d7"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u!=0) must equal bool(t!=u)"
formal_spec = "three_way_comparable_with<T, U, Cat>  (t<=>u!=0) == bool(t!=u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.4"
tags = [ "concepts", "comparison", "three_way_comparable_with", "inequality", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_common_ref_consistency_f9a2d5c8"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, Cat(t<=>u) must equal Cat(CONVERT_TO_LVALUE<C>(t2)<=>CONVERT_TO_LVALUE<C>(u2)) where C is common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>"
formal_spec = "three_way_comparable_with<T, U, Cat>  Cat(t<=>u) == Cat(CONVERT_TO_LVALUE<C>(t2)<=>CONVERT_TO_LVALUE<C>(u2)) where C = common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.5"
tags = [ "concepts", "comparison", "three_way_comparable_with", "common_reference", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_less_consistency_e4b7a9d1"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u<0) must equal bool(t<u)"
formal_spec = "three_way_comparable_with<T, U, Cat>  (t<=>u<0) == bool(t<u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.6"
tags = [ "concepts", "comparison", "three_way_comparable_with", "less_than", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_gt_consistency_d2f8c5a3"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u>0) must equal bool(t>u)"
formal_spec = "three_way_comparable_with<T, U, Cat>  (t<=>u>0) == bool(t>u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.7"
tags = [ "concepts", "comparison", "three_way_comparable_with", "greater_than", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_le_consistency_c7a1f4d9"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u<=0) must equal bool(t<=u)"
formal_spec = "three_way_comparable_with<T, U, Cat>  (t<=>u<=0) == bool(t<=u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.8"
tags = [ "concepts", "comparison", "three_way_comparable_with", "less_equal", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_ge_consistency_b5d3a8f2"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, (t<=>u>=0) must equal bool(t>=u)"
formal_spec = "three_way_comparable_with<T, U, Cat>  (t<=>u>=0) == bool(t>=u)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.9"
tags = [ "concepts", "comparison", "three_way_comparable_with", "greater_equal", "spaceship",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_concept_three_way_comparable_with_strong_totally_ordered_a9f2c6d4"
content = "For T, U, and Cat to model three_way_comparable_with<T, U, Cat>, if Cat is convertible to strong_ordering, then T and U must model totally_ordered_with<T, U>"
formal_spec = "three_way_comparable_with<T, U, Cat>  convertible_to<Cat, strong_ordering>  totally_ordered_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.10"
tags = [ "concepts", "comparison", "three_way_comparable_with", "strong_ordering", "totally_ordered_with",]
header = "<compare>"

[[axioms]]
id = "cpp20_cmp_alg_strong_order_type_mismatch_ill_formed_a7f3e2d1"
content = "If the decayed types of E and F differ, strong_order(E, F) is ill-formed."
formal_spec = "decay_t<decltype(E)> != decay_t<decltype(F)> => ill_formed(strong_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.1"
tags = [ "comparison", "customization-point", "type-constraint", "strong-ordering",]
function = "std::strong_order"
header = "<compare>"
signature = "strong_ordering strong_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_strong_order_adl_precedence_b8d4f1c2"
content = "strong_order first attempts to use argument-dependent lookup to find a user-provided strong_order function."
formal_spec = "well_formed(strong_ordering(strong_order(E, F))) && adl_only(strong_order) => strong_order(E, F)  strong_ordering(strong_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.2"
tags = [ "comparison", "customization-point", "adl", "strong-ordering",]
function = "std::strong_order"
header = "<compare>"
signature = "strong_ordering strong_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_strong_order_float_iec559_consistency_c9e5a2b3"
content = "For floating-point type T with numeric_limits<T>::is_iec559 == true, strong_order must be consistent with ISO/IEC 60559 totalOrder operation."
formal_spec = "is_floating_point_v<T> && numeric_limits<T>::is_iec559 => strong_order(E, F) consistent_with iso_iec_60559_totalOrder"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.3"
tags = [ "comparison", "floating-point", "iec559", "strong-ordering", "totalOrder",]
function = "std::strong_order"
header = "<compare>"
signature = "strong_ordering strong_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_strong_order_float_comparison_consistency_d0f6b3c4"
content = "For floating-point type T, strong_order yields a value consistent with T's comparison operators."
formal_spec = "is_floating_point_v<decay_t<decltype(E)>> => strong_order(E, F) consistent_with comparison_operators<T>"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.3"
tags = [ "comparison", "floating-point", "strong-ordering", "consistency",]
function = "std::strong_order"
header = "<compare>"
signature = "strong_ordering strong_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_strong_order_three_way_fallback_e1a7c4d5"
content = "If ADL and floating-point handling do not apply, strong_order falls back to strong_ordering(compare_three_way()(E, F)) if well-formed."
formal_spec = "!adl_found && !is_floating_point && well_formed(strong_ordering(compare_three_way()(E, F))) => strong_order(E, F)  strong_ordering(compare_three_way()(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.4"
tags = [ "comparison", "three-way-comparison", "strong-ordering", "fallback",]
function = "std::strong_order"
header = "<compare>"
signature = "strong_ordering strong_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_strong_order_final_ill_formed_f2b8d5e6"
content = "If none of the strong_order resolution steps produce a well-formed expression, strong_order(E, F) is ill-formed."
formal_spec = "!adl_found && !is_floating_point && !well_formed(compare_three_way()) => ill_formed(strong_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.5"
tags = [ "comparison", "customization-point", "strong-ordering", "substitution-failure",]
function = "std::strong_order"
header = "<compare>"
signature = "strong_ordering strong_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_type_mismatch_ill_formed_a3c9e6f7"
content = "If the decayed types of E and F differ, weak_order(E, F) is ill-formed."
formal_spec = "decay_t<decltype(E)> != decay_t<decltype(F)> => ill_formed(weak_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.1"
tags = [ "comparison", "customization-point", "type-constraint", "weak-ordering",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_adl_precedence_b4d0a7c8"
content = "weak_order first attempts to use argument-dependent lookup to find a user-provided weak_order function."
formal_spec = "well_formed(weak_ordering(weak_order(E, F))) && adl_only(weak_order) => weak_order(E, F)  weak_ordering(weak_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.2"
tags = [ "comparison", "customization-point", "adl", "weak-ordering",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_float_strong_order_consistency_c5e1b8d9"
content = "For floating-point type T, weak_order must be consistent with both T's comparison operators and strong_order."
formal_spec = "is_floating_point_v<decay_t<decltype(E)>> => weak_order(E, F) consistent_with comparison_operators<T> && weak_order(E, F) consistent_with strong_order(E, F)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.3"
tags = [ "comparison", "floating-point", "weak-ordering", "consistency",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_float_iec559_equivalence_classes_d6f2c9e0"
content = "For floating-point type T with numeric_limits<T>::is_iec559 == true, weak_order must group values into specific equivalence classes: all negative NaNs, negative infinity, normal negatives, subnormal negatives, both zeros, subnormal positives, normal positives, positive infinity, all positive NaNs."
formal_spec = "is_floating_point_v<T> && numeric_limits<T>::is_iec559 => weak_order(E, F) consistent_with equivalence_classes([neg_nan], [-inf], [norm_neg], [subnorm_neg], [0], [subnorm_pos], [norm_pos], [+inf], [pos_nan])"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.3"
tags = [ "comparison", "floating-point", "iec559", "weak-ordering", "nan", "zero", "equivalence-class",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_three_way_fallback_e7a3d0f1"
content = "If ADL and floating-point handling do not apply, weak_order falls back to weak_ordering(compare_three_way()(E, F)) if well-formed."
formal_spec = "!adl_found && !is_floating_point && well_formed(weak_ordering(compare_three_way()(E, F))) => weak_order(E, F)  weak_ordering(compare_three_way()(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.4"
tags = [ "comparison", "three-way-comparison", "weak-ordering", "fallback",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_strong_order_fallback_f8b4e1a2"
content = "If three-way comparison is not available, weak_order falls back to weak_ordering(strong_order(E, F)) if well-formed."
formal_spec = "!adl_found && !is_floating_point && !well_formed(compare_three_way()) && well_formed(weak_ordering(strong_order(E, F))) => weak_order(E, F)  weak_ordering(strong_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.5"
tags = [ "comparison", "weak-ordering", "strong-ordering", "fallback",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_weak_order_final_ill_formed_a9c5f2b3"
content = "If none of the weak_order resolution steps produce a well-formed expression, weak_order(E, F) is ill-formed."
formal_spec = "!adl_found && !is_floating_point && !well_formed(compare_three_way()) && !well_formed(strong_order()) => ill_formed(weak_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.6"
tags = [ "comparison", "customization-point", "weak-ordering", "substitution-failure",]
function = "std::weak_order"
header = "<compare>"
signature = "weak_ordering weak_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_partial_order_type_mismatch_ill_formed_b0d6a3c4"
content = "If the decayed types of E and F differ, partial_order(E, F) is ill-formed."
formal_spec = "decay_t<decltype(E)> != decay_t<decltype(F)> => ill_formed(partial_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.1"
tags = [ "comparison", "customization-point", "type-constraint", "partial-ordering",]
function = "std::partial_order"
header = "<compare>"
signature = "partial_ordering partial_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_partial_order_adl_precedence_c1e7b4d5"
content = "partial_order first attempts to use argument-dependent lookup to find a user-provided partial_order function."
formal_spec = "well_formed(partial_ordering(partial_order(E, F))) && adl_only(partial_order) => partial_order(E, F)  partial_ordering(partial_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.2"
tags = [ "comparison", "customization-point", "adl", "partial-ordering",]
function = "std::partial_order"
header = "<compare>"
signature = "partial_ordering partial_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_partial_order_three_way_fallback_d2f8c5e6"
content = "If ADL does not apply, partial_order falls back to partial_ordering(compare_three_way()(E, F)) if well-formed."
formal_spec = "!adl_found && well_formed(partial_ordering(compare_three_way()(E, F))) => partial_order(E, F)  partial_ordering(compare_three_way()(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.3"
tags = [ "comparison", "three-way-comparison", "partial-ordering", "fallback",]
function = "std::partial_order"
header = "<compare>"
signature = "partial_ordering partial_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_partial_order_weak_order_fallback_e3a9d6f7"
content = "If three-way comparison is not available, partial_order falls back to partial_ordering(weak_order(E, F)) if well-formed."
formal_spec = "!adl_found && !well_formed(compare_three_way()) && well_formed(partial_ordering(weak_order(E, F))) => partial_order(E, F)  partial_ordering(weak_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.4"
tags = [ "comparison", "partial-ordering", "weak-ordering", "fallback",]
function = "std::partial_order"
header = "<compare>"
signature = "partial_ordering partial_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_partial_order_final_ill_formed_f4b0e7a8"
content = "If none of the partial_order resolution steps produce a well-formed expression, partial_order(E, F) is ill-formed."
formal_spec = "!adl_found && !well_formed(compare_three_way()) && !well_formed(weak_order()) => ill_formed(partial_order(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.5"
tags = [ "comparison", "customization-point", "partial-ordering", "substitution-failure",]
function = "std::partial_order"
header = "<compare>"
signature = "partial_ordering partial_order(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_strong_order_fallback_type_mismatch_ill_formed_a5c1f8b9"
content = "If the decayed types of E and F differ, compare_strong_order_fallback(E, F) is ill-formed."
formal_spec = "decay_t<decltype(E)> != decay_t<decltype(F)> => ill_formed(compare_strong_order_fallback(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.1"
tags = [ "comparison", "customization-point", "type-constraint", "strong-ordering",]
function = "std::compare_strong_order_fallback"
header = "<compare>"
signature = "strong_ordering compare_strong_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_strong_order_fallback_strong_order_precedence_b6d2a9c0"
content = "compare_strong_order_fallback first attempts to use strong_order(E, F) if it is well-formed."
formal_spec = "well_formed(strong_order(E, F)) => compare_strong_order_fallback(E, F)  strong_order(E, F)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.2"
tags = [ "comparison", "customization-point", "strong-ordering", "fallback",]
function = "std::compare_strong_order_fallback"
header = "<compare>"
signature = "strong_ordering compare_strong_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_strong_order_fallback_operator_fallback_c7e3b0d1"
content = "If strong_order is not available and E==F and E<F are well-formed with boolean-testable results, compare_strong_order_fallback synthesizes strong_ordering from == and < operators."
formal_spec = "!well_formed(strong_order(E, F)) && well_formed(E==F) && well_formed(E<F) && boolean_testable<decltype(E==F)> && boolean_testable<decltype(E<F)> => compare_strong_order_fallback(E, F)  (E==F ? strong_ordering::equal : E<F ? strong_ordering::less : strong_ordering::greater)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.3"
tags = [ "comparison", "strong-ordering", "operator-synthesis", "fallback", "boolean-testable",]
function = "std::compare_strong_order_fallback"
header = "<compare>"
signature = "strong_ordering compare_strong_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_strong_order_fallback_single_evaluation_d8f4c1e2"
content = "In compare_strong_order_fallback operator synthesis fallback, E and F are evaluated only once."
formal_spec = "compare_strong_order_fallback(E, F) uses operator_fallback => evaluation_count(E) == 1 && evaluation_count(F) == 1"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.3"
tags = [ "comparison", "evaluation-semantics", "strong-ordering", "side-effects",]
function = "std::compare_strong_order_fallback"
header = "<compare>"
signature = "strong_ordering compare_strong_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_strong_order_fallback_final_ill_formed_e9a5d2f3"
content = "If neither strong_order nor operator synthesis are available, compare_strong_order_fallback(E, F) is ill-formed."
formal_spec = "!well_formed(strong_order(E, F)) && (!well_formed(E==F) || !well_formed(E<F) || !boolean_testable<decltype(E==F)> || !boolean_testable<decltype(E<F)>) => ill_formed(compare_strong_order_fallback(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.4"
tags = [ "comparison", "customization-point", "strong-ordering", "substitution-failure",]
function = "std::compare_strong_order_fallback"
header = "<compare>"
signature = "strong_ordering compare_strong_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_weak_order_fallback_type_mismatch_ill_formed_f0b6e3a4"
content = "If the decayed types of E and F differ, compare_weak_order_fallback(E, F) is ill-formed."
formal_spec = "decay_t<decltype(E)> != decay_t<decltype(F)> => ill_formed(compare_weak_order_fallback(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.1"
tags = [ "comparison", "customization-point", "type-constraint", "weak-ordering",]
function = "std::compare_weak_order_fallback"
header = "<compare>"
signature = "weak_ordering compare_weak_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_weak_order_fallback_weak_order_precedence_a1c7f4b5"
content = "compare_weak_order_fallback first attempts to use weak_order(E, F) if it is well-formed."
formal_spec = "well_formed(weak_order(E, F)) => compare_weak_order_fallback(E, F)  weak_order(E, F)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.2"
tags = [ "comparison", "customization-point", "weak-ordering", "fallback",]
function = "std::compare_weak_order_fallback"
header = "<compare>"
signature = "weak_ordering compare_weak_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_weak_order_fallback_operator_fallback_b2d8e5c6"
content = "If weak_order is not available and E==F and E<F are well-formed with boolean-testable results, compare_weak_order_fallback synthesizes weak_ordering from == and < operators using equivalent instead of equal."
formal_spec = "!well_formed(weak_order(E, F)) && well_formed(E==F) && well_formed(E<F) && boolean_testable<decltype(E==F)> && boolean_testable<decltype(E<F)> => compare_weak_order_fallback(E, F)  (E==F ? weak_ordering::equivalent : E<F ? weak_ordering::less : weak_ordering::greater)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.3"
tags = [ "comparison", "weak-ordering", "operator-synthesis", "fallback", "boolean-testable",]
function = "std::compare_weak_order_fallback"
header = "<compare>"
signature = "weak_ordering compare_weak_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_weak_order_fallback_single_evaluation_c3e9f6d7"
content = "In compare_weak_order_fallback operator synthesis fallback, E and F are evaluated only once."
formal_spec = "compare_weak_order_fallback(E, F) uses operator_fallback => evaluation_count(E) == 1 && evaluation_count(F) == 1"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.3"
tags = [ "comparison", "evaluation-semantics", "weak-ordering", "side-effects",]
function = "std::compare_weak_order_fallback"
header = "<compare>"
signature = "weak_ordering compare_weak_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_weak_order_fallback_final_ill_formed_d4f0a7e8"
content = "If neither weak_order nor operator synthesis are available, compare_weak_order_fallback(E, F) is ill-formed."
formal_spec = "!well_formed(weak_order(E, F)) && (!well_formed(E==F) || !well_formed(E<F) || !boolean_testable<decltype(E==F)> || !boolean_testable<decltype(E<F)>) => ill_formed(compare_weak_order_fallback(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.4"
tags = [ "comparison", "customization-point", "weak-ordering", "substitution-failure",]
function = "std::compare_weak_order_fallback"
header = "<compare>"
signature = "weak_ordering compare_weak_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_partial_order_fallback_type_mismatch_ill_formed_e5a1b8f9"
content = "If the decayed types of E and F differ, compare_partial_order_fallback(E, F) is ill-formed."
formal_spec = "decay_t<decltype(E)> != decay_t<decltype(F)> => ill_formed(compare_partial_order_fallback(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.1"
tags = [ "comparison", "customization-point", "type-constraint", "partial-ordering",]
function = "std::compare_partial_order_fallback"
header = "<compare>"
signature = "partial_ordering compare_partial_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_partial_order_fallback_partial_order_precedence_f6b2c9a0"
content = "compare_partial_order_fallback first attempts to use partial_order(E, F) if it is well-formed."
formal_spec = "well_formed(partial_order(E, F)) => compare_partial_order_fallback(E, F)  partial_order(E, F)"
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.2"
tags = [ "comparison", "customization-point", "partial-ordering", "fallback",]
function = "std::compare_partial_order_fallback"
header = "<compare>"
signature = "partial_ordering compare_partial_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_partial_order_fallback_operator_fallback_a7c3d0b1"
content = "If partial_order is not available and E==F, E<F, and F<E are all well-formed with boolean-testable results, compare_partial_order_fallback synthesizes partial_ordering from ==, <, and > operators, including unordered case."
formal_spec = "!well_formed(partial_order(E, F)) && well_formed(E==F) && well_formed(E<F) && well_formed(F<E) && boolean_testable<decltype(E==F)> && boolean_testable<decltype(E<F)> && boolean_testable<decltype(F<E)> => compare_partial_order_fallback(E, F)  (E==F ? partial_ordering::equivalent : E<F ? partial_ordering::less : F<E ? partial_ordering::greater : partial_ordering::unordered)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.3"
tags = [ "comparison", "partial-ordering", "operator-synthesis", "fallback", "boolean-testable", "unordered",]
function = "std::compare_partial_order_fallback"
header = "<compare>"
signature = "partial_ordering compare_partial_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_partial_order_fallback_single_evaluation_b8d4e1c2"
content = "In compare_partial_order_fallback operator synthesis fallback, E and F are evaluated only once."
formal_spec = "compare_partial_order_fallback(E, F) uses operator_fallback => evaluation_count(E) == 1 && evaluation_count(F) == 1"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.3"
tags = [ "comparison", "evaluation-semantics", "partial-ordering", "side-effects",]
function = "std::compare_partial_order_fallback"
header = "<compare>"
signature = "partial_ordering compare_partial_order_fallback(E, F)"

[[axioms]]
id = "cpp20_cmp_alg_compare_partial_order_fallback_final_ill_formed_c9e5f2d3"
content = "If neither partial_order nor three-operator synthesis are available, compare_partial_order_fallback(E, F) is ill-formed."
formal_spec = "!well_formed(partial_order(E, F)) && (!well_formed(E==F) || !well_formed(E<F) || !well_formed(F<E) || !boolean_testable<decltype(E==F)> || !boolean_testable<decltype(E<F)> || !boolean_testable<decltype(F<E)>) => ill_formed(compare_partial_order_fallback(E, F))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.4"
tags = [ "comparison", "customization-point", "partial-ordering", "substitution-failure",]
function = "std::compare_partial_order_fallback"
header = "<compare>"
signature = "partial_ordering compare_partial_order_fallback(E, F)"

[[axioms]]
id = "cpp20_func_require_invoke_reference_converts_ill_formed_a1b2c3d4"
content = "If reference_converts_from_temporary_v<R, decltype(INVOKE(f, t1, t2,..., tN))> is true, INVOKE<R>(f, t1, t2,..., tN) is ill-formed."
formal_spec = "reference_converts_from_temporary_v<R, decltype(INVOKE(f, t1, t2,..., tN))> == true => ill_formed(INVOKE<R>(f, t1, t2,..., tN))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.require"
source_module = "[func.require]/2"
tags = [ "invoke", "reference", "lifetime", "safety",]
function = "INVOKE"
header = "<functional>"
signature = "R INVOKE<R>(F f, Args... args)"
depends_on = [ "extract_precond_buffer_valid_storage_a8f3d2e1", "ilp_break_anti_pattern_destructor_bypass",]

[[axioms]]
id = "cpp20_func_invoke_constraint_invocable_e5f6a7b8"
content = "std::invoke requires is_invocable_v<F, Args...> to be true."
formal_spec = "call(std::invoke<F, Args...>) => requires(is_invocable_v<F, Args...> == true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/1"
tags = [ "invoke", "constraint", "concepts",]
function = "std::invoke"
header = "<functional>"
signature = "invoke_result_t<F, Args...> std::invoke(F&& f, Args&&... args)"
depends_on = [ "for_loop_typed_auto_constraint_f_callable_d4e5f6a7",]

[[axioms]]
id = "cpp20_func_invoke_r_constraint_invocable_r_d9e0f1a2"
content = "std::invoke_r requires is_invocable_r_v<R, F, Args...> to be true."
formal_spec = "call(std::invoke_r<R, F, Args...>) => requires(is_invocable_r_v<R, F, Args...> == true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/3"
tags = [ "invoke", "constraint", "concepts",]
function = "std::invoke_r"
header = "<functional>"
signature = "R std::invoke_r(F&& f, Args&&... args)"
depends_on = [ "for_loop_typed_auto_constraint_f_callable_d4e5f6a7",]

[[axioms]]
id = "cpp20_refwrap_const_constraint_not_self_b3c4d5e6"
content = "reference_wrapper<T> constructor from U&& requires is_same_v<remove_cvref_t<U>, reference_wrapper> to be false."
formal_spec = "call(reference_wrapper<T>::reference_wrapper(U&&)) => requires(is_same_v<remove_cvref_t<U>, reference_wrapper> == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.const"
source_module = "[refwrap.const]/2"
tags = [ "reference_wrapper", "constraint", "constructor",]
function = "std::reference_wrapper::reference_wrapper"
header = "<functional>"
signature = "reference_wrapper<T>::reference_wrapper(U&& u)"
depends_on = [ "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3",]

[[axioms]]
id = "cpp20_refwrap_const_constraint_fun_well_formed_a7b8c9d0"
content = "reference_wrapper<T> constructor from U&& requires FUN(declval<U>()) to be well-formed, where FUN is void FUN(T&) noexcept; void FUN(T&&) = delete;"
formal_spec = "call(reference_wrapper<T>::reference_wrapper(U&&)) => requires(well_formed(FUN(declval<U>())) && FUN == {void FUN(T&) noexcept; void FUN(T&&) = delete;})"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.const"
source_module = "[refwrap.const]/2"
tags = [ "reference_wrapper", "constraint", "constructor", "reference",]
function = "std::reference_wrapper::reference_wrapper"
header = "<functional>"
signature = "reference_wrapper<T>::reference_wrapper(U&& u)"
depends_on = [ "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3", "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6",]

[[axioms]]
id = "cpp20_refwrap_invoke_mandate_t_complete_c5d6e7f8"
content = "reference_wrapper<T>::operator() mandates that T is a complete type."
formal_spec = "call(reference_wrapper<T>::operator()(ArgTypes&&... args)) => mandates(is_complete_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.invoke"
source_module = "[refwrap.invoke]/1"
tags = [ "reference_wrapper", "invoke", "mandate", "complete_type",]
function = "std::reference_wrapper::operator()"
header = "<functional>"
signature = "invoke_result_t<T&, ArgTypes...> std::reference_wrapper<T>::operator()(ArgTypes&&... args) const"
depends_on = [ "for_loop_typed_auto_constraint_f_callable_d4e5f6a7",]

[[axioms]]
id = "cpp20_refwrap_comparisons_constraint_expr_well_formed_f1a2b3c4"
content = "reference_wrapper operator== comparison requires x.get() == y.get() to be well-formed and convertible to bool."
formal_spec = "call(operator==(reference_wrapper x, reference_wrapper y)) => requires(well_formed(x.get() == y.get()) && convertible_to<decltype(x.get() == y.get()), bool>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/1"
tags = [ "reference_wrapper", "comparison", "constraint",]
function = "std::operator=="
header = "<functional>"
signature = "bool std::operator==(reference_wrapper<T> x, reference_wrapper<T> y)"

[[axioms]]
id = "cpp20_refwrap_comparisons_const_t_constraint_e9f0a1b2"
content = "reference_wrapper operator==(reference_wrapper, const T&) requires x.get() == y to be well-formed and convertible to bool."
formal_spec = "call(operator==(reference_wrapper x, const T& y)) => requires(well_formed(x.get() == y) && convertible_to<decltype(x.get() == y), bool>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/3"
tags = [ "reference_wrapper", "comparison", "constraint",]
function = "std::operator=="
header = "<functional>"
signature = "bool std::operator==(reference_wrapper<T> x, const T& y)"

[[axioms]]
id = "cpp20_refwrap_comparisons_const_ref_constraint_d3e4f5a6"
content = "reference_wrapper operator==(reference_wrapper<T>, reference_wrapper<const T>) requires is_const_v<T> to be false and x.get() == y.get() to be well-formed and convertible to bool."
formal_spec = "call(operator==(reference_wrapper<T> x, reference_wrapper<const T> y)) => requires(is_const_v<T> == false && well_formed(x.get() == y.get()) && convertible_to<decltype(x.get() == y.get()), bool>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/5"
tags = [ "reference_wrapper", "comparison", "constraint", "cv_qualifier",]
function = "std::operator=="
header = "<functional>"
signature = "bool std::operator==(reference_wrapper<T> x, reference_wrapper<const T> y)"

[[axioms]]
id = "cpp20_refwrap_comparisons_spaceship_constraint_b7c8d9e0"
content = "reference_wrapper operator<=>(reference_wrapper, reference_wrapper) requires synth-three-way(x.get(), y.get()) to be well-formed."
formal_spec = "call(operator<=>(reference_wrapper x, reference_wrapper y)) => requires(well_formed(synth-three-way(x.get(), y.get())))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/7"
tags = [ "reference_wrapper", "comparison", "three_way", "constraint",]
function = "std::operator<=>"
header = "<functional>"
signature = "auto std::operator<=>(reference_wrapper<T> x, reference_wrapper<T> y)"

[[axioms]]
id = "cpp20_refwrap_comparisons_spaceship_const_t_a5b6c7d8"
content = "reference_wrapper operator<=>(reference_wrapper, const T&) requires synth-three-way(x.get(), y) to be well-formed."
formal_spec = "call(operator<=>(reference_wrapper x, const T& y)) => requires(well_formed(synth-three-way(x.get(), y)))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/9"
tags = [ "reference_wrapper", "comparison", "three_way", "constraint",]
function = "std::operator<=>"
header = "<functional>"
signature = "auto std::operator<=>(reference_wrapper<T> x, const T& y)"

[[axioms]]
id = "cpp20_refwrap_comparisons_spaceship_const_ref_e1f2a3b4"
content = "reference_wrapper operator<=>(reference_wrapper<T>, reference_wrapper<const T>) requires is_const_v<T> to be false and synth-three-way(x.get(), y.get()) to be well-formed."
formal_spec = "call(operator<=>(reference_wrapper<T> x, reference_wrapper<const T> y)) => requires(is_const_v<T> == false && well_formed(synth-three-way(x.get(), y.get())))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/11"
tags = [ "reference_wrapper", "comparison", "three_way", "constraint", "cv_qualifier",]
function = "std::operator<=>"
header = "<functional>"
signature = "auto std::operator<=>(reference_wrapper<T> x, reference_wrapper<const T> y)"

[[axioms]]
id = "cpp20_comparisons_pointer_strict_total_order_c9d0e1f2"
content = "For comparison function object templates less, greater, less_equal, and greater_equal, specializations for pointer types yield results consistent with the implementation-defined strict total order over pointers."
formal_spec = "is_pointer_v<P> && (specialized(less<P>) || specialized(greater<P>) || specialized(less_equal<P>) || specialized(greater_equal<P>)) => result_consistent_with(implementation_defined_strict_total_order_over_pointers)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.general"
source_module = "[comparisons.general]/2"
tags = [ "comparison", "pointer", "total_order", "implementation_defined",]
function = "std::less"
header = "<functional>"
signature = "bool std::less<P>::operator()(const P& x, const P& y) const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1", "extract_precond_buffer_non_null_b7c8d9e0",]

[[axioms]]
id = "cpp20_comparisons_void_spec_pointer_order_a7b8c9d0"
content = "For comparison function objects less<void>, greater<void>, less_equal<void>, and greater_equal<void>, if the call operator calls a built-in operator comparing pointers, the result is consistent with the implementation-defined strict total order over pointers."
formal_spec = "(specialized(less<void>) || specialized(greater<void>) || specialized(less_equal<void>) || specialized(greater_equal<void>)) && calls_builtin_operator_on_pointers(call_operator) => result_consistent_with(implementation_defined_strict_total_order_over_pointers)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.general"
source_module = "[comparisons.general]/2"
tags = [ "comparison", "pointer", "total_order", "implementation_defined", "void_specialization",]
function = "std::less<void>"
header = "<functional>"
signature = "auto std::less<void>::operator()(T&& t, U&& u) const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_compare_three_way_constraint_comparable_e5f6a7b8"
content = "std::compare_three_way::operator() requires T and U to satisfy three_way_comparable_with."
formal_spec = "call(std::compare_three_way::operator()(T&& t, U&& u)) => requires(three_way_comparable_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.three.way"
source_module = "[comparisons.three.way]/1"
tags = [ "comparison", "three_way", "constraint", "concepts",]
function = "std::compare_three_way::operator()"
header = "<functional>"
signature = "auto std::compare_three_way::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_compare_three_way_precond_pointer_equality_preserving_d1e2f3a4"
content = "std::compare_three_way::operator() precondition: If the expression results in a call to a built-in operator<=> comparing pointers of type P, the conversion sequences from both T and U to P must be equality-preserving; otherwise, T and U model three_way_comparable_with."
formal_spec = "builtin_operator_spaceship_on_pointers(std::forward<T>(t) <=> std::forward<U>(u), P) => requires(equality_preserving(conversion_sequence(T, P)) && equality_preserving(conversion_sequence(U, P))) || model(three_way_comparable_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.three.way"
source_module = "[comparisons.three.way]/2"
tags = [ "comparison", "three_way", "precondition", "pointer", "equality_preserving",]
function = "std::compare_three_way::operator()"
header = "<functional>"
signature = "auto std::compare_three_way::operator()(T&& t, U&& u) const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1", "extract_precond_buffer_alignment_e3d9a1f5",]

[[axioms]]
id = "cpp20_ranges_equal_to_constraint_comparable_b9c0d1e2"
content = "std::ranges::equal_to::operator() requires T and U to satisfy equality_comparable_with."
formal_spec = "call(std::ranges::equal_to::operator()(T&& t, U&& u)) => requires(equality_comparable_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/1"
tags = [ "comparison", "ranges", "constraint", "concepts",]
function = "std::ranges::equal_to::operator()"
header = "<functional>"
signature = "bool std::ranges::equal_to::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_equal_to_precond_pointer_equality_preserving_f3a4b5c6"
content = "std::ranges::equal_to::operator() precondition: If the expression results in a call to a built-in operator== comparing pointers of type P, the conversion sequences from both T and U to P must be equality-preserving; otherwise, T and U model equality_comparable_with."
formal_spec = "builtin_operator_eq_on_pointers(std::forward<T>(t) == std::forward<U>(u), P) => requires(equality_preserving(conversion_sequence(T, P)) && equality_preserving(conversion_sequence(U, P))) || model(equality_comparable_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/2"
tags = [ "comparison", "ranges", "precondition", "pointer", "equality_preserving",]
function = "std::ranges::equal_to::operator()"
header = "<functional>"
signature = "bool std::ranges::equal_to::operator()(T&& t, U&& u) const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_ranges_not_equal_to_constraint_comparable_a7b8c9d0"
content = "std::ranges::not_equal_to::operator() requires T and U to satisfy equality_comparable_with."
formal_spec = "call(std::ranges::not_equal_to::operator()(T&& t, U&& u)) => requires(equality_comparable_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/4"
tags = [ "comparison", "ranges", "constraint", "concepts",]
function = "std::ranges::not_equal_to::operator()"
header = "<functional>"
signature = "bool std::ranges::not_equal_to::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_greater_constraint_totally_ordered_e1f2a3b4"
content = "std::ranges::greater::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(std::ranges::greater::operator()(T&& t, U&& u)) => requires(totally_ordered_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/6"
tags = [ "comparison", "ranges", "constraint", "concepts", "total_order",]
function = "std::ranges::greater::operator()"
header = "<functional>"
signature = "bool std::ranges::greater::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_less_constraint_totally_ordered_c5d6e7f8"
content = "std::ranges::less::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(std::ranges::less::operator()(T&& t, U&& u)) => requires(totally_ordered_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/8"
tags = [ "comparison", "ranges", "constraint", "concepts", "total_order",]
function = "std::ranges::less::operator()"
header = "<functional>"
signature = "bool std::ranges::less::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_less_precond_pointer_equality_preserving_b3c4d5e6"
content = "std::ranges::less::operator() precondition: If the expression results in a call to a built-in operator< comparing pointers of type P, the conversion sequences from both T and U to P must be equality-preserving; otherwise, T and U model totally_ordered_with."
formal_spec = "builtin_operator_less_on_pointers(std::forward<T>(t) < std::forward<U>(u), P) => requires(equality_preserving(conversion_sequence(T, P)) && equality_preserving(conversion_sequence(U, P))) || model(totally_ordered_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/9"
tags = [ "comparison", "ranges", "precondition", "pointer", "equality_preserving",]
function = "std::ranges::less::operator()"
header = "<functional>"
signature = "bool std::ranges::less::operator()(T&& t, U&& u) const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_ranges_less_precond_trichotomy_a9b0c1d2"
content = "std::ranges::less::operator() precondition: For any expressions ET and EU such that decltype((ET)) is T and decltype((EU)) is U, exactly one of ranges::less{}(ET, EU), ranges::less{}(EU, ET), or ranges::equal_to{}(ET, EU) is true."
formal_spec = "forall ET, EU: (decltype((ET)) == T && decltype((EU)) == U) => exactly_one_true(ranges::less{}(ET, EU), ranges::less{}(EU, ET), ranges::equal_to{}(ET, EU))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/9"
tags = [ "comparison", "ranges", "precondition", "trichotomy", "total_order",]
function = "std::ranges::less::operator()"
header = "<functional>"
signature = "bool std::ranges::less::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_greater_equal_constraint_totally_ordered_f7a8b9c0"
content = "std::ranges::greater_equal::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(std::ranges::greater_equal::operator()(T&& t, U&& u)) => requires(totally_ordered_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/11"
tags = [ "comparison", "ranges", "constraint", "concepts", "total_order",]
function = "std::ranges::greater_equal::operator()"
header = "<functional>"
signature = "bool std::ranges::greater_equal::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_less_equal_constraint_totally_ordered_d3e4f5a6"
content = "std::ranges::less_equal::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(std::ranges::less_equal::operator()(T&& t, U&& u)) => requires(totally_ordered_with<T, U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/13"
tags = [ "comparison", "ranges", "constraint", "concepts", "total_order",]
function = "std::ranges::less_equal::operator()"
header = "<functional>"
signature = "bool std::ranges::less_equal::operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_time_duration_rep_not_duration_8a3f2d91"
content = "If duration is instantiated with a duration type as the argument for the template parameter Rep, the program is ill-formed."
formal_spec = "is_specialization<Rep, duration> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.general"
source_module = "[time.duration.general]/2"
tags = [ "duration", "template", "constraint", "ill-formed",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_duration_period_must_be_ratio_7b4e1c82"
content = "If Period is not a specialization of ratio, the program is ill-formed."
formal_spec = "!is_specialization<Period, ratio> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.general"
source_module = "[time.duration.general]/3"
tags = [ "duration", "template", "constraint", "ill-formed",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_duration_period_num_positive_9c2d5f73"
content = "If Period::num is not positive, the program is ill-formed."
formal_spec = "Period::num <= 0 => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.general"
source_module = "[time.duration.general]/3"
tags = [ "duration", "template", "constraint", "ill-formed",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_duration_rep_arithmetic_6d8a3e92"
content = "Rep shall be an arithmetic type or a class emulating an arithmetic type."
formal_spec = "is_arithmetic_v<Rep> || emulates_arithmetic<Rep>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.general"
source_module = "[time.duration.general]/2"
tags = [ "duration", "template", "constraint",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_duration_cons_rep2_constraint_3f7b9d21"
content = "duration(const Rep2& r) requires is_convertible_v<const Rep2&, rep> is true and either treat_as_floating_point_v<rep> is true or treat_as_floating_point_v<Rep2> is false."
formal_spec = "!is_convertible_v<const Rep2&, rep> || (!treat_as_floating_point_v<rep> && treat_as_floating_point_v<Rep2>) => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cons"
source_module = "[time.duration.cons]/1"
tags = [ "duration", "constructor", "constraint", "conversion",]
function = "std::chrono::duration::duration"
header = "<chrono>"
signature = "std::chrono::duration<Rep, Period>::duration(const Rep2& r)"

[[axioms]]
id = "cpp20_time_duration_cons_duration_constraint_8e4c2a61"
content = "duration(const duration<Rep2, Period2>& d) requires is_convertible_v<const Rep2&, rep> is true, ratio_divide<Period2::type, period> is valid, and either treat_as_floating_point_v<rep> is true or (ratio_divide<Period2, period>::den is 1 and treat_as_floating_point_v<Rep2> is false)."
formal_spec = "!is_convertible_v<const Rep2&, rep> || !valid_ratio_divide<Period2::type, period> || (!treat_as_floating_point_v<rep> && (ratio_divide<Period2, period>::den != 1 || treat_as_floating_point_v<Rep2>)) => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cons"
source_module = "[time.duration.cons]/3"
tags = [ "duration", "constructor", "constraint", "conversion", "truncation",]
function = "std::chrono::duration::duration"
header = "<chrono>"
signature = "std::chrono::duration<Rep, Period>::duration(const std::chrono::duration<Rep2, Period2>& d)"

[[axioms]]
id = "cpp20_time_duration_count_returns_rep_5a9f7b32"
content = "count() returns the internal representation rep_."
formal_spec = "count() == rep_"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.observer"
source_module = "[time.duration.observer]/1"
tags = [ "duration", "observer", "postcondition",]
function = "std::chrono::duration::count"
header = "<chrono>"
signature = "rep std::chrono::duration<Rep, Period>::count() const"

[[axioms]]
id = "cpp20_time_duration_cast_constraint_2d4e8c71"
content = "duration_cast<ToDuration> requires ToDuration is a specialization of duration."
formal_spec = "!is_specialization<ToDuration, duration> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/1"
tags = [ "duration", "conversion", "constraint",]
function = "std::chrono::duration_cast"
header = "<chrono>"
signature = "ToDuration std::chrono::duration_cast(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_floor_constraint_6f3a9e82"
content = "floor<ToDuration> requires ToDuration is a specialization of duration."
formal_spec = "!is_specialization<ToDuration, duration> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/4"
tags = [ "duration", "conversion", "constraint", "rounding",]
function = "std::chrono::floor"
header = "<chrono>"
signature = "ToDuration std::chrono::floor(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_ceil_constraint_7a2b5d93"
content = "ceil<ToDuration> requires ToDuration is a specialization of duration."
formal_spec = "!is_specialization<ToDuration, duration> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/6"
tags = [ "duration", "conversion", "constraint", "rounding",]
function = "std::chrono::ceil"
header = "<chrono>"
signature = "ToDuration std::chrono::ceil(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_round_constraint_4c8e1f72"
content = "round<ToDuration> requires ToDuration is a specialization of duration and treat_as_floating_point_v<typename ToDuration::rep> is false."
formal_spec = "!is_specialization<ToDuration, duration> || treat_as_floating_point_v<typename ToDuration::rep> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/8"
tags = [ "duration", "conversion", "constraint", "rounding",]
function = "std::chrono::round"
header = "<chrono>"
signature = "ToDuration std::chrono::round(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_literal_overflow_9b5d2e83"
content = "If any duration literal suffix (h, min, s, ms, us, ns) is applied to an integer-literal and the resulting chrono::duration value cannot be represented in the result type because of overflow, the program is ill-formed."
formal_spec = "integer_literal_suffix(h|min|s|ms|us|ns) && overflow(result_type) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/3"
tags = [ "duration", "literal", "overflow", "ill-formed",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_duration_abs_constraint_3e7a9c42"
content = "abs(duration<Rep, Period> d) requires numeric_limits<Rep>::is_signed is true."
formal_spec = "!numeric_limits<Rep>::is_signed => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.alg"
source_module = "[time.duration.alg]/1"
tags = [ "duration", "algorithm", "constraint", "signed",]
function = "std::chrono::abs"
header = "<chrono>"
signature = "std::chrono::duration<Rep, Period> std::chrono::abs(std::chrono::duration<Rep, Period> d)"

[[axioms]]
id = "cpp20_time_duration_operator_mult_rep2_constraint_5d8f3a91"
content = "operator*(const duration<Rep1, Period>& d, const Rep2& s) requires is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true."
formal_spec = "!is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.nonmember"
source_module = "[time.duration.nonmember]/4"
tags = [ "duration", "arithmetic", "constraint", "multiplication",]
function = "std::chrono::operator*"
header = "<chrono>"
signature = "std::chrono::duration<common_type_t<Rep1, Rep2>, Period> std::chrono::operator*(const std::chrono::duration<Rep1, Period>& d, const Rep2& s)"

[[axioms]]
id = "cpp20_time_duration_operator_mult_rep1_constraint_6c2e9f84"
content = "operator*(const Rep1& s, const duration<Rep2, Period>& d) requires is_convertible_v<const Rep1&, common_type_t<Rep1, Rep2>> is true."
formal_spec = "!is_convertible_v<const Rep1&, common_type_t<Rep1, Rep2>> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.nonmember"
source_module = "[time.duration.nonmember]/6"
tags = [ "duration", "arithmetic", "constraint", "multiplication",]
function = "std::chrono::operator*"
header = "<chrono>"
signature = "std::chrono::duration<common_type_t<Rep1, Rep2>, Period> std::chrono::operator*(const Rep1& s, const std::chrono::duration<Rep2, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_operator_div_rep2_constraint_7b4d1a92"
content = "operator/(const duration<Rep1, Period>& d, const Rep2& s) requires is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true and Rep2 is not a specialization of duration."
formal_spec = "!is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> || is_specialization<Rep2, duration> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.nonmember"
source_module = "[time.duration.nonmember]/8"
tags = [ "duration", "arithmetic", "constraint", "division",]
function = "std::chrono::operator/"
header = "<chrono>"
signature = "std::chrono::duration<common_type_t<Rep1, Rep2>, Period> std::chrono::operator/(const std::chrono::duration<Rep1, Period>& d, const Rep2& s)"

[[axioms]]
id = "cpp20_time_duration_operator_mod_rep2_constraint_8a5e2c73"
content = "operator%(const duration<Rep1, Period>& d, const Rep2& s) requires is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true and Rep2 is not a specialization of duration."
formal_spec = "!is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> || is_specialization<Rep2, duration> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.nonmember"
source_module = "[time.duration.nonmember]/12"
tags = [ "duration", "arithmetic", "constraint", "modulo",]
function = "std::chrono::operator%"
header = "<chrono>"
signature = "std::chrono::duration<common_type_t<Rep1, Rep2>, Period> std::chrono::operator%(const std::chrono::duration<Rep1, Period>& d, const Rep2& s)"

[[axioms]]
id = "cpp20_time_duration_spaceship_constraint_9c6f4d81"
content = "operator<=>(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs) requires three_way_comparable<typename CT::rep>."
formal_spec = "!three_way_comparable<typename CT::rep> => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.comparisons"
source_module = "[time.duration.comparisons]/7"
tags = [ "duration", "comparison", "constraint", "spaceship",]
function = "std::chrono::operator<=>"
header = "<chrono>"
signature = "auto std::chrono::operator<=>(const std::chrono::duration<Rep1, Period1>& lhs, const std::chrono::duration<Rep2, Period2>& rhs)"

[[axioms]]
id = "cpp20_time_duration_cons_truncation_prevention_4f9b7e31"
content = "The duration constructor from duration<Rep2, Period2> prevents implicit truncation errors when converting between integral-based duration types by requiring ratio_divide<Period2, period>::den is 1 when both are integral."
formal_spec = "is_integral<rep> && is_integral<Rep2> && ratio_divide<Period2, period>::den != 1 => constraint_not_satisfied"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "time.duration.cons"
source_module = "[time.duration.cons]/3"
tags = [ "duration", "constructor", "truncation", "safety",]
function = "std::chrono::duration::duration"
header = "<chrono>"
signature = "std::chrono::duration<Rep, Period>::duration(const std::chrono::duration<Rep2, Period2>& d)"

[[axioms]]
id = "cpp20_time_duration_floor_postcond_greatest_2e8a5d93"
content = "floor<ToDuration>(d) returns the greatest result t representable in ToDuration for which t <= d."
formal_spec = "result = max({t | t in ToDuration && t <= d})"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/5"
tags = [ "duration", "conversion", "postcondition", "rounding",]
function = "std::chrono::floor"
header = "<chrono>"
signature = "ToDuration std::chrono::floor(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_ceil_postcond_least_7c3f9a42"
content = "ceil<ToDuration>(d) returns the least result t representable in ToDuration for which t >= d."
formal_spec = "result = min({t | t in ToDuration && t >= d})"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/7"
tags = [ "duration", "conversion", "postcondition", "rounding",]
function = "std::chrono::ceil"
header = "<chrono>"
signature = "ToDuration std::chrono::ceil(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_round_postcond_closest_9a4e7b82"
content = "round<ToDuration>(d) returns the value of ToDuration that is closest to d. If there are two closest values, then return the value t for which t % 2 == 0."
formal_spec = "result = argmin_{t in ToDuration}(|t - d|) with tiebreak (t % 2 == 0)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.cast"
source_module = "[time.duration.cast]/9"
tags = [ "duration", "conversion", "postcondition", "rounding",]
function = "std::chrono::round"
header = "<chrono>"
signature = "ToDuration std::chrono::round(const std::chrono::duration<Rep, Period>& d)"

[[axioms]]
id = "cpp20_time_duration_abs_postcond_5b8c2f91"
content = "abs(d) returns d if d >= d.zero(), otherwise returns -d."
formal_spec = "result = (d >= d.zero()) ? d : -d"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.alg"
source_module = "[time.duration.alg]/2"
tags = [ "duration", "algorithm", "postcondition",]
function = "std::chrono::abs"
header = "<chrono>"
signature = "std::chrono::duration<Rep, Period> std::chrono::abs(std::chrono::duration<Rep, Period> d)"

[[axioms]]
id = "cpp20_time_duration_zero_postcond_3d7f9a21"
content = "duration::zero() returns duration(duration_values<rep>::zero())."
formal_spec = "zero() == duration(duration_values<rep>::zero())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.special"
source_module = "[time.duration.special]/1"
tags = [ "duration", "special-value", "postcondition",]
function = "std::chrono::duration::zero"
header = "<chrono>"
signature = "static constexpr std::chrono::duration<Rep, Period> std::chrono::duration<Rep, Period>::zero() noexcept"

[[axioms]]
id = "cpp20_time_duration_min_postcond_6e4a8c72"
content = "duration::min() returns duration(duration_values<rep>::min())."
formal_spec = "min() == duration(duration_values<rep>::min())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.special"
source_module = "[time.duration.special]/2"
tags = [ "duration", "special-value", "postcondition",]
function = "std::chrono::duration::min"
header = "<chrono>"
signature = "static constexpr std::chrono::duration<Rep, Period> std::chrono::duration<Rep, Period>::min() noexcept"

[[axioms]]
id = "cpp20_time_duration_max_postcond_8f2b5d93"
content = "duration::max() returns duration(duration_values<rep>::max())."
formal_spec = "max() == duration(duration_values<rep>::max())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.special"
source_module = "[time.duration.special]/3"
tags = [ "duration", "special-value", "postcondition",]
function = "std::chrono::duration::max"
header = "<chrono>"
signature = "static constexpr std::chrono::duration<Rep, Period> std::chrono::duration<Rep, Period>::max() noexcept"

[[axioms]]
id = "cpp20_time_duration_operator_h_int_postcond_1a9c6e82"
content = "operator\"\"h(unsigned long long hours) returns a duration literal representing hours hours."
formal_spec = "operator\"\"h(hours) == chrono::hours(hours)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/5"
tags = [ "duration", "literal", "postcondition",]
function = "std::chrono::operator\"\"h"
header = "<chrono>"
signature = "constexpr std::chrono::hours std::chrono::operator\"\"h(unsigned long long hours)"

[[axioms]]
id = "cpp20_time_duration_operator_min_int_postcond_2b7d4f91"
content = "operator\"\"min(unsigned long long minutes) returns a duration literal representing minutes minutes."
formal_spec = "operator\"\"min(minutes) == chrono::minutes(minutes)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/6"
tags = [ "duration", "literal", "postcondition",]
function = "std::chrono::operator\"\"min"
header = "<chrono>"
signature = "constexpr std::chrono::minutes std::chrono::operator\"\"min(unsigned long long minutes)"

[[axioms]]
id = "cpp20_time_duration_operator_s_int_postcond_3c8e5a72"
content = "operator\"\"s(unsigned long long sec) returns a duration literal representing sec seconds."
formal_spec = "operator\"\"s(sec) == chrono::seconds(sec)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/7"
tags = [ "duration", "literal", "postcondition",]
function = "std::chrono::operator\"\"s"
header = "<chrono>"
signature = "constexpr std::chrono::seconds std::chrono::operator\"\"s(unsigned long long sec)"

[[axioms]]
id = "cpp20_time_duration_operator_ms_int_postcond_4d9f6b83"
content = "operator\"\"ms(unsigned long long msec) returns a duration literal representing msec milliseconds."
formal_spec = "operator\"\"ms(msec) == chrono::milliseconds(msec)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/9"
tags = [ "duration", "literal", "postcondition",]
function = "std::chrono::operator\"\"ms"
header = "<chrono>"
signature = "constexpr std::chrono::milliseconds std::chrono::operator\"\"ms(unsigned long long msec)"

[[axioms]]
id = "cpp20_time_duration_operator_us_int_postcond_5e0a7c94"
content = "operator\"\"us(unsigned long long usec) returns a duration literal representing usec microseconds."
formal_spec = "operator\"\"us(usec) == chrono::microseconds(usec)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/10"
tags = [ "duration", "literal", "postcondition",]
function = "std::chrono::operator\"\"us"
header = "<chrono>"
signature = "constexpr std::chrono::microseconds std::chrono::operator\"\"us(unsigned long long usec)"

[[axioms]]
id = "cpp20_time_duration_operator_ns_int_postcond_6f1b8d05"
content = "operator\"\"ns(unsigned long long nsec) returns a duration literal representing nsec nanoseconds."
formal_spec = "operator\"\"ns(nsec) == chrono::nanoseconds(nsec)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.literals"
source_module = "[time.duration.literals]/11"
tags = [ "duration", "literal", "postcondition",]
function = "std::chrono::operator\"\"ns"
header = "<chrono>"
signature = "constexpr std::chrono::nanoseconds std::chrono::operator\"\"ns(unsigned long long nsec)"

[[axioms]]
id = "cpp20_time_duration_copy_ctor_constexpr_7a2c9f84"
content = "The defaulted copy constructor of duration shall be a constexpr function if and only if the required initialization of the member rep_ for copy would be constexpr-suitable."
formal_spec = "is_constexpr(duration(const duration&)) <=> constexpr_suitable(rep_(other.rep_))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.general"
source_module = "[time.duration.general]/5"
tags = [ "duration", "constructor", "constexpr", "copy",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_duration_exceptions_from_rep_8b3d0e95"
content = "Members of duration do not throw exceptions other than those thrown by the indicated operations on their representations."
formal_spec = "exceptions(duration::op) subset_of exceptions(rep::corresponding_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.general"
source_module = "[time.duration.general]/4"
tags = [ "duration", "exception", "guarantee",]
header = "<chrono>"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_time_duration_from_stream_parse_failure_9c4e1f06"
content = "In from_stream, if the parse fails to decode a valid duration, is.setstate(ios_base::failbit) is called and d is not modified."
formal_spec = "parse_fails(is, fmt) => (is.setstate(ios_base::failbit) && d == d_old)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.duration.io"
source_module = "[time.duration.io]/3"
tags = [ "duration", "io", "parsing", "error-handling",]
function = "std::chrono::from_stream"
header = "<chrono>"
signature = "std::basic_istream<charT, traits>& std::chrono::from_stream(std::basic_istream<charT, traits>& is, const charT* fmt, std::chrono::duration<Rep, Period>& d, std::basic_string<charT, traits, Alloc>* abbrev, std::chrono::minutes* offset)"

[[axioms]]
id = "cpp20_time_point_general_duration_specialization_7a3f8c2e"
content = "If Duration template parameter is not a specialization of std::chrono::duration, the program is ill-formed."
formal_spec = "!is_specialization_of<Duration, duration> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.general"
source_module = "[time.point.general]/1"
tags = [ "template", "constraint", "duration", "ill-formed",]
header = "<chrono>"

[[axioms]]
id = "cpp20_time_point_cons_default_effect_epoch_4b9d2f1a"
content = "Default constructor initializes d_ with duration::zero(), representing the epoch."
formal_spec = "time_point() => d_ == duration::zero() && represents_epoch(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cons"
source_module = "[time.point.cons]/1"
tags = [ "constructor", "initialization", "epoch",]
function = "std::chrono::time_point::time_point"
header = "<chrono>"
signature = "constexpr std::chrono::time_point<Clock, Duration>::time_point()"

[[axioms]]
id = "cpp20_time_point_cons_duration_effect_epoch_plus_d_8c4e7a1b"
content = "Explicit constructor from duration d initializes d_ with d, representing epoch + d."
formal_spec = "time_point(d) => d_ == d && represents_time(*this, epoch + d)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cons"
source_module = "[time.point.cons]/2"
tags = [ "constructor", "initialization", "duration",]
function = "std::chrono::time_point::time_point"
header = "<chrono>"
signature = "constexpr explicit std::chrono::time_point<Clock, Duration>::time_point(const Duration& d)"

[[axioms]]
id = "cpp20_time_point_cons_conversion_constraint_9f2a5d3c"
content = "Converting constructor from time_point<clock, Duration2> requires is_convertible_v<Duration2, duration> to be true."
formal_spec = "time_point(time_point<clock, Duration2>) requires is_convertible_v<Duration2, duration>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cons"
source_module = "[time.point.cons]/3"
tags = [ "constructor", "constraint", "conversion", "template",]
function = "std::chrono::time_point::time_point"
header = "<chrono>"
signature = "template<class Duration2> constexpr std::chrono::time_point<Clock, Duration>::time_point(const time_point<clock, Duration2>& t)"

[[axioms]]
id = "cpp20_time_point_cons_conversion_effect_1e8b4c9f"
content = "Converting constructor initializes d_ with t.time_since_epoch()."
formal_spec = "time_point(t) => d_ == t.time_since_epoch()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cons"
source_module = "[time.point.cons]/4"
tags = [ "constructor", "initialization", "conversion",]
function = "std::chrono::time_point::time_point"
header = "<chrono>"
signature = "template<class Duration2> constexpr std::chrono::time_point<Clock, Duration>::time_point(const time_point<clock, Duration2>& t)"

[[axioms]]
id = "cpp20_time_point_observer_time_since_epoch_3d7f2a8e"
content = "time_since_epoch() returns d_, the duration since epoch."
formal_spec = "time_since_epoch() == d_"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.observer"
source_module = "[time.point.observer]/1"
tags = [ "observer", "getter", "duration",]
function = "std::chrono::time_point::time_since_epoch"
header = "<chrono>"
signature = "constexpr Duration std::chrono::time_point<Clock, Duration>::time_since_epoch() const"

[[axioms]]
id = "cpp20_time_point_arithmetic_pre_increment_5a9c3e7d"
content = "Pre-increment operator++ increments d_ and returns *this."
formal_spec = "operator++() => ++d_ && return *this"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.arithmetic"
source_module = "[time.point.arithmetic]/1-2"
tags = [ "arithmetic", "increment", "operator",]
function = "std::chrono::time_point::operator++"
header = "<chrono>"
signature = "constexpr time_point<Clock, Duration>& std::chrono::time_point<Clock, Duration>::operator++()"

[[axioms]]
id = "cpp20_time_point_arithmetic_post_increment_7f1d8b2c"
content = "Post-increment operator++(int) returns time_point{d_++}."
formal_spec = "operator++(int) => return time_point{d_++}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.arithmetic"
source_module = "[time.point.arithmetic]/3"
tags = [ "arithmetic", "increment", "operator",]
function = "std::chrono::time_point::operator++"
header = "<chrono>"
signature = "constexpr time_point<Clock, Duration> std::chrono::time_point<Clock, Duration>::operator++(int)"

[[axioms]]
id = "cpp20_time_point_arithmetic_pre_decrement_2e6a9f4b"
content = "Pre-decrement operator-- decrements d_ and returns *this."
formal_spec = "operator--() => --d_ && return *this"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.arithmetic"
source_module = "[time.point.arithmetic]/4-5"
tags = [ "arithmetic", "decrement", "operator",]
function = "std::chrono::time_point::operator--"
header = "<chrono>"
signature = "constexpr time_point<Clock, Duration>& std::chrono::time_point<Clock, Duration>::operator--()"

[[axioms]]
id = "cpp20_time_point_arithmetic_post_decrement_8c3d5a1f"
content = "Post-decrement operator--(int) returns time_point{d_--}."
formal_spec = "operator--(int) => return time_point{d_--}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.arithmetic"
source_module = "[time.point.arithmetic]/6"
tags = [ "arithmetic", "decrement", "operator",]
function = "std::chrono::time_point::operator--"
header = "<chrono>"
signature = "constexpr time_point<Clock, Duration> std::chrono::time_point<Clock, Duration>::operator--(int)"

[[axioms]]
id = "cpp20_time_point_arithmetic_plus_assign_4b8e2d9a"
content = "operator+=(d) adds d to d_ and returns *this."
formal_spec = "operator+=(d) => d_ += d && return *this"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.arithmetic"
source_module = "[time.point.arithmetic]/7-8"
tags = [ "arithmetic", "compound-assignment", "operator",]
function = "std::chrono::time_point::operator+="
header = "<chrono>"
signature = "constexpr time_point<Clock, Duration>& std::chrono::time_point<Clock, Duration>::operator+=(const Duration& d)"

[[axioms]]
id = "cpp20_time_point_arithmetic_minus_assign_9f3c7e1d"
content = "operator-=(d) subtracts d from d_ and returns *this."
formal_spec = "operator-=(d) => d_ -= d && return *this"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.arithmetic"
source_module = "[time.point.arithmetic]/9-10"
tags = [ "arithmetic", "compound-assignment", "operator",]
function = "std::chrono::time_point::operator-="
header = "<chrono>"
signature = "constexpr time_point<Clock, Duration>& std::chrono::time_point<Clock, Duration>::operator-=(const Duration& d)"

[[axioms]]
id = "cpp20_time_point_special_min_6d2f9a5c"
content = "min() returns time_point(duration::min()), representing the minimum representable time_point."
formal_spec = "min() == time_point(duration::min())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.special"
source_module = "[time.point.special]/1"
tags = [ "special-value", "min", "static",]
function = "std::chrono::time_point::min"
header = "<chrono>"
signature = "static constexpr time_point<Clock, Duration> std::chrono::time_point<Clock, Duration>::min() noexcept"

[[axioms]]
id = "cpp20_time_point_special_max_1a7e4b8f"
content = "max() returns time_point(duration::max()), representing the maximum representable time_point."
formal_spec = "max() == time_point(duration::max())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.special"
source_module = "[time.point.special]/2"
tags = [ "special-value", "max", "static",]
function = "std::chrono::time_point::max"
header = "<chrono>"
signature = "static constexpr time_point<Clock, Duration> std::chrono::time_point<Clock, Duration>::max() noexcept"

[[axioms]]
id = "cpp20_time_point_nonmember_add_duration_3e8d1c5f"
content = "operator+(time_point, duration) returns CT(lhs.time_since_epoch() + rhs) where CT is time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>."
formal_spec = "operator+(lhs, rhs) == CT(lhs.time_since_epoch() + rhs) where CT = time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.nonmember"
source_module = "[time.point.nonmember]/1"
tags = [ "arithmetic", "operator", "addition",]
function = "std::chrono::operator+"
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Rep2, class Period2> constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>> operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs)"

[[axioms]]
id = "cpp20_time_point_nonmember_add_commutative_7b4f2a9e"
content = "operator+(duration, time_point) returns rhs + lhs, providing commutative addition."
formal_spec = "operator+(lhs_duration, rhs_timepoint) == rhs_timepoint + lhs_duration"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.nonmember"
source_module = "[time.point.nonmember]/2"
tags = [ "arithmetic", "operator", "addition", "commutative",]
function = "std::chrono::operator+"
header = "<chrono>"
signature = "template<class Rep1, class Period1, class Clock, class Duration2> constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>> operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_nonmember_subtract_duration_5c9a3f7d"
content = "operator-(time_point, duration) returns CT(lhs.time_since_epoch() - rhs) where CT is time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>."
formal_spec = "operator-(lhs, rhs) == CT(lhs.time_since_epoch() - rhs) where CT = time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.nonmember"
source_module = "[time.point.nonmember]/3"
tags = [ "arithmetic", "operator", "subtraction",]
function = "std::chrono::operator-"
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Rep2, class Period2> constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>> operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs)"

[[axioms]]
id = "cpp20_time_point_nonmember_subtract_time_points_2f6d8e1a"
content = "operator-(time_point, time_point) returns lhs.time_since_epoch() - rhs.time_since_epoch() as common_type_t<Duration1, Duration2>."
formal_spec = "operator-(lhs, rhs) == lhs.time_since_epoch() - rhs.time_since_epoch()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.nonmember"
source_module = "[time.point.nonmember]/4"
tags = [ "arithmetic", "operator", "subtraction", "duration",]
function = "std::chrono::operator-"
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Duration2> constexpr common_type_t<Duration1, Duration2> operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_comparisons_equal_9a3e7c1f"
content = "operator==(time_point, time_point) returns lhs.time_since_epoch() == rhs.time_since_epoch()."
formal_spec = "operator==(lhs, rhs) == (lhs.time_since_epoch() == rhs.time_since_epoch())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.comparisons"
source_module = "[time.point.comparisons]/1"
tags = [ "comparison", "operator", "equality",]
function = "std::chrono::operator=="
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Duration2> constexpr bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_comparisons_less_4e8b2d5a"
content = "operator<(time_point, time_point) returns lhs.time_since_epoch() < rhs.time_since_epoch()."
formal_spec = "operator<(lhs, rhs) == (lhs.time_since_epoch() < rhs.time_since_epoch())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.comparisons"
source_module = "[time.point.comparisons]/2"
tags = [ "comparison", "operator", "ordering",]
function = "std::chrono::operator<"
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Duration2> constexpr bool operator<(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_comparisons_greater_7c1f9a3e"
content = "operator>(time_point, time_point) returns rhs < lhs."
formal_spec = "operator>(lhs, rhs) == (rhs < lhs)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.comparisons"
source_module = "[time.point.comparisons]/3"
tags = [ "comparison", "operator", "ordering",]
function = "std::chrono::operator>"
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Duration2> constexpr bool operator>(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_comparisons_less_equal_2d5a8e4b"
content = "operator<=(time_point, time_point) returns !(rhs < lhs)."
formal_spec = "operator<=(lhs, rhs) == !(rhs < lhs)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.comparisons"
source_module = "[time.point.comparisons]/4"
tags = [ "comparison", "operator", "ordering",]
function = "std::chrono::operator<="
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Duration2> constexpr bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_comparisons_greater_equal_6f9c3a7d"
content = "operator>=(time_point, time_point) returns !(lhs < rhs)."
formal_spec = "operator>=(lhs, rhs) == !(lhs < rhs)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.comparisons"
source_module = "[time.point.comparisons]/5"
tags = [ "comparison", "operator", "ordering",]
function = "std::chrono::operator>="
header = "<chrono>"
signature = "template<class Clock, class Duration1, class Duration2> constexpr bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_comparisons_three_way_1e7d4b9f"
content = "operator<=>(time_point, time_point) returns lhs.time_since_epoch() <=> rhs.time_since_epoch() when Duration2 is three_way_comparable_with Duration1."
formal_spec = "three_way_comparable_with<Duration1, Duration2> && operator<=>(lhs, rhs) == (lhs.time_since_epoch() <=> rhs.time_since_epoch())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.comparisons"
source_module = "[time.point.comparisons]/6"
tags = [ "comparison", "operator", "three-way", "spaceship",]
function = "std::chrono::operator<=>"
header = "<chrono>"
signature = "template<class Clock, class Duration1, three_way_comparable_with<Duration1> Duration2> constexpr auto operator<=>(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs)"

[[axioms]]
id = "cpp20_time_point_cast_constraint_duration_specialization_8a4f2e6c"
content = "time_point_cast requires ToDuration to be a specialization of duration."
formal_spec = "time_point_cast<ToDuration>(...) requires is_specialization_of<ToDuration, duration>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/1"
tags = [ "conversion", "constraint", "template",]
function = "std::chrono::time_point_cast"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t)"

[[axioms]]
id = "cpp20_time_point_cast_effect_duration_cast_3c9e5a1d"
content = "time_point_cast returns time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))."
formal_spec = "time_point_cast<ToDuration>(t) == time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/2"
tags = [ "conversion", "duration-cast",]
function = "std::chrono::time_point_cast"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t)"

[[axioms]]
id = "cpp20_time_point_floor_constraint_duration_specialization_7e2a9f4b"
content = "floor requires ToDuration to be a specialization of duration."
formal_spec = "floor<ToDuration>(...) requires is_specialization_of<ToDuration, duration>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/3"
tags = [ "conversion", "constraint", "rounding",]
function = "std::chrono::floor"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_point_floor_effect_5d8c1f3a"
content = "floor returns time_point<Clock, ToDuration>(floor<ToDuration>(tp.time_since_epoch()))."
formal_spec = "floor<ToDuration>(tp) == time_point<Clock, ToDuration>(floor<ToDuration>(tp.time_since_epoch()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/4"
tags = [ "conversion", "rounding", "floor",]
function = "std::chrono::floor"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_point_ceil_constraint_duration_specialization_9b3e6d2f"
content = "ceil requires ToDuration to be a specialization of duration."
formal_spec = "ceil<ToDuration>(...) requires is_specialization_of<ToDuration, duration>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/5"
tags = [ "conversion", "constraint", "rounding",]
function = "std::chrono::ceil"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_point_ceil_effect_4a7e2c8d"
content = "ceil returns time_point<Clock, ToDuration>(ceil<ToDuration>(tp.time_since_epoch()))."
formal_spec = "ceil<ToDuration>(tp) == time_point<Clock, ToDuration>(ceil<ToDuration>(tp.time_since_epoch()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/6"
tags = [ "conversion", "rounding", "ceil",]
function = "std::chrono::ceil"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_point_round_constraint_duration_specialization_6f1d9a3e"
content = "round requires ToDuration to be a specialization of duration."
formal_spec = "round<ToDuration>(...) requires is_specialization_of<ToDuration, duration>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/7"
tags = [ "conversion", "constraint", "rounding",]
function = "std::chrono::round"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_point_round_constraint_integral_rep_2c5e8f4a"
content = "round requires treat_as_floating_point_v<typename ToDuration::rep> to be false."
formal_spec = "round<ToDuration>(...) requires !treat_as_floating_point_v<typename ToDuration::rep>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/7"
tags = [ "conversion", "constraint", "rounding", "integral",]
function = "std::chrono::round"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_point_round_effect_8d3a7f1c"
content = "round returns time_point<Clock, ToDuration>(round<ToDuration>(tp.time_since_epoch()))."
formal_spec = "round<ToDuration>(tp) == time_point<Clock, ToDuration>(round<ToDuration>(tp.time_since_epoch()))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.point.cast"
source_module = "[time.point.cast]/8"
tags = [ "conversion", "rounding", "round",]
function = "std::chrono::round"
header = "<chrono>"
signature = "template<class ToDuration, class Clock, class Duration> constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp)"

[[axioms]]
id = "cpp20_time_cal_day_ctor_truncation_f4a8b2c1"
content = "Constructing day with unsigned value d outside range [0,255] results in unspecified value held in internal storage"
formal_spec = "day(unsigned d) && d > 255 => unspecified(d_)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.day"
source_module = "[time.cal.day.members]/1"
tags = [ "truncation", "initialization", "unspecified",]
function = "std::chrono::day::day"
header = "<chrono>"
signature = "explicit constexpr day(unsigned d) noexcept"

[[axioms]]
id = "cpp20_time_cal_day_ok_range_a5f7c3d1"
content = "day::ok() returns true if and only if the internal value d_ is in range [1,31]"
formal_spec = "day.ok() <=> (1 <= d_ && d_ <= 31)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.day"
source_module = "[time.cal.day.members]/15"
tags = [ "validity", "range",]
function = "std::chrono::day::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_month_ctor_truncation_b7c8d9e0"
content = "Constructing month with unsigned value m outside range [0,255] results in unspecified value held in internal storage"
formal_spec = "month(unsigned m) && m > 255 => unspecified(m_)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.month"
source_module = "[time.cal.month.members]/1"
tags = [ "truncation", "initialization", "unspecified",]
function = "std::chrono::month::month"
header = "<chrono>"
signature = "explicit constexpr month(unsigned m) noexcept"

[[axioms]]
id = "cpp20_time_cal_month_ok_range_c8d9e0f1"
content = "month::ok() returns true if and only if the internal value m_ is in range [1,12]"
formal_spec = "month.ok() <=> (1 <= m_ && m_ <= 12)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.month"
source_module = "[time.cal.month.members]/15"
tags = [ "validity", "range",]
function = "std::chrono::month::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_month_add_euclidean_d9e0f1a2"
content = "month addition uses Euclidean division modulo 12, always producing result in range [1,12] even if !x.ok()"
formal_spec = "month(x) + months(y) => month{modulo(unsigned{x} + (y.count() - 1), 12) + 1} where modulo uses Euclidean division with range [0,11]"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.month"
source_module = "[time.cal.month.nonmembers]/3"
tags = [ "arithmetic", "modulo", "euclidean",]
function = "std::chrono::operator+"
header = "<chrono>"
signature = "constexpr month operator+(const month& x, const months& y) noexcept"

[[axioms]]
id = "cpp20_time_cal_month_subtract_result_range_e0f1a2b3"
content = "month subtraction when both operands satisfy ok() returns value m in range [months{0}, months{11}] satisfying y + m == x"
formal_spec = "x.ok() && y.ok() && (x - y == m) => (m >= months{0} && m <= months{11} && y + m == x)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.month"
source_module = "[time.cal.month.nonmembers]/6"
tags = [ "arithmetic", "subtraction", "range",]
function = "std::chrono::operator-"
header = "<chrono>"
signature = "constexpr months operator-(const month& x, const month& y) noexcept"

[[axioms]]
id = "cpp20_time_cal_month_subtract_unspecified_f1a2b3c4"
content = "month subtraction when !x.ok() || !y.ok() returns unspecified value"
formal_spec = "(!x.ok() || !y.ok()) && (x - y) => unspecified(result)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.month"
source_module = "[time.cal.month.nonmembers]/6"
tags = [ "arithmetic", "unspecified",]
function = "std::chrono::operator-"
header = "<chrono>"
signature = "constexpr months operator-(const month& x, const month& y) noexcept"

[[axioms]]
id = "cpp20_time_cal_year_ctor_truncation_a2b3c4d5"
content = "Constructing year with int value y outside range [-32767,32767] results in unspecified value held in internal storage"
formal_spec = "year(int y) && (y < -32767 || y > 32767) => unspecified(y_)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.year"
source_module = "[time.cal.year.members]/1"
tags = [ "truncation", "initialization", "unspecified",]
function = "std::chrono::year::year"
header = "<chrono>"
signature = "explicit constexpr year(int y) noexcept"

[[axioms]]
id = "cpp20_time_cal_year_ok_range_b3c4d5e6"
content = "year::ok() returns true if and only if y_ is in range [min().y_, max().y_] which is [-32767, 32767]"
formal_spec = "year.ok() <=> (min().y_ <= y_ && y_ <= max().y_) <=> (-32767 <= y_ && y_ <= 32767)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.year"
source_module = "[time.cal.year.members]/18"
tags = [ "validity", "range",]
function = "std::chrono::year::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_year_is_leap_formula_c4d5e6f7"
content = "year::is_leap() returns true if year is divisible by 4 and either not divisible by 100 or divisible by 400"
formal_spec = "year.is_leap() <=> (y_ % 4 == 0 && (y_ % 100 != 0 || y_ % 400 == 0))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.year"
source_module = "[time.cal.year.members]/16"
tags = [ "leap-year", "calendar",]
function = "std::chrono::year::is_leap"
header = "<chrono>"
signature = "constexpr bool is_leap() const noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_ctor_seven_normalization_d5e6f7a8"
content = "Constructing weekday with unsigned value 7 normalizes to 0 (Sunday); values outside [0,255] result in unspecified storage"
formal_spec = "weekday(unsigned wd) => (wd_ = (wd == 7 ? 0 : wd)) && (wd > 255 => unspecified(wd_))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wd"
source_module = "[time.cal.wd.members]/1"
tags = [ "initialization", "normalization", "unspecified",]
function = "std::chrono::weekday::weekday"
header = "<chrono>"
signature = "explicit constexpr weekday(unsigned wd) noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_ok_range_e6f7a8b9"
content = "weekday::ok() returns true if and only if wd_ is in range [0,6]"
formal_spec = "weekday.ok() <=> (wd_ <= 6)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wd"
source_module = "[time.cal.wd.members]/20"
tags = [ "validity", "range",]
function = "std::chrono::weekday::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_add_euclidean_f7a8b9c0"
content = "weekday addition uses Euclidean division modulo 7, always producing result in range [0,6] even if !x.ok()"
formal_spec = "weekday(x) + days(y) => weekday{modulo(wd_ + y.count(), 7)} where modulo uses Euclidean division with range [0,6]"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wd"
source_module = "[time.cal.wd.nonmembers]/2"
tags = [ "arithmetic", "modulo", "euclidean",]
function = "std::chrono::operator+"
header = "<chrono>"
signature = "constexpr weekday operator+(const weekday& x, const days& y) noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_subtract_result_range_a8b9c0d1"
content = "weekday subtraction when both operands satisfy ok() returns value d in range [days{0}, days{6}] satisfying y + d == x"
formal_spec = "x.ok() && y.ok() && (x - y == d) => (d >= days{0} && d <= days{6} && y + d == x)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wd"
source_module = "[time.cal.wd.nonmembers]/5"
tags = [ "arithmetic", "subtraction", "range",]
function = "std::chrono::operator-"
header = "<chrono>"
signature = "constexpr days operator-(const weekday& x, const weekday& y) noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_subtract_unspecified_b9c0d1e2"
content = "weekday subtraction when !x.ok() || !y.ok() returns unspecified value"
formal_spec = "(!x.ok() || !y.ok()) && (x - y) => unspecified(result)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wd"
source_module = "[time.cal.wd.nonmembers]/5"
tags = [ "arithmetic", "unspecified",]
function = "std::chrono::operator-"
header = "<chrono>"
signature = "constexpr days operator-(const weekday& x, const weekday& y) noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_indexed_ctor_unspecified_c0d1e2f3"
content = "Constructing weekday_indexed with !wd.ok() or index not in [0,7] results in unspecified values held"
formal_spec = "weekday_indexed(wd, index) && (!wd.ok() || index > 7) => unspecified(wd_) || unspecified(index_)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wdidx"
source_module = "[time.cal.wdidx.members]/1"
tags = [ "initialization", "unspecified",]
function = "std::chrono::weekday_indexed::weekday_indexed"
header = "<chrono>"
signature = "constexpr weekday_indexed(const chrono::weekday& wd, unsigned index) noexcept"

[[axioms]]
id = "cpp20_time_cal_weekday_indexed_ok_range_d1e2f3a4"
content = "weekday_indexed::ok() returns true if and only if wd_.ok() and index_ is in range [1,5]"
formal_spec = "weekday_indexed.ok() <=> (wd_.ok() && 1 <= index_ && index_ <= 5)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.wdidx"
source_module = "[time.cal.wdidx.members]/4"
tags = [ "validity", "range",]
function = "std::chrono::weekday_indexed::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_month_day_ok_constraint_e2f3a4b5"
content = "month_day::ok() returns true only if m_.ok() is true, 1d <= d_, and d_ does not exceed days in month m_ (29 for February)"
formal_spec = "month_day.ok() <=> (m_.ok() && 1 <= unsigned{d_} && unsigned{d_} <= days_in_month(m_, assume_leap_feb=true))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.md"
source_module = "[time.cal.md.members]/4"
tags = [ "validity", "constraint",]
function = "std::chrono::month_day::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_month_day_ok_february_assumption_f3a4b5c6"
content = "month_day::ok() assumes February has 29 days for validation purposes"
formal_spec = "month_day.ok() && m_ == February => max_valid_day = 29"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.md"
source_module = "[time.cal.md.members]/4"
tags = [ "validity", "february", "leap-year",]
function = "std::chrono::month_day::ok"
header = "<chrono>"
signature = "constexpr bool ok() const noexcept"

[[axioms]]
id = "cpp20_time_cal_ymd_sys_days_ok_roundtrip_a4b5c6d7"
content = "For any year_month_day ymd where ymd.ok() is true, the round-trip ymd == year_month_day{sys_days{ymd}} is true"
formal_spec = "ymd.ok() => (ymd == year_month_day{sys_days{ymd}})"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.ymd"
source_module = "[time.cal.ymd.members]/4"
tags = [ "roundtrip", "conversion", "invariant",]
function = "std::chrono::year_month_day::year_month_day"
header = "<chrono>"
signature = "constexpr year_month_day(const sys_days& dp) noexcept"

[[axioms]]
id = "cpp20_time_cal_ymd_sys_days_unspecified_not_ok_b5c6d7e8"
content = "Converting year_month_day to sys_days when !ok() but y_.ok() && m_.ok() returns sys_days{y_/m_/1d} + (d_ - 1d); otherwise unspecified"
formal_spec = "!ymd.ok() && y_.ok() && m_.ok() => sys_days(ymd) == sys_days{y_/m_/1d} + (d_ - 1d); !ymd.ok() && !(y_.ok() && m_.ok()) => unspecified(sys_days(ymd))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.ymd"
source_module = "[time.cal.ymd.members]/19"
tags = [ "conversion", "unspecified",]
function = "std::chrono::year_month_day::operator sys_days"
header = "<chrono>"
signature = "constexpr operator sys_days() const noexcept"

[[axioms]]
id = "cpp20_time_cal_ym_add_months_constraint_c6d7e8f9"
content = "year_month::operator+=(months) requires months parameter's implicit conversion to years be worse than to months"
formal_spec = "year_month::operator+=(months dm) requires worse_conversion_sequence(dm, years) than conversion_sequence(dm, months)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.ym"
source_module = "[time.cal.ym.members]/4"
tags = [ "constraint", "overload-resolution",]
function = "std::chrono::year_month::operator+="
header = "<chrono>"
signature = "constexpr year_month& operator+=(const months& dm) noexcept"

[[axioms]]
id = "cpp20_time_cal_ym_add_months_result_ok_d7e8f9a0"
content = "year_month operator+(ym, months dm) returns year_month value z such that z.ok() && z - ym == dm"
formal_spec = "z = (ym + dm) => (z.ok() && (z - ym) == dm)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.ym"
source_module = "[time.cal.ym.nonmembers]/4"
tags = [ "postcondition", "arithmetic",]
function = "std::chrono::operator+"
header = "<chrono>"
signature = "constexpr year_month operator+(const year_month& ym, const months& dm) noexcept"

[[axioms]]
id = "cpp20_time_cal_ym_add_months_complexity_e8f9a0b1"
content = "year_month operator+(ym, months dm) has O(1) complexity with respect to dm value"
formal_spec = "time_complexity(ym + dm) == O(1)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.ym"
source_module = "[time.cal.ym.nonmembers]/5"
tags = [ "complexity", "performance",]
function = "std::chrono::operator+"
header = "<chrono>"
signature = "constexpr year_month operator+(const year_month& ym, const months& dm) noexcept"

[[axioms]]
id = "cpp20_time_cal_ymd_add_months_constraint_f9a0b1c2"
content = "year_month_day::operator+=(months) requires months parameter's implicit conversion to years be worse than to months"
formal_spec = "year_month_day::operator+=(months m) requires worse_conversion_sequence(m, years) than conversion_sequence(m, months)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "time.cal.ymd"
source_module = "[time.cal.ymd.members]/6"
tags = [ "constraint", "overload-resolution",]
function = "std::chrono::year_month_day::operator+="
header = "<chrono>"
signature = "constexpr year_month_day& operator+=(const months& m) noexcept"

[[axioms]]
id = "cpp20_accumulate_precond_t_copyconstructible_a8f3d2e1"
content = "Type T must meet Cpp17CopyConstructible and Cpp17CopyAssignable requirements for std::accumulate."
formal_spec = "call(accumulate<InputIterator, T>) => meets(T, Cpp17CopyConstructible) && meets(T, Cpp17CopyAssignable)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[accumulate]/1"
tags = [ "accumulate", "type-requirements", "concepts",]
function = "std::accumulate"
header = "<numeric>"
signature = "T std::accumulate(InputIterator first, InputIterator last, T init)"

[[axioms]]
id = "cpp20_accumulate_precond_binary_op_no_modify_b9c4e7f2"
content = "In the range [first, last], binary_op must neither modify elements nor invalidate iterators or subranges."
formal_spec = "in_range(it, [first, last]) && call(binary_op) => !modifies_elements(binary_op) && !invalidates_iterators(binary_op) && !invalidates_subranges(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[accumulate]/1"
tags = [ "accumulate", "binary-operation", "iterator-safety",]
function = "std::accumulate"
header = "<numeric>"
signature = "T std::accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_reduce_mandate_binary_op_convertible_c7d2f9a4"
content = "All of binary_op(init, *first), binary_op(*first, init), binary_op(init, init), and binary_op(*first, *first) must be convertible to T for std::reduce."
formal_spec = "call(reduce<T, BinaryOperation>) => convertible_to<decltype(binary_op(init, *first)), T> && convertible_to<decltype(binary_op(*first, init)), T> && convertible_to<decltype(binary_op(init, init)), T> && convertible_to<decltype(binary_op(*first, *first)), T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[reduce]/5"
tags = [ "reduce", "type-requirements", "binary-operation",]
function = "std::reduce"
header = "<numeric>"
signature = "T std::reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_reduce_precond_t_moveconstructible_d8e3a1f6"
content = "Type T must meet Cpp17MoveConstructible requirements for std::reduce."
formal_spec = "call(reduce<InputIterator, T>) => meets(T, Cpp17MoveConstructible)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[reduce]/6"
tags = [ "reduce", "type-requirements", "concepts",]
function = "std::reduce"
header = "<numeric>"
signature = "T std::reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_reduce_precond_binary_op_no_invalidate_e9f4b2c7"
content = "binary_op must neither invalidate iterators or subranges, nor modify elements in the range [first, last] for std::reduce."
formal_spec = "in_range(it, [first, last]) && call(binary_op) => !invalidates_iterators(binary_op) && !invalidates_subranges(binary_op) && !modifies_elements(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[reduce]/6"
tags = [ "reduce", "binary-operation", "iterator-safety",]
function = "std::reduce"
header = "<numeric>"
signature = "T std::reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_inner_product_precond_t_copyable_f0a5c3d8"
content = "Type T must meet Cpp17CopyConstructible and Cpp17CopyAssignable requirements for std::inner_product."
formal_spec = "call(inner_product<InputIterator1, InputIterator2, T>) => meets(T, Cpp17CopyConstructible) && meets(T, Cpp17CopyAssignable)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[inner.product]/1"
tags = [ "inner-product", "type-requirements", "concepts",]
function = "std::inner_product"
header = "<numeric>"
signature = "T std::inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init)"

[[axioms]]
id = "cpp20_inner_product_precond_no_modify_a1b6d4e9"
content = "In the ranges [first1, last1] and [first2, first2+(last1-first1)], binary_op1 and binary_op2 must neither modify elements nor invalidate iterators or subranges."
formal_spec = "(in_range(it1, [first1, last1]) || in_range(it2, [first2, first2+(last1-first1)])) && (call(binary_op1) || call(binary_op2)) => !modifies_elements(binary_op1) && !modifies_elements(binary_op2) && !invalidates_iterators(binary_op1) && !invalidates_iterators(binary_op2)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[inner.product]/1"
tags = [ "inner-product", "binary-operation", "iterator-safety",]
function = "std::inner_product"
header = "<numeric>"
signature = "T std::inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)"

[[axioms]]
id = "cpp20_transform_reduce_mandate_convertible_b2c7e5f0"
content = "All of binary_op1(init, init), binary_op1(init, binary_op2(*first1, *first2)), binary_op1(binary_op2(*first1, *first2), init), and binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2)) must be convertible to T."
formal_spec = "call(transform_reduce<T, BinaryOperation1, BinaryOperation2>) => convertible_to<decltype(binary_op1(init, init)), T> && convertible_to<decltype(binary_op1(init, binary_op2(*first1, *first2))), T> && convertible_to<decltype(binary_op1(binary_op2(*first1, *first2), init)), T> && convertible_to<decltype(binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))), T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.reduce]/3"
tags = [ "transform-reduce", "type-requirements", "binary-operation",]
function = "std::transform_reduce"
header = "<numeric>"
signature = "T std::transform_reduce(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)"

[[axioms]]
id = "cpp20_transform_reduce_precond_t_movable_c3d8f6a1"
content = "Type T must meet Cpp17MoveConstructible requirements for std::transform_reduce."
formal_spec = "call(transform_reduce<T>) => meets(T, Cpp17MoveConstructible)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.reduce]/4"
tags = [ "transform-reduce", "type-requirements", "concepts",]
function = "std::transform_reduce"
header = "<numeric>"
signature = "T std::transform_reduce(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)"

[[axioms]]
id = "cpp20_transform_reduce_precond_no_invalidate_d4e9a7b2"
content = "Neither binary_op1 nor binary_op2 may invalidate subranges or modify elements in the ranges [first1, last1] and [first2, first2+(last1-first1)]."
formal_spec = "(in_range(it, [first1, last1]) || in_range(it, [first2, first2+(last1-first1)])) && (call(binary_op1) || call(binary_op2)) => !invalidates_subranges(binary_op1) && !invalidates_subranges(binary_op2) && !modifies_elements(binary_op1) && !modifies_elements(binary_op2)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.reduce]/4"
tags = [ "transform-reduce", "iterator-safety", "binary-operation",]
function = "std::transform_reduce"
header = "<numeric>"
signature = "T std::transform_reduce(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)"

[[axioms]]
id = "cpp20_transform_reduce_unary_mandate_e5f0b8c3"
content = "All of binary_op(init, init), binary_op(init, unary_op(*first)), binary_op(unary_op(*first), init), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T."
formal_spec = "call(transform_reduce<T, BinaryOperation, UnaryOperation>) => convertible_to<decltype(binary_op(init, init)), T> && convertible_to<decltype(binary_op(init, unary_op(*first))), T> && convertible_to<decltype(binary_op(unary_op(*first), init)), T> && convertible_to<decltype(binary_op(unary_op(*first), unary_op(*first))), T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.reduce]/7"
tags = [ "transform-reduce", "type-requirements", "unary-operation",]
function = "std::transform_reduce"
header = "<numeric>"
signature = "T std::transform_reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op, UnaryOperation unary_op)"

[[axioms]]
id = "cpp20_transform_reduce_unary_precond_no_invalidate_f6a1c9d4"
content = "Neither unary_op nor binary_op may invalidate subranges or modify elements in the range [first, last]."
formal_spec = "in_range(it, [first, last]) && (call(unary_op) || call(binary_op)) => !invalidates_subranges(unary_op) && !invalidates_subranges(binary_op) && !modifies_elements(unary_op) && !modifies_elements(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.reduce]/8"
tags = [ "transform-reduce", "iterator-safety", "unary-operation",]
function = "std::transform_reduce"
header = "<numeric>"
signature = "T std::transform_reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op, UnaryOperation unary_op)"

[[axioms]]
id = "cpp20_partial_sum_mandate_value_constructible_a7b2d0e5"
content = "InputIterator's value type must be constructible from *first for std::partial_sum."
formal_spec = "call(partial_sum<InputIterator>) => constructible_from<typename iterator_traits<InputIterator>::value_type, decltype(*first)>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[partial.sum]/1"
tags = [ "partial-sum", "type-requirements", "iterator",]
function = "std::partial_sum"
header = "<numeric>"
signature = "OutputIterator std::partial_sum(InputIterator first, InputIterator last, OutputIterator result)"

[[axioms]]
id = "cpp20_partial_sum_mandate_result_convertible_b8c3e1f6"
content = "The result of std::move(acc) + *i or binary_op(std::move(acc), *i) must be implicitly convertible to InputIterator's value type."
formal_spec = "call(partial_sum<InputIterator, BinaryOperation>) => convertible_to<decltype(std::move(acc) + *i), typename iterator_traits<InputIterator>::value_type> || convertible_to<decltype(binary_op(std::move(acc), *i)), typename iterator_traits<InputIterator>::value_type>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[partial.sum]/1"
tags = [ "partial-sum", "type-requirements", "binary-operation",]
function = "std::partial_sum"
header = "<numeric>"
signature = "OutputIterator std::partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_partial_sum_mandate_acc_writable_c9d4f2a7"
content = "The accumulator acc must be writable to result for std::partial_sum."
formal_spec = "call(partial_sum<InputIterator, OutputIterator>) => writable<OutputIterator, decltype(acc)>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[partial.sum]/1"
tags = [ "partial-sum", "iterator", "writable",]
function = "std::partial_sum"
header = "<numeric>"
signature = "OutputIterator std::partial_sum(InputIterator first, InputIterator last, OutputIterator result)"

[[axioms]]
id = "cpp20_partial_sum_precond_no_modify_d0e5a3b8"
content = "In the ranges [first, last] and [result, result+(last-first)], binary_op must neither modify elements nor invalidate iterators or subranges."
formal_spec = "(in_range(it, [first, last]) || in_range(it, [result, result+(last-first)])) && call(binary_op) => !modifies_elements(binary_op) && !invalidates_iterators(binary_op) && !invalidates_subranges(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[partial.sum]/2"
tags = [ "partial-sum", "binary-operation", "iterator-safety",]
function = "std::partial_sum"
header = "<numeric>"
signature = "OutputIterator std::partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_exclusive_scan_mandate_convertible_e1f6b4c9"
content = "All of binary_op(init, init), binary_op(init, *first), and binary_op(*first, *first) must be convertible to T for std::exclusive_scan."
formal_spec = "call(exclusive_scan<T, BinaryOperation>) => convertible_to<decltype(binary_op(init, init)), T> && convertible_to<decltype(binary_op(init, *first)), T> && convertible_to<decltype(binary_op(*first, *first)), T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[exclusive.scan]/3"
tags = [ "exclusive-scan", "type-requirements", "binary-operation",]
function = "std::exclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_exclusive_scan_precond_t_movable_f2a7c5d0"
content = "Type T must meet Cpp17MoveConstructible requirements for std::exclusive_scan."
formal_spec = "call(exclusive_scan<T>) => meets(T, Cpp17MoveConstructible)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[exclusive.scan]/4"
tags = [ "exclusive-scan", "type-requirements", "concepts",]
function = "std::exclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_exclusive_scan_precond_no_invalidate_a3b8d6e1"
content = "binary_op must neither invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)]."
formal_spec = "(in_range(it, [first, last]) || in_range(it, [result, result+(last-first)])) && call(binary_op) => !invalidates_iterators(binary_op) && !invalidates_subranges(binary_op) && !modifies_elements(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[exclusive.scan]/4"
tags = [ "exclusive-scan", "iterator-safety", "binary-operation",]
function = "std::exclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_inclusive_scan_mandate_init_convertible_b4c9e7f2"
content = "If init is provided, all of binary_op(init, init), binary_op(init, *first), and binary_op(*first, *first) must be convertible to T; otherwise, binary_op(*first, *first) must be convertible to U (value type of decltype(first))."
formal_spec = "call(inclusive_scan<BinaryOperation, T?>) => (has(init) => (convertible_to<decltype(binary_op(init, init)), T> && convertible_to<decltype(binary_op(init, *first)), T> && convertible_to<decltype(binary_op(*first, *first)), T>)) && (!has(init) => convertible_to<decltype(binary_op(*first, *first)), U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[inclusive.scan]/4"
tags = [ "inclusive-scan", "type-requirements", "binary-operation",]
function = "std::inclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, T init)"

[[axioms]]
id = "cpp20_inclusive_scan_precond_movable_c5d0f8a3"
content = "If init is provided, T must meet Cpp17MoveConstructible requirements; otherwise, U (value type of decltype(first)) must meet Cpp17MoveConstructible requirements."
formal_spec = "call(inclusive_scan<T?, U>) => (has(init) => meets(T, Cpp17MoveConstructible)) && (!has(init) => meets(U, Cpp17MoveConstructible))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[inclusive.scan]/5"
tags = [ "inclusive-scan", "type-requirements", "concepts",]
function = "std::inclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, T init)"

[[axioms]]
id = "cpp20_inclusive_scan_precond_no_invalidate_d6e1a9b4"
content = "binary_op must neither invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)]."
formal_spec = "(in_range(it, [first, last]) || in_range(it, [result, result+(last-first)])) && call(binary_op) => !invalidates_iterators(binary_op) && !invalidates_subranges(binary_op) && !modifies_elements(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[inclusive.scan]/5"
tags = [ "inclusive-scan", "iterator-safety", "binary-operation",]
function = "std::inclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, T init)"

[[axioms]]
id = "cpp20_transform_exclusive_scan_mandate_e7f2b0c5"
content = "All of binary_op(init, init), binary_op(init, unary_op(*first)), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T."
formal_spec = "call(transform_exclusive_scan<T, BinaryOperation, UnaryOperation>) => convertible_to<decltype(binary_op(init, init)), T> && convertible_to<decltype(binary_op(init, unary_op(*first))), T> && convertible_to<decltype(binary_op(unary_op(*first), unary_op(*first))), T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.exclusive.scan]/1"
tags = [ "transform-exclusive-scan", "type-requirements", "binary-operation", "unary-operation",]
function = "std::transform_exclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::transform_exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op, UnaryOperation unary_op)"

[[axioms]]
id = "cpp20_transform_exclusive_scan_precond_movable_f8a3c1d6"
content = "Type T must meet Cpp17MoveConstructible requirements for std::transform_exclusive_scan."
formal_spec = "call(transform_exclusive_scan<T>) => meets(T, Cpp17MoveConstructible)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.exclusive.scan]/2"
tags = [ "transform-exclusive-scan", "type-requirements", "concepts",]
function = "std::transform_exclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::transform_exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op, UnaryOperation unary_op)"

[[axioms]]
id = "cpp20_transform_exclusive_scan_precond_no_invalidate_a9b4d2e7"
content = "Neither unary_op nor binary_op may invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)]."
formal_spec = "(in_range(it, [first, last]) || in_range(it, [result, result+(last-first)])) && (call(unary_op) || call(binary_op)) => !invalidates_iterators(unary_op) && !invalidates_iterators(binary_op) && !invalidates_subranges(unary_op) && !invalidates_subranges(binary_op) && !modifies_elements(unary_op) && !modifies_elements(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.exclusive.scan]/2"
tags = [ "transform-exclusive-scan", "iterator-safety", "binary-operation", "unary-operation",]
function = "std::transform_exclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::transform_exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op, UnaryOperation unary_op)"

[[axioms]]
id = "cpp20_transform_inclusive_scan_mandate_b0c5e3f8"
content = "If init is provided, all of binary_op(init, init), binary_op(init, unary_op(*first)), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T; otherwise, binary_op(unary_op(*first), unary_op(*first)) must be convertible to U."
formal_spec = "call(transform_inclusive_scan<T?, U, BinaryOperation, UnaryOperation>) => (has(init) => (convertible_to<decltype(binary_op(init, init)), T> && convertible_to<decltype(binary_op(init, unary_op(*first))), T> && convertible_to<decltype(binary_op(unary_op(*first), unary_op(*first))), T>)) && (!has(init) => convertible_to<decltype(binary_op(unary_op(*first), unary_op(*first))), U>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.inclusive.scan]/2"
tags = [ "transform-inclusive-scan", "type-requirements", "binary-operation", "unary-operation",]
function = "std::transform_inclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::transform_inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, UnaryOperation unary_op, T init)"

[[axioms]]
id = "cpp20_transform_inclusive_scan_precond_movable_c1d6f4a9"
content = "If init is provided, T must meet Cpp17MoveConstructible requirements; otherwise, U must meet Cpp17MoveConstructible requirements."
formal_spec = "call(transform_inclusive_scan<T?, U>) => (has(init) => meets(T, Cpp17MoveConstructible)) && (!has(init) => meets(U, Cpp17MoveConstructible))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.inclusive.scan]/3"
tags = [ "transform-inclusive-scan", "type-requirements", "concepts",]
function = "std::transform_inclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::transform_inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, UnaryOperation unary_op, T init)"

[[axioms]]
id = "cpp20_transform_inclusive_scan_precond_no_invalidate_d2e7a5b0"
content = "Neither unary_op nor binary_op may invalidate iterators or subranges, nor modify elements in the ranges [first, last] or [result, result+(last-first)]."
formal_spec = "(in_range(it, [first, last]) || in_range(it, [result, result+(last-first)])) && (call(unary_op) || call(binary_op)) => !invalidates_iterators(unary_op) && !invalidates_iterators(binary_op) && !invalidates_subranges(unary_op) && !invalidates_subranges(binary_op) && !modifies_elements(unary_op) && !modifies_elements(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[transform.inclusive.scan]/3"
tags = [ "transform-inclusive-scan", "iterator-safety", "binary-operation", "unary-operation",]
function = "std::transform_inclusive_scan"
header = "<numeric>"
signature = "OutputIterator std::transform_inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, UnaryOperation unary_op, T init)"

[[axioms]]
id = "cpp20_adjacent_difference_mandate_no_exec_e3f8b6c1"
content = "For overloads with no ExecutionPolicy, T (value type of decltype(first)) must be constructible from *first, acc must be writable to result, and the result of binary_op(val, std::move(acc)) must be writable to result."
formal_spec = "call(adjacent_difference<InputIterator, OutputIterator>) && !has(ExecutionPolicy) => constructible_from<T, decltype(*first)> && writable<OutputIterator, decltype(acc)> && writable<OutputIterator, decltype(binary_op(val, std::move(acc)))>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[adjacent.difference]/2"
tags = [ "adjacent-difference", "type-requirements", "iterator",]
function = "std::adjacent_difference"
header = "<numeric>"
signature = "OutputIterator std::adjacent_difference(InputIterator first, InputIterator last, OutputIterator result)"

[[axioms]]
id = "cpp20_adjacent_difference_mandate_with_exec_f4a9c7d2"
content = "For overloads with ExecutionPolicy, the results of binary_op(*first, *first) and *first must be writable to result."
formal_spec = "call(adjacent_difference<ForwardIterator1, ForwardIterator2, ExecutionPolicy>) && has(ExecutionPolicy) => writable<ForwardIterator2, decltype(binary_op(*first, *first))> && writable<ForwardIterator2, decltype(*first)>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[adjacent.difference]/2"
tags = [ "adjacent-difference", "type-requirements", "iterator", "execution-policy",]
function = "std::adjacent_difference"
header = "<numeric>"
signature = "ForwardIterator2 std::adjacent_difference(ExecutionPolicy&& exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result)"

[[axioms]]
id = "cpp20_adjacent_difference_precond_no_exec_a5b0d8e3"
content = "For overloads with no ExecutionPolicy, T must meet Cpp17MoveAssignable requirements."
formal_spec = "call(adjacent_difference<InputIterator, OutputIterator>) && !has(ExecutionPolicy) => meets(T, Cpp17MoveAssignable)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[adjacent.difference]/3"
tags = [ "adjacent-difference", "type-requirements", "concepts",]
function = "std::adjacent_difference"
header = "<numeric>"
signature = "OutputIterator std::adjacent_difference(InputIterator first, InputIterator last, OutputIterator result)"

[[axioms]]
id = "cpp20_adjacent_difference_precond_no_modify_b6c1e9f4"
content = "In the ranges [first, last] and [result, result+(last-first)], binary_op must neither modify elements nor invalidate iterators or subranges."
formal_spec = "(in_range(it, [first, last]) || in_range(it, [result, result+(last-first)])) && call(binary_op) => !modifies_elements(binary_op) && !invalidates_iterators(binary_op) && !invalidates_subranges(binary_op)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[adjacent.difference]/3"
tags = [ "adjacent-difference", "iterator-safety", "binary-operation",]
function = "std::adjacent_difference"
header = "<numeric>"
signature = "OutputIterator std::adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)"

[[axioms]]
id = "cpp20_iota_mandate_t_convertible_c7d2f0a5"
content = "T must be convertible to ForwardIterator's value type for std::iota."
formal_spec = "call(iota<ForwardIterator, T>) => convertible_to<T, typename iterator_traits<ForwardIterator>::value_type>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.iota]/1"
tags = [ "iota", "type-requirements", "iterator",]
function = "std::iota"
header = "<numeric>"
signature = "void std::iota(ForwardIterator first, ForwardIterator last, T value)"

[[axioms]]
id = "cpp20_iota_mandate_increment_well_formed_d8e3a1b6"
content = "The expression ++val, where val has type T, must be well-formed for std::iota."
formal_spec = "call(iota<ForwardIterator, T>) => well_formed(++val) where val: T"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.iota]/1"
tags = [ "iota", "type-requirements", "increment",]
function = "std::iota"
header = "<numeric>"
signature = "void std::iota(ForwardIterator first, ForwardIterator last, T value)"

[[axioms]]
id = "cpp20_gcd_mandate_integer_not_bool_e9f4b2c7"
content = "M and N must both be integer types other than cv bool for std::gcd."
formal_spec = "call(gcd<M, N>) => is_integer_type(M) && is_integer_type(N) && !is_same_v<remove_cv_t<M>, bool> && !is_same_v<remove_cv_t<N>, bool>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.gcd]/1"
tags = [ "gcd", "type-requirements", "integer",]
function = "std::gcd"
header = "<numeric>"
signature = "common_type_t<M, N> std::gcd(M m, N n)"

[[axioms]]
id = "cpp20_gcd_precond_representable_f0a5c3d8"
content = "|m| and |n| must be representable as a value of common_type_t<M, N> for std::gcd."
formal_spec = "call(gcd<M, N>(m, n)) => representable<common_type_t<M, N>>(|m|) && representable<common_type_t<M, N>>(|n|)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.gcd]/2"
tags = [ "gcd", "preconditions", "integer",]
function = "std::gcd"
header = "<numeric>"
signature = "common_type_t<M, N> std::gcd(M m, N n)"

[[axioms]]
id = "cpp20_lcm_mandate_integer_not_bool_a1b6d4e9"
content = "M and N must both be integer types other than cv bool for std::lcm."
formal_spec = "call(lcm<M, N>) => is_integer_type(M) && is_integer_type(N) && !is_same_v<remove_cv_t<M>, bool> && !is_same_v<remove_cv_t<N>, bool>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.lcm]/1"
tags = [ "lcm", "type-requirements", "integer",]
function = "std::lcm"
header = "<numeric>"
signature = "common_type_t<M, N> std::lcm(M m, N n)"

[[axioms]]
id = "cpp20_lcm_precond_args_representable_b2c7e5f0"
content = "|m| and |n| must be representable as a value of common_type_t<M, N> for std::lcm."
formal_spec = "call(lcm<M, N>(m, n)) => representable<common_type_t<M, N>>(|m|) && representable<common_type_t<M, N>>(|n|)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.lcm]/2"
tags = [ "lcm", "preconditions", "integer",]
function = "std::lcm"
header = "<numeric>"
signature = "common_type_t<M, N> std::lcm(M m, N n)"

[[axioms]]
id = "cpp20_lcm_precond_result_representable_c3d8f6a1"
content = "The least common multiple of |m| and |n| must be representable as a value of type common_type_t<M, N> for std::lcm."
formal_spec = "call(lcm<M, N>(m, n)) => representable<common_type_t<M, N>>(lcm(|m|, |n|))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.lcm]/2"
tags = [ "lcm", "preconditions", "integer",]
function = "std::lcm"
header = "<numeric>"
signature = "common_type_t<M, N> std::lcm(M m, N n)"

[[axioms]]
id = "cpp20_midpoint_scalar_constraint_arithmetic_d4e9a7b2"
content = "T must be an arithmetic type other than cv bool for scalar std::midpoint."
formal_spec = "call(midpoint<T>(a, b)) && !is_pointer_v<T> => is_arithmetic_v<T> && !is_same_v<remove_cv_t<T>, bool>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.midpoint]/1"
tags = [ "midpoint", "type-requirements", "arithmetic",]
function = "std::midpoint"
header = "<numeric>"
signature = "T std::midpoint(T a, T b) noexcept"

[[axioms]]
id = "cpp20_midpoint_pointer_constraint_object_e5f0b8c3"
content = "T must be an object type for pointer std::midpoint."
formal_spec = "call(midpoint<T*>(a, b)) => is_object_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.midpoint]/4"
tags = [ "midpoint", "type-requirements", "pointer",]
function = "std::midpoint"
header = "<numeric>"
signature = "T* std::midpoint(T* a, T* b)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_midpoint_pointer_mandate_complete_f6a1c9d4"
content = "T must be a complete type for pointer std::midpoint."
formal_spec = "call(midpoint<T*>(a, b)) => is_complete_v<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.midpoint]/5"
tags = [ "midpoint", "type-requirements", "complete-type",]
function = "std::midpoint"
header = "<numeric>"
signature = "T* std::midpoint(T* a, T* b)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_midpoint_pointer_precond_same_array_a7b2d0e5"
content = "a and b must point to, respectively, elements i and j of the same array object x for pointer std::midpoint."
formal_spec = "call(midpoint<T*>(a, b)) => same_array_object(a, b) && a == &x[i] && b == &x[j]"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.ops.midpoint]/6"
tags = [ "midpoint", "preconditions", "pointer", "array",]
function = "std::midpoint"
header = "<numeric>"
signature = "T* std::midpoint(T* a, T* b)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_add_sat_constraint_integer_b8c3e1f6"
content = "T must be a signed or unsigned integer type for std::add_sat."
formal_spec = "call(add_sat<T>) => (is_signed_integer_type(T) || is_unsigned_integer_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.func]/2"
tags = [ "saturation-arithmetic", "type-requirements", "integer",]
function = "std::add_sat"
header = "<numeric>"
signature = "T std::add_sat(T x, T y) noexcept"

[[axioms]]
id = "cpp20_sub_sat_constraint_integer_c9d4f2a7"
content = "T must be a signed or unsigned integer type for std::sub_sat."
formal_spec = "call(sub_sat<T>) => (is_signed_integer_type(T) || is_unsigned_integer_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.func]/4"
tags = [ "saturation-arithmetic", "type-requirements", "integer",]
function = "std::sub_sat"
header = "<numeric>"
signature = "T std::sub_sat(T x, T y) noexcept"

[[axioms]]
id = "cpp20_mul_sat_constraint_integer_d0e5a3b8"
content = "T must be a signed or unsigned integer type for std::mul_sat."
formal_spec = "call(mul_sat<T>) => (is_signed_integer_type(T) || is_unsigned_integer_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.func]/6"
tags = [ "saturation-arithmetic", "type-requirements", "integer",]
function = "std::mul_sat"
header = "<numeric>"
signature = "T std::mul_sat(T x, T y) noexcept"

[[axioms]]
id = "cpp20_div_sat_constraint_integer_e1f6b4c9"
content = "T must be a signed or unsigned integer type for std::div_sat."
formal_spec = "call(div_sat<T>) => (is_signed_integer_type(T) || is_unsigned_integer_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.func]/8"
tags = [ "saturation-arithmetic", "type-requirements", "integer",]
function = "std::div_sat"
header = "<numeric>"
signature = "T std::div_sat(T x, T y) noexcept"

[[axioms]]
id = "cpp20_div_sat_precond_y_nonzero_f2a7c5d0"
content = "y != 0 must be true for std::div_sat - dividing by zero violates precondition."
formal_spec = "call(div_sat<T>(x, y)) => y != 0"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.func]/9"
tags = [ "saturation-arithmetic", "preconditions", "division", "undefined-behavior",]
function = "std::div_sat"
header = "<numeric>"
signature = "T std::div_sat(T x, T y) noexcept"

[[axioms]]
id = "cpp20_div_sat_precond_not_constexpr_if_violated_a3b8d6e1"
content = "A function call expression that violates the precondition y != 0 is not a core constant expression for std::div_sat."
formal_spec = "call(div_sat<T>(x, y)) && y == 0 => !is_core_constant_expression(div_sat(x, y))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.func]/11"
tags = [ "saturation-arithmetic", "constexpr", "preconditions",]
function = "std::div_sat"
header = "<numeric>"
signature = "T std::div_sat(T x, T y) noexcept"

[[axioms]]
id = "cpp20_saturate_cast_constraint_integer_b4c9e7f2"
content = "R and T must be signed or unsigned integer types for std::saturate_cast."
formal_spec = "call(saturate_cast<R, T>) => (is_signed_integer_type(R) || is_unsigned_integer_type(R)) && (is_signed_integer_type(T) || is_unsigned_integer_type(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "numeric.ops"
source_module = "[numeric.sat.cast]/1"
tags = [ "saturation-arithmetic", "type-requirements", "integer", "cast",]
function = "std::saturate_cast"
header = "<numeric>"
signature = "R std::saturate_cast(T x) noexcept"

[[axioms]]
id = "cpp20_coroutine_handle_null_no_referent_a3f8d2e1"
content = "A coroutine_handle object whose member address() returns a null pointer value does not refer to any coroutine."
formal_spec = "coroutine_handle h && h.address() == nullptr => !refers_to_coroutine(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.general"
source_module = "[coroutine.handle.general]/1"
tags = [ "coroutine", "handle", "null", "referent",]
header = "<coroutine>"

[[axioms]]
id = "cpp20_coroutine_handle_equality_via_address_b7c3e9f4"
content = "Two coroutine_handle objects refer to the same coroutine if and only if their member address() returns the same non-null value."
formal_spec = "coroutine_handle h1, h2 && refers_to_same_coroutine(h1, h2) <=> (h1.address() == h2.address() && h1.address() != nullptr)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.general"
source_module = "[coroutine.handle.general]/1"
tags = [ "coroutine", "handle", "equality", "identity",]
function = "std::coroutine_handle::address"
header = "<coroutine>"
signature = "void* std::coroutine_handle<T>::address() const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_specialization_ub_d4e8a2f9"
content = "If a program declares an explicit or partial specialization of coroutine_handle, the behavior is undefined."
formal_spec = "declares_specialization(coroutine_handle) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.general"
source_module = "[coroutine.handle.general]/2"
tags = [ "coroutine", "handle", "specialization", "undefined_behavior",]
header = "<coroutine>"

[[axioms]]
id = "cpp20_coroutine_handle_default_ctor_postcond_e5a9b3c7"
content = "After default construction or construction from nullptr_t, coroutine_handle::address() returns nullptr."
formal_spec = "coroutine_handle h{} || coroutine_handle h{nullptr} => h.address() == nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.con"
source_module = "[coroutine.handle.con]/1"
tags = [ "coroutine", "handle", "constructor", "postcondition",]
function = "std::coroutine_handle::coroutine_handle"
header = "<coroutine>"
signature = "constexpr std::coroutine_handle<T>::coroutine_handle() noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_from_promise_precond_f6b2c8d4"
content = "from_promise(p) requires p to be a reference to a promise object of a coroutine."
formal_spec = "coroutine_handle::from_promise(p) requires is_promise_object(p) && is_coroutine_promise(p)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.con"
source_module = "[coroutine.handle.con]/2"
tags = [ "coroutine", "handle", "promise", "precondition",]
function = "std::coroutine_handle::from_promise"
header = "<coroutine>"
signature = "static std::coroutine_handle<Promise> std::coroutine_handle<Promise>::from_promise(Promise& p)"
depends_on = [ "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4",]

[[axioms]]
id = "cpp20_coroutine_handle_from_promise_postcond_a7c3d9e5"
content = "After from_promise(p), addressof(h.promise()) == addressof(p)."
formal_spec = "h = coroutine_handle::from_promise(p) => addressof(h.promise()) == addressof(p)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.con"
source_module = "[coroutine.handle.con]/3"
tags = [ "coroutine", "handle", "promise", "postcondition",]
function = "std::coroutine_handle::from_promise"
header = "<coroutine>"
signature = "static std::coroutine_handle<Promise> std::coroutine_handle<Promise>::from_promise(Promise& p)"
depends_on = [ "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4", "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_assign_null_postcond_b8d4e0f6"
content = "After operator=(nullptr_t), coroutine_handle::address() returns nullptr."
formal_spec = "h = nullptr => h.address() == nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.con"
source_module = "[coroutine.handle.con]/5"
tags = [ "coroutine", "handle", "assignment", "postcondition",]
function = "std::coroutine_handle::operator="
header = "<coroutine>"
signature = "std::coroutine_handle<T>& std::coroutine_handle<T>::operator=(nullptr_t) noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_from_address_void_precond_c9e5a1f7"
content = "coroutine_handle<>::from_address(addr) requires addr was obtained via a prior call to address() on an object whose type is a specialization of coroutine_handle."
formal_spec = "coroutine_handle<>::from_address(addr) requires exists h: coroutine_handle<T> && addr == h.address()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.export.import"
source_module = "[coroutine.handle.export.import]/2"
tags = [ "coroutine", "handle", "precondition", "address",]
function = "std::coroutine_handle<>::from_address"
header = "<coroutine>"
signature = "static constexpr std::coroutine_handle<> std::coroutine_handle<>::from_address(void* addr)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1", "extract_precond_buffer_non_null_b7c8d9e0",]

[[axioms]]
id = "cpp20_coroutine_handle_from_address_void_postcond_d0f6b2a8"
content = "After coroutine_handle<>::from_address(addr), from_address(address()) == *this."
formal_spec = "h = coroutine_handle<>::from_address(addr) => h.from_address(h.address()) == h"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.export.import"
source_module = "[coroutine.handle.export.import]/3"
tags = [ "coroutine", "handle", "postcondition", "roundtrip",]
function = "std::coroutine_handle<>::from_address"
header = "<coroutine>"
signature = "static constexpr std::coroutine_handle<> std::coroutine_handle<>::from_address(void* addr)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_from_address_typed_precond_e1a7c3d9"
content = "coroutine_handle<Promise>::from_address(addr) requires addr was obtained via a prior call to address() on an object of type cv coroutine_handle<Promise>."
formal_spec = "coroutine_handle<Promise>::from_address(addr) requires exists h: cv coroutine_handle<Promise> && addr == h.address()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.export.import"
source_module = "[coroutine.handle.export.import]/4"
tags = [ "coroutine", "handle", "precondition", "address", "typed",]
function = "std::coroutine_handle<Promise>::from_address"
header = "<coroutine>"
signature = "static constexpr std::coroutine_handle<Promise> std::coroutine_handle<Promise>::from_address(void* addr)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1", "extract_precond_buffer_non_null_b7c8d9e0",]

[[axioms]]
id = "cpp20_coroutine_handle_from_address_typed_postcond_f2b8d4e0"
content = "After coroutine_handle<Promise>::from_address(addr), from_address(address()) == *this."
formal_spec = "h = coroutine_handle<Promise>::from_address(addr) => h.from_address(h.address()) == h"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.export.import"
source_module = "[coroutine.handle.export.import]/5"
tags = [ "coroutine", "handle", "postcondition", "roundtrip", "typed",]
function = "std::coroutine_handle<Promise>::from_address"
header = "<coroutine>"
signature = "static constexpr std::coroutine_handle<Promise> std::coroutine_handle<Promise>::from_address(void* addr)"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_bool_conversion_a3c9e5f1"
content = "Explicit conversion to bool returns true if address() != nullptr."
formal_spec = "coroutine_handle h && static_cast<bool>(h) <=> h.address() != nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.observers"
source_module = "[coroutine.handle.observers]/1"
tags = [ "coroutine", "handle", "conversion", "bool",]
function = "std::coroutine_handle::operator bool"
header = "<coroutine>"
signature = "constexpr explicit std::coroutine_handle<T>::operator bool() const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_coroutine_handle_done_precond_b4d0f6a2"
content = "Calling done() requires *this refers to a suspended coroutine."
formal_spec = "h.done() requires refers_to_coroutine(h) && is_suspended(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.observers"
source_module = "[coroutine.handle.observers]/2"
tags = [ "coroutine", "handle", "precondition", "suspended",]
function = "std::coroutine_handle::done"
header = "<coroutine>"
signature = "bool std::coroutine_handle<T>::done() const"

[[axioms]]
id = "cpp20_coroutine_handle_done_returns_final_c5e1a7b3"
content = "done() returns true if the coroutine is suspended at its final suspend point, otherwise false."
formal_spec = "h.done() == true <=> is_suspended_at_final(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.observers"
source_module = "[coroutine.handle.observers]/3"
tags = [ "coroutine", "handle", "observer", "final_suspend",]
function = "std::coroutine_handle::done"
header = "<coroutine>"
signature = "bool std::coroutine_handle<T>::done() const"

[[axioms]]
id = "cpp20_coroutine_handle_resume_cross_thread_impl_def_d6f2b8c4"
content = "Resuming a coroutine via resume, operator(), or destroy on an execution agent other than the one on which it was suspended has implementation-defined behavior unless each execution agent either is an instance of std::thread or std::jthread, or is the thread that executes main."
formal_spec = "resume_on_agent(h, agent2) && suspended_on_agent(h, agent1) && agent1 != agent2 && !(is_std_thread(agent1) && is_std_thread(agent2)) && !(is_std_jthread(agent1) && is_std_jthread(agent2)) && !(is_main_thread(agent1) || is_main_thread(agent2)) => implementation_defined_behavior"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "coroutine.handle.resumption"
source_module = "[coroutine.handle.resumption]/1"
tags = [ "coroutine", "handle", "resume", "concurrency", "implementation_defined",]
header = "<coroutine>"

[[axioms]]
id = "cpp20_coroutine_handle_resume_precond_suspended_e7a3c9d5"
content = "Calling resume() or operator()() requires *this refers to a suspended coroutine."
formal_spec = "h.resume() || h() requires refers_to_coroutine(h) && is_suspended(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.resumption"
source_module = "[coroutine.handle.resumption]/2"
tags = [ "coroutine", "handle", "precondition", "suspended", "resume",]
function = "std::coroutine_handle::resume"
header = "<coroutine>"
signature = "void std::coroutine_handle<T>::resume() const"

[[axioms]]
id = "cpp20_coroutine_handle_resume_precond_not_final_f8b4d0e6"
content = "Calling resume() or operator()() requires the coroutine is not suspended at its final suspend point."
formal_spec = "h.resume() || h() requires !is_suspended_at_final(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.resumption"
source_module = "[coroutine.handle.resumption]/2"
tags = [ "coroutine", "handle", "precondition", "final_suspend", "resume",]
function = "std::coroutine_handle::resume"
header = "<coroutine>"
signature = "void std::coroutine_handle<T>::resume() const"

[[axioms]]
id = "cpp20_coroutine_handle_destroy_precond_suspended_a9c5e1f7"
content = "Calling destroy() requires *this refers to a suspended coroutine."
formal_spec = "h.destroy() requires refers_to_coroutine(h) && is_suspended(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.resumption"
source_module = "[coroutine.handle.resumption]/4"
tags = [ "coroutine", "handle", "precondition", "suspended", "destroy",]
function = "std::coroutine_handle::destroy"
header = "<coroutine>"
signature = "void std::coroutine_handle<T>::destroy() const"

[[axioms]]
id = "cpp20_coroutine_handle_promise_precond_refers_b0d6f2a8"
content = "Calling promise() requires *this refers to a coroutine."
formal_spec = "h.promise() requires refers_to_coroutine(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.promise"
source_module = "[coroutine.handle.promise]/1"
tags = [ "coroutine", "handle", "precondition", "promise",]
function = "std::coroutine_handle::promise"
header = "<coroutine>"
signature = "Promise& std::coroutine_handle<Promise>::promise() const"
depends_on = [ "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4",]

[[axioms]]
id = "cpp20_coroutine_handle_promise_returns_ref_c1e7a3b9"
content = "promise() returns a reference to the promise of the coroutine."
formal_spec = "h.promise() returns Promise& && refers_to_promise_of_coroutine(h)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.handle.promise"
source_module = "[coroutine.handle.promise]/2"
tags = [ "coroutine", "handle", "promise", "reference",]
function = "std::coroutine_handle::promise"
header = "<coroutine>"
signature = "Promise& std::coroutine_handle<Promise>::promise() const"
depends_on = [ "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4",]

[[axioms]]
id = "cpp20_coroutine_traits_primary_promise_type_requires_valid_qualified_id_a7f3d2e1"
content = "coroutine_traits<R, ArgTypes...> has promise_type member only if R::promise_type is a valid qualified-id denoting a type."
formal_spec = "is_valid_qualified_id(R::promise_type) && denotes_type(R::promise_type) <=> has_member(coroutine_traits<R, ArgTypes...>, promise_type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.traits.primary"
source_module = "[coroutine.traits.primary]/1"
tags = [ "coroutine", "traits", "template", "sfinae",]
function = "coroutine_traits"
header = "<coroutine>"
signature = "template<typename R, typename... ArgTypes> struct coroutine_traits"

[[axioms]]
id = "cpp20_coroutine_traits_primary_promise_type_member_definition_b8c4d5e2"
content = "When R::promise_type is valid and denotes a type, coroutine_traits<R, ArgTypes...>::promise_type is defined as using promise_type = R::promise_type."
formal_spec = "is_valid_qualified_id(R::promise_type) && denotes_type(R::promise_type) => coroutine_traits<R, ArgTypes...>::promise_type == R::promise_type"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.traits.primary"
source_module = "[coroutine.traits.primary]/1"
tags = [ "coroutine", "traits", "template", "type_alias",]
function = "coroutine_traits"
header = "<coroutine>"
signature = "template<typename R, typename... ArgTypes> struct coroutine_traits"

[[axioms]]
id = "cpp20_coroutine_traits_primary_no_members_when_invalid_c9d5e6f3"
content = "coroutine_traits<R, ArgTypes...> has no members when R::promise_type is not a valid qualified-id or does not denote a type."
formal_spec = "!(is_valid_qualified_id(R::promise_type) && denotes_type(R::promise_type)) => no_members(coroutine_traits<R, ArgTypes...>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.traits.primary"
source_module = "[coroutine.traits.primary]/1"
tags = [ "coroutine", "traits", "template", "sfinae",]
function = "coroutine_traits"
header = "<coroutine>"
signature = "template<typename R, typename... ArgTypes> struct coroutine_traits"

[[axioms]]
id = "cpp20_coroutine_traits_specialization_constraint_promise_type_required_d0e6f7a4"
content = "Program-defined specializations of coroutine_traits must define a publicly accessible nested type named promise_type."
formal_spec = "is_program_defined_specialization(coroutine_traits<R, ArgTypes...>) => has_public_member_type(coroutine_traits<R, ArgTypes...>, promise_type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.traits.primary"
source_module = "[coroutine.traits.primary]/2"
tags = [ "coroutine", "traits", "specialization", "requirement", "customization_point",]
function = "coroutine_traits"
header = "<coroutine>"
signature = "template<typename R, typename... ArgTypes> struct coroutine_traits"

[[axioms]]
id = "cpp20_coroutine_traits_specialization_constraint_public_access_e1f7a8b5"
content = "The promise_type member in program-defined coroutine_traits specializations must be publicly accessible."
formal_spec = "is_program_defined_specialization(coroutine_traits<R, ArgTypes...>) && has_member_type(coroutine_traits<R, ArgTypes...>, promise_type) => is_public(coroutine_traits<R, ArgTypes...>::promise_type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.traits.primary"
source_module = "[coroutine.traits.primary]/2"
tags = [ "coroutine", "traits", "specialization", "access_control", "requirement",]
function = "coroutine_traits"
header = "<coroutine>"
signature = "template<typename R, typename... ArgTypes> struct coroutine_traits"

[[axioms]]
id = "cpp20_coroutine_traits_primary_promise_type_public_access_f2a8b9c6"
content = "The promise_type member defined by the primary coroutine_traits template is publicly accessible."
formal_spec = "is_valid_qualified_id(R::promise_type) && denotes_type(R::promise_type) => is_public(coroutine_traits<R, ArgTypes...>::promise_type)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "coroutine.traits.primary"
source_module = "[coroutine.traits.primary]/1"
tags = [ "coroutine", "traits", "access_control", "template",]
function = "coroutine_traits"
header = "<coroutine>"
signature = "template<typename R, typename... ArgTypes> struct coroutine_traits"

[[axioms]]
id = "cpp20_jthread_cons_default_postcond_no_thread_a1b2c3d4"
content = "Default-constructed jthread does not represent a thread of execution: get_id() == id() is true"
formal_spec = "jthread() => get_id() == id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/2"
tags = [ "thread", "jthread", "constructor", "postcondition",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread()"

[[axioms]]
id = "cpp20_jthread_cons_default_postcond_stop_not_possible_e5f6a7b8"
content = "Default-constructed jthread has no stop source: ssource.stop_possible() is false"
formal_spec = "jthread() => ssource.stop_possible() == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/2"
tags = [ "thread", "jthread", "constructor", "postcondition", "stop_token",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread()"

[[axioms]]
id = "cpp20_jthread_cons_f_constraint_not_jthread_c9d0e1f2"
content = "jthread template constructor requires remove_cvref_t<F> is not the same type as jthread"
formal_spec = "jthread(F&&, Args&&...) requires !same_as<remove_cvref_t<F>, jthread>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/3"
tags = [ "thread", "jthread", "constructor", "constraint", "template",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"
depends_on = [ "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5",]

[[axioms]]
id = "cpp20_jthread_cons_f_mandate_f_constructible_a3b4c5d6"
content = "jthread template constructor mandates is_constructible_v<decay_t<F>, F> is true"
formal_spec = "jthread(F&&, Args&&...) => is_constructible_v<decay_t<F>, F> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/4.1"
tags = [ "thread", "jthread", "constructor", "mandate", "template",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"
depends_on = [ "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5",]

[[axioms]]
id = "cpp20_jthread_cons_f_mandate_args_constructible_b7c8d9e0"
content = "jthread template constructor mandates (is_constructible_v<decay_t<Args>, Args> && ...) is true"
formal_spec = "jthread(F&&, Args&&...) => (is_constructible_v<decay_t<Args>, Args> && ...)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/4.2"
tags = [ "thread", "jthread", "constructor", "mandate", "template",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"
depends_on = [ "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5",]

[[axioms]]
id = "cpp20_jthread_cons_f_mandate_invocable_f1a2b3c4"
content = "jthread template constructor mandates is_invocable_v<decay_t<F>, decay_t<Args>...> || is_invocable_v<decay_t<F>, stop_token, decay_t<Args>...> is true"
formal_spec = "jthread(F&&, Args&&...) => is_invocable_v<decay_t<F>, decay_t<Args>...> || is_invocable_v<decay_t<F>, stop_token, decay_t<Args>...>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/4.3"
tags = [ "thread", "jthread", "constructor", "mandate", "template", "invocable",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"
depends_on = [ "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5",]

[[axioms]]
id = "cpp20_jthread_cons_f_effect_terminate_on_exception_d5e6f7a8"
content = "If the invoke expression in jthread constructor exits via an exception, terminate is called"
formal_spec = "jthread(F&&, Args&&...) && invoke_throws_exception => terminate()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/5"
tags = [ "thread", "jthread", "constructor", "exception", "terminate",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_cons_f_postcond_id_not_default_e9f0a1b2"
content = "After successful jthread(F&&, Args&&...) construction, get_id() != id() is true"
formal_spec = "jthread(F&&, Args&&...) => get_id() != id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/7"
tags = [ "thread", "jthread", "constructor", "postcondition",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"

[[axioms]]
id = "cpp20_jthread_cons_f_postcond_stop_possible_c3d4e5f6"
content = "After successful jthread(F&&, Args&&...) construction, ssource.stop_possible() is true"
formal_spec = "jthread(F&&, Args&&...) => ssource.stop_possible() == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/7"
tags = [ "thread", "jthread", "constructor", "postcondition", "stop_token",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"

[[axioms]]
id = "cpp20_jthread_cons_f_postcond_represents_thread_a7b8c9d0"
content = "After successful jthread(F&&, Args&&...) construction, *this represents the newly started thread"
formal_spec = "jthread(F&&, Args&&...) => represents(*this, new_thread)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/7"
tags = [ "thread", "jthread", "constructor", "postcondition",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"

[[axioms]]
id = "cpp20_jthread_cons_f_throws_system_error_b1c2d3e4"
content = "jthread(F&&, Args&&...) throws system_error if unable to start the new thread"
formal_spec = "jthread(F&&, Args&&...) && !can_start_thread => throws(system_error)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/8"
tags = [ "thread", "jthread", "constructor", "exception", "system_error",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(F&& f, Args&&... args)"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_cons_move_postcond_x_id_default_f5a6b7c8"
content = "After jthread move construction, x.get_id() == id() is true"
formal_spec = "jthread(jthread&& x) => post: x.get_id() == id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/10"
tags = [ "thread", "jthread", "move", "constructor", "postcondition",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(jthread&& x)"

[[axioms]]
id = "cpp20_jthread_cons_move_postcond_this_id_from_x_d9e0f1a2"
content = "After jthread move construction, get_id() returns the value of x.get_id() prior to construction"
formal_spec = "jthread(jthread&& x) => post: get_id() == pre: x.get_id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/10"
tags = [ "thread", "jthread", "move", "constructor", "postcondition",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(jthread&& x)"

[[axioms]]
id = "cpp20_jthread_cons_move_postcond_ssource_moved_b3c4d5e6"
content = "After jthread move construction, ssource has the value of x.ssource prior to construction"
formal_spec = "jthread(jthread&& x) => post: ssource == pre: x.ssource"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/10"
tags = [ "thread", "jthread", "move", "constructor", "postcondition", "stop_token",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(jthread&& x)"

[[axioms]]
id = "cpp20_jthread_cons_move_postcond_x_stop_not_possible_a7b8c9d0"
content = "After jthread move construction, x.ssource.stop_possible() is false"
formal_spec = "jthread(jthread&& x) => post: x.ssource.stop_possible() == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/10"
tags = [ "thread", "jthread", "move", "constructor", "postcondition", "stop_token",]
function = "jthread::jthread"
header = "<thread>"
signature = "jthread(jthread&& x)"

[[axioms]]
id = "cpp20_jthread_dtor_effect_request_stop_join_e1f2a3b4"
content = "jthread destructor calls request_stop() and then join() if joinable() is true"
formal_spec = "~jthread() && joinable() => request_stop() then join()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/11"
tags = [ "thread", "jthread", "destructor", "join", "stop_token",]
function = "jthread::~jthread"
header = "<thread>"
signature = "~jthread()"

[[axioms]]
id = "cpp20_jthread_move_assign_effect_self_no_effect_c5d6e7f8"
content = "jthread move assignment has no effects if &x == this is true"
formal_spec = "operator=(jthread&& x) && &x == this => no_effects"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/12"
tags = [ "thread", "jthread", "move", "assignment", "self-assignment",]
function = "jthread::operator="
header = "<thread>"
signature = "jthread& operator=(jthread&& x)"
depends_on = [ "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_jthread_move_assign_effect_request_stop_join_a9b0c1d2"
content = "jthread move assignment calls request_stop() and join() if &x != this and joinable() is true"
formal_spec = "operator=(jthread&& x) && &x != this && joinable() => request_stop() then join()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/12"
tags = [ "thread", "jthread", "move", "assignment", "join", "stop_token",]
function = "jthread::operator="
header = "<thread>"
signature = "jthread& operator=(jthread&& x)"
depends_on = [ "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_jthread_move_assign_postcond_id_from_x_e3f4a5b6"
content = "After jthread move assignment, get_id() returns the value of x.get_id() prior to assignment"
formal_spec = "operator=(jthread&& x) => post: get_id() == pre: x.get_id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/13"
tags = [ "thread", "jthread", "move", "assignment", "postcondition",]
function = "jthread::operator="
header = "<thread>"
signature = "jthread& operator=(jthread&& x)"
depends_on = [ "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_jthread_move_assign_postcond_ssource_from_x_c7d8e9f0"
content = "After jthread move assignment, ssource has the value of x.ssource prior to assignment"
formal_spec = "operator=(jthread&& x) => post: ssource == pre: x.ssource"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.cons"
source_module = "[thread.jthread.cons]/13"
tags = [ "thread", "jthread", "move", "assignment", "postcondition", "stop_token",]
function = "jthread::operator="
header = "<thread>"
signature = "jthread& operator=(jthread&& x)"
depends_on = [ "ctrl_r_conversion_operator_precondition_rvalue_143",]

[[axioms]]
id = "cpp20_jthread_joinable_returns_id_not_default_a1b2c3d4"
content = "jthread::joinable() returns get_id() != id()"
formal_spec = "joinable() <=> get_id() != id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/2"
tags = [ "thread", "jthread", "joinable",]
function = "jthread::joinable"
header = "<thread>"
signature = "bool joinable() const noexcept"

[[axioms]]
id = "cpp20_jthread_join_postcond_thread_completed_b5c6d7e8"
content = "After jthread::join() returns, the thread represented by *this has completed"
formal_spec = "join() => post: thread_completed(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/5"
tags = [ "thread", "jthread", "join", "postcondition",]
function = "jthread::join"
header = "<thread>"
signature = "void join()"

[[axioms]]
id = "cpp20_jthread_join_postcond_id_default_f9a0b1c2"
content = "After jthread::join() returns, get_id() == id() is true"
formal_spec = "join() => post: get_id() == id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/5"
tags = [ "thread", "jthread", "join", "postcondition",]
function = "jthread::join"
header = "<thread>"
signature = "void join()"

[[axioms]]
id = "cpp20_jthread_join_throws_deadlock_detected_d3e4f5a6"
content = "jthread::join() throws system_error with resource_deadlock_would_occur if deadlock is detected"
formal_spec = "join() && deadlock_detected => throws(system_error, resource_deadlock_would_occur)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/7.1"
tags = [ "thread", "jthread", "join", "exception", "deadlock",]
function = "jthread::join"
header = "<thread>"
signature = "void join()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_join_throws_self_join_b7c8d9e0"
content = "jthread::join() throws system_error with resource_deadlock_would_occur if get_id() == this_thread::get_id()"
formal_spec = "join() && get_id() == this_thread::get_id() => throws(system_error, resource_deadlock_would_occur)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/7.1"
tags = [ "thread", "jthread", "join", "exception", "self-join",]
function = "jthread::join"
header = "<thread>"
signature = "void join()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_join_throws_no_such_process_a1b2c3d4"
content = "jthread::join() throws system_error with no_such_process if the thread is not valid"
formal_spec = "join() && !valid_thread(*this) => throws(system_error, no_such_process)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/7.2"
tags = [ "thread", "jthread", "join", "exception",]
function = "jthread::join"
header = "<thread>"
signature = "void join()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_join_throws_invalid_argument_e5f6a7b8"
content = "jthread::join() throws system_error with invalid_argument if the thread is not joinable"
formal_spec = "join() && !joinable() => throws(system_error, invalid_argument)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/7.3"
tags = [ "thread", "jthread", "join", "exception", "precondition",]
function = "jthread::join"
header = "<thread>"
signature = "void join()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_detach_postcond_id_default_c9d0e1f2"
content = "After jthread::detach() returns, get_id() == id() is true"
formal_spec = "detach() => post: get_id() == id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/9"
tags = [ "thread", "jthread", "detach", "postcondition",]
function = "jthread::detach"
header = "<thread>"
signature = "void detach()"

[[axioms]]
id = "cpp20_jthread_detach_throws_no_such_process_a3b4c5d6"
content = "jthread::detach() throws system_error with no_such_process if the thread is not valid"
formal_spec = "detach() && !valid_thread(*this) => throws(system_error, no_such_process)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/11.1"
tags = [ "thread", "jthread", "detach", "exception",]
function = "jthread::detach"
header = "<thread>"
signature = "void detach()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_detach_throws_invalid_argument_b7c8d9e0"
content = "jthread::detach() throws system_error with invalid_argument if the thread is not joinable"
formal_spec = "detach() && !joinable() => throws(system_error, invalid_argument)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/11.2"
tags = [ "thread", "jthread", "detach", "exception", "precondition",]
function = "jthread::detach"
header = "<thread>"
signature = "void detach()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_jthread_get_id_returns_default_if_no_thread_f1a2b3c4"
content = "jthread::get_id() returns a default constructed id object if *this does not represent a thread"
formal_spec = "!represents(*this, thread) => get_id() == id()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/12"
tags = [ "thread", "jthread", "get_id",]
function = "jthread::get_id"
header = "<thread>"
signature = "jthread::id get_id() const noexcept"

[[axioms]]
id = "cpp20_jthread_get_id_returns_thread_id_d5e6f7a8"
content = "jthread::get_id() returns this_thread::get_id() for the thread of execution represented by *this"
formal_spec = "represents(*this, thread) => get_id() == this_thread::get_id(thread)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.mem"
source_module = "[thread.jthread.mem]/12"
tags = [ "thread", "jthread", "get_id",]
function = "jthread::get_id"
header = "<thread>"
signature = "jthread::id get_id() const noexcept"

[[axioms]]
id = "cpp20_jthread_get_stop_source_returns_ssource_a9b0c1d2"
content = "jthread::get_stop_source() returns ssource"
formal_spec = "get_stop_source() == ssource"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.stop"
source_module = "[thread.jthread.stop]/1"
tags = [ "thread", "jthread", "stop_token", "stop_source",]
function = "jthread::get_stop_source"
header = "<thread>"
signature = "stop_source get_stop_source() noexcept"

[[axioms]]
id = "cpp20_jthread_get_stop_token_returns_ssource_token_e3f4a5b6"
content = "jthread::get_stop_token() returns ssource.get_token()"
formal_spec = "get_stop_token() == ssource.get_token()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.stop"
source_module = "[thread.jthread.stop]/2"
tags = [ "thread", "jthread", "stop_token",]
function = "jthread::get_stop_token"
header = "<thread>"
signature = "stop_token get_stop_token() const noexcept"

[[axioms]]
id = "cpp20_jthread_request_stop_returns_ssource_request_c7d8e9f0"
content = "jthread::request_stop() returns ssource.request_stop()"
formal_spec = "request_stop() == ssource.request_stop()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.stop"
source_module = "[thread.jthread.stop]/3"
tags = [ "thread", "jthread", "stop_token", "request_stop",]
function = "jthread::request_stop"
header = "<thread>"
signature = "bool request_stop() noexcept"

[[axioms]]
id = "cpp20_jthread_swap_friend_equivalent_member_a1b2c3d4"
content = "Free function swap(jthread&, jthread&) is equivalent to x.swap(y)"
formal_spec = "swap(x, y) <=> x.swap(y)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.special"
source_module = "[thread.jthread.special]/1"
tags = [ "thread", "jthread", "swap",]
function = "swap"
header = "<thread>"
signature = "void swap(jthread& x, jthread& y) noexcept"

[[axioms]]
id = "cpp20_jthread_hardware_concurrency_delegates_thread_b5c6d7e8"
content = "jthread::hardware_concurrency() returns thread::hardware_concurrency()"
formal_spec = "jthread::hardware_concurrency() == thread::hardware_concurrency()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.jthread.static"
source_module = "[thread.jthread.static]/1"
tags = [ "thread", "jthread", "hardware_concurrency", "static",]
function = "jthread::hardware_concurrency"
header = "<thread>"
signature = "static unsigned int hardware_concurrency() noexcept"

[[axioms]]
id = "cpp20_stoptoken_concepts_stoppable_callback_registration_precond_a7f3e2d1"
content = "If t.stop_possible() is true during stoppable callback registration, callback_fn must be successfully initialized from init before the callback can be registered."
formal_spec = "stoppable_callback_registration(scb, t, init) && t.stop_possible() => (callback_fn.initialized_from(init) before callback_registered(t.stop_state, callback_fn))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/3.2.1"
tags = [ "concurrency", "stop_token", "callback", "initialization",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_callback_registration_throw_constraint_b8d4f1a3"
content = "During stoppable callback registration, if t.stop_possible() is true, construction of scb shall only throw exceptions thrown by the initialization of callback_fn from init."
formal_spec = "stoppable_callback_registration(scb, t, init) && t.stop_possible() && throws(scb.constructor) => exception_source(callback_fn.initialization(init))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/3.2.1.2"
tags = [ "concurrency", "stop_token", "callback", "exception",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_callback_terminate_on_exception_c9e5a2f7"
content = "If a registered callback invocation exits via an exception during a stop request operation, std::terminate shall be invoked."
formal_spec = "stop_request_operation(state) && callback_registered(state, callback_fn) && throws(callback_fn()) => invokes(std::terminate)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/12"
tags = [ "concurrency", "stop_token", "callback", "exception", "terminate",]
header = "<stop_token>"
depends_on = [ "ilp_end_with_return_error_effect_abort_terminates_c3d8e5f6",]

[[axioms]]
id = "cpp20_stoptoken_concepts_deregistration_blocking_precond_d1a7b3e8"
content = "If callback_fn is concurrently executing on another thread during stoppable callback deregistration, the deregistration shall block until callback_fn returns, such that the return strongly happens before the destruction of callback_fn."
formal_spec = "stoppable_callback_deregistration(scb) && executing_on_other_thread(callback_fn) => (blocks_until(callback_fn.returns) && strongly_happens_before(callback_fn.returns, callback_fn.destruction))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/3.3.3"
tags = [ "concurrency", "stop_token", "callback", "synchronization", "blocking",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_deregistration_no_self_block_e2f8c4d9"
content = "If callback_fn is executing on the current thread during stoppable callback deregistration, the destructor shall not block waiting for the return from the invocation of callback_fn."
formal_spec = "stoppable_callback_deregistration(scb) && executing_on_current_thread(callback_fn) => !blocks_on(callback_fn.returns)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/3.3.4"
tags = [ "concurrency", "stop_token", "callback", "deadlock_prevention",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_deregistration_no_cross_block_f3a9d5e1"
content = "A stoppable callback deregistration shall not block on the completion of the invocation of some other callback registered with the same logical stop state."
formal_spec = "stoppable_callback_deregistration(scb1) && registered_with(scb2, same_stop_state(scb1)) && scb1 != scb2 => !blocks_on(scb2.callback_fn.completion)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/3.3.5"
tags = [ "concurrency", "stop_token", "callback", "deadlock_prevention",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_stop_possible_propagation_a4e7b2f8"
content = "Any evaluation of u.stop_possible() or u.stop_requested() that happens after an evaluation of t.stop_possible() that is false must also be false, where u and t reference the same stop state."
formal_spec = "same_stop_state(t, u) && evaluates(t.stop_possible(), false, SP) && happens_after(eval, SP) && (eval = u.stop_possible() || eval = u.stop_requested()) => evaluates(eval, false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/7.1"
tags = [ "concurrency", "stop_token", "synchronization",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_stop_requested_propagation_b5f8c3a9"
content = "Any evaluation of u.stop_possible() or u.stop_requested() that happens after an evaluation of t.stop_requested() that is true must also be true, where u and t reference the same stop state."
formal_spec = "same_stop_state(t, u) && evaluates(t.stop_requested(), true, SR) && happens_after(eval, SR) && (eval = u.stop_possible() || eval = u.stop_requested()) => evaluates(eval, true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/7.2"
tags = [ "concurrency", "stop_token", "synchronization",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_disengaged_stop_possible_false_c6a9d4e2"
content = "If stoppable_token object t is disengaged, evaluations of t.stop_possible() and t.stop_requested() are false."
formal_spec = "disengaged(t) && models(typeof(t), stoppable_token) => (t.stop_possible() == false && t.stop_requested() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/7.4"
tags = [ "concurrency", "stop_token", "disengaged",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stoptoken_concepts_equality_semantics_d7b1e5f3"
content = "If t and u reference the same stop state, or if both t and u are disengaged, t==u is true; otherwise, it is false."
formal_spec = "models(typeof(t), stoppable_token) && models(typeof(u), stoppable_token) => ((same_stop_state(t, u) || (disengaged(t) && disengaged(u))) <=> (t == u))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/7.5"
tags = [ "concurrency", "stop_token", "equality",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_disengaged_behavior_e8c2f6a4"
content = "If stoppable-source object s is disengaged, s.stop_possible() and s.stop_requested() shall be false."
formal_spec = "disengaged(s) && models(typeof(s), stoppable-source) => (s.stop_possible() == false && s.stop_requested() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/9"
tags = [ "concurrency", "stop_source", "disengaged",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_disengaged_get_token_f9d3a7e5"
content = "If stoppable-source object t is disengaged, t.get_token() shall return a disengaged stop token."
formal_spec = "disengaged(t) && models(typeof(t), stoppable-source) => disengaged(t.get_token())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/10"
tags = [ "concurrency", "stop_source", "stop_token", "disengaged",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_no_data_races_a1e8b4f9"
content = "Calls to the member functions request_stop, stop_requested, and stop_possible and similarly named member functions on associated stoppable_token objects do not introduce data races."
formal_spec = "(calls(src.request_stop) || calls(src.stop_requested) || calls(src.stop_possible) || calls(tok.stop_requested) || calls(tok.stop_possible)) && associated(src, tok) => !introduces_data_race"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/11"
tags = [ "concurrency", "stop_source", "stop_token", "thread_safety",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_request_stop_synchronizes_b2f9c5a8"
content = "A call to request_stop that returns true synchronizes with a call to stop_requested on an associated stoppable_token or stoppable-source object that returns true."
formal_spec = "calls(src.request_stop, true) && associated(src, tok_or_src) && calls(tok_or_src.stop_requested, true) => synchronizes_with(src.request_stop, tok_or_src.stop_requested)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/11"
tags = [ "concurrency", "stop_source", "synchronization",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_callback_registration_synchronizes_c3a1d6e9"
content = "Registration of a callback synchronizes with the invocation of that callback."
formal_spec = "callback_registration(scb, callback_fn, state) && invokes(callback_fn) => synchronizes_with(callback_registration, callback_fn.invocation)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/11"
tags = [ "concurrency", "stop_token", "callback", "synchronization",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_disengaged_request_stop_d4b2e7f1"
content = "If the stoppable-source is disengaged, request_stop shall have no effect and return false."
formal_spec = "disengaged(src) && models(typeof(src), stoppable-source) && calls(src.request_stop()) => (no_effect && returns(false))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/12"
tags = [ "concurrency", "stop_source", "disengaged",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_request_stop_atomic_e5c3f8a2"
content = "A stop request operation's determination of whether a stop request has been made and the making of the stop request shall happen atomically, as-if by a read-modify-write operation."
formal_spec = "stop_request_operation(state) => (atomic_operation(determine_stop_requested(state) && make_stop_request(state)) && semantics(read_modify_write))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/12"
tags = [ "concurrency", "stop_source", "atomicity",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stopsource_concepts_request_stop_postcond_f6d4a9b3"
content = "After a call to request_stop, either a call to stop_possible shall return false or a call to stop_requested shall return true."
formal_spec = "after(src.request_stop()) => (src.stop_possible() == false || src.stop_requested() == true)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.concepts"
source_module = "[stoptoken.concepts]/12"
tags = [ "concurrency", "stop_source", "postcondition",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stop_token_disengaged_definition_a7e5c1f9"
content = "A stop_token object is disengaged when its exposition-only stop-state member is empty."
formal_spec = "typeof(tok) == stop_token => (disengaged(tok) <=> empty(tok.stop-state))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.general"
source_module = "[stoptoken.general]/2"
tags = [ "concurrency", "stop_token", "disengaged",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stop_token_stop_requested_disengaged_b8f6d2a1"
content = "stop_token::stop_requested() returns false if the token is disengaged."
formal_spec = "typeof(tok) == stop_token && disengaged(tok) => tok.stop_requested() == false"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "stoptoken.mem"
source_module = "[stoptoken.mem]/2"
tags = [ "concurrency", "stop_token", "disengaged",]
function = "std::stop_token::stop_requested"
header = "<stop_token>"
signature = "bool std::stop_token::stop_requested() const noexcept"

[[axioms]]
id = "cpp20_stop_token_stop_possible_no_source_c9a7e3d2"
content = "stop_token::stop_possible() returns false if the token is disengaged or if a stop request was not made and there are no associated stop_source objects."
formal_spec = "typeof(tok) == stop_token && (disengaged(tok) || (!stop_requested(tok.stop-state) && no_associated_stop_source(tok))) => tok.stop_possible() == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.mem"
source_module = "[stoptoken.mem]/3"
tags = [ "concurrency", "stop_token", "disengaged",]
function = "std::stop_token::stop_possible"
header = "<stop_token>"
signature = "bool std::stop_token::stop_possible() const noexcept"

[[axioms]]
id = "cpp20_stop_source_disengaged_definition_d1b8f4e3"
content = "A stop_source object is disengaged when its exposition-only stop-state member is empty."
formal_spec = "typeof(src) == stop_source => (disengaged(src) <=> empty(src.stop-state))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.general"
source_module = "[stopsource.general]/1"
tags = [ "concurrency", "stop_source", "disengaged",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_stop_source_constructor_postcond_e2c9a5f6"
content = "After default construction of stop_source, stop_possible() is true and stop_requested() is false."
formal_spec = "after(stop_source()) => (src.stop_possible() == true && src.stop_requested() == false)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.cons"
source_module = "[stopsource.cons]/2"
tags = [ "concurrency", "stop_source", "postcondition",]
function = "std::stop_source::stop_source"
header = "<stop_token>"
signature = "std::stop_source::stop_source()"

[[axioms]]
id = "cpp20_stop_source_constructor_bad_alloc_f3d1b6a9"
content = "stop_source default constructor throws bad_alloc if memory cannot be allocated for the stop state."
formal_spec = "calls(stop_source()) && !can_allocate_memory(stop_state) => throws(bad_alloc)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.cons"
source_module = "[stopsource.cons]/3"
tags = [ "concurrency", "stop_source", "exception", "allocation",]
function = "std::stop_source::stop_source"
header = "<stop_token>"
signature = "std::stop_source::stop_source()"
depends_on = [ "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1",]

[[axioms]]
id = "cpp20_stop_source_get_token_disengaged_a4f7c2e8"
content = "stop_source::get_token() returns stop_token() if stop_possible() is false."
formal_spec = "typeof(src) == stop_source && src.stop_possible() == false => src.get_token() == stop_token()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.mem"
source_module = "[stopsource.mem]/2"
tags = [ "concurrency", "stop_source", "stop_token",]
function = "std::stop_source::get_token"
header = "<stop_token>"
signature = "stop_token std::stop_source::get_token() const noexcept"

[[axioms]]
id = "cpp20_stop_source_stop_possible_definition_b5e8d3f1"
content = "stop_source::stop_possible() returns true if and only if stop-state is not nullptr."
formal_spec = "typeof(src) == stop_source => (src.stop_possible() <=> (src.stop-state != nullptr))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.mem"
source_module = "[stopsource.mem]/3"
tags = [ "concurrency", "stop_source",]
function = "std::stop_source::stop_possible"
header = "<stop_token>"
signature = "bool std::stop_source::stop_possible() const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_stop_callback_mandates_invocable_c6f9a4e2"
content = "stop_callback must be instantiated with a template parameter CallbackFn that satisfies both invocable and destructible."
formal_spec = "instantiate(stop_callback<CallbackFn>) => (invocable<CallbackFn> && destructible<CallbackFn>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopcallback.general"
source_module = "[stopcallback.general]/2"
tags = [ "concurrency", "stop_callback", "constraint",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_never_stop_token_stop_requested_always_false_d7a1e5f3"
content = "never_stop_token::stop_requested() always returns false."
formal_spec = "typeof(tok) == never_stop_token => tok.stop_requested() == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.never"
source_module = "[stoptoken.never]/1"
tags = [ "concurrency", "never_stop_token",]
function = "std::never_stop_token::stop_requested"
header = "<stop_token>"
signature = "static constexpr bool std::never_stop_token::stop_requested() noexcept"

[[axioms]]
id = "cpp20_never_stop_token_stop_possible_always_false_e8b2f6a4"
content = "never_stop_token::stop_possible() always returns false."
formal_spec = "typeof(tok) == never_stop_token => tok.stop_possible() == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.never"
source_module = "[stoptoken.never]/1"
tags = [ "concurrency", "never_stop_token",]
function = "std::never_stop_token::stop_possible"
header = "<stop_token>"
signature = "static constexpr bool std::never_stop_token::stop_possible() noexcept"

[[axioms]]
id = "cpp20_inplace_stop_token_stop_requested_ub_after_dtor_f9c3a7e5"
content = "The behavior of inplace_stop_token::stop_requested() is undefined unless the call strongly happens before the start of the destructor of the associated inplace_stop_source object."
formal_spec = "calls(tok.stop_requested()) && has_associated_source(tok, src) && !strongly_happens_before(tok.stop_requested(), src.~inplace_stop_source().start) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.inplace.mem"
source_module = "[stoptoken.inplace.mem]/3"
tags = [ "concurrency", "inplace_stop_token", "lifetime", "undefined_behavior",]
function = "std::inplace_stop_token::stop_requested"
header = "<stop_token>"
signature = "bool std::inplace_stop_token::stop_requested() const noexcept"
depends_on = [ "extract_precond_object_lifetime_started_b8c2d4e6",]

[[axioms]]
id = "cpp20_inplace_stop_token_stop_possible_impl_defined_a1d8e4f9"
content = "The behavior of inplace_stop_token::stop_possible() is implementation-defined unless the call strongly happens before the end of the storage duration of the associated inplace_stop_source object."
formal_spec = "calls(tok.stop_possible()) && has_associated_source(tok, src) && !strongly_happens_before(tok.stop_possible(), end_of_storage_duration(src)) => implementation_defined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stoptoken.inplace.mem"
source_module = "[stoptoken.inplace.mem]/5"
tags = [ "concurrency", "inplace_stop_token", "lifetime", "implementation_defined",]
function = "std::inplace_stop_token::stop_possible"
header = "<stop_token>"
signature = "bool std::inplace_stop_token::stop_possible() const noexcept"

[[axioms]]
id = "cpp20_inplace_stop_source_constructor_postcond_b2e9f5a8"
content = "After construction of inplace_stop_source, stop_requested() is false."
formal_spec = "after(inplace_stop_source()) => src.stop_requested() == false"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.inplace.cons"
source_module = "[stopsource.inplace.cons]/2"
tags = [ "concurrency", "inplace_stop_source", "postcondition",]
function = "std::inplace_stop_source::inplace_stop_source"
header = "<stop_token>"
signature = "constexpr std::inplace_stop_source::inplace_stop_source() noexcept"

[[axioms]]
id = "cpp20_inplace_stop_source_get_token_association_c3f1a6e9"
content = "inplace_stop_source::get_token() returns a new associated inplace_stop_token object whose stop-source member equals this."
formal_spec = "typeof(src) == inplace_stop_source => src.get_token().stop-source == &src"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.inplace.mem"
source_module = "[stopsource.inplace.mem]/1"
tags = [ "concurrency", "inplace_stop_source", "inplace_stop_token",]
function = "std::inplace_stop_source::get_token"
header = "<stop_token>"
signature = "constexpr inplace_stop_token std::inplace_stop_source::get_token() const noexcept"

[[axioms]]
id = "cpp20_inplace_stop_source_stop_possible_always_true_d4a2b7f1"
content = "inplace_stop_source::stop_possible() always returns true."
formal_spec = "typeof(src) == inplace_stop_source => src.stop_possible() == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.inplace.general"
source_module = "[stopsource.inplace.general]/1"
tags = [ "concurrency", "inplace_stop_source",]
function = "std::inplace_stop_source::stop_possible"
header = "<stop_token>"
signature = "static constexpr bool std::inplace_stop_source::stop_possible() noexcept"

[[axioms]]
id = "cpp20_inplace_stop_source_request_stop_postcond_e5b3c8a2"
content = "After inplace_stop_source::request_stop() is called, stop_requested() is true."
formal_spec = "after(src.request_stop()) => src.stop_requested() == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopsource.inplace.mem"
source_module = "[stopsource.inplace.mem]/4"
tags = [ "concurrency", "inplace_stop_source", "postcondition",]
function = "std::inplace_stop_source::request_stop"
header = "<stop_token>"
signature = "bool std::inplace_stop_source::request_stop() noexcept"

[[axioms]]
id = "cpp20_inplace_stop_callback_mandates_invocable_f6c4d9e3"
content = "inplace_stop_callback must be instantiated with a template parameter CallbackFn that satisfies both invocable and destructible."
formal_spec = "instantiate(inplace_stop_callback<CallbackFn>) => (invocable<CallbackFn> && destructible<CallbackFn>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stopcallback.inplace.general"
source_module = "[stopcallback.inplace.general]/1"
tags = [ "concurrency", "inplace_stop_callback", "constraint",]
header = "<stop_token>"

[[axioms]]
id = "cpp20_atomic_constraint_t_trivially_copyable_a1b2c3d4"
content = "The template argument T for atomic<T> must satisfy is_trivially_copyable_v<T> being true."
formal_spec = "instantiate(atomic<T>) => is_trivially_copyable_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.generic.general"
source_module = "[atomics.types.generic.general]/1"
tags = [ "atomic", "type_traits", "constraint",]
function = "std::atomic"
header = "<atomic>"
signature = "template<class T> struct atomic"

[[axioms]]
id = "cpp20_atomic_constraint_t_copy_constructible_b2c3d4e5"
content = "The template argument T for atomic<T> must satisfy is_copy_constructible_v<T> being true."
formal_spec = "instantiate(atomic<T>) => is_copy_constructible_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.generic.general"
source_module = "[atomics.types.generic.general]/1"
tags = [ "atomic", "type_traits", "constraint",]
function = "std::atomic"
header = "<atomic>"
signature = "template<class T> struct atomic"

[[axioms]]
id = "cpp20_atomic_constraint_t_move_constructible_c3d4e5f6"
content = "The template argument T for atomic<T> must satisfy is_move_constructible_v<T> being true."
formal_spec = "instantiate(atomic<T>) => is_move_constructible_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.generic.general"
source_module = "[atomics.types.generic.general]/1"
tags = [ "atomic", "type_traits", "constraint",]
function = "std::atomic"
header = "<atomic>"
signature = "template<class T> struct atomic"

[[axioms]]
id = "cpp20_atomic_constraint_t_copy_assignable_d4e5f6a7"
content = "The template argument T for atomic<T> must satisfy is_copy_assignable_v<T> being true."
formal_spec = "instantiate(atomic<T>) => is_copy_assignable_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.generic.general"
source_module = "[atomics.types.generic.general]/1"
tags = [ "atomic", "type_traits", "constraint",]
function = "std::atomic"
header = "<atomic>"
signature = "template<class T> struct atomic"

[[axioms]]
id = "cpp20_atomic_constraint_t_move_assignable_e5f6a7b8"
content = "The template argument T for atomic<T> must satisfy is_move_assignable_v<T> being true."
formal_spec = "instantiate(atomic<T>) => is_move_assignable_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.generic.general"
source_module = "[atomics.types.generic.general]/1"
tags = [ "atomic", "type_traits", "constraint",]
function = "std::atomic"
header = "<atomic>"
signature = "template<class T> struct atomic"

[[axioms]]
id = "cpp20_atomic_constraint_t_same_remove_cv_f6a7b8c9"
content = "The template argument T for atomic<T> must satisfy is_same_v<T, remove_cv_t<T>> being true (T must not be cv-qualified)."
formal_spec = "instantiate(atomic<T>) => is_same_v<T, remove_cv_t<T>> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.generic.general"
source_module = "[atomics.types.generic.general]/1"
tags = [ "atomic", "type_traits", "constraint", "cv_qualification",]
function = "std::atomic"
header = "<atomic>"
signature = "template<class T> struct atomic"

[[axioms]]
id = "cpp20_atomic_default_ctor_constraint_default_constructible_a7b8c9d0"
content = "The default constructor of atomic<T> is constrained by is_default_constructible_v<T> being true."
formal_spec = "call(atomic<T>::atomic()) requires is_default_constructible_v<T> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/1"
tags = [ "atomic", "constructor", "constraint",]
function = "std::atomic::atomic"
header = "<atomic>"
signature = "constexpr atomic() noexcept(is_nothrow_default_constructible_v<T>)"

[[axioms]]
id = "cpp20_atomic_init_not_atomic_race_ub_b8c9d0e1"
content = "Construction/initialization of atomic<T> is not an atomic operation. Having an access to an atomic object A race with its construction results in undefined behavior."
formal_spec = "construction(atomic<T> A) && race(access(A), construction(A)) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/3"
tags = [ "atomic", "initialization", "race", "undefined_behavior", "concurrency",]
function = "std::atomic::atomic"
header = "<atomic>"
signature = "constexpr atomic(T desired) noexcept"

[[axioms]]
id = "cpp20_atomic_store_precond_order_valid_c9d0e1f2"
content = "Calling atomic<T>::store() requires that order is memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "call(atomic<T>::store(desired, order)) requires order in {memory_order::relaxed, memory_order::release, memory_order::seq_cst}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/7"
tags = [ "atomic", "precondition", "memory_order",]
function = "std::atomic::store"
header = "<atomic>"
signature = "void store(T desired, memory_order order = memory_order::seq_cst) noexcept"

[[axioms]]
id = "cpp20_atomic_store_volatile_constraint_lock_free_d0e1f2a3"
content = "The volatile overload of atomic<T>::store() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T>::store() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/6"
tags = [ "atomic", "constraint", "volatile", "lock_free",]
function = "std::atomic::store"
header = "<atomic>"
signature = "void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_load_precond_order_valid_e1f2a3b4"
content = "Calling atomic<T>::load() requires that order is memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst."
formal_spec = "call(atomic<T>::load(order)) requires order in {memory_order::relaxed, memory_order::acquire, memory_order::seq_cst}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/13"
tags = [ "atomic", "precondition", "memory_order",]
function = "std::atomic::load"
header = "<atomic>"
signature = "T load(memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomic_load_volatile_constraint_lock_free_f2a3b4c5"
content = "The volatile overload of atomic<T>::load() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T>::load() const volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/12"
tags = [ "atomic", "constraint", "volatile", "lock_free",]
function = "std::atomic::load"
header = "<atomic>"
signature = "T load(memory_order order = memory_order::seq_cst) const volatile noexcept"

[[axioms]]
id = "cpp20_atomic_conversion_volatile_constraint_lock_free_a3b4c5d6"
content = "The volatile overload of atomic<T>::operator T() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T>::operator T() const volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/16"
tags = [ "atomic", "constraint", "volatile", "lock_free", "conversion",]
function = "std::atomic::operator T"
header = "<atomic>"
signature = "operator T() const volatile noexcept"

[[axioms]]
id = "cpp20_atomic_exchange_volatile_constraint_lock_free_b4c5d6e7"
content = "The volatile overload of atomic<T>::exchange() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T>::exchange() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/18"
tags = [ "atomic", "constraint", "volatile", "lock_free",]
function = "std::atomic::exchange"
header = "<atomic>"
signature = "T exchange(T desired, memory_order order = memory_order::seq_cst) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_compare_exchange_volatile_constraint_lock_free_c5d6e7f8"
content = "The volatile overload of atomic<T>::compare_exchange_weak/strong() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T>::compare_exchange_{weak|strong}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/21"
tags = [ "atomic", "constraint", "volatile", "lock_free",]
function = "std::atomic::compare_exchange_weak"
header = "<atomic>"
signature = "bool compare_exchange_weak(T& expected, T desired, memory_order success, memory_order failure) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_compare_exchange_precond_failure_order_d6e7f8a9"
content = "Calling atomic<T>::compare_exchange_weak/strong() requires that failure order is memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst."
formal_spec = "call(atomic<T>::compare_exchange_{weak|strong}(expected, desired, success, failure)) requires failure in {memory_order::relaxed, memory_order::acquire, memory_order::seq_cst}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/22"
tags = [ "atomic", "precondition", "memory_order",]
function = "std::atomic::compare_exchange_weak"
header = "<atomic>"
signature = "bool compare_exchange_weak(T& expected, T desired, memory_order success, memory_order failure) noexcept"

[[axioms]]
id = "cpp20_atomic_wait_precond_order_valid_e7f8a9b0"
content = "Calling atomic<T>::wait() requires that order is memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst."
formal_spec = "call(atomic<T>::wait(old, order)) requires order in {memory_order::relaxed, memory_order::acquire, memory_order::seq_cst}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/29"
tags = [ "atomic", "precondition", "memory_order", "waiting",]
function = "std::atomic::wait"
header = "<atomic>"
signature = "void wait(T old, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomic_int_fetch_key_volatile_constraint_lock_free_f8a9b0c1"
content = "The volatile overload of atomic<integral-type>::fetch_key() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<integral-type>::fetch_{add|sub|and|or|xor|max|min}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.int"
source_module = "[atomics.types.int]/5"
tags = [ "atomic", "constraint", "volatile", "lock_free", "integer",]
function = "std::atomic::fetch_add"
header = "<atomic>"
signature = "integral-type fetch_add(integral-type operand, memory_order order = memory_order::seq_cst) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_int_store_key_volatile_constraint_lock_free_a9b0c1d2"
content = "The volatile overload of atomic<integral-type>::store_key() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<integral-type>::store_{add|sub|and|or|xor|max|min}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.int"
source_module = "[atomics.types.int]/10"
tags = [ "atomic", "constraint", "volatile", "lock_free", "integer",]
function = "std::atomic::store_add"
header = "<atomic>"
signature = "void store_add(integral-type operand, memory_order order = memory_order::seq_cst) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_int_store_key_precond_order_valid_b0c1d2e3"
content = "Calling atomic<integral-type>::store_key() requires that order is memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "call(atomic<integral-type>::store_{add|sub|and|or|xor|max|min}(operand, order)) requires order in {memory_order::relaxed, memory_order::release, memory_order::seq_cst}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.int"
source_module = "[atomics.types.int]/11"
tags = [ "atomic", "precondition", "memory_order", "integer",]
function = "std::atomic::store_add"
header = "<atomic>"
signature = "void store_add(integral-type operand, memory_order order = memory_order::seq_cst) noexcept"

[[axioms]]
id = "cpp20_atomic_int_operator_compound_volatile_constraint_lock_free_c1d2e3f4"
content = "The volatile overload of atomic<integral-type>::operator+=/etc is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<integral-type>::operator{+=|-=|&=||=|^=}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.int"
source_module = "[atomics.types.int]/14"
tags = [ "atomic", "constraint", "volatile", "lock_free", "integer",]
function = "std::atomic::operator+="
header = "<atomic>"
signature = "integral-type operator+=(integral-type operand) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_float_fetch_key_volatile_constraint_lock_free_d2e3f4a5"
content = "The volatile overload of atomic<floating-point-type>::fetch_key() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<floating-point-type>::fetch_{add|sub|max|min|fmaximum|fminimum|fmaximum_num|fminimum_num}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.float"
source_module = "[atomics.types.float]/5"
tags = [ "atomic", "constraint", "volatile", "lock_free", "floating_point",]
function = "std::atomic::fetch_add"
header = "<atomic>"
signature = "floating-point-type fetch_add(floating-point-type operand, memory_order order = memory_order::seq_cst) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_float_store_key_volatile_constraint_lock_free_e3f4a5b6"
content = "The volatile overload of atomic<floating-point-type>::store_key() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<floating-point-type>::store_{add|sub|max|min|fmaximum|fminimum|fmaximum_num|fminimum_num}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.float"
source_module = "[atomics.types.float]/11"
tags = [ "atomic", "constraint", "volatile", "lock_free", "floating_point",]
function = "std::atomic::store_add"
header = "<atomic>"
signature = "void store_add(floating-point-type operand, memory_order order = memory_order::seq_cst) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_float_store_key_precond_order_valid_f4a5b6c7"
content = "Calling atomic<floating-point-type>::store_key() requires that order is memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "call(atomic<floating-point-type>::store_{add|sub|max|min|fmaximum|fminimum|fmaximum_num|fminimum_num}(operand, order)) requires order in {memory_order::relaxed, memory_order::release, memory_order::seq_cst}"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.float"
source_module = "[atomics.types.float]/12"
tags = [ "atomic", "precondition", "memory_order", "floating_point",]
function = "std::atomic::store_add"
header = "<atomic>"
signature = "void store_add(floating-point-type operand, memory_order order = memory_order::seq_cst) noexcept"

[[axioms]]
id = "cpp20_atomic_float_operator_compound_volatile_constraint_lock_free_a5b6c7d8"
content = "The volatile overload of atomic<floating-point-type>::operator+=/etc is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<floating-point-type>::operator{+=|-=}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.float"
source_module = "[atomics.types.float]/17"
tags = [ "atomic", "constraint", "volatile", "lock_free", "floating_point",]
function = "std::atomic::operator+="
header = "<atomic>"
signature = "floating-point-type operator+=(floating-point-type operand) volatile noexcept"

[[axioms]]
id = "cpp20_atomic_pointer_fetch_key_volatile_constraint_lock_free_b6c7d8e9"
content = "The volatile overload of atomic<T*>::fetch_key() is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T*>::fetch_{add|sub|max|min}() volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.pointer"
source_module = "[atomics.types.pointer]/4"
tags = [ "atomic", "constraint", "volatile", "lock_free", "pointer",]
function = "std::atomic::fetch_add"
header = "<atomic>"
signature = "T* fetch_add(ptrdiff_t operand, memory_order order = memory_order::seq_cst) volatile noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomic_pointer_fetch_key_mandate_complete_type_c7d8e9f0"
content = "Calling atomic<T*>::fetch_key() mandates that T is a complete object type (pointer arithmetic on void* or function pointers is ill-formed)."
formal_spec = "call(atomic<T*>::fetch_{add|sub|max|min}()) requires is_complete_object_type(T) == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.pointer"
source_module = "[atomics.types.pointer]/5"
tags = [ "atomic", "mandate", "pointer", "complete_type",]
function = "std::atomic::fetch_add"
header = "<atomic>"
signature = "T* fetch_add(ptrdiff_t operand, memory_order order = memory_order::seq_cst) noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomic_assignment_volatile_constraint_lock_free_d8e9f0a1"
content = "The volatile overload of atomic<T>::operator=(T) is constrained by is_always_lock_free being true."
formal_spec = "call(atomic<T>::operator=(T) volatile) requires is_always_lock_free == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.types.operations"
source_module = "[atomics.types.operations]/9"
tags = [ "atomic", "constraint", "volatile", "lock_free",]
function = "std::atomic::operator="
header = "<atomic>"
signature = "T operator=(T desired) volatile noexcept"

[[axioms]]
id = "cpp20_atomics_ref_generic_trivially_copyable_constraint_a3b7c9d1"
content = "The program is ill-formed if is_trivially_copyable_v<T> is false for atomic_ref<T>."
formal_spec = "atomic_ref<T> && !is_trivially_copyable_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.generic.general"
source_module = "[atomics.ref.generic.general]/2"
tags = [ "atomic", "type_constraint", "trivially_copyable", "ill_formed",]
function = "std::atomic_ref"
header = "<atomic>"
signature = "template<class T> struct atomic_ref"

[[axioms]]
id = "cpp20_atomics_ref_generic_lifetime_precondition_e5f2a8c4"
content = "The lifetime of an object referenced by atomic_ref shall exceed the lifetime of all atomic_refs that reference the object."
formal_spec = "forall(atomic_ref<T> ar referencing obj) => lifetime(obj) > lifetime(ar)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.generic.general"
source_module = "[atomics.ref.generic.general]/3"
tags = [ "atomic", "lifetime", "precondition", "concurrency",]
function = "std::atomic_ref"
header = "<atomic>"
signature = "template<class T> struct atomic_ref"

[[axioms]]
id = "cpp20_atomics_ref_generic_exclusive_access_b4c8d2e6"
content = "While any atomic_ref instances exist that reference an object, all accesses to that object shall exclusively occur through those atomic_ref instances."
formal_spec = "exists(atomic_ref<T> ar referencing obj) && access(obj) && !through_atomic_ref(access) => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.generic.general"
source_module = "[atomics.ref.generic.general]/3"
tags = [ "atomic", "concurrency", "data_race", "exclusive_access",]
function = "std::atomic_ref"
header = "<atomic>"
signature = "template<class T> struct atomic_ref"

[[axioms]]
id = "cpp20_atomics_ref_generic_no_subobject_concurrent_ref_f9a3b7c1"
content = "No subobject of the object referenced by atomic_ref shall be concurrently referenced by any other atomic_ref object."
formal_spec = "atomic_ref<T>(obj) && atomic_ref<U>(subobject_of(obj)) && concurrent => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.generic.general"
source_module = "[atomics.ref.generic.general]/3"
tags = [ "atomic", "concurrency", "subobject", "data_race",]
function = "std::atomic_ref"
header = "<atomic>"
signature = "template<class T> struct atomic_ref"

[[axioms]]
id = "cpp20_atomics_ref_generic_volatile_lock_free_constraint_d8e2f4a6"
content = "The program is ill-formed if is_always_lock_free is false and is_volatile_v<T> is true for atomic_ref<T>."
formal_spec = "atomic_ref<T> && !is_always_lock_free && is_volatile_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.generic.general"
source_module = "[atomics.ref.generic.general]/5"
tags = [ "atomic", "volatile", "lock_free", "ill_formed",]
function = "std::atomic_ref"
header = "<atomic>"
signature = "template<class T> struct atomic_ref"

[[axioms]]
id = "cpp20_atomics_ref_ops_alignment_precondition_c7d1e5f9"
content = "The object passed to atomic_ref constructor must be aligned to required_alignment."
formal_spec = "atomic_ref<T>(obj) && alignment_of(obj) < required_alignment => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/5"
tags = [ "atomic", "alignment", "precondition", "constructor",]
function = "std::atomic_ref::atomic_ref"
header = "<atomic>"
signature = "constexpr explicit atomic_ref(T& obj)"

[[axioms]]
id = "cpp20_atomics_ref_ops_required_alignment_minimum_a2b6c8d0"
content = "The required_alignment for atomic_ref<T> is at least alignof(T)."
formal_spec = "atomic_ref<T>::required_alignment >= alignof(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/1"
tags = [ "atomic", "alignment", "constraint",]
function = "std::atomic_ref::required_alignment"
header = "<atomic>"
signature = "static constexpr size_t required_alignment"

[[axioms]]
id = "cpp20_atomics_ref_ops_converting_ctor_constraint_e4f8a2b6"
content = "The converting constructor from atomic_ref<U> requires T and U are similar types and is_convertible_v<U*, T*> is true."
formal_spec = "atomic_ref<T>(atomic_ref<U>) => similar_types(T, U) && is_convertible_v<U*, T*>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/9"
tags = [ "atomic", "constraint", "constructor", "type_conversion",]
function = "std::atomic_ref::atomic_ref"
header = "<atomic>"
signature = "template<class U> constexpr atomic_ref(const atomic_ref<U>&) noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_store_const_constraint_c1d5e9f3"
content = "The store operation is constrained: is_const_v<T> must be false."
formal_spec = "atomic_ref<T>::store(...) && is_const_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/11"
tags = [ "atomic", "constraint", "store", "const",]
function = "std::atomic_ref::store"
header = "<atomic>"
signature = "constexpr void store(value_type desired, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_store_order_precondition_b8c2d6e0"
content = "The store operation requires order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "atomic_ref<T>::store(desired, order) && order != relaxed && order != release && order != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/12"
tags = [ "atomic", "precondition", "memory_order", "store",]
function = "std::atomic_ref::store"
header = "<atomic>"
signature = "constexpr void store(value_type desired, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_load_order_precondition_a4b8c2d6"
content = "The load operation requires order to be memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst."
formal_spec = "atomic_ref<T>::load(order) && order != relaxed && order != acquire && order != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/16"
tags = [ "atomic", "precondition", "memory_order", "load",]
function = "std::atomic_ref::load"
header = "<atomic>"
signature = "constexpr value_type load(memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_exchange_const_constraint_d2e6f0a4"
content = "The exchange operation is constrained: is_const_v<T> must be false."
formal_spec = "atomic_ref<T>::exchange(...) && is_const_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/20"
tags = [ "atomic", "constraint", "exchange", "const",]
function = "std::atomic_ref::exchange"
header = "<atomic>"
signature = "constexpr value_type exchange(value_type desired, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_cmpxchg_const_constraint_e3f7a1b5"
content = "The compare_exchange operations are constrained: is_const_v<T> must be false."
formal_spec = "(atomic_ref<T>::compare_exchange_weak(...) || atomic_ref<T>::compare_exchange_strong(...)) && is_const_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/23"
tags = [ "atomic", "constraint", "compare_exchange", "const",]
function = "std::atomic_ref::compare_exchange_weak"
header = "<atomic>"
signature = "constexpr bool compare_exchange_weak(value_type& expected, value_type desired, memory_order success, memory_order failure) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_cmpxchg_failure_order_precondition_f4a8b2c6"
content = "The compare_exchange operations require failure to be memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst."
formal_spec = "compare_exchange(expected, desired, success, failure) && failure != relaxed && failure != acquire && failure != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/24"
tags = [ "atomic", "precondition", "memory_order", "compare_exchange",]
function = "std::atomic_ref::compare_exchange_weak"
header = "<atomic>"
signature = "constexpr bool compare_exchange_weak(value_type& expected, value_type desired, memory_order success, memory_order failure) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_wait_order_precondition_a5b9c3d7"
content = "The wait operation requires order to be memory_order::relaxed, memory_order::acquire, or memory_order::seq_cst."
formal_spec = "atomic_ref<T>::wait(old, order) && order != relaxed && order != acquire && order != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/28"
tags = [ "atomic", "precondition", "memory_order", "wait",]
function = "std::atomic_ref::wait"
header = "<atomic>"
signature = "constexpr void wait(value_type old, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_notify_one_const_constraint_b6c0d4e8"
content = "The notify_one operation is constrained: is_const_v<T> must be false."
formal_spec = "atomic_ref<T>::notify_one() && is_const_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/31"
tags = [ "atomic", "constraint", "notify", "const",]
function = "std::atomic_ref::notify_one"
header = "<atomic>"
signature = "constexpr void notify_one() const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_notify_all_const_constraint_c7d1e5f9"
content = "The notify_all operation is constrained: is_const_v<T> must be false."
formal_spec = "atomic_ref<T>::notify_all() && is_const_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/34"
tags = [ "atomic", "constraint", "notify", "const",]
function = "std::atomic_ref::notify_all"
header = "<atomic>"
signature = "constexpr void notify_all() const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_int_volatile_lock_free_constraint_d8e2f4a6"
content = "For integral specializations, the program is ill-formed if is_always_lock_free is false and is_volatile_v<integral-type> is true."
formal_spec = "atomic_ref<integral-type> && !is_always_lock_free && is_volatile_v<integral-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.int"
source_module = "[atomics.ref.int]/2"
tags = [ "atomic", "integral", "volatile", "lock_free", "ill_formed",]
function = "std::atomic_ref<integral-type>"
header = "<atomic>"
signature = "template<> struct atomic_ref<integral-type>"

[[axioms]]
id = "cpp20_atomics_ref_int_fetch_key_const_constraint_e9f3a7b1"
content = "The fetch_key operations on integral types are constrained: is_const_v<integral-type> must be false."
formal_spec = "atomic_ref<integral-type>::fetch_key(...) && is_const_v<integral-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.int"
source_module = "[atomics.ref.int]/5"
tags = [ "atomic", "integral", "constraint", "fetch", "const",]
function = "std::atomic_ref<integral-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_int_signed_overflow_no_ub_f0a4b8c2"
content = "For signed integer types in fetch_key operations (except fetch_max/fetch_min), the computation is performed as if converted to unsigned, computed, and converted back, resulting in no undefined behavior from overflow."
formal_spec = "atomic_ref<signed_integral>::fetch_key(operand) && key != max && key != min => no_undefined_behavior_from_overflow"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.int"
source_module = "[atomics.ref.int]/8"
tags = [ "atomic", "integral", "signed", "overflow", "well_defined",]
function = "std::atomic_ref<integral-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_int_store_key_const_constraint_a1b5c9d3"
content = "The store_key operations on integral types are constrained: is_const_v<integral-type> must be false."
formal_spec = "atomic_ref<integral-type>::store_key(...) && is_const_v<integral-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.int"
source_module = "[atomics.ref.int]/10"
tags = [ "atomic", "integral", "constraint", "store", "const",]
function = "std::atomic_ref<integral-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_int_store_key_order_precondition_b2c6d0e4"
content = "The store_key operations on integral types require order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "atomic_ref<integral-type>::store_key(operand, order) && order != relaxed && order != release && order != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.int"
source_module = "[atomics.ref.int]/11"
tags = [ "atomic", "integral", "precondition", "memory_order", "store",]
function = "std::atomic_ref<integral-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_int_operator_compound_const_constraint_c3d7e1f5"
content = "The compound assignment operators on integral atomic_ref are constrained: is_const_v<integral-type> must be false."
formal_spec = "atomic_ref<integral-type>::operator_op=(...) && is_const_v<integral-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.int"
source_module = "[atomics.ref.int]/14"
tags = [ "atomic", "integral", "constraint", "operator", "const",]
function = "std::atomic_ref<integral-type>::operator+="
header = "<atomic>"
signature = "constexpr value_type operator+=(value_type operand) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_float_volatile_lock_free_constraint_d4e8f2a6"
content = "For floating-point specializations, the program is ill-formed if is_always_lock_free is false and is_volatile_v<floating-point-type> is true."
formal_spec = "atomic_ref<floating-point-type> && !is_always_lock_free && is_volatile_v<floating-point-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/2"
tags = [ "atomic", "floating_point", "volatile", "lock_free", "ill_formed",]
function = "std::atomic_ref<floating-point-type>"
header = "<atomic>"
signature = "template<> struct atomic_ref<floating-point-type>"

[[axioms]]
id = "cpp20_atomics_ref_float_fetch_key_const_constraint_e5f9a3b7"
content = "The fetch_key operations on floating-point types are constrained: is_const_v<floating-point-type> must be false."
formal_spec = "atomic_ref<floating-point-type>::fetch_key(...) && is_const_v<floating-point-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/5"
tags = [ "atomic", "floating_point", "constraint", "fetch", "const",]
function = "std::atomic_ref<floating-point-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_float_unrepresentable_result_unspecified_f6a0b4c8"
content = "For floating-point fetch_key operations, if the result is not a representable value for its type, the result is unspecified, but the operations otherwise have no undefined behavior."
formal_spec = "atomic_ref<floating-point-type>::fetch_key(operand) && !representable(result) => unspecified_result && no_undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/8"
tags = [ "atomic", "floating_point", "unspecified", "no_ub",]
function = "std::atomic_ref<floating-point-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_float_store_key_const_constraint_a7b1c5d9"
content = "The store_key operations on floating-point types are constrained: is_const_v<floating-point-type> must be false."
formal_spec = "atomic_ref<floating-point-type>::store_key(...) && is_const_v<floating-point-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/11"
tags = [ "atomic", "floating_point", "constraint", "store", "const",]
function = "std::atomic_ref<floating-point-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_float_store_key_order_precondition_b8c2d6e0"
content = "The store_key operations on floating-point types require order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "atomic_ref<floating-point-type>::store_key(operand, order) && order != relaxed && order != release && order != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/12"
tags = [ "atomic", "floating_point", "precondition", "memory_order", "store",]
function = "std::atomic_ref<floating-point-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_float_store_unrepresentable_result_unspecified_c9d3e7f1"
content = "For floating-point store_key operations, if the result is not a representable value for its type, the result is unspecified, but the operations otherwise have no undefined behavior."
formal_spec = "atomic_ref<floating-point-type>::store_key(operand) && !representable(result) => unspecified_result && no_undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/14"
tags = [ "atomic", "floating_point", "unspecified", "no_ub", "store",]
function = "std::atomic_ref<floating-point-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(value_type operand, memory_order order = memory_order::seq_cst) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_float_operator_compound_const_constraint_d0e4f8a2"
content = "The compound assignment operators on floating-point atomic_ref are constrained: is_const_v<floating-point-type> must be false."
formal_spec = "atomic_ref<floating-point-type>::operator_op=(...) && is_const_v<floating-point-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.float"
source_module = "[atomics.ref.float]/17"
tags = [ "atomic", "floating_point", "constraint", "operator", "const",]
function = "std::atomic_ref<floating-point-type>::operator+="
header = "<atomic>"
signature = "constexpr value_type operator+=(value_type operand) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_pointer_volatile_lock_free_constraint_e1f5a9b3"
content = "For pointer specializations, the program is ill-formed if is_always_lock_free is false and is_volatile_v<pointer-type> is true."
formal_spec = "atomic_ref<pointer-type> && !is_always_lock_free && is_volatile_v<pointer-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/2"
tags = [ "atomic", "pointer", "volatile", "lock_free", "ill_formed",]
function = "std::atomic_ref<pointer-type>"
header = "<atomic>"
signature = "template<> struct atomic_ref<pointer-type>"

[[axioms]]
id = "cpp20_atomics_ref_pointer_fetch_key_const_constraint_f2a6b0c4"
content = "The fetch_key operations on pointer types are constrained: is_const_v<pointer-type> must be false."
formal_spec = "atomic_ref<pointer-type>::fetch_key(...) && is_const_v<pointer-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/5"
tags = [ "atomic", "pointer", "constraint", "fetch", "const",]
function = "std::atomic_ref<pointer-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_fetch_key_complete_type_mandate_a3b7c1d5"
content = "The fetch_key operations on pointer types mandate that remove_pointer_t<pointer-type> is a complete object type."
formal_spec = "atomic_ref<pointer-type>::fetch_key(...) && !complete_object_type(remove_pointer_t<pointer-type>) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/6"
tags = [ "atomic", "pointer", "mandate", "complete_type", "fetch",]
function = "std::atomic_ref<pointer-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_undefined_address_no_ub_b4c8d2e6"
content = "For pointer fetch_key operations, the result may be an undefined address, but the operations otherwise have no undefined behavior."
formal_spec = "atomic_ref<pointer-type>::fetch_key(operand) => may_be_undefined_address(result) && no_undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/9"
tags = [ "atomic", "pointer", "undefined_address", "no_ub",]
function = "std::atomic_ref<pointer-type>::fetch_add"
header = "<atomic>"
signature = "constexpr value_type fetch_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_store_key_const_constraint_c5d9e3f7"
content = "The store_key operations on pointer types are constrained: is_const_v<pointer-type> must be false."
formal_spec = "atomic_ref<pointer-type>::store_key(...) && is_const_v<pointer-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/11"
tags = [ "atomic", "pointer", "constraint", "store", "const",]
function = "std::atomic_ref<pointer-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_store_key_complete_type_mandate_d6e0f4a8"
content = "The store_key operations on pointer types mandate that remove_pointer_t<pointer-type> is a complete object type."
formal_spec = "atomic_ref<pointer-type>::store_key(...) && !complete_object_type(remove_pointer_t<pointer-type>) => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/12"
tags = [ "atomic", "pointer", "mandate", "complete_type", "store",]
function = "std::atomic_ref<pointer-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_store_key_order_precondition_e7f1a5b9"
content = "The store_key operations on pointer types require order to be memory_order::relaxed, memory_order::release, or memory_order::seq_cst."
formal_spec = "atomic_ref<pointer-type>::store_key(operand, order) && order != relaxed && order != release && order != seq_cst => undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/13"
tags = [ "atomic", "pointer", "precondition", "memory_order", "store",]
function = "std::atomic_ref<pointer-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_store_undefined_address_no_ub_f8a2b6c0"
content = "For pointer store_key operations, the result may be an undefined address, but the operations otherwise have no undefined behavior."
formal_spec = "atomic_ref<pointer-type>::store_key(operand) => may_be_undefined_address(result) && no_undefined_behavior"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/15"
tags = [ "atomic", "pointer", "undefined_address", "no_ub", "store",]
function = "std::atomic_ref<pointer-type>::store_add"
header = "<atomic>"
signature = "constexpr void store_add(difference_type operand, memory_order order = memory_order::seq_cst) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_pointer_operator_compound_const_constraint_a9b3c7d1"
content = "The compound assignment operators on pointer atomic_ref are constrained: is_const_v<pointer-type> must be false."
formal_spec = "atomic_ref<pointer-type>::operator_op=(...) && is_const_v<pointer-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.pointer"
source_module = "[atomics.ref.pointer]/16"
tags = [ "atomic", "pointer", "constraint", "operator", "const",]
function = "std::atomic_ref<pointer-type>::operator+="
header = "<atomic>"
signature = "constexpr value_type operator+=(difference_type operand) const noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_atomics_ref_memop_increment_postfix_const_constraint_b0c4d8e2"
content = "The postfix increment operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false."
formal_spec = "atomic_ref<referred-type>::operator++(int) && is_const_v<referred-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.memop"
source_module = "[atomics.ref.memop]/2"
tags = [ "atomic", "operator", "increment", "const", "constraint",]
function = "std::atomic_ref::operator++"
header = "<atomic>"
signature = "constexpr value_type operator++(int) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_memop_decrement_postfix_const_constraint_c1d5e9f3"
content = "The postfix decrement operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false."
formal_spec = "atomic_ref<referred-type>::operator--(int) && is_const_v<referred-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.memop"
source_module = "[atomics.ref.memop]/4"
tags = [ "atomic", "operator", "decrement", "const", "constraint",]
function = "std::atomic_ref::operator--"
header = "<atomic>"
signature = "constexpr value_type operator--(int) const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_memop_increment_prefix_const_constraint_d2e6f0a4"
content = "The prefix increment operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false."
formal_spec = "atomic_ref<referred-type>::operator++() && is_const_v<referred-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.memop"
source_module = "[atomics.ref.memop]/6"
tags = [ "atomic", "operator", "increment", "const", "constraint",]
function = "std::atomic_ref::operator++"
header = "<atomic>"
signature = "constexpr value_type operator++() const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_memop_decrement_prefix_const_constraint_e3f7a1b5"
content = "The prefix decrement operator on integer/pointer atomic_ref is constrained: is_const_v<referred-type> must be false."
formal_spec = "atomic_ref<referred-type>::operator--() && is_const_v<referred-type> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.memop"
source_module = "[atomics.ref.memop]/8"
tags = [ "atomic", "operator", "decrement", "const", "constraint",]
function = "std::atomic_ref::operator--"
header = "<atomic>"
signature = "constexpr value_type operator--() const noexcept"

[[axioms]]
id = "cpp20_atomics_ref_ops_operator_assign_const_constraint_f4a8b2c6"
content = "The assignment operator on atomic_ref is constrained: is_const_v<T> must be false."
formal_spec = "atomic_ref<T>::operator=(value_type) && is_const_v<T> => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "atomics.ref.ops"
source_module = "[atomics.ref.ops]/14"
tags = [ "atomic", "constraint", "operator", "assignment", "const",]
function = "std::atomic_ref::operator="
header = "<atomic>"
signature = "constexpr value_type operator=(value_type desired) const noexcept"

[[axioms]]
id = "cpp20_span_overview_trivially_copyable_a1b2c3d4"
content = "span<ElementType, Extent> is a trivially copyable type."
formal_spec = "std::is_trivially_copyable_v<span<ElementType, Extent>> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "views.span"
source_module = "[span.overview]/3"
tags = [ "type_trait", "trivially_copyable", "span",]
header = "<span>"

[[axioms]]
id = "cpp20_span_overview_element_complete_object_e5f6a7b8"
content = "ElementType is required to be a complete object type that is not an abstract class type."
formal_spec = "requires<ElementType>: is_complete_object_type_v<ElementType> && !is_abstract_v<ElementType>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "views.span"
source_module = "[span.overview]/4"
tags = [ "constraint", "type_requirement", "span",]
header = "<span>"

[[axioms]]
id = "cpp20_span_overview_invalidation_c9d0e1f2"
content = "For a span s, any operation that invalidates a pointer in the range [s.data(), s.data()+s.size()) invalidates pointers, iterators, and references to elements of s."
formal_spec = "forall ptr in [s.data(), s.data()+s.size()): invalidates(ptr) => invalidates(all_pointers_to(s)) && invalidates(all_iterators_to(s)) && invalidates(all_references_to(s))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "views.span"
source_module = "[span.overview]/5"
tags = [ "invalidation", "iterator", "pointer", "span",]
header = "<span>"

[[axioms]]
id = "cpp20_span_cons_default_constraint_g3h4i5j6"
content = "Default constructor constraint: Extent == dynamic_extent || Extent == 0 must be true."
formal_spec = "constraint(span()): (Extent == dynamic_extent) || (Extent == 0)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/1"
tags = [ "constraint", "constructor", "span",]
function = "std::span::span"
header = "<span>"
signature = "constexpr span() noexcept"

[[axioms]]
id = "cpp20_span_cons_default_postcond_k7l8m9n0"
content = "Default constructor postcondition: size() == 0 && data() == nullptr."
formal_spec = "postcond(span()): size() == 0 && data() == nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/2"
tags = [ "postcondition", "constructor", "span",]
function = "std::span::span"
header = "<span>"
signature = "constexpr span() noexcept"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_span_cons_iter_count_precond_valid_range_o1p2q3r4"
content = "Constructor from iterator and count precondition: [first, first + count) must be a valid range."
formal_spec = "precond(span(first, count)): is_valid_range(first, first + count)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/4.1"
tags = [ "precondition", "constructor", "iterator", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It> constexpr explicit(extent != dynamic_extent) span(It first, size_type count)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_span_cons_iter_count_precond_contiguous_s5t6u7v8"
content = "Constructor from iterator and count precondition: It must model contiguous_iterator."
formal_spec = "precond(span(first, count)): models<contiguous_iterator>(It)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/4.2"
tags = [ "precondition", "constructor", "iterator", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It> constexpr explicit(extent != dynamic_extent) span(It first, size_type count)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_span_cons_iter_count_hardened_extent_w9x0y1z2"
content = "Constructor from iterator and count hardened precondition: If extent is not equal to dynamic_extent, then count == extent must be true."
formal_spec = "hardened_precond(span(first, count)): (extent == dynamic_extent) || (count == extent)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/5"
tags = [ "hardened_precondition", "constructor", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It> constexpr explicit(extent != dynamic_extent) span(It first, size_type count)"

[[axioms]]
id = "cpp20_span_cons_iter_sentinel_precond_valid_range_a3b4c5d6"
content = "Constructor from iterator and sentinel precondition: [first, last) must be a valid range."
formal_spec = "precond(span(first, last)): is_valid_range(first, last)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/9.1"
tags = [ "precondition", "constructor", "iterator", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It, class End> constexpr explicit(extent != dynamic_extent) span(It first, End last)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_span_cons_iter_sentinel_precond_contiguous_e7f8g9h0"
content = "Constructor from iterator and sentinel precondition: It must model contiguous_iterator."
formal_spec = "precond(span(first, last)): models<contiguous_iterator>(It)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/9.2"
tags = [ "precondition", "constructor", "iterator", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It, class End> constexpr explicit(extent != dynamic_extent) span(It first, End last)"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_span_cons_iter_sentinel_precond_sized_sentinel_i1j2k3l4"
content = "Constructor from iterator and sentinel precondition: End must model sized_sentinel_for<It>."
formal_spec = "precond(span(first, last)): models<sized_sentinel_for<It>>(End)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/9.3"
tags = [ "precondition", "constructor", "iterator", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It, class End> constexpr explicit(extent != dynamic_extent) span(It first, End last)"

[[axioms]]
id = "cpp20_span_cons_iter_sentinel_hardened_extent_m5n6o7p8"
content = "Constructor from iterator and sentinel hardened precondition: If extent is not equal to dynamic_extent, then (last - first) == extent must be true."
formal_spec = "hardened_precond(span(first, last)): (extent == dynamic_extent) || ((last - first) == extent)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/10"
tags = [ "hardened_precondition", "constructor", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class It, class End> constexpr explicit(extent != dynamic_extent) span(It first, End last)"

[[axioms]]
id = "cpp20_span_cons_range_precond_contiguous_q9r0s1t2"
content = "Constructor from range precondition: R must model ranges::contiguous_range and ranges::sized_range."
formal_spec = "precond(span(r)): models<ranges::contiguous_range>(R) && models<ranges::sized_range>(R)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/17.1"
tags = [ "precondition", "constructor", "range", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class R> constexpr explicit(extent != dynamic_extent) span(R&& r)"
depends_on = [ "for_loop_range_impl_precond_range_valid_b3c4d5e6",]

[[axioms]]
id = "cpp20_span_cons_range_precond_borrowed_u3v4w5x6"
content = "Constructor from range precondition: If is_const_v<element_type> is false, R must model ranges::borrowed_range."
formal_spec = "precond(span(r)): is_const_v<element_type> || models<ranges::borrowed_range>(R)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/17.2"
tags = [ "precondition", "constructor", "range", "lifetime", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class R> constexpr explicit(extent != dynamic_extent) span(R&& r)"
depends_on = [ "for_loop_range_impl_precond_range_valid_b3c4d5e6",]

[[axioms]]
id = "cpp20_span_cons_range_hardened_extent_y7z8a9b0"
content = "Constructor from range hardened precondition: If extent is not equal to dynamic_extent, then ranges::size(r) == extent must be true."
formal_spec = "hardened_precond(span(r)): (extent == dynamic_extent) || (ranges::size(r) == extent)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/18"
tags = [ "hardened_precondition", "constructor", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class R> constexpr explicit(extent != dynamic_extent) span(R&& r)"

[[axioms]]
id = "cpp20_span_cons_init_list_hardened_extent_c1d2e3f4"
content = "Constructor from initializer_list hardened precondition: If extent is not equal to dynamic_extent, then il.size() == extent must be true."
formal_spec = "hardened_precond(span(il)): (extent == dynamic_extent) || (il.size() == extent)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/22"
tags = [ "hardened_precondition", "constructor", "initializer_list", "span",]
function = "std::span::span"
header = "<span>"
signature = "constexpr explicit(extent != dynamic_extent) span(std::initializer_list<value_type> il)"

[[axioms]]
id = "cpp20_span_cons_converting_hardened_extent_g5h6i7j8"
content = "Converting constructor hardened precondition: If extent is not equal to dynamic_extent, then s.size() == extent must be true."
formal_spec = "hardened_precond(span(s)): (extent == dynamic_extent) || (s.size() == extent)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.cons"
source_module = "[span.cons]/26"
tags = [ "hardened_precondition", "constructor", "conversion", "span",]
function = "std::span::span"
header = "<span>"
signature = "template<class OtherElementType, size_t OtherExtent> constexpr explicit(see below) span(const span<OtherElementType, OtherExtent>& s) noexcept"

[[axioms]]
id = "cpp20_span_sub_first_template_mandates_k9l0m1n2"
content = "first<Count>() mandates: Count <= Extent must be true."
formal_spec = "mandates(first<Count>()): Count <= Extent"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/1"
tags = [ "mandates", "subview", "span",]
function = "std::span::first"
header = "<span>"
signature = "template<size_t Count> constexpr span<element_type, Count> first() const"

[[axioms]]
id = "cpp20_span_sub_first_template_hardened_o3p4q5r6"
content = "first<Count>() hardened precondition: Count <= size() must be true."
formal_spec = "hardened_precond(first<Count>()): Count <= size()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/2"
tags = [ "hardened_precondition", "subview", "span",]
function = "std::span::first"
header = "<span>"
signature = "template<size_t Count> constexpr span<element_type, Count> first() const"

[[axioms]]
id = "cpp20_span_sub_last_template_mandates_s7t8u9v0"
content = "last<Count>() mandates: Count <= Extent must be true."
formal_spec = "mandates(last<Count>()): Count <= Extent"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/4"
tags = [ "mandates", "subview", "span",]
function = "std::span::last"
header = "<span>"
signature = "template<size_t Count> constexpr span<element_type, Count> last() const"

[[axioms]]
id = "cpp20_span_sub_last_template_hardened_w1x2y3z4"
content = "last<Count>() hardened precondition: Count <= size() must be true."
formal_spec = "hardened_precond(last<Count>()): Count <= size()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/5"
tags = [ "hardened_precondition", "subview", "span",]
function = "std::span::last"
header = "<span>"
signature = "template<size_t Count> constexpr span<element_type, Count> last() const"

[[axioms]]
id = "cpp20_span_sub_subspan_template_mandates_a5b6c7d8"
content = "subspan<Offset, Count>() mandates: Offset <= Extent && (Count == dynamic_extent || Count <= Extent - Offset) must be true."
formal_spec = "mandates(subspan<Offset, Count>()): (Offset <= Extent) && ((Count == dynamic_extent) || (Count <= Extent - Offset))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/7"
tags = [ "mandates", "subview", "span",]
function = "std::span::subspan"
header = "<span>"
signature = "template<size_t Offset, size_t Count = dynamic_extent> constexpr span<element_type, see below> subspan() const"

[[axioms]]
id = "cpp20_span_sub_subspan_template_hardened_e9f0g1h2"
content = "subspan<Offset, Count>() hardened precondition: Offset <= size() && (Count == dynamic_extent || Count <= size() - Offset) must be true."
formal_spec = "hardened_precond(subspan<Offset, Count>()): (Offset <= size()) && ((Count == dynamic_extent) || (Count <= size() - Offset))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/8"
tags = [ "hardened_precondition", "subview", "span",]
function = "std::span::subspan"
header = "<span>"
signature = "template<size_t Offset, size_t Count = dynamic_extent> constexpr span<element_type, see below> subspan() const"

[[axioms]]
id = "cpp20_span_sub_first_dynamic_hardened_i3j4k5l6"
content = "first(count) hardened precondition: count <= size() must be true."
formal_spec = "hardened_precond(first(count)): count <= size()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/11"
tags = [ "hardened_precondition", "subview", "span",]
function = "std::span::first"
header = "<span>"
signature = "constexpr span<element_type, dynamic_extent> first(size_type count) const"

[[axioms]]
id = "cpp20_span_sub_last_dynamic_hardened_m7n8o9p0"
content = "last(count) hardened precondition: count <= size() must be true."
formal_spec = "hardened_precond(last(count)): count <= size()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/13"
tags = [ "hardened_precondition", "subview", "span",]
function = "std::span::last"
header = "<span>"
signature = "constexpr span<element_type, dynamic_extent> last(size_type count) const"

[[axioms]]
id = "cpp20_span_sub_subspan_dynamic_hardened_q1r2s3t4"
content = "subspan(offset, count) hardened precondition: offset <= size() && (count == dynamic_extent || count <= size() - offset) must be true."
formal_spec = "hardened_precond(subspan(offset, count)): (offset <= size()) && ((count == dynamic_extent) || (count <= size() - offset))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.sub"
source_module = "[span.sub]/15"
tags = [ "hardened_precondition", "subview", "span",]
function = "std::span::subspan"
header = "<span>"
signature = "constexpr span<element_type, dynamic_extent> subspan(size_type offset, size_type count = dynamic_extent) const"

[[axioms]]
id = "cpp20_span_elem_subscript_hardened_u5v6w7x8"
content = "operator[](idx) hardened precondition: idx < size() must be true."
formal_spec = "hardened_precond(operator[](idx)): idx < size()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.elem"
source_module = "[span.elem]/1"
tags = [ "hardened_precondition", "element_access", "span",]
function = "std::span::operator[]"
header = "<span>"
signature = "constexpr reference operator[](size_type idx) const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_span_elem_at_throws_y9z0a1b2"
content = "at(idx) throws out_of_range if idx >= size() is true."
formal_spec = "(idx >= size()) && call(at(idx)) => throws(out_of_range)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.elem"
source_module = "[span.elem]/5"
tags = [ "exception", "element_access", "bounds_check", "span",]
function = "std::span::at"
header = "<span>"
signature = "constexpr reference at(size_type idx) const"
depends_on = [ "for_loop_range_impl_exception_ranges_begin_propagates_f3a4b5c6",]

[[axioms]]
id = "cpp20_span_elem_front_hardened_c3d4e5f6"
content = "front() hardened precondition: empty() is false."
formal_spec = "hardened_precond(front()): !empty()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.elem"
source_module = "[span.elem]/6"
tags = [ "hardened_precondition", "element_access", "span",]
function = "std::span::front"
header = "<span>"
signature = "constexpr reference front() const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_span_elem_back_hardened_g7h8i9j0"
content = "back() hardened precondition: empty() is false."
formal_spec = "hardened_precond(back()): !empty()"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.elem"
source_module = "[span.elem]/9"
tags = [ "hardened_precondition", "element_access", "span",]
function = "std::span::back"
header = "<span>"
signature = "constexpr reference back() const"
depends_on = [ "extract_precond_pointer_non_null_a5f7c3d1",]

[[axioms]]
id = "cpp20_span_iterators_contiguous_model_k1l2m3n4"
content = "span::iterator models contiguous_iterator, meets Cpp17RandomAccessIterator requirements, and meets constexpr iterator requirements."
formal_spec = "models<contiguous_iterator>(span::iterator) && meets<Cpp17RandomAccessIterator>(span::iterator) && meets<constexpr_iterator>(span::iterator)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.iterators"
source_module = "[span.iterators]/1"
tags = [ "iterator", "contiguous_iterator", "span",]
header = "<span>"
depends_on = [ "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0",]

[[axioms]]
id = "cpp20_span_iterators_container_requirements_o5p6q7r8"
content = "All requirements on container iterators apply to span::iterator as well."
formal_spec = "satisfies<container_iterator_requirements>(span::iterator)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.iterators"
source_module = "[span.iterators]/2"
tags = [ "iterator", "container", "span",]
header = "<span>"

[[axioms]]
id = "cpp20_span_iterators_begin_empty_s9t0u1v2"
content = "If empty() is true, begin() returns the same value as end()."
formal_spec = "empty() => (begin() == end())"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "span.iterators"
source_module = "[span.iterators]/3"
tags = [ "iterator", "empty", "span",]
function = "std::span::begin"
header = "<span>"
signature = "constexpr iterator begin() const noexcept"

[[axioms]]
id = "cpp20_func_require_invoke_r_illformed_temp_ref_a1b2c3d4"
content = "INVOKE<R>(f, t1, t2, ..., tN) is ill-formed if reference_converts_from_temporary_v<R, decltype(INVOKE(f, t1, t2, ..., tN))> is true."
formal_spec = "reference_converts_from_temporary_v<R, decltype(INVOKE(f, args...))> == true => ill_formed(INVOKE<R>(f, args...))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.require"
source_module = "[func.require]/2"
tags = [ "invoke", "reference", "temporary", "ill-formed",]

[[axioms]]
id = "cpp20_func_invoke_r_constraint_invocable_r_c9d0e1f2"
content = "std::invoke_r requires is_invocable_r_v<R, F, Args...> to be true."
formal_spec = "call(std::invoke_r<R>(f, args...)) => is_invocable_r_v<R, F, Args...> == true"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.invoke"
source_module = "[func.invoke]/3"
tags = [ "invoke", "constraint", "type_trait",]
function = "std::invoke_r"
header = "<functional>"
signature = "template<class R, class F, class... Args> constexpr R invoke_r(F&& f, Args&&... args)"

[[axioms]]
id = "cpp20_refwrap_invoke_mandates_complete_type_g3h4i5j6"
content = "Calling operator() on reference_wrapper requires T to be a complete type."
formal_spec = "call(reference_wrapper<T>::operator()(args...)) => complete_type(T)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.invoke"
source_module = "[refwrap.invoke]/1"
tags = [ "reference_wrapper", "mandates", "complete_type", "invocation",]
function = "std::reference_wrapper::operator()"
header = "<functional>"
signature = "template<class... ArgTypes> constexpr invoke_result_t<T&, ArgTypes...> operator()(ArgTypes&&... args) const"

[[axioms]]
id = "cpp20_refwrap_const_constraint_no_rvalue_binding_k7l8m9n0"
content = "reference_wrapper constructor is constrained to prevent binding to rvalue references via deleted FUN(T&&)."
formal_spec = "is_same_v<remove_cvref_t<U>, reference_wrapper> == false && well_formed(FUN(declval<U>())) => constructible(reference_wrapper<T>, U&&)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.const"
source_module = "[refwrap.const]/1-2"
tags = [ "reference_wrapper", "constructor", "constraint", "rvalue",]
function = "std::reference_wrapper::reference_wrapper"
header = "<functional>"
signature = "template<class U> constexpr reference_wrapper(U&& u)"

[[axioms]]
id = "cpp20_refwrap_incomplete_type_comparison_note_o1p2q3r4"
content = "Using comparison operators on reference_wrapper<T> where T is incomplete can lead to ill-formed program with no diagnostic required."
formal_spec = "incomplete_type(T) && use_comparison_operator(reference_wrapper<T>) => potential_ill_formed_ndr"
layer = "cpp20_stdlib"
confidence = 0.75
source_file = "refwrap.general"
source_module = "[refwrap.general]/3"
tags = [ "reference_wrapper", "incomplete_type", "comparison", "ill-formed-ndr",]
function = "std::reference_wrapper comparison operators"
header = "<functional>"
signature = "friend constexpr bool operator==(reference_wrapper, reference_wrapper)"

[[axioms]]
id = "cpp20_ref_cref_deleted_rvalue_s5t6u7v8"
content = "The ref and cref functions are deleted for rvalue arguments to prevent dangling references."
formal_spec = "is_rvalue(T&&) => deleted(ref(T&&)) && deleted(cref(T&&))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "functional.syn"
source_module = "[functional.syn]"
tags = [ "ref", "cref", "deleted", "rvalue", "dangling",]
function = "std::ref"
header = "<functional>"
signature = "template<class T> void ref(const T&&) = delete"

[[axioms]]
id = "cpp20_compare_three_way_constraint_w9x0y1z2"
content = "compare_three_way::operator() requires T and U to satisfy three_way_comparable_with."
formal_spec = "call(compare_three_way{}(t, u)) => three_way_comparable_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.three.way"
source_module = "[comparisons.three.way]/1"
tags = [ "comparison", "three_way", "constraint", "concept",]
function = "std::compare_three_way::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr auto operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_compare_three_way_precond_pointer_eq_preserving_a3b4c5d6"
content = "For compare_three_way with built-in pointer comparison, conversion sequences from T and U to P must be equality-preserving."
formal_spec = "builtin_pointer_compare(forward<T>(t) <=> forward<U>(u), P) => equality_preserving(conversion<T, P>) && equality_preserving(conversion<U, P>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.three.way"
source_module = "[comparisons.three.way]/2"
tags = [ "comparison", "three_way", "precondition", "pointer", "equality_preserving",]
function = "std::compare_three_way::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr auto operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_equal_to_constraint_e7f8a9b0"
content = "ranges::equal_to::operator() requires T and U to satisfy equality_comparable_with."
formal_spec = "call(ranges::equal_to{}(t, u)) => equality_comparable_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/1"
tags = [ "ranges", "comparison", "constraint", "concept",]
function = "std::ranges::equal_to::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_equal_to_precond_pointer_eq_preserving_c1d2e3f4"
content = "For ranges::equal_to with built-in pointer comparison, conversion sequences must be equality-preserving."
formal_spec = "builtin_pointer_compare(forward<T>(t) == forward<U>(u), P) => equality_preserving(conversion<T, P>) && equality_preserving(conversion<U, P>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/2"
tags = [ "ranges", "comparison", "precondition", "pointer", "equality_preserving",]
function = "std::ranges::equal_to::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_not_equal_to_constraint_g5h6i7j8"
content = "ranges::not_equal_to::operator() requires T and U to satisfy equality_comparable_with."
formal_spec = "call(ranges::not_equal_to{}(t, u)) => equality_comparable_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/4"
tags = [ "ranges", "comparison", "constraint", "concept",]
function = "std::ranges::not_equal_to::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_less_constraint_k9l0m1n2"
content = "ranges::less::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(ranges::less{}(t, u)) => totally_ordered_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/8"
tags = [ "ranges", "comparison", "constraint", "concept",]
function = "std::ranges::less::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_less_precond_pointer_eq_preserving_o3p4q5r6"
content = "For ranges::less with built-in pointer comparison, conversion sequences must be equality-preserving and exactly one of less(t,u), less(u,t), or equal_to(t,u) is true."
formal_spec = "builtin_pointer_compare(forward<T>(t) < forward<U>(u), P) => equality_preserving(conversion<T, P>) && equality_preserving(conversion<U, P>) && exactly_one(ranges::less{}(t, u), ranges::less{}(u, t), ranges::equal_to{}(t, u))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/9"
tags = [ "ranges", "comparison", "precondition", "pointer", "trichotomy",]
function = "std::ranges::less::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_greater_constraint_s7t8u9v0"
content = "ranges::greater::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(ranges::greater{}(t, u)) => totally_ordered_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/6"
tags = [ "ranges", "comparison", "constraint", "concept",]
function = "std::ranges::greater::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_greater_equal_constraint_w1x2y3z4"
content = "ranges::greater_equal::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(ranges::greater_equal{}(t, u)) => totally_ordered_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/11"
tags = [ "ranges", "comparison", "constraint", "concept",]
function = "std::ranges::greater_equal::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_ranges_less_equal_constraint_a5b6c7d8"
content = "ranges::less_equal::operator() requires T and U to satisfy totally_ordered_with."
formal_spec = "call(ranges::less_equal{}(t, u)) => totally_ordered_with<T, U>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.cmp"
source_module = "[range.cmp]/13"
tags = [ "ranges", "comparison", "constraint", "concept",]
function = "std::ranges::less_equal::operator()"
header = "<functional>"
signature = "template<class T, class U> constexpr bool operator()(T&& t, U&& u) const"

[[axioms]]
id = "cpp20_func_wrap_func_inv_throws_bad_function_call_e9f0a1b2"
content = "Calling operator() on an empty std::function throws bad_function_call."
formal_spec = "!has_target(function<R(Args...)>) && call(operator()(args...)) => throws(bad_function_call)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.wrap.func.inv"
source_module = "[func.wrap.func.inv]/2"
tags = [ "function", "invocation", "exception", "bad_function_call",]
function = "std::function::operator()"
header = "<functional>"
signature = "R operator()(ArgTypes... args) const"

[[axioms]]
id = "cpp20_func_wrap_move_inv_precond_valid_target_c3d4e5f6"
content = "Calling operator() on move_only_function has precondition that *this has a target."
formal_spec = "call(move_only_function::operator()(args...)) => has_target(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.wrap.move.inv"
source_module = "[func.wrap.move.inv]/1"
tags = [ "move_only_function", "invocation", "precondition",]
function = "std::move_only_function::operator()"
header = "<functional>"
signature = "R operator()(ArgTypes... args) cv-ref noexcept(noex)"

[[axioms]]
id = "cpp20_func_wrap_copy_inv_precond_valid_target_g7h8i9j0"
content = "Calling operator() on copyable_function has precondition that *this has a target."
formal_spec = "call(copyable_function::operator()(args...)) => has_target(*this)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.wrap.copy.inv"
source_module = "[func.wrap.copy.inv]/1"
tags = [ "copyable_function", "invocation", "precondition",]
function = "std::copyable_function::operator()"
header = "<functional>"
signature = "R operator()(ArgTypes... args) cv-ref noexcept(noex)"

[[axioms]]
id = "cpp20_func_wrap_ref_ctor_precond_callable_k1l2m3n4"
content = "function_ref constructor from F has precondition that f is a callable for R(ArgTypes...) with cv-qualifications and noexcept."
formal_spec = "construct(function_ref, f) => callable_with_signature<F, R(ArgTypes...) cv noexcept(noex)>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.wrap.ref.ctor"
source_module = "[func.wrap.ref.ctor]/3"
tags = [ "function_ref", "constructor", "precondition", "callable",]
function = "std::function_ref::function_ref"
header = "<functional>"
signature = "template<class F> function_ref(F* f) noexcept"

[[axioms]]
id = "cpp20_func_wrap_ref_ctor_precond_not_null_o5p6q7r8"
content = "function_ref constructor from function pointer has precondition that f is not a null pointer."
formal_spec = "construct(function_ref, F* f) => f != nullptr"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.wrap.ref.ctor"
source_module = "[func.wrap.ref.ctor]/3"
tags = [ "function_ref", "constructor", "precondition", "null_pointer",]
function = "std::function_ref::function_ref"
header = "<functional>"
signature = "template<class F> function_ref(F* f) noexcept"

[[axioms]]
id = "cpp20_func_wrap_ref_dangling_precond_s9t0u1v2"
content = "function_ref constructed from nontype template parameter must not outlive the referenced callable when it refers to a pointer to member."
formal_spec = "is_member_pointer(decltype(f)) && function_ref_from_nontype<f>(obj) => lifetime(obj) >= lifetime(function_ref)"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "func.wrap.ref.ctor"
source_module = "[func.wrap.ref.ctor]/7"
tags = [ "function_ref", "lifetime", "dangling", "precondition",]
function = "std::function_ref::function_ref"
header = "<functional>"
signature = "template<auto f> function_ref(nontype_t<f>, T& obj) noexcept"

[[axioms]]
id = "cpp20_call_wrapper_moveconstructible_destructible_w3x4y5z6"
content = "Every call wrapper meets the Cpp17MoveConstructible and Cpp17Destructible requirements."
formal_spec = "is_call_wrapper(T) => Cpp17MoveConstructible<T> && Cpp17Destructible<T>"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.require"
source_module = "[func.require]/3"
tags = [ "call_wrapper", "requirement", "move_constructible", "destructible",]

[[axioms]]
id = "cpp20_simple_call_wrapper_copyconstructible_copyassignable_a7b8c9d0"
content = "A simple call wrapper meets Cpp17CopyConstructible and Cpp17CopyAssignable requirements and has constexpr non-throwing copy/move constructors and assignment operators."
formal_spec = "is_simple_call_wrapper(T) => Cpp17CopyConstructible<T> && Cpp17CopyAssignable<T> && noexcept(copy_ctor(T)) && noexcept(move_ctor(T)) && noexcept(copy_assign(T)) && noexcept(move_assign(T))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.require"
source_module = "[func.require]/6"
tags = [ "call_wrapper", "requirement", "copy_constructible", "copy_assignable", "constexpr",]

[[axioms]]
id = "cpp20_perfect_forwarding_call_wrapper_cv_qual_e1f2a3b4"
content = "A perfect forwarding call wrapper delivers state entities with cv-qualifiers matching the call wrapper, and cv shall be neither volatile nor const volatile."
formal_spec = "is_perfect_forwarding_call_wrapper(W) && cv_of(W) in {volatile, const_volatile} => ill_formed"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.require"
source_module = "[func.require]/4"
tags = [ "call_wrapper", "perfect_forwarding", "cv_qualifier", "constraint",]

[[axioms]]
id = "cpp20_comparisons_pointer_strict_total_order_c5d6e7f8"
content = "For less, greater, less_equal, greater_equal with pointer types, the specializations yield results consistent with the implementation-defined strict total order over pointers."
formal_spec = "is_pointer(T) && (less<T> || greater<T> || less_equal<T> || greater_equal<T>) => result_consistent_with_strict_total_order(pointers)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "comparisons.general"
source_module = "[comparisons.general]/2"
tags = [ "comparison", "pointer", "strict_total_order",]

[[axioms]]
id = "cpp20_refwrap_trivially_copyable_g9h0i1j2"
content = "reference_wrapper<T> is a trivially copyable type."
formal_spec = "is_trivially_copyable(reference_wrapper<T>)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.general"
source_module = "[refwrap.general]/2"
tags = [ "reference_wrapper", "trivially_copyable", "type_property",]

[[axioms]]
id = "cpp20_refwrap_comparison_eq_constraint_k3l4m5n6"
content = "reference_wrapper equality comparison requires x.get() == y.get() to be well-formed and convertible to bool."
formal_spec = "well_formed(x.get() == y.get()) && convertible_to<decltype(x.get() == y.get()), bool> => callable(operator==(reference_wrapper x, reference_wrapper y))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/1"
tags = [ "reference_wrapper", "comparison", "constraint",]
function = "std::reference_wrapper::operator=="
header = "<functional>"
signature = "friend constexpr bool operator==(reference_wrapper x, reference_wrapper y)"

[[axioms]]
id = "cpp20_refwrap_comparison_spaceship_constraint_o7p8q9r0"
content = "reference_wrapper three-way comparison requires synth-three-way(x.get(), y.get()) to be well-formed."
formal_spec = "well_formed(synth_three_way(x.get(), y.get())) => callable(operator<=>(reference_wrapper x, reference_wrapper y))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/7"
tags = [ "reference_wrapper", "comparison", "three_way", "constraint",]
function = "std::reference_wrapper::operator<=>"
header = "<functional>"
signature = "friend constexpr auto operator<=>(reference_wrapper x, reference_wrapper y)"

[[axioms]]
id = "cpp20_refwrap_const_t_spaceship_constraint_s1t2u3v4"
content = "reference_wrapper<T> three-way comparison with reference_wrapper<const T> requires is_const_v<T> to be false."
formal_spec = "is_const_v<T> == false => callable(operator<=>(reference_wrapper<T> x, reference_wrapper<const T> y))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "refwrap.comparisons"
source_module = "[refwrap.comparisons]/11"
tags = [ "reference_wrapper", "comparison", "three_way", "const", "constraint",]
function = "std::reference_wrapper::operator<=>"
header = "<functional>"
signature = "friend constexpr auto operator<=>(reference_wrapper x, reference_wrapper<const T> y)"

[[axioms]]
id = "cpp20_func_bind_call_wrapper_same_type_w5x6y7z8"
content = "Argument forwarding call wrappers returned by a given standard library function template have the same type if the types of their corresponding state entities are the same."
formal_spec = "same_state_entity_types(call_wrapper1, call_wrapper2) && same_source_function_template(call_wrapper1, call_wrapper2) => same_type(decltype(call_wrapper1), decltype(call_wrapper2))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.require"
source_module = "[func.require]/8"
tags = [ "call_wrapper", "type_identity", "bind",]

[[axioms]]
id = "cpp20_hash_constraint_type_enabled_a9b0c1d2"
content = "std::hash is enabled only for specific types; for types where hash is not explicitly enabled, the specialization is disabled."
formal_spec = "!is_hash_enabled<T> => disabled(hash<T>)"
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "unord.hash"
source_module = "[unord.hash]"
tags = [ "hash", "constraint", "type_trait",]
function = "std::hash"
header = "<functional>"
signature = "template<class T> struct hash"

[[axioms]]
id = "cpp20_boyer_moore_searcher_precond_random_access_e3f4a5b6"
content = "boyer_moore_searcher requires RandomAccessIterator for the pattern."
formal_spec = "construct(boyer_moore_searcher, first, last) => random_access_iterator(decltype(first))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.search.bm"
source_module = "[func.search.bm]"
tags = [ "searcher", "boyer_moore", "iterator", "random_access",]
function = "std::boyer_moore_searcher"
header = "<functional>"
signature = "template<class RandomAccessIterator, class Hash, class BinaryPredicate> class boyer_moore_searcher"

[[axioms]]
id = "cpp20_boyer_moore_horspool_searcher_precond_random_access_g7h8i9j0"
content = "boyer_moore_horspool_searcher requires RandomAccessIterator for the pattern."
formal_spec = "construct(boyer_moore_horspool_searcher, first, last) => random_access_iterator(decltype(first))"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "func.search.bmh"
source_module = "[func.search.bmh]"
tags = [ "searcher", "boyer_moore_horspool", "iterator", "random_access",]
function = "std::boyer_moore_horspool_searcher"
header = "<functional>"
signature = "template<class RandomAccessIterator, class Hash, class BinaryPredicate> class boyer_moore_horspool_searcher"

[[axioms]]
id = "cpp20_thread_no_represent_after_moved_from_e7c2a9f5"
content = "A thread object does not represent a thread of execution after being moved from."
formal_spec = "moved_from(t) => !represents_thread(t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.thread.class.general"
source_module = "[thread.thread.class.general]/1"
tags = [ "thread", "move", "lifetime",]
header = "<thread>"

[[axioms]]
id = "cpp20_thread_no_represent_after_detach_f3a8d1c6"
content = "A thread object does not represent a thread of execution after a successful call to detach."
formal_spec = "detach_success(t) => !represents_thread(t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.thread.class.general"
source_module = "[thread.thread.class.general]/1"
tags = [ "thread", "detach", "lifetime",]
function = "std::thread::detach"
header = "<thread>"
signature = "void detach()"

[[axioms]]
id = "cpp20_thread_no_represent_after_join_b9e4f7a2"
content = "A thread object does not represent a thread of execution after a successful call to join."
formal_spec = "join_success(t) => !represents_thread(t)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.thread.class.general"
source_module = "[thread.thread.class.general]/1"
tags = [ "thread", "join", "lifetime",]
function = "std::thread::join"
header = "<thread>"
signature = "void join()"

[[axioms]]
id = "cpp20_thread_unique_representation_c5d9a3e8"
content = "No two thread objects simultaneously represent the same thread of execution."
formal_spec = "forall t1, t2: thread. represents_same_thread(t1, t2) => (t1 == t2) || !simultaneous(t1, t2)"
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.thread.class.general"
source_module = "[thread.thread.class.general]/1"
tags = [ "thread", "uniqueness", "invariant",]
header = "<thread>"

