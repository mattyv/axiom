version = "1.0"
source = "eel.is/c++draft"
extracted_at = "2025-12-30T02:09:16.597755+00:00"

[[axioms]]
id = "cpp20_container_reqmts_value_type_erasable_a1b2c3d4"
content = '''Container value_type T must be Cpp17Erasable from container X.'''
formal_spec = '''container(X) && value_type(X, T) => Cpp17Erasable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/2-3"
tags = ['container', 'requirements', 'precondition', 'erasable']

[[axioms]]
id = "cpp20_container_reqmts_copy_ctor_precondition_b2c3d4e5"
content = '''Copy constructing a container requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''copy_construct(container(X)) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/12"
tags = ['container', 'requirements', 'precondition', 'copy']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_container_reqmts_equality_precondition_c3d4e5f6"
content = '''Container equality comparison requires T to meet Cpp17EqualityComparable requirements.'''
formal_spec = '''equality_compare(container(X, T)) => Cpp17EqualityComparable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/42"
tags = ['container', 'requirements', 'precondition', 'equality']

[[axioms]]
id = "cpp20_container_reqmts_swap_allocator_ub_d4e5f6a7"
content = '''Swapping containers with unequal allocators when propagate_on_container_swap is false is undefined behavior.'''
formal_spec = '''swap(container(a), container(b)) && !propagate_on_container_swap(allocator_type) && a.get_allocator() != b.get_allocator() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/65"
tags = ['container', 'swap', 'allocator', 'undefined-behavior']

[[axioms]]
id = "cpp20_container_reqmts_insert_single_exception_safety_e5f6a7b8"
content = '''If an exception is thrown by insert() or emplace() while inserting a single element, the function has no effects (strong exception guarantee).'''
formal_spec = '''(insert_single(container, elem) || emplace_single(container, args)) && throws_exception => no_effects'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.1"
tags = ['container', 'exception-safety', 'insert', 'emplace']
depends_on = ['cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_container_reqmts_push_exception_safety_f6a7b8c9"
content = '''If an exception is thrown by push_back(), push_front(), emplace_back(), or emplace_front(), the function has no effects (strong exception guarantee).'''
formal_spec = '''(push_back(container) || push_front(container) || emplace_back(container) || emplace_front(container)) && throws_exception => no_effects'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.2"
tags = ['container', 'exception-safety', 'push']
depends_on = ['cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_container_reqmts_erase_nothrow_a7b8c9d0"
content = '''Container erase(), clear(), pop_back(), and pop_front() functions do not throw exceptions.'''
formal_spec = '''(erase(container) || clear(container) || pop_back(container) || pop_front(container)) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.3"
tags = ['container', 'exception-safety', 'erase', 'nothrow']

[[axioms]]
id = "cpp20_container_reqmts_iterator_copy_nothrow_b8c9d0e1"
content = '''No copy constructor or assignment operator of a returned container iterator throws an exception.'''
formal_spec = '''(copy_construct(iterator) || copy_assign(iterator)) && is_container_iterator(iterator) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.4"
tags = ['container', 'iterator', 'exception-safety', 'nothrow']
depends_on = ['cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_iterator_operations_prev_effect_d6a0b3c8', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_container_reqmts_swap_nothrow_c9d0e1f2"
content = '''Container swap() function does not throw an exception.'''
formal_spec = '''swap(container) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.5"
tags = ['container', 'swap', 'exception-safety', 'nothrow']
depends_on = ['cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_container_reqmts_swap_no_invalidate_d0e1f2a3"
content = '''Container swap() does not invalidate any references, pointers, or iterators referring to elements of the swapped containers (end() iterator may be invalidated).'''
formal_spec = '''swap(container(a), container(b)) => valid(element_references(a)) && valid(element_references(b))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.reqmts"
source_module = "[container.reqmts]/66.6"
tags = ['container', 'swap', 'iterator-validity']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4"
content = '''Container allocator_type::value_type must be the same as container value_type.'''
formal_spec = '''allocator_aware_container(X) => allocator_type(X)::value_type == value_type(X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/5"
tags = ['container', 'allocator', 'mandates']

[[axioms]]
id = "cpp20_container_alloc_reqmts_default_ctor_precondition_f2a3b4c5"
content = '''Default constructing an allocator-aware container requires the allocator type to meet Cpp17DefaultConstructible requirements.'''
formal_spec = '''default_construct(allocator_aware_container(X)) => Cpp17DefaultConstructible(allocator_type(X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/8"
tags = ['container', 'allocator', 'precondition', 'default-constructor']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_container_alloc_reqmts_copy_ctor_alloc_precondition_a3b4c5d6"
content = '''Copy constructing an allocator-aware container with a specified allocator requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''copy_construct_with_allocator(allocator_aware_container(X), m) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/13"
tags = ['container', 'allocator', 'precondition', 'copy']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_container_alloc_reqmts_move_ctor_alloc_precondition_b4c5d6e7"
content = '''Move constructing an allocator-aware container with a different allocator requires T to be Cpp17MoveInsertable into X.'''
formal_spec = '''move_construct_with_allocator(allocator_aware_container(X), rv, m) => Cpp17MoveInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/18"
tags = ['container', 'allocator', 'precondition', 'move']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_container_alloc_reqmts_copy_assign_precondition_c5d6e7f8"
content = '''Copy assignment of an allocator-aware container requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.'''
formal_spec = '''copy_assign(allocator_aware_container(X)) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/22"
tags = ['container', 'allocator', 'precondition', 'copy-assignment']
depends_on = ['cpp20_variant_copy_assign_deleted_condition_k1l2m3n4']

[[axioms]]
id = "cpp20_container_alloc_reqmts_move_assign_precondition_d6e7f8a9"
content = '''Move assignment of an allocator-aware container requires T to be Cpp17MoveInsertable and Cpp17MoveAssignable if propagate_on_container_move_assignment is false.'''
formal_spec = '''move_assign(allocator_aware_container(X)) && !propagate_on_container_move_assignment(allocator_type) => Cpp17MoveInsertable(T, X) && Cpp17MoveAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.alloc.reqmts"
source_module = "[container.alloc.reqmts]/26"
tags = ['container', 'allocator', 'precondition', 'move-assignment']
depends_on = ['cpp20_weak_ptr_assignment_move_effect_c0e4a8f3']

[[axioms]]
id = "cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0"
content = '''Implementations must avoid data races when contents of different elements in the same container are modified concurrently (except for vector<bool>).'''
formal_spec = '''container(X) && !is_vector_bool(X) && modify_concurrent(element(i), element(j)) && i != j => no_data_race'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.requirements.dataraces"
source_module = "[container.requirements.dataraces]/2"
tags = ['container', 'concurrency', 'data-race']

[[axioms]]
id = "cpp20_container_dataraces_vector_bool_exception_f8a9b0c1"
content = '''For vector<bool>, modifying different elements concurrently can result in a data race (exception to general container rule).'''
formal_spec = '''is_vector_bool(X) && modify_concurrent(element(i), element(j)) => possible_data_race'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.requirements.dataraces"
source_module = "[container.requirements.dataraces]/3"
tags = ['container', 'concurrency', 'data-race', 'vector-bool']
depends_on = ['cpp20_container_dataraces_concurrent_element_modification_e7f8a9b0', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_sequence_reqmts_n_copies_precondition_a9b0c1d2"
content = '''Constructing a sequence container with n copies of t requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''construct(sequence_container(X), n, t) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/5"
tags = ['sequence-container', 'precondition', 'copy']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_sequence_reqmts_iterator_range_precondition_b0c1d2e3"
content = '''Constructing a sequence container from iterator range [i,j) requires T to be Cpp17EmplaceConstructible from *i.'''
formal_spec = '''construct(sequence_container(X), i, j) => Cpp17EmplaceConstructible(T, X, *i)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/8"
tags = ['sequence-container', 'precondition', 'iterator']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_iterator_operations_prev_effect_d6a0b3c8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_il_precondition_c1d2e3f4"
content = '''Assignment from initializer_list requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.'''
formal_spec = '''assign(sequence_container(X), initializer_list) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/17"
tags = ['sequence-container', 'precondition', 'initializer-list']
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a']

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_precondition_d2e3f4a5"
content = '''Calling emplace(p, args) requires T to be Cpp17EmplaceConstructible from args. For vector, inplace_vector, and deque, T must also be Cpp17MoveInsertable and Cpp17MoveAssignable.'''
formal_spec = '''emplace(sequence_container(X), p, args) => Cpp17EmplaceConstructible(T, X, args) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => (Cpp17MoveInsertable(T, X) && Cpp17MoveAssignable(T)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/21"
tags = ['sequence-container', 'emplace', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_copy_precondition_e3f4a5b6"
content = '''Calling insert(p, t) requires T to be Cpp17CopyInsertable. For vector, inplace_vector, and deque, T must also be Cpp17CopyAssignable.'''
formal_spec = '''insert(sequence_container(X), p, t) => Cpp17CopyInsertable(T, X) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17CopyAssignable(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/25"
tags = ['sequence-container', 'insert', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_move_precondition_f4a5b6c7"
content = '''Calling insert(p, rv) requires T to be Cpp17MoveInsertable. For vector, inplace_vector, and deque, T must also be Cpp17MoveAssignable.'''
formal_spec = '''insert(sequence_container(X), p, rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X) && ((is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17MoveAssignable(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/29"
tags = ['sequence-container', 'insert', 'precondition', 'move']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_n_precondition_a5b6c7d8"
content = '''Calling insert(p, n, t) requires T to be Cpp17CopyInsertable and Cpp17CopyAssignable.'''
formal_spec = '''insert(sequence_container(X), p, n, t) => Cpp17CopyInsertable(T, X) && Cpp17CopyAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/33"
tags = ['sequence-container', 'insert', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_range_no_self_b6c7d8e9"
content = '''Calling insert(p, i, j) with iterators i and j that are iterators into the container a is undefined behavior.'''
formal_spec = '''insert(sequence_container(a), p, i, j) && (is_iterator_into(i, a) || is_iterator_into(j, a)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/37"
tags = ['sequence-container', 'insert', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_sequence_reqmts_insert_range_rg_no_overlap_c7d8e9f0"
content = '''Calling insert_range(p, rg) requires that rg and the container a do not overlap.'''
formal_spec = '''insert_range(sequence_container(a), p, rg) && overlaps(rg, a) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/41"
tags = ['sequence-container', 'insert', 'precondition', 'range']

[[axioms]]
id = "cpp20_sequence_reqmts_erase_precondition_d8e9f0a1"
content = '''Calling erase(q) on vector, inplace_vector, and deque requires T to be Cpp17MoveAssignable.'''
formal_spec = '''erase(sequence_container(X), q) && (is_vector(X) || is_inplace_vector(X) || is_deque(X)) => Cpp17MoveAssignable(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/46"
tags = ['sequence-container', 'erase', 'precondition']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_range_no_overlap_e9f0a1b2"
content = '''Calling assign(i, j) with iterators i and j that are iterators into the container a is undefined behavior.'''
formal_spec = '''assign(sequence_container(a), i, j) && (is_iterator_into(i, a) || is_iterator_into(j, a)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/58"
tags = ['sequence-container', 'assign', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_range_rg_no_overlap_f0a1b2c3"
content = '''Calling assign_range(rg) requires that rg and the container a do not overlap.'''
formal_spec = '''assign_range(sequence_container(a), rg) && overlaps(rg, a) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/62"
tags = ['sequence-container', 'assign', 'precondition', 'range']

[[axioms]]
id = "cpp20_sequence_reqmts_assign_n_no_self_ref_a1b2c3d4"
content = '''Calling assign(n, t) requires that t is not a reference into the container a.'''
formal_spec = '''assign(sequence_container(a), n, t) && is_reference_into(t, a) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/67"
tags = ['sequence-container', 'assign', 'precondition']
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_front_precondition_b2c3d4e5"
content = '''Calling front() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(front, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/72"
tags = ['sequence-container', 'front', 'precondition', 'hardened']
function = "front"
header = "<vector>"
signature = '''reference front()'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_back_precondition_c3d4e5f6"
content = '''Calling back() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(back, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/76"
tags = ['sequence-container', 'back', 'precondition', 'hardened']
function = "back"
header = "<vector>"
signature = '''reference back()'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_front_precondition_d4e5f6a7"
content = '''Calling emplace_front(args) requires T to be Cpp17EmplaceConstructible into X from args.'''
formal_spec = '''emplace_front(sequence_container(X), args) => Cpp17EmplaceConstructible(T, X, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/80"
tags = ['sequence-container', 'emplace_front', 'precondition']
function = "emplace_front"
header = "<deque>"
signature = '''reference emplace_front(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_emplace_back_precondition_e5f6a7b8"
content = '''Calling emplace_back(args) requires T to be Cpp17EmplaceConstructible into X from args. For vector, T must also be Cpp17MoveInsertable.'''
formal_spec = '''emplace_back(sequence_container(X), args) => Cpp17EmplaceConstructible(T, X, args) && (is_vector(X) => Cpp17MoveInsertable(T, X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/85"
tags = ['sequence-container', 'emplace_back', 'precondition']
function = "emplace_back"
header = "<vector>"
signature = '''reference emplace_back(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_push_front_copy_precondition_f6a7b8c9"
content = '''Calling push_front(t) requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''push_front(sequence_container(X), t) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/90"
tags = ['sequence-container', 'push_front', 'precondition']
function = "push_front"
header = "<deque>"
signature = '''void push_front(const T& t)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_push_front_move_precondition_a7b8c9d0"
content = '''Calling push_front(rv) requires T to be Cpp17MoveInsertable into X.'''
formal_spec = '''push_front(sequence_container(X), rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/94"
tags = ['sequence-container', 'push_front', 'precondition', 'move']
function = "push_front"
header = "<deque>"
signature = '''void push_front(T&& rv)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_push_back_copy_precondition_b8c9d0e1"
content = '''Calling push_back(t) requires T to be Cpp17CopyInsertable into X.'''
formal_spec = '''push_back(sequence_container(X), t) => Cpp17CopyInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/102"
tags = ['sequence-container', 'push_back', 'precondition']
function = "push_back"
header = "<vector>"
signature = '''void push_back(const T& t)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_push_back_move_precondition_c9d0e1f2"
content = '''Calling push_back(rv) requires T to be Cpp17MoveInsertable into X.'''
formal_spec = '''push_back(sequence_container(X), rv) && is_rvalue(rv) => Cpp17MoveInsertable(T, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/106"
tags = ['sequence-container', 'push_back', 'precondition', 'move']
function = "push_back"
header = "<vector>"
signature = '''void push_back(T&& rv)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_sequence_reqmts_pop_front_precondition_d0e1f2a3"
content = '''Calling pop_front() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(pop_front, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/114"
tags = ['sequence-container', 'pop_front', 'precondition', 'hardened']
function = "pop_front"
header = "<deque>"
signature = '''void pop_front()'''

[[axioms]]
id = "cpp20_sequence_reqmts_pop_back_precondition_e1f2a3b4"
content = '''Calling pop_back() on a container requires the container to be non-empty (hardened precondition).'''
formal_spec = '''call(pop_back, container(a)) && a.empty() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/118"
tags = ['sequence-container', 'pop_back', 'precondition', 'hardened']
function = "pop_back"
header = "<vector>"
signature = '''void pop_back()'''

[[axioms]]
id = "cpp20_sequence_reqmts_subscript_precondition_f2a3b4c5"
content = '''Calling operator[](n) on a container requires n < a.size() (hardened precondition).'''
formal_spec = '''call(operator[], container(a), n) && n >= a.size() => hardened_precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/122"
tags = ['sequence-container', 'subscript', 'precondition', 'hardened']
function = "operator[]"
header = "<vector>"
signature = '''reference operator[](size_type n)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_range_access_size_returns_integer_like_a8b1c5d9', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_sequence_reqmts_at_throws_out_of_range_a3b4c5d6"
content = '''Calling at(n) throws out_of_range if n >= a.size().'''
formal_spec = '''call(at, container(a), n) && n >= a.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sequence.reqmts"
source_module = "[sequence.reqmts]/127"
tags = ['sequence-container', 'at', 'exception']
function = "at"
header = "<vector>"
signature = '''reference at(size_type n)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4', 'cpp20_range_access_size_returns_integer_like_a8b1c5d9']

[[axioms]]
id = "cpp20_container_opt_reqmts_threeway_precondition_b4c5d6e7"
content = '''Container three-way comparison requires either T models three_way_comparable, or operator< is defined for T and is a total ordering relationship.'''
formal_spec = '''three_way_compare(container(X, T)) => (three_way_comparable(T) || (defined(operator<, T) && total_ordering(operator<, T)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.opt.reqmts"
source_module = "[container.opt.reqmts]/3"
tags = ['container', 'comparison', 'precondition']
depends_on = ['cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_container_node_pair_specialization_ub_c5d6e7f8"
content = '''If a user-defined specialization of pair exists for pair<const Key, T> or pair<Key, T>, where Key is the container's key_type and T is the container's mapped_type, the behavior of operations involving node handles is undefined.'''
formal_spec = '''user_specialization(pair<const Key, T>) || user_specialization(pair<Key, T>) => node_handle_operations_undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.overview"
source_module = "[container.node.overview]/4"
tags = ['container', 'node-handle', 'undefined-behavior', 'pair']

[[axioms]]
id = "cpp20_container_node_move_assign_precondition_d6e7f8a9"
content = '''Node handle move assignment requires either the target is empty, or propagate_on_container_move_assignment is true, or the allocators are equal.'''
formal_spec = '''move_assign(node_handle, nh) && alloc_.has_value() && !propagate_on_container_move_assignment && alloc_ != nh.alloc_ => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.cons"
source_module = "[container.node.cons]/2"
tags = ['container', 'node-handle', 'precondition', 'move-assignment']
depends_on = ['cpp20_weak_ptr_assignment_move_effect_c0e4a8f3']

[[axioms]]
id = "cpp20_container_node_value_precondition_e7f8a9b0"
content = '''Calling value() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(value, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/1"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::value"
header = "<map>"
signature = '''value_type& value() const'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_value_type_constraint_e5f6a7b8', 'c11_c_conversion_syntax_operation_c943b988']

[[axioms]]
id = "cpp20_container_node_key_precondition_f8a9b0c1"
content = '''Calling key() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(key, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/4"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::key"
header = "<map>"
signature = '''key_type& key() const'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'c11_c_typing_effective_syntax_comparison_5b005edd', 'c11_cpp_typing_sorts_operation_720193ca', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'c11_c_decl_global_syntax_comparison_232484e5']

[[axioms]]
id = "cpp20_container_node_mapped_precondition_a9b0c1d2"
content = '''Calling mapped() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(mapped, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/8"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::mapped"
header = "<map>"
signature = '''mapped_type& mapped() const'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_container_node_get_allocator_precondition_b0c1d2e3"
content = '''Calling get_allocator() on a node handle requires the node handle to be non-empty.'''
formal_spec = '''call(get_allocator, node_handle(nh)) && nh.empty() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.observers"
source_module = "[container.node.observers]/11"
tags = ['container', 'node-handle', 'precondition']
function = "node_handle::get_allocator"
header = "<map>"
signature = '''allocator_type get_allocator() const'''
depends_on = ['cpp20_container_alloc_reqmts_allocator_type_value_match_e1f2a3b4']

[[axioms]]
id = "cpp20_container_node_swap_precondition_c1d2e3f4"
content = '''Swapping node handles requires either both are empty, or propagate_on_container_swap is true, or the allocators are equal.'''
formal_spec = '''swap(node_handle(nh1), node_handle(nh2)) && nh1.alloc_.has_value() && nh2.alloc_.has_value() && !propagate_on_container_swap && nh1.alloc_ != nh2.alloc_ => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "container.node.modifiers"
source_module = "[container.node.modifiers]/1"
tags = ['container', 'node-handle', 'precondition', 'swap']

[[axioms]]
id = "cpp20_forward_rvalue_overload_mandates_a3b7c9d1"
content = '''The second overload of std::forward (taking remove_reference_t<T>&&) requires that is_lvalue_reference_v<T> is false. Attempting to forward an rvalue as an lvalue reference is ill-formed.'''
formal_spec = '''call(std::forward<T>, remove_reference_t<T>&&) && is_lvalue_reference_v<T> => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/2"
tags = ['forwarding', 'move_semantics', 'mandates', 'type_constraint']
function = "std::forward"
header = "<utility>"
signature = '''template<class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept'''
depends_on = ['cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_basic_lval_temp_materialization_b4e9f1c5', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a']

[[axioms]]
id = "cpp20_forward_lvalue_overload_returns_f2e8a1c4"
content = '''The first overload of std::forward (taking remove_reference_t<T>&) returns static_cast<T&&>(t), preserving the value category of the original expression.'''
formal_spec = '''call(std::forward<T>, remove_reference_t<T>&) => static_cast<T&&>(t)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/3"
tags = ['forwarding', 'move_semantics', 'perfect_forwarding']
function = "std::forward"
header = "<utility>"
signature = '''template<class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_forward_rvalue_overload_returns_b5d9e3f7"
content = '''The second overload of std::forward (taking remove_reference_t<T>&&) returns static_cast<T&&>(t), enabling forwarding of rvalues.'''
formal_spec = '''call(std::forward<T>, remove_reference_t<T>&&) && !is_lvalue_reference_v<T> => static_cast<T&&>(t)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/3"
tags = ['forwarding', 'move_semantics', 'perfect_forwarding']
function = "std::forward"
header = "<utility>"
signature = '''template<class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_forward_like_mandates_referenceable_c7a2b4e6"
content = '''std::forward_like requires that T is a referenceable type. A type is referenceable if it can have a reference formed to it (not void, not a function type with cv-qualifiers or ref-qualifiers).'''
formal_spec = '''call(std::forward_like<T>, U&&) && !is_referenceable_v<T> => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/5"
tags = ['forwarding', 'mandates', 'type_constraint', 'forward_like']
function = "std::forward_like"
header = "<utility>"
signature = '''template<class T, class U> constexpr auto forward_like(U&& x) noexcept -> see below'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_forward_like_return_type_d8f1c3a9"
content = '''std::forward_like<T>(x) returns static_cast<V>(x) where V is computed as OVERRIDE_REF(T&&, COPY_CONST(remove_reference_t<T>, remove_reference_t<U>)), propagating const-ness and reference category from T to U.'''
formal_spec = '''let COPY_CONST(A, B) = is_const_v<A> ? const B : B; let OVERRIDE_REF(A, B) = is_rvalue_reference_v<A> ? remove_reference_t<B>&& : B&; let V = OVERRIDE_REF(T&&, COPY_CONST(remove_reference_t<T>, remove_reference_t<U>)); forward_like<T>(x) => static_cast<V>(x)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "forward"
source_module = "[forward]/6-7"
tags = ['forwarding', 'forward_like', 'const_propagation', 'reference_propagation']
function = "std::forward_like"
header = "<utility>"
signature = '''template<class T, class U> constexpr auto forward_like(U&& x) noexcept -> V'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_move_returns_rvalue_ref_e4b6d2a8"
content = '''std::move(t) returns static_cast<remove_reference_t<T>&&>(t), unconditionally casting t to an rvalue reference to enable move semantics.'''
formal_spec = '''call(std::move<T>, T&&) => static_cast<remove_reference_t<T>&&>(t)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/10"
tags = ['move_semantics', 'rvalue_reference', 'cast']
function = "std::move"
header = "<utility>"
signature = '''template<class T> constexpr remove_reference_t<T>&& move(T&& t) noexcept'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_move_if_noexcept_conditional_f9c5a1b3"
content = '''std::move_if_noexcept(x) returns a const lvalue reference if the type is not nothrow move constructible but is copy constructible; otherwise returns an rvalue reference. This enables strong exception safety when moving could throw.'''
formal_spec = '''move_if_noexcept(x) => (!is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>) ? const T& : T&&'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/11-12"
tags = ['move_semantics', 'exception_safety', 'conditional_move']
function = "std::move_if_noexcept"
header = "<utility>"
signature = '''template<class T> constexpr conditional_t<!is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>, const T&, T&&> move_if_noexcept(T& x) noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_basic_lval_temp_materialization_b4e9f1c5', 'cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_forward_signal_safe_a2d4f6c8"
content = '''All functions specified in [forward] (std::forward, std::forward_like, std::move, std::move_if_noexcept) are signal-safe and may be called from signal handlers.'''
formal_spec = '''is_signal_safe(std::forward) && is_signal_safe(std::forward_like) && is_signal_safe(std::move) && is_signal_safe(std::move_if_noexcept)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "forward"
source_module = "[forward]/1"
tags = ['signal_safety', 'async_signal_safe']
function = "std::forward"
header = "<utility>"
signature = '''template<class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_constraint_move_constructible_a3b7c2d1"
content = '''The template std::swap(T&, T&) requires is_move_constructible_v<T> to be true.'''
formal_spec = '''call(swap(a, b)) => is_move_constructible_v<T> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/1"
tags = ['swap', 'constraint', 'type_traits', 'move_constructible']
function = "std::swap"
header = "<utility>"
signature = '''template<class T> constexpr void swap(T& a, T& b) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_constraint_move_assignable_e4f8g5h2"
content = '''The template std::swap(T&, T&) requires is_move_assignable_v<T> to be true.'''
formal_spec = '''call(swap(a, b)) => is_move_assignable_v<T> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/1"
tags = ['swap', 'constraint', 'type_traits', 'move_assignable']
function = "std::swap"
header = "<utility>"
signature = '''template<class T> constexpr void swap(T& a, T& b) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_precond_cpp17moveconstructible_b5c9d3e7"
content = '''Calling std::swap(T&, T&) requires that type T meets the Cpp17MoveConstructible requirements.'''
formal_spec = '''call(swap(a, b)) => meets_cpp17_move_constructible<T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/2"
tags = ['swap', 'precondition', 'named_requirements', 'move_constructible']
function = "std::swap"
header = "<utility>"
signature = '''template<class T> constexpr void swap(T& a, T& b) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_precond_cpp17moveassignable_f6g0h4i8"
content = '''Calling std::swap(T&, T&) requires that type T meets the Cpp17MoveAssignable requirements.'''
formal_spec = '''call(swap(a, b)) => meets_cpp17_move_assignable<T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/2"
tags = ['swap', 'precondition', 'named_requirements', 'move_assignable']
function = "std::swap"
header = "<utility>"
signature = '''template<class T> constexpr void swap(T& a, T& b) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_effect_exchange_values_c7d1e5f9"
content = '''std::swap(T&, T&) exchanges the values stored in the two locations.'''
formal_spec = '''pre(a == A && b == B) && call(swap(a, b)) => post(a == B && b == A)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/3"
tags = ['swap', 'effect', 'exchange']
function = "std::swap"
header = "<utility>"
signature = '''template<class T> constexpr void swap(T& a, T& b) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_noexcept_spec_g8h2i6j0"
content = '''The noexcept specification of std::swap(T&, T&) is equivalent to is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>.'''
formal_spec = '''noexcept(swap(a, b)) == (is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/4"
tags = ['swap', 'noexcept', 'exception_specification']
function = "std::swap"
header = "<utility>"
signature = '''template<class T> constexpr void swap(T& a, T& b) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_any_reset_noexcept_b7c8d9e0', 'cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_utility_swap_array_noexcept_spec_w4x8y2z6']

[[axioms]]
id = "cpp20_utility_swap_array_constraint_swappable_k9l3m7n1"
content = '''The array overload of std::swap requires is_swappable_v<T> to be true.'''
formal_spec = '''call(swap(a[N], b[N])) => is_swappable_v<T> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/5"
tags = ['swap', 'constraint', 'array', 'type_traits', 'swappable']
function = "std::swap"
header = "<utility>"
signature = '''template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)'''
depends_on = ['cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a']

[[axioms]]
id = "cpp20_utility_swap_array_precond_elements_swappable_o0p4q8r2"
content = '''Calling std::swap on arrays requires that a[i] is swappable with b[i] for all i in the range [0, N).'''
formal_spec = '''call(swap(a[N], b[N])) => forall(i in [0, N): is_swappable_with(a[i], b[i]))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/6"
tags = ['swap', 'precondition', 'array', 'swappable']
function = "std::swap"
header = "<utility>"
signature = '''template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)'''
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_utility_swap_array_effect_swap_ranges_s1t5u9v3"
content = '''std::swap on arrays has the effect of calling swap_ranges(a, a+N, b).'''
formal_spec = '''call(swap(a[N], b[N])) => effect_equivalent(swap_ranges(a, a+N, b))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/7"
tags = ['swap', 'effect', 'array', 'swap_ranges']
function = "std::swap"
header = "<utility>"
signature = '''template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_utility_swap_array_noexcept_spec_w4x8y2z6"
content = '''The noexcept specification of std::swap for arrays is is_nothrow_swappable_v<T>.'''
formal_spec = '''noexcept(swap(a[N], b[N])) == is_nothrow_swappable_v<T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "utility.swap"
source_module = "[utility.swap]/5"
tags = ['swap', 'noexcept', 'array', 'exception_specification']
function = "std::swap"
header = "<utility>"
signature = '''template<class T, size_t N> constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>)'''
depends_on = ['cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_any_reset_noexcept_b7c8d9e0', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_declval_odr_use_forbidden_7c8e3f2a"
content = '''The function template std::declval shall not be odr-used. It is only valid as an unevaluated operand.'''
formal_spec = '''odr_used(declval<T>()) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "declval"
source_module = "[declval]/2"
tags = ['unevaluated', 'odr-use', 'template', 'metaprogramming']
function = "std::declval"
header = "<utility>"
signature = '''template<class T> add_rvalue_reference_t<T> declval() noexcept'''
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2']

[[axioms]]
id = "cpp20_declval_incomplete_type_allowed_b5a9d4c1"
content = '''The template parameter T of std::declval may be an incomplete type.'''
formal_spec = '''declval<T>() => allows(incomplete_type(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "declval"
source_module = "[declval]/3"
tags = ['incomplete-type', 'template', 'metaprogramming', 'type-traits']
function = "std::declval"
header = "<utility>"
signature = '''template<class T> add_rvalue_reference_t<T> declval() noexcept'''
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0']

[[axioms]]
id = "cpp20_variant_no_args_illformed_a1b2c3d4"
content = '''A program that instantiates the definition of variant with no template arguments is ill-formed.'''
formal_spec = '''sizeof...(Types) == 0 && instantiate(variant<Types...>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/3"
tags = ['variant', 'template', 'constraint', 'ill-formed']
header = "<variant>"
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2']

[[axioms]]
id = "cpp20_variant_explicit_specialization_illformed_e5f6g7h8"
content = '''If a program declares an explicit or partial specialization of variant, the program is ill-formed, no diagnostic required.'''
formal_spec = '''(explicit_specialization(variant) || partial_specialization(variant)) => ill_formed_ndr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/4"
tags = ['variant', 'specialization', 'ill-formed', 'ndr']
header = "<variant>"

[[axioms]]
id = "cpp20_variant_types_destructible_i9j0k1l2"
content = '''All types in the variant Types parameter pack shall meet the Cpp17Destructible requirements.'''
formal_spec = '''forall Ti in Types: meets_cpp17_destructible(Ti)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/2"
tags = ['variant', 'constraint', 'destructible']
header = "<variant>"

[[axioms]]
id = "cpp20_variant_get_index_precondition_m3n4o5p6"
content = '''Calling GET<I>(v) requires that v.index() is I.'''
formal_spec = '''call(GET<I>, v) => precondition(v.index() == I)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/4"
tags = ['variant', 'precondition', 'get', 'access']
function = "GET"
header = "<variant>"
signature = '''variant_alternative_t<I, variant<Types...>>& GET(variant<Types...>& v)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_get_throws_bad_variant_access_q7r8s9t0"
content = '''Calling std::get<I>(v) throws bad_variant_access if v.index() is not I.'''
formal_spec = '''call(get<I>, v) && v.index() != I => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/7"
tags = ['variant', 'exception', 'get', 'access']
function = "std::get"
header = "<variant>"
signature = '''variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_variant_bad_variant_access_u1v2w3x4']

[[axioms]]
id = "cpp20_variant_get_type_throws_bad_variant_access_y5z6a7b8"
content = '''Calling std::get<T>(v) throws bad_variant_access if v does not hold a value of type T.'''
formal_spec = '''call(get<T>, v) && !holds_alternative<T>(v) => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/9"
tags = ['variant', 'exception', 'get', 'access']
function = "std::get"
header = "<variant>"
signature = '''T& get(variant<Types...>& v)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_variant_get_throws_bad_variant_access_q7r8s9t0', 'cpp20_variant_bad_variant_access_u1v2w3x4']

[[axioms]]
id = "cpp20_variant_bad_variant_access_u1v2w3x4"
content = '''Objects of type bad_variant_access are thrown to report invalid accesses to the value of a variant object.'''
formal_spec = '''invalid_variant_access => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.bad.access"
source_module = "[variant.bad.access]/1"
tags = ['variant', 'exception', 'bad_variant_access']
header = "<variant>"
depends_on = ['cpp20_variant_get_throws_bad_variant_access_q7r8s9t0']

[[axioms]]
id = "cpp20_variant_get_index_mandates_c9d0e1f2"
content = '''std::get<I> mandates that I is less than sizeof...(Types).'''
formal_spec = '''call(get<I>, variant<Types...>) => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/6"
tags = ['variant', 'mandates', 'get', 'constraint']
function = "std::get"
header = "<variant>"
signature = '''variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_get_type_mandates_unique_g3h4i5j6"
content = '''std::get<T> mandates that the type T occurs exactly once in Types.'''
formal_spec = '''call(get<T>, variant<Types...>) => mandates(count(T, Types) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/8"
tags = ['variant', 'mandates', 'get', 'constraint']
function = "std::get"
header = "<variant>"
signature = '''T& get(variant<Types...>& v)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_holds_alternative_mandates_k7l8m9n0"
content = '''holds_alternative<T> mandates that the type T occurs exactly once in Types.'''
formal_spec = '''call(holds_alternative<T>, variant<Types...>) => mandates(count(T, Types) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/1"
tags = ['variant', 'mandates', 'holds_alternative', 'constraint']
function = "std::holds_alternative"
header = "<variant>"
signature = '''bool holds_alternative(const variant<Types...>& v) noexcept'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_alternative_mandates_o1p2q3r4"
content = '''variant_alternative<I, variant<Types...>>::type mandates that I is less than sizeof...(Types).'''
formal_spec = '''variant_alternative<I, variant<Types...>> => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.helper"
source_module = "[variant.helper]/4"
tags = ['variant', 'mandates', 'variant_alternative', 'constraint']
header = "<variant>"

[[axioms]]
id = "cpp20_variant_emplace_mandates_s5t6u7v8"
content = '''emplace<I>(...) mandates that I is less than sizeof...(Types).'''
formal_spec = '''call(emplace<I>, variant<Types...>) => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/5"
tags = ['variant', 'mandates', 'emplace', 'constraint']
function = "std::variant::emplace"
header = "<variant>"
signature = '''variant_alternative_t<I, variant<Types...>>& emplace(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_emplace_valueless_w9x0y1z2"
content = '''If an exception is thrown during the initialization of the contained value in emplace, the variant is permitted to not hold a value (become valueless_by_exception).'''
formal_spec = '''call(emplace<I>, v, args...) && throws_during_init => permitted(v.valueless_by_exception())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/11"
tags = ['variant', 'exception', 'emplace', 'valueless']
function = "std::variant::emplace"
header = "<variant>"
signature = '''variant_alternative_t<I, variant<Types...>>& emplace(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_variant_swap_precondition_swappable_a3b4c5d6"
content = '''Each Ti must meet the Cpp17Swappable requirements for variant::swap.'''
formal_spec = '''call(swap, variant<Types...>&, variant<Types...>&) => precondition(forall Ti in Types: cpp17_swappable(Ti))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.swap"
source_module = "[variant.swap]/2"
tags = ['variant', 'precondition', 'swap', 'swappable']
function = "std::variant::swap"
header = "<variant>"
signature = '''void swap(variant& rhs) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_swap_mandates_move_constructible_e7f8g9h0"
content = '''variant::swap mandates that is_move_constructible_v<Ti> is true for all i.'''
formal_spec = '''call(swap, variant<Types...>&) => mandates(forall Ti in Types: is_move_constructible_v<Ti>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.swap"
source_module = "[variant.swap]/1"
tags = ['variant', 'mandates', 'swap', 'move_constructible']
function = "std::variant::swap"
header = "<variant>"
signature = '''void swap(variant& rhs) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_visit_throws_bad_variant_access_i1j2k3l4"
content = '''std::visit throws bad_variant_access if any variant argument is valueless_by_exception.'''
formal_spec = '''call(visit, vis, vars...) && (exists v in vars: v.valueless_by_exception()) => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.visit"
source_module = "[variant.visit]/7"
tags = ['variant', 'exception', 'visit', 'valueless']
function = "std::visit"
header = "<variant>"
signature = '''see below visit(Visitor&& vis, Variants&&... vars)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_variant_get_throws_bad_variant_access_q7r8s9t0', 'cpp20_variant_bad_variant_access_u1v2w3x4']

[[axioms]]
id = "cpp20_variant_visit_mandates_valid_expression_m5n6o7p8"
content = '''For each valid pack m, e(m) must be a valid expression and all such expressions must be of the same type and value category.'''
formal_spec = '''call(visit, vis, vars...) => mandates(forall valid m: valid_expr(e(m)) && same_type_and_category(all e(m)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.visit"
source_module = "[variant.visit]/5"
tags = ['variant', 'mandates', 'visit', 'constraint']
function = "std::visit"
header = "<variant>"
signature = '''see below visit(Visitor&& vis, Variants&&... vars)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_ctor_in_place_type_unique_q9r0s1t2"
content = '''Constructor with in_place_type_t<T> requires exactly one occurrence of T in Types.'''
formal_spec = '''call(variant, in_place_type_t<T>, args...) => constraint(count(T, Types) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/20"
tags = ['variant', 'constraint', 'constructor', 'in_place']
function = "std::variant::variant"
header = "<variant>"
signature = '''variant(in_place_type_t<T>, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_variant_ctor_in_place_index_bound_u3v4w5x6"
content = '''Constructor with in_place_index_t<I> requires I to be less than sizeof...(Types).'''
formal_spec = '''call(variant, in_place_index_t<I>, args...) => constraint(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/30"
tags = ['variant', 'constraint', 'constructor', 'in_place']
function = "std::variant::variant"
header = "<variant>"
signature = '''variant(in_place_index_t<I>, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_variant_move_assign_exception_valueless_y7z8a9b0"
content = '''If an exception is thrown during the call to Tj's move construction in move assignment, the variant will hold no value.'''
formal_spec = '''move_assign(v, rhs) && throws_during_move_construct(Tj) => v.valueless_by_exception()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/10.1"
tags = ['variant', 'exception', 'assignment', 'valueless']
function = "std::variant::operator="
header = "<variant>"
signature = '''variant& operator=(variant&& rhs) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_weak_ptr_assignment_move_effect_c0e4a8f3', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_variant_converting_assign_exception_valueless_c1d2e3f4"
content = '''If an exception is thrown during the initialization of the contained value in converting assignment, the variant object is permitted to not hold a value.'''
formal_spec = '''converting_assign(v, t) && throws_during_init => permitted(v.valueless_by_exception())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/16.2"
tags = ['variant', 'exception', 'assignment', 'valueless']
function = "std::variant::operator="
header = "<variant>"
signature = '''variant& operator=(T&& t) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']

[[axioms]]
id = "cpp20_variant_index_valueless_returns_npos_g5h6i7j8"
content = '''If valueless_by_exception() is true, index() returns variant_npos.'''
formal_spec = '''v.valueless_by_exception() => v.index() == variant_npos'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.status"
source_module = "[variant.status]/3"
tags = ['variant', 'valueless', 'index', 'npos']
function = "std::variant::index"
header = "<variant>"
signature = '''size_t index() const noexcept'''

[[axioms]]
id = "cpp20_variant_valueless_by_exception_k9l0m1n2"
content = '''valueless_by_exception() returns false if and only if the variant holds a value.'''
formal_spec = '''v.valueless_by_exception() == false <=> v.holds_value()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.status"
source_module = "[variant.status]/1"
tags = ['variant', 'valueless', 'status']
function = "std::variant::valueless_by_exception"
header = "<variant>"
signature = '''bool valueless_by_exception() const noexcept'''

[[axioms]]
id = "cpp20_variant_get_if_returns_nullptr_o3p4q5r6"
content = '''get_if returns nullptr if v is nullptr or if v->index() != I.'''
formal_spec = '''(v == nullptr || v->index() != I) => get_if<I>(v) == nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/11"
tags = ['variant', 'get_if', 'nullptr', 'access']
function = "std::get_if"
header = "<variant>"
signature = '''add_pointer_t<variant_alternative_t<I, variant<Types...>>> get_if(variant<Types...>* v) noexcept'''
depends_on = ['c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_variant_get_if_mandates_index_s7t8u9v0"
content = '''get_if<I> mandates that I is less than sizeof...(Types).'''
formal_spec = '''call(get_if<I>, variant<Types...>*) => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/10"
tags = ['variant', 'mandates', 'get_if', 'constraint']
function = "std::get_if"
header = "<variant>"
signature = '''add_pointer_t<variant_alternative_t<I, variant<Types...>>> get_if(variant<Types...>* v) noexcept'''
depends_on = ['c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_variant_get_if_type_mandates_unique_w1x2y3z4"
content = '''get_if<T> mandates that the type T occurs exactly once in Types.'''
formal_spec = '''call(get_if<T>, variant<Types...>*) => mandates(count(T, Types) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/12"
tags = ['variant', 'mandates', 'get_if', 'constraint']
function = "std::get_if"
header = "<variant>"
signature = '''add_pointer_t<T> get_if(variant<Types...>* v) noexcept'''
depends_on = ['c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_variant_emplace_type_unique_a5b6c7d8"
content = '''emplace<T>(...) requires T to occur exactly once in Types.'''
formal_spec = '''call(emplace<T>, variant<Types...>) => constraint(count(T, Types) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/1"
tags = ['variant', 'constraint', 'emplace']
function = "std::variant::emplace"
header = "<variant>"
signature = '''T& emplace(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_hash_enabled_condition_e9f0g1h2"
content = '''The specialization hash<variant<Types...>> is enabled if and only if every specialization in hash<remove_const_t<Types>>... is enabled.'''
formal_spec = '''enabled(hash<variant<Types...>>) <=> forall Ti in Types: enabled(hash<remove_const_t<Ti>>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.hash"
source_module = "[variant.hash]/1"
tags = ['variant', 'hash', 'constraint']
header = "<variant>"

[[axioms]]
id = "cpp20_variant_dtor_destroys_value_i3j4k5l6"
content = '''The variant destructor destroys the currently contained value if valueless_by_exception() is false.'''
formal_spec = '''!v.valueless_by_exception() && destruct(v) => destroy(contained_value(v))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.dtor"
source_module = "[variant.dtor]/1"
tags = ['variant', 'destructor', 'lifetime']
function = "std::variant::~variant"
header = "<variant>"
signature = '''~variant()'''
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2']

[[axioms]]
id = "cpp20_variant_ctor_converting_ambiguous_illformed_m7n8o9p0"
content = '''Converting constructor is ill-formed if the expression FUN(forward<T>(t)) is not well-formed (e.g., ambiguous overload).'''
formal_spec = '''!well_formed(FUN(forward<T>(t))) => ill_formed(variant(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/15.5"
tags = ['variant', 'constraint', 'constructor', 'ambiguous']
function = "std::variant::variant"
header = "<variant>"
signature = '''variant(T&& t) noexcept(see below)'''
depends_on = ['cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_variant_assign_converting_ambiguous_illformed_q1r2s3t4"
content = '''Converting assignment is ill-formed if the expression FUN(forward<T>(t)) is not well-formed (e.g., ambiguous overload).'''
formal_spec = '''!well_formed(FUN(forward<T>(t))) => ill_formed(v = t)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/12.3"
tags = ['variant', 'constraint', 'assignment', 'ambiguous']
function = "std::variant::operator="
header = "<variant>"
signature = '''variant& operator=(T&& t) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_relops_valueless_equal_u5v6w7x8"
content = '''Two valueless variants compare equal.'''
formal_spec = '''v.valueless_by_exception() && w.valueless_by_exception() => (v == w) == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.relops"
source_module = "[variant.relops]/2"
tags = ['variant', 'comparison', 'valueless', 'equality']
function = "operator=="
header = "<variant>"
signature = '''bool operator==(const variant<Types...>& v, const variant<Types...>& w)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_relops_valueless_less_y9z0a1b2"
content = '''A valueless variant is less than a non-valueless variant.'''
formal_spec = '''v.valueless_by_exception() && !w.valueless_by_exception() => (v < w) == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.relops"
source_module = "[variant.relops]/6"
tags = ['variant', 'comparison', 'valueless', 'ordering']
function = "operator<"
header = "<variant>"
signature = '''bool operator<(const variant<Types...>& v, const variant<Types...>& w)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_spaceship_valueless_ordering_c3d4e5f6"
content = '''In three-way comparison, two valueless variants yield strong_ordering::equal, valueless < non-valueless yields strong_ordering::less, non-valueless > valueless yields strong_ordering::greater.'''
formal_spec = '''v.valueless_by_exception() && w.valueless_by_exception() => (v <=> w) == strong_ordering::equal && v.valueless_by_exception() && !w.valueless_by_exception() => (v <=> w) == strong_ordering::less'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.relops"
source_module = "[variant.relops]/13"
tags = ['variant', 'comparison', 'spaceship', 'valueless']
function = "operator<=>"
header = "<variant>"
signature = '''common_comparison_category_t<compare_three_way_result_t<Types>...> operator<=>(const variant<Types...>& v, const variant<Types...>& w)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0"
content = '''The copy constructor is defined as deleted unless is_copy_constructible_v<Ti> is true for all i.'''
formal_spec = '''!(forall Ti in Types: is_copy_constructible_v<Ti>) => deleted(variant(const variant&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/9"
tags = ['variant', 'constraint', 'constructor', 'copy', 'deleted']
function = "std::variant::variant"
header = "<variant>"
signature = '''variant(const variant& w) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_variant_copy_assign_deleted_condition_k1l2m3n4"
content = '''The copy assignment operator is defined as deleted unless is_copy_constructible_v<Ti> && is_copy_assignable_v<Ti> is true for all i.'''
formal_spec = '''!(forall Ti in Types: is_copy_constructible_v<Ti> && is_copy_assignable_v<Ti>) => deleted(variant::operator=(const variant&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/5"
tags = ['variant', 'constraint', 'assignment', 'copy', 'deleted']
function = "std::variant::operator="
header = "<variant>"
signature = '''variant& operator=(const variant& rhs)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_variant_swap_specialized_constraints_o5p6q7r8"
content = '''The specialized swap for variant requires is_move_constructible_v<Ti> && is_swappable_v<Ti> is true for all i.'''
formal_spec = '''call(swap, variant<Types...>&, variant<Types...>&) => constraint(forall Ti in Types: is_move_constructible_v<Ti> && is_swappable_v<Ti>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.specalg"
source_module = "[variant.specalg]/1"
tags = ['variant', 'constraint', 'swap']
function = "std::swap"
header = "<variant>"
signature = '''void swap(variant<Types...>& v, variant<Types...>& w) noexcept(see below)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_expected_unexpected_illformed_type_a1b2c3d4"
content = '''A program that instantiates the definition of unexpected for a non-object type, an array type, a specialization of unexpected, or a cv-qualified type is ill-formed.'''
formal_spec = '''instantiate(unexpected<E>) && (is_non_object_type(E) || is_array_type(E) || is_specialization_of(E, unexpected) || is_cv_qualified(E)) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.general"
source_module = "[expected.un.general]/2"
tags = ['type_constraint', 'unexpected', 'ill-formed']
header = "<expected>"
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_expected_value_type_constraint_e5f6a7b8"
content = '''A type T is a valid value type for expected if remove_cv_t<T> is void or a complete non-array object type that is not in_place_t, unexpect_t, or a specialization of unexpected.'''
formal_spec = '''valid_value_type(T) <=> (is_void(remove_cv_t<T>) || (is_complete_object_type(T) && !is_array_type(T) && !is_same(remove_cv_t<T>, in_place_t) && !is_same(remove_cv_t<T>, unexpect_t) && !is_specialization_of(remove_cv_t<T>, unexpected)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/2"
tags = ['type_constraint', 'expected', 'value_type']
header = "<expected>"
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_expected_error_type_constraint_c9d0e1f2"
content = '''A program that instantiates the definition of expected<T, E> with a type for the E parameter that is not a valid template argument for unexpected is ill-formed.'''
formal_spec = '''instantiate(expected<T, E>) && !valid_unexpected_arg(E) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/2"
tags = ['type_constraint', 'expected', 'error_type', 'ill-formed']
header = "<expected>"
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0']

[[axioms]]
id = "cpp20_expected_t_destructible_a3b4c5d6"
content = '''When T is not cv void, T shall meet the Cpp17Destructible requirements.'''
formal_spec = '''instantiate(expected<T, E>) && !is_void(T) => Cpp17Destructible(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/3"
tags = ['type_constraint', 'expected', 'destructible']
header = "<expected>"

[[axioms]]
id = "cpp20_expected_e_destructible_e7f8a9b0"
content = '''E shall meet the Cpp17Destructible requirements.'''
formal_spec = '''instantiate(expected<T, E>) => Cpp17Destructible(E)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/3"
tags = ['type_constraint', 'expected', 'error_type', 'destructible']
header = "<expected>"

[[axioms]]
id = "cpp20_expected_arrow_precondition_c1d2e3f4"
content = '''Calling operator->() on expected requires has_value() to be true.'''
formal_spec = '''call(expected<T,E>::operator->()) => precondition(has_value() == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/1"
tags = ['precondition', 'expected', 'observer', 'hardened']
function = "std::expected::operator->"
header = "<expected>"
signature = '''constexpr const T* std::expected<T, E>::operator->() const noexcept'''
depends_on = ['cpp20_const_pointer_cast_mandates_7a8b9c0d', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_expected_deref_precondition_a5b6c7d8"
content = '''Calling operator*() on expected requires has_value() to be true.'''
formal_spec = '''call(expected<T,E>::operator*()) => precondition(has_value() == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/3"
tags = ['precondition', 'expected', 'observer', 'hardened']
function = "std::expected::operator*"
header = "<expected>"
signature = '''constexpr const T& std::expected<T, E>::operator*() const& noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_expected_deref_rvalue_precondition_e9f0a1b2"
content = '''Calling operator*() rvalue overloads on expected requires has_value() to be true.'''
formal_spec = '''call(expected<T,E>::operator*() &&) || call(expected<T,E>::operator*() const&&) => precondition(has_value() == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/5"
tags = ['precondition', 'expected', 'observer', 'hardened']
function = "std::expected::operator*"
header = "<expected>"
signature = '''constexpr T&& std::expected<T, E>::operator*() && noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_expected_value_throws_bad_access_c3d4e5f6"
content = '''Calling value() on expected when has_value() is false throws bad_expected_access with the error.'''
formal_spec = '''!has_value() && call(expected<T,E>::value()) => throws(bad_expected_access<E>(error()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/10"
tags = ['exception', 'expected', 'observer', 'bad_expected_access']
function = "std::expected::value"
header = "<expected>"
signature = '''constexpr const T& std::expected<T, E>::value() const&'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0"
content = '''Calling value() rvalue overloads on expected when has_value() is false throws bad_expected_access with moved error.'''
formal_spec = '''!has_value() && (call(expected<T,E>::value() &&) || call(expected<T,E>::value() const&&)) => throws(bad_expected_access<E>(std::move(error())))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/13"
tags = ['exception', 'expected', 'observer', 'bad_expected_access']
function = "std::expected::value"
header = "<expected>"
signature = '''constexpr T&& std::expected<T, E>::value() &&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_error_precondition_e1f2a3b4"
content = '''Calling error() on expected requires has_value() to be false.'''
formal_spec = '''call(expected<T,E>::error()) => precondition(has_value() == false)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/14"
tags = ['precondition', 'expected', 'observer', 'hardened']
function = "std::expected::error"
header = "<expected>"
signature = '''constexpr const E& std::expected<T, E>::error() const& noexcept'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_error_rvalue_precondition_c5d6e7f8"
content = '''Calling error() rvalue overloads on expected requires has_value() to be false.'''
formal_spec = '''call(expected<T,E>::error() &&) || call(expected<T,E>::error() const&&) => precondition(has_value() == false)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/16"
tags = ['precondition', 'expected', 'observer', 'hardened']
function = "std::expected::error"
header = "<expected>"
signature = '''constexpr E&& std::expected<T, E>::error() && noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_and_then_mandates_a9b0c1d2"
content = '''For and_then, the result type U must be a specialization of expected and U::error_type must be same as E.'''
formal_spec = '''call(expected<T,E>::and_then(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F, val>>, expected) && is_same_v<typename U::error_type, E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/3"
tags = ['mandates', 'expected', 'monadic', 'and_then']
function = "std::expected::and_then"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::and_then(F&& f) &'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_or_else_mandates_e3f4a5b6"
content = '''For or_else, the result type G must be a specialization of expected and G::value_type must be same as T.'''
formal_spec = '''call(expected<T,E>::or_else(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F, error()>>, expected) && is_same_v<typename G::value_type, T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/11"
tags = ['mandates', 'expected', 'monadic', 'or_else']
function = "std::expected::or_else"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::or_else(F&& f) &'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_transform_mandates_c7d8e9f0"
content = '''For transform, the result type U must be a valid value type for expected.'''
formal_spec = '''call(expected<T,E>::transform(F)) => mandates(valid_value_type(remove_cv_t<invoke_result_t<F, val>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/19"
tags = ['mandates', 'expected', 'monadic', 'transform']
function = "std::expected::transform"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::transform(F&& f) &'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_transform_error_mandates_a1b2c3d4"
content = '''For transform_error, the result type G must be a valid template argument for unexpected.'''
formal_spec = '''call(expected<T,E>::transform_error(F)) => mandates(valid_unexpected_arg(remove_cv_t<invoke_result_t<F, error()>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/27"
tags = ['mandates', 'expected', 'monadic', 'transform_error']
function = "std::expected::transform_error"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::transform_error(F&& f) &'''
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2']

[[axioms]]
id = "cpp20_unexpected_swap_mandates_e5f6a7b8"
content = '''Calling swap on unexpected mandates that is_swappable_v<E> is true.'''
formal_spec = '''call(unexpected<E>::swap(other)) => mandates(is_swappable_v<E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.swap"
source_module = "[expected.un.swap]/1"
tags = ['mandates', 'unexpected', 'swap']
function = "std::unexpected::swap"
header = "<expected>"
signature = '''constexpr void std::unexpected<E>::swap(unexpected& other) noexcept(is_nothrow_swappable_v<E>)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_error_type_constraint_c9d0e1f2', 'cpp20_expected_unexpected_illformed_type_a1b2c3d4']

[[axioms]]
id = "cpp20_unexpected_equality_mandates_c9d0e1f2"
content = '''The expression x.error() == y.error() must be well-formed and its result convertible to bool for unexpected equality comparison.'''
formal_spec = '''call(operator==(unexpected<E1>, unexpected<E2>)) => mandates(well_formed(x.error() == y.error()) && is_convertible_v<decltype(x.error() == y.error()), bool>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.eq"
source_module = "[expected.un.eq]/1"
tags = ['mandates', 'unexpected', 'equality']
function = "operator=="
header = "<expected>"
signature = '''template<class E2> friend constexpr bool operator==(const unexpected& x, const unexpected<E2>& y)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_expected_void_e_destructible_a3b4c5d6"
content = '''For expected<void, E>, E shall meet the requirements of Cpp17Destructible.'''
formal_spec = '''instantiate(expected<void, E>) => Cpp17Destructible(E)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.general"
source_module = "[expected.void.general]/3"
tags = ['type_constraint', 'expected', 'void', 'destructible']
header = "<expected>"

[[axioms]]
id = "cpp20_expected_void_error_precondition_e7f8a9b0"
content = '''Calling error() on expected<void, E> requires has_value() to be false.'''
formal_spec = '''call(expected<void,E>::error()) => precondition(has_value() == false)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/5"
tags = ['precondition', 'expected', 'void', 'observer', 'hardened']
function = "std::expected<void,E>::error"
header = "<expected>"
signature = '''constexpr const E& std::expected<T, E>::error() const& noexcept'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_void_error_rvalue_precondition_c1d2e3f4"
content = '''Calling error() rvalue overloads on expected<void, E> requires has_value() to be false.'''
formal_spec = '''call(expected<void,E>::error() &&) || call(expected<void,E>::error() const&&) => precondition(has_value() == false)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/7"
tags = ['precondition', 'expected', 'void', 'observer', 'hardened']
function = "std::expected<void,E>::error"
header = "<expected>"
signature = '''constexpr E&& std::expected<T, E>::error() && noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_void_value_throws_bad_access_a5b6c7d8"
content = '''Calling value() on expected<void, E> when has_value() is false throws bad_expected_access with the error.'''
formal_spec = '''!has_value() && call(expected<void,E>::value()) => throws(bad_expected_access<E>(error()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/4"
tags = ['exception', 'expected', 'void', 'observer', 'bad_expected_access']
function = "std::expected<void,E>::value"
header = "<expected>"
signature = '''constexpr void std::expected<T, E>::value() const&'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_copy_ctor_deleted_e9f0a1b2"
content = '''The copy constructor of expected is defined as deleted unless both T and E are copy constructible.'''
formal_spec = '''!is_copy_constructible_v<T> || !is_copy_constructible_v<E> => deleted(expected<T,E>::expected(const expected&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.cons"
source_module = "[expected.object.cons]/9"
tags = ['constraint', 'expected', 'constructor', 'deleted']
function = "std::expected::expected"
header = "<expected>"
signature = '''constexpr std::expected<T, E>::expected(const expected& rhs)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_copy_assign_deleted_c3d4e5f6"
content = '''The copy assignment operator of expected is defined as deleted unless T and E are copy assignable, copy constructible, and at least one of T or E is nothrow move constructible.'''
formal_spec = '''(!is_copy_assignable_v<T> || !is_copy_constructible_v<T> || !is_copy_assignable_v<E> || !is_copy_constructible_v<E> || (!is_nothrow_move_constructible_v<T> && !is_nothrow_move_constructible_v<E>)) => deleted(expected<T,E>::operator=(const expected&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.assign"
source_module = "[expected.object.assign]/4"
tags = ['constraint', 'expected', 'assignment', 'deleted']
function = "std::expected::operator="
header = "<expected>"
signature = '''constexpr std::expected<T, E>& std::expected<T, E>::operator=(const expected& rhs)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_variant_copy_assign_deleted_condition_k1l2m3n4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_void_copy_ctor_deleted_a7b8c9d0"
content = '''The copy constructor of expected<void, E> is defined as deleted unless E is copy constructible.'''
formal_spec = '''!is_copy_constructible_v<E> => deleted(expected<void,E>::expected(const expected&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.cons"
source_module = "[expected.void.cons]/5"
tags = ['constraint', 'expected', 'void', 'constructor', 'deleted']
function = "std::expected<void,E>::expected"
header = "<expected>"
signature = '''constexpr std::expected<T, E>::expected(const expected& rhs)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_variant_copy_ctor_deleted_condition_g7h8i9j0', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']

[[axioms]]
id = "cpp20_expected_void_copy_assign_deleted_e1f2a3b4"
content = '''The copy assignment operator of expected<void, E> is defined as deleted unless E is copy assignable and copy constructible.'''
formal_spec = '''(!is_copy_assignable_v<E> || !is_copy_constructible_v<E>) => deleted(expected<void,E>::operator=(const expected&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.assign"
source_module = "[expected.void.assign]/3"
tags = ['constraint', 'expected', 'void', 'assignment', 'deleted']
function = "std::expected<void,E>::operator="
header = "<expected>"
signature = '''constexpr std::expected<T, E>& std::expected<T, E>::operator=(const expected& rhs)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_variant_copy_assign_deleted_condition_k1l2m3n4', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_value_mandates_copy_e_c5d6e7f8"
content = '''Calling value() on expected mandates that E is copy constructible.'''
formal_spec = '''call(expected<T,E>::value() const&) || call(expected<T,E>::value() &) => mandates(is_copy_constructible_v<E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/8"
tags = ['mandates', 'expected', 'observer', 'value']
function = "std::expected::value"
header = "<expected>"
signature = '''constexpr const T& std::expected<T, E>::value() const&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_value_rvalue_mandates_a9b0c1d2"
content = '''Calling value() rvalue overloads on expected mandates that E is copy constructible and constructible from decltype(std::move(error())).'''
formal_spec = '''call(expected<T,E>::value() &&) || call(expected<T,E>::value() const&&) => mandates(is_copy_constructible_v<E> && is_constructible_v<E, decltype(std::move(error()))>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/11"
tags = ['mandates', 'expected', 'observer', 'value']
function = "std::expected::value"
header = "<expected>"
signature = '''constexpr T&& std::expected<T, E>::value() &&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_value_or_mandates_e3f4a5b6"
content = '''Calling value_or() const& mandates that T is copy constructible and U is convertible to T.'''
formal_spec = '''call(expected<T,E>::value_or(U&&) const&) => mandates(is_copy_constructible_v<T> && is_convertible_v<U, T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/18"
tags = ['mandates', 'expected', 'observer', 'value_or']
function = "std::expected::value_or"
header = "<expected>"
signature = '''template<class U = remove_cv_t<T>> constexpr T std::expected<T, E>::value_or(U&& v) const&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_value_or_rvalue_mandates_c7d8e9f0"
content = '''Calling value_or() && mandates that T is move constructible and U is convertible to T.'''
formal_spec = '''call(expected<T,E>::value_or(U&&) &&) => mandates(is_move_constructible_v<T> && is_convertible_v<U, T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/20"
tags = ['mandates', 'expected', 'observer', 'value_or']
function = "std::expected::value_or"
header = "<expected>"
signature = '''template<class U = remove_cv_t<T>> constexpr T std::expected<T, E>::value_or(U&& v) &&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_error_or_mandates_a1b2c3d4"
content = '''Calling error_or() const& mandates that E is copy constructible and G is convertible to E.'''
formal_spec = '''call(expected<T,E>::error_or(G&&) const&) => mandates(is_copy_constructible_v<E> && is_convertible_v<G, E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/22"
tags = ['mandates', 'expected', 'observer', 'error_or']
function = "std::expected::error_or"
header = "<expected>"
signature = '''template<class G = E> constexpr E std::expected<T, E>::error_or(G&& e) const&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_expected_error_or_rvalue_mandates_e5f6a7b8"
content = '''Calling error_or() && mandates that E is move constructible and G is convertible to E.'''
formal_spec = '''call(expected<T,E>::error_or(G&&) &&) => mandates(is_move_constructible_v<E> && is_convertible_v<G, E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/24"
tags = ['mandates', 'expected', 'observer', 'error_or']
function = "std::expected::error_or"
header = "<expected>"
signature = '''template<class G = E> constexpr E std::expected<T, E>::error_or(G&& e) &&'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_bad_expected_access_exception_purpose_c9d0e1f2"
content = '''The class template bad_expected_access defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of an expected<T, E> object for which has_value() is false.'''
formal_spec = '''!has_value() && access_value(expected<T,E>) => may_throw(bad_expected_access<E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.bad"
source_module = "[expected.bad]/1"
tags = ['exception', 'bad_expected_access', 'expected']
header = "<expected>"
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_basic_life_end_without_destructor_9c0d1e2f', 'cpp20_class_dtor_trivial_conditions_a9d6e5b8']

[[axioms]]
id = "cpp20_expected_void_and_then_mandates_a3b4c5d6"
content = '''For and_then on expected<void, E>, the result type U must be a specialization of expected and U::error_type must be same as E.'''
formal_spec = '''call(expected<void,E>::and_then(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F>>, expected) && is_same_v<typename U::error_type, E>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/3"
tags = ['mandates', 'expected', 'void', 'monadic', 'and_then']
function = "std::expected<void,E>::and_then"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::and_then(F&& f) &'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_void_or_else_mandates_e7f8a9b0"
content = '''For or_else on expected<void, E>, the result type G must be a specialization of expected and G::value_type must be void.'''
formal_spec = '''call(expected<void,E>::or_else(F)) => mandates(is_specialization_of(remove_cvref_t<invoke_result_t<F, error()>>, expected) && is_void_v<typename G::value_type>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/11"
tags = ['mandates', 'expected', 'void', 'monadic', 'or_else']
function = "std::expected<void,E>::or_else"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::or_else(F&& f) &'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_void_transform_mandates_c1d2e3f4"
content = '''For transform on expected<void, E>, the result type U must be a valid value type for expected.'''
formal_spec = '''call(expected<void,E>::transform(F)) => mandates(valid_value_type(remove_cv_t<invoke_result_t<F>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/19"
tags = ['mandates', 'expected', 'void', 'monadic', 'transform']
function = "std::expected<void,E>::transform"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::transform(F&& f) &'''
depends_on = ['cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2']

[[axioms]]
id = "cpp20_expected_void_transform_error_mandates_a5b6c7d8"
content = '''For transform_error on expected<void, E>, the result type G must be a valid template argument for unexpected.'''
formal_spec = '''call(expected<void,E>::transform_error(F)) => mandates(valid_unexpected_arg(remove_cv_t<invoke_result_t<F, error()>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/27"
tags = ['mandates', 'expected', 'void', 'monadic', 'transform_error']
function = "std::expected<void,E>::transform_error"
header = "<expected>"
signature = '''template<class F> constexpr auto std::expected<T, E>::transform_error(F&& f) &'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_expected_copy_assign_deleted_c3d4e5f6', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_expected_copy_ctor_deleted_e9f0a1b2', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2']

[[axioms]]
id = "cpp20_iterator_operations_advance_negative_precondition_a3f7c2e9"
content = '''Calling std::advance with a negative distance n requires the iterator to be a bidirectional iterator.'''
formal_spec = '''n < 0 && !models<Cpp17BidirectionalIterator>(InputIterator) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/2"
tags = ['iterator', 'precondition', 'bidirectional']
function = "std::advance"
header = "<iterator>"
signature = '''template<class InputIterator, class Distance> constexpr void advance(InputIterator& i, Distance n)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_iterator_operations_distance_reachable_precondition_b4e8d1f6"
content = '''Calling std::distance requires that last is reachable from first, or for random access iterators, first is reachable from last.'''
formal_spec = '''(!reachable(first, last) && !(models<Cpp17RandomAccessIterator>(InputIterator) && reachable(last, first))) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/4"
tags = ['iterator', 'precondition', 'reachability']
function = "std::distance"
header = "<iterator>"
signature = '''template<class InputIterator> constexpr typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last)'''
depends_on = ['cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0']

[[axioms]]
id = "cpp20_iterator_operations_next_effect_c5f9a2b7"
content = '''std::next advances a copy of the iterator by n positions and returns the result.'''
formal_spec = '''next(x, n) == (advance(copy(x), n), copy(x))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/6"
tags = ['iterator', 'effect']
function = "std::next"
header = "<iterator>"
signature = '''template<class InputIterator> constexpr InputIterator next(InputIterator x, typename iterator_traits<InputIterator>::difference_type n = 1)'''
depends_on = ['cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_iterator_operations_prev_effect_d6a0b3c8"
content = '''std::prev retreats a copy of the iterator by n positions and returns the result.'''
formal_spec = '''prev(x, n) == (advance(copy(x), -n), copy(x))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/7"
tags = ['iterator', 'effect', 'bidirectional']
function = "std::prev"
header = "<iterator>"
signature = '''template<class BidirectionalIterator> constexpr BidirectionalIterator prev(BidirectionalIterator x, typename iterator_traits<BidirectionalIterator>::difference_type n = 1)'''
depends_on = ['cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6', 'cpp20_iterator_operations_next_effect_c5f9a2b7']

[[axioms]]
id = "cpp20_iterator_operations_prev_requires_bidirectional_e7b1c4d9"
content = '''std::prev requires a bidirectional iterator because it calls advance with a negative value (-n).'''
formal_spec = '''call(prev, x, n) => models<Cpp17BidirectionalIterator>(BidirectionalIterator) && n >= 0'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/7"
tags = ['iterator', 'precondition', 'bidirectional']
function = "std::prev"
header = "<iterator>"
signature = '''template<class BidirectionalIterator> constexpr BidirectionalIterator prev(BidirectionalIterator x, typename iterator_traits<BidirectionalIterator>::difference_type n = 1)'''
depends_on = ['cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_no_data_race_modify_a3b7c9d1"
content = '''Algorithms shall not modify objects referenced through an iterator argument unless the specification requires such modification, for purposes of determining the existence of data races.'''
formal_spec = '''algorithm(iter_args...) && !specification_requires_modification(iter_arg) => !modifies(object_referenced_by(iter_arg))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/3"
tags = ['concurrency', 'data-race', 'iterator', 'modification']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_mutable_iterator_required_e5f2a8b4"
content = '''If an algorithm's Effects element specifies that a value pointed to by any iterator passed as argument is modified, then the type of that argument shall meet the requirements of a mutable iterator.'''
formal_spec = '''algorithm_effects_modifies_value(iter) => meets_mutable_iterator_requirements(decltype(iter))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.1"
tags = ['iterator', 'mutable', 'constraint', 'modification']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0"
content = '''If an algorithm's template parameter is named InputIterator, InputIterator1, or InputIterator2, the template argument shall meet the Cpp17InputIterator requirements.'''
formal_spec = '''template_param_name(param) in {"InputIterator", "InputIterator1", "InputIterator2"} => meets_cpp17_input_iterator_requirements(template_arg(param))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.2"
tags = ['iterator', 'input-iterator', 'constraint', 'template']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4']

[[axioms]]
id = "cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4"
content = '''If an algorithm's template parameter is named OutputIterator, OutputIterator1, or OutputIterator2, the template argument shall meet the Cpp17OutputIterator requirements.'''
formal_spec = '''template_param_name(param) in {"OutputIterator", "OutputIterator1", "OutputIterator2"} => meets_cpp17_output_iterator_requirements(template_arg(param))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.3"
tags = ['iterator', 'output-iterator', 'constraint', 'template']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0']

[[axioms]]
id = "cpp20_algorithms_requirements_forwarditerator_requirement_f5a6b7c8"
content = '''If an algorithm's template parameter is named ForwardIterator, ForwardIterator1, ForwardIterator2, or NoThrowForwardIterator, the template argument shall meet the Cpp17ForwardIterator requirements if it is required to be a mutable iterator, or model forward_iterator otherwise.'''
formal_spec = '''template_param_name(param) in {"ForwardIterator", "ForwardIterator1", "ForwardIterator2", "NoThrowForwardIterator"} => (requires_mutable_iterator(param) ? meets_cpp17_forward_iterator_requirements(template_arg(param)) : models_forward_iterator(template_arg(param)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.4"
tags = ['iterator', 'forward-iterator', 'constraint', 'template']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_nothrow_forwarditerator_noexcept_d9e0f1a2"
content = '''If an algorithm's template parameter is named NoThrowForwardIterator, the template argument is required to have the property that no exceptions are thrown from increment, assignment, or comparison of, or indirection through, valid iterators.'''
formal_spec = '''template_param_name(param) == "NoThrowForwardIterator" => noexcept(++valid_iter) && noexcept(valid_iter = other) && noexcept(valid_iter == other) && noexcept(*valid_iter)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.5"
tags = ['iterator', 'forward-iterator', 'noexcept', 'constraint', 'exception']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0']

[[axioms]]
id = "cpp20_algorithms_requirements_bidirectionaliterator_requirement_a3b4c5d6"
content = '''If an algorithm's template parameter is named BidirectionalIterator, BidirectionalIterator1, or BidirectionalIterator2, the template argument shall meet the Cpp17BidirectionalIterator requirements if it is required to be a mutable iterator, or model bidirectional_iterator otherwise.'''
formal_spec = '''template_param_name(param) in {"BidirectionalIterator", "BidirectionalIterator1", "BidirectionalIterator2"} => (requires_mutable_iterator(param) ? meets_cpp17_bidirectional_iterator_requirements(template_arg(param)) : models_bidirectional_iterator(template_arg(param)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.6"
tags = ['iterator', 'bidirectional-iterator', 'constraint', 'template']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_randomaccessiterator_requirement_e7f8a9b0"
content = '''If an algorithm's template parameter is named RandomAccessIterator, RandomAccessIterator1, or RandomAccessIterator2, the template argument shall meet the Cpp17RandomAccessIterator requirements if it is required to be a mutable iterator, or model random_access_iterator otherwise.'''
formal_spec = '''template_param_name(param) in {"RandomAccessIterator", "RandomAccessIterator1", "RandomAccessIterator2"} => (requires_mutable_iterator(param) ? meets_cpp17_random_access_iterator_requirements(template_arg(param)) : models_random_access_iterator(template_arg(param)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.7"
tags = ['iterator', 'random-access-iterator', 'constraint', 'template']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_wellformed_c1d2e3f4"
content = '''When Predicate pred is an algorithm argument and first is its iterator argument with value type T, the expression pred(*first) shall be well-formed and the type decltype(pred(*first)) shall model boolean-testable.'''
formal_spec = '''algorithm_takes_predicate(pred) && iterator_arg(first) && value_type(first) == T => well_formed(pred(*first)) && models_boolean_testable(decltype(pred(*first)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = ['predicate', 'callable', 'constraint', 'boolean-testable']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_no_nonconst_apply_g5h6i7j8"
content = '''The Predicate function object shall not apply any non-constant function through its argument.'''
formal_spec = '''is_predicate(pred) && applies_through_arg(pred, func) => is_const_function(func)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = ['predicate', 'callable', 'const-correctness', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_glvalue_equivalence_k9l0m1n2"
content = '''Given a glvalue u of type (possibly const) T that designates the same object as *first, pred(u) shall be a valid expression that is equal to pred(*first).'''
formal_spec = '''is_predicate(pred) && glvalue(u, T) && designates_same_object(u, *first) => valid_expression(pred(u)) && pred(u) == pred(*first)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = ['predicate', 'callable', 'equivalence', 'constraint']
depends_on = ['cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2', 'cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_wellformed_o3p4q5r6"
content = '''If an algorithm takes BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments with respective value types T1 and T2, the expression binary_pred(*first1, *first2) shall be well-formed and the type decltype(binary_pred(*first1, *first2)) shall model boolean-testable.'''
formal_spec = '''algorithm_takes_binary_predicate(binary_pred) && iterator_args(first1, first2) && value_type(first1) == T1 && value_type(first2) == T2 => well_formed(binary_pred(*first1, *first2)) && models_boolean_testable(decltype(binary_pred(*first1, *first2)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'callable', 'constraint', 'boolean-testable']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_value_wellformed_s7t8u9v0"
content = '''When T value is part of the signature, the expression binary_pred(*first1, value) shall be well-formed and the type decltype(binary_pred(*first1, value)) shall model boolean-testable.'''
formal_spec = '''algorithm_takes_binary_predicate(binary_pred) && signature_has_value(T) => well_formed(binary_pred(*first1, value)) && models_boolean_testable(decltype(binary_pred(*first1, value)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'callable', 'constraint', 'boolean-testable']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_no_nonconst_apply_w1x2y3z4"
content = '''The BinaryPredicate function object shall not apply any non-constant function through any of its arguments.'''
formal_spec = '''is_binary_predicate(binary_pred) && applies_through_arg(binary_pred, func, any_arg) => is_const_function(func)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'callable', 'const-correctness', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_glvalue_equivalence_a5b6c7d8"
content = '''Given glvalues u of type (possibly const) T1 designating the same object as *first1, and v of type (possibly const) T2 designating the same object as *first2, binary_pred(u, *first2), binary_pred(*first1, v), and binary_pred(u, v) shall each be a valid expression equal to binary_pred(*first1, *first2).'''
formal_spec = '''is_binary_predicate(binary_pred) && glvalue(u, T1) && designates_same_object(u, *first1) && glvalue(v, T2) && designates_same_object(v, *first2) => valid_expression(binary_pred(u, *first2)) && binary_pred(u, *first2) == binary_pred(*first1, *first2) && valid_expression(binary_pred(*first1, v)) && binary_pred(*first1, v) == binary_pred(*first1, *first2) && valid_expression(binary_pred(u, v)) && binary_pred(u, v) == binary_pred(*first1, *first2)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'callable', 'equivalence', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_value_glvalue_equiv_e9f0a1b2"
content = '''Given a glvalue u of type (possibly const) T1 designating the same object as *first1, binary_pred(u, value) shall be a valid expression that is equal to binary_pred(*first1, value).'''
formal_spec = '''is_binary_predicate(binary_pred) && glvalue(u, T1) && designates_same_object(u, *first1) && signature_has_value(T) => valid_expression(binary_pred(u, value)) && binary_pred(u, value) == binary_pred(*first1, value)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'callable', 'equivalence', 'constraint']
depends_on = ['cpp20_basic_lval_glvalue_to_prvalue_conversion_a7c3d8f2', 'cpp20_basic_life_glvalue_properties_well_defined_2d3e4f5a']

[[axioms]]
id = "cpp20_algorithms_requirements_condition_boolean_result_c3d4e5f6"
content = '''When the description of an algorithm gives an expression such as *first == value for a condition, the expression shall evaluate to either true or false in boolean contexts.'''
formal_spec = '''algorithm_condition_expression(expr) => evaluates_to_bool(expr) && (expr == true || expr == false)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/10"
tags = ['condition', 'boolean', 'constraint', 'expression']

[[axioms]]
id = "cpp20_algorithms_requirements_explicit_template_args_unspecified_g7h8i9j0"
content = '''The well-formedness and behavior of a call to an algorithm with an explicitly-specified template argument list is unspecified, except where explicitly stated otherwise.'''
formal_spec = '''algorithm_call_with_explicit_template_args(algo, args...) && !explicitly_specified_behavior(algo) => unspecified_wellformedness(call) && unspecified_behavior(call)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/15"
tags = ['template', 'unspecified', 'constraint', 'well-formedness']
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_algorithms_requirements_outputiterator_requirement_b1c2d3e4', 'cpp20_algorithms_requirements_inputiterator_requirement_c7d8e9f0']

[[axioms]]
id = "cpp20_algorithms_requirements_ranges_dispatch_begin_k1l2m3n4"
content = '''Overloads of algorithms that take range arguments behave as if a corresponding iterator argument is initialized with ranges::begin(r).'''
formal_spec = '''algorithm_takes_range(algo, r) => iterator_arg_initialized_as(ranges::begin(r))'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/14.1"
tags = ['range', 'dispatch', 'iterator', 'begin']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_ranges_dispatch_end_o5p6q7r8"
content = '''Overloads of algorithms that take range arguments behave as if a corresponding sentinel argument is initialized with ranges::end(r), or ranges::next(ranges::begin(r), ranges::end(r)) if the type of r models forward_range and computing ranges::next meets the specified complexity requirements.'''
formal_spec = '''algorithm_takes_range(algo, r) => sentinel_arg_initialized_as(models_forward_range(r) && complexity_requirements_met(ranges::next) ? ranges::next(ranges::begin(r), ranges::end(r)) : ranges::end(r))'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/14.2"
tags = ['range', 'dispatch', 'sentinel', 'end']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_algorithms_requirements_integer_like_difference_type_cast_s9t0u1v2"
content = '''Given an iterator a whose difference type is D, and an expression n of integer-like type other than cv D, the semantics of a+n and a-n are, respectively, those of a+D(n) and a-D(n).'''
formal_spec = '''difference_type(a) == D && integer_like(n) && !same_type(remove_cv(decltype(n)), D) => semantics(a + n) == semantics(a + D(n)) && semantics(a - n) == semantics(a - D(n))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/12"
tags = ['iterator', 'arithmetic', 'difference-type', 'conversion']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_algorithms_requirements_sentinel_to_iterator_conversion_w3x4y5z6"
content = '''In algorithm return values, when a sentinel value s denoting the end of a range [i, s) is returned where an iterator is expected, the semantics are as if the sentinel is converted into an iterator using ranges::next(i, s).'''
formal_spec = '''algorithm_returns_iterator(algo) && sentinel_denotes_end(s, range(i, s)) => return_semantics(s) == return_semantics(ranges::next(i, s))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/13"
tags = ['sentinel', 'iterator', 'conversion', 'return-value']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_range_access_begin_rvalue_non_borrowed_illformed_a3b7c1d9"
content = '''Calling ranges::begin on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::begin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.1"
tags = ['ranges', 'begin', 'borrowed_range', 'ill-formed']
function = "ranges::begin"
header = "<ranges>"
signature = '''auto ranges::begin(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_begin_incomplete_array_ndr_e5f2a8c4"
content = '''Calling ranges::begin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::begin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.2"
tags = ['ranges', 'begin', 'array', 'incomplete_type', 'ill-formed', 'ndr']
function = "ranges::begin"
header = "<ranges>"
signature = '''auto ranges::begin(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_end_rvalue_non_borrowed_illformed_b4c8d2e6"
content = '''Calling ranges::end on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::end(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.1"
tags = ['ranges', 'end', 'borrowed_range', 'ill-formed']
function = "ranges::end"
header = "<ranges>"
signature = '''auto ranges::end(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_end_incomplete_array_ndr_c6d9e3f7"
content = '''Calling ranges::end on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::end(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.2"
tags = ['ranges', 'end', 'array', 'incomplete_type', 'ill-formed', 'ndr']
function = "ranges::end"
header = "<ranges>"
signature = '''auto ranges::end(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_end_unknown_bound_array_illformed_d7e0f4a8"
content = '''Calling ranges::end on an array of unknown bound is ill-formed.'''
formal_spec = '''is_array_type(T) && is_unknown_bound_array(T) => ill_formed(ranges::end(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.3"
tags = ['ranges', 'end', 'array', 'unknown_bound', 'ill-formed']
function = "ranges::end"
header = "<ranges>"
signature = '''auto ranges::end(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_cbegin_rvalue_non_borrowed_illformed_e8f1a5b9"
content = '''Calling ranges::cbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::cbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cbegin"
source_module = "[range.access.cbegin]/1.1"
tags = ['ranges', 'cbegin', 'borrowed_range', 'ill-formed']
function = "ranges::cbegin"
header = "<ranges>"
signature = '''auto ranges::cbegin(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_cend_rvalue_non_borrowed_illformed_f9a2b6c0"
content = '''Calling ranges::cend on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::cend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cend"
source_module = "[range.access.cend]/1.1"
tags = ['ranges', 'cend', 'borrowed_range', 'ill-formed']
function = "ranges::cend"
header = "<ranges>"
signature = '''auto ranges::cend(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_rbegin_rvalue_non_borrowed_illformed_a0b3c7d1"
content = '''Calling ranges::rbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::rbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.1"
tags = ['ranges', 'rbegin', 'borrowed_range', 'ill-formed']
function = "ranges::rbegin"
header = "<ranges>"
signature = '''auto ranges::rbegin(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_rbegin_incomplete_array_ndr_b1c4d8e2"
content = '''Calling ranges::rbegin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::rbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.2"
tags = ['ranges', 'rbegin', 'array', 'incomplete_type', 'ill-formed', 'ndr']
function = "ranges::rbegin"
header = "<ranges>"
signature = '''auto ranges::rbegin(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_rend_rvalue_non_borrowed_illformed_c2d5e9f3"
content = '''Calling ranges::rend on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::rend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.1"
tags = ['ranges', 'rend', 'borrowed_range', 'ill-formed']
function = "ranges::rend"
header = "<ranges>"
signature = '''auto ranges::rend(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_rend_incomplete_array_ndr_d3e6f0a4"
content = '''Calling ranges::rend on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::rend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.2"
tags = ['ranges', 'rend', 'array', 'incomplete_type', 'ill-formed', 'ndr']
function = "ranges::rend"
header = "<ranges>"
signature = '''auto ranges::rend(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_crbegin_rvalue_non_borrowed_illformed_e4f7a1b5"
content = '''Calling ranges::crbegin on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::crbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crbegin"
source_module = "[range.access.crbegin]/1.1"
tags = ['ranges', 'crbegin', 'borrowed_range', 'ill-formed']
function = "ranges::crbegin"
header = "<ranges>"
signature = '''auto ranges::crbegin(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_crend_rvalue_non_borrowed_illformed_f5a8b2c6"
content = '''Calling ranges::crend on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::crend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crend"
source_module = "[range.access.crend]/1.1"
tags = ['ranges', 'crend', 'borrowed_range', 'ill-formed']
function = "ranges::crend"
header = "<ranges>"
signature = '''auto ranges::crend(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_size_unknown_bound_array_illformed_a6b9c3d7"
content = '''Calling ranges::size on an array of unknown bound is ill-formed.'''
formal_spec = '''is_unknown_bound_array(T) => ill_formed(ranges::size(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.1"
tags = ['ranges', 'size', 'array', 'unknown_bound', 'ill-formed']
function = "ranges::size"
header = "<ranges>"
signature = '''auto ranges::size(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_ssize_requires_valid_size_b7c0d4e8"
content = '''Calling ranges::ssize requires ranges::size to be a valid expression; if ranges::size(t) is ill-formed, ranges::ssize(E) is also ill-formed.'''
formal_spec = '''ill_formed(ranges::size(t)) => ill_formed(ranges::ssize(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.ssize"
source_module = "[range.prim.ssize]/2"
tags = ['ranges', 'ssize', 'size', 'ill-formed']
function = "ranges::ssize"
header = "<ranges>"
signature = '''auto ranges::ssize(E)'''

[[axioms]]
id = "cpp20_range_access_empty_unknown_bound_array_illformed_c8d1e5f9"
content = '''Calling ranges::empty on an array of unknown bound is ill-formed.'''
formal_spec = '''is_unknown_bound_array(T) => ill_formed(ranges::empty(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/2.1"
tags = ['ranges', 'empty', 'array', 'unknown_bound', 'ill-formed']
function = "ranges::empty"
header = "<ranges>"
signature = '''bool ranges::empty(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_data_rvalue_non_borrowed_illformed_d9e2f6a0"
content = '''Calling ranges::data on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::data(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.1"
tags = ['ranges', 'data', 'borrowed_range', 'ill-formed']
function = "ranges::data"
header = "<ranges>"
signature = '''auto ranges::data(E)'''
depends_on = ['cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_access_data_incomplete_array_ndr_e0f3a7b1"
content = '''Calling ranges::data on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array_type(T) && is_incomplete_type(remove_all_extents_t<T>) => ill_formed_ndr(ranges::data(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.2"
tags = ['ranges', 'data', 'array', 'incomplete_type', 'ill-formed', 'ndr']
function = "ranges::data"
header = "<ranges>"
signature = '''auto ranges::data(E)'''
depends_on = ['for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']

[[axioms]]
id = "cpp20_range_access_cdata_rvalue_non_borrowed_illformed_f1a4b8c2"
content = '''Calling ranges::cdata on an rvalue of a type where enable_borrowed_range is false is ill-formed.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<T>> => ill_formed(ranges::cdata(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.cdata"
source_module = "[range.prim.cdata]/1.1"
tags = ['ranges', 'cdata', 'borrowed_range', 'ill-formed']
function = "ranges::cdata"
header = "<ranges>"
signature = '''const auto* ranges::cdata(E)'''
depends_on = ['cpp20_const_pointer_cast_mandates_7a8b9c0d', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489']

[[axioms]]
id = "cpp20_range_access_begin_models_input_or_output_iterator_a2b5c9d3"
content = '''Whenever ranges::begin(E) is a valid expression, its type models input_or_output_iterator.'''
formal_spec = '''valid_expr(ranges::begin(E)) => models<input_or_output_iterator>(decltype(ranges::begin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/4"
tags = ['ranges', 'begin', 'iterator', 'concept', 'postcondition']
function = "ranges::begin"
header = "<ranges>"
signature = '''auto ranges::begin(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_end_models_sentinel_for_b3c6d0e4"
content = '''Whenever ranges::end(E) is a valid expression, the types S and I of ranges::end(E) and ranges::begin(E) model sentinel_for<S, I>.'''
formal_spec = '''valid_expr(ranges::end(E)) && valid_expr(ranges::begin(E)) => models<sentinel_for>(decltype(ranges::end(E)), decltype(ranges::begin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/4"
tags = ['ranges', 'end', 'sentinel', 'concept', 'postcondition']
function = "ranges::end"
header = "<ranges>"
signature = '''auto ranges::end(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_cbegin_models_constant_iterator_c4d7e1f5"
content = '''Whenever ranges::cbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator.'''
formal_spec = '''valid_expr(ranges::cbegin(E)) => models<input_or_output_iterator>(decltype(ranges::cbegin(E))) && models<constant_iterator>(decltype(ranges::cbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cbegin"
source_module = "[range.access.cbegin]/2"
tags = ['ranges', 'cbegin', 'iterator', 'constant_iterator', 'concept', 'postcondition']
function = "ranges::cbegin"
header = "<ranges>"
signature = '''auto ranges::cbegin(E)'''
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_range_access_rbegin_models_input_or_output_iterator_d5e8f2a6"
content = '''Whenever ranges::rbegin(E) is a valid expression, its type models input_or_output_iterator.'''
formal_spec = '''valid_expr(ranges::rbegin(E)) => models<input_or_output_iterator>(decltype(ranges::rbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/4"
tags = ['ranges', 'rbegin', 'iterator', 'concept', 'postcondition']
function = "ranges::rbegin"
header = "<ranges>"
signature = '''auto ranges::rbegin(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_rend_models_sentinel_for_e6f9a3b7"
content = '''Whenever ranges::rend(E) is a valid expression, the types S and I of ranges::rend(E) and ranges::rbegin(E) model sentinel_for<S, I>.'''
formal_spec = '''valid_expr(ranges::rend(E)) && valid_expr(ranges::rbegin(E)) => models<sentinel_for>(decltype(ranges::rend(E)), decltype(ranges::rbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/4"
tags = ['ranges', 'rend', 'sentinel', 'concept', 'postcondition']
function = "ranges::rend"
header = "<ranges>"
signature = '''auto ranges::rend(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_crbegin_models_constant_iterator_f7a0b4c8"
content = '''Whenever ranges::crbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator.'''
formal_spec = '''valid_expr(ranges::crbegin(E)) => models<input_or_output_iterator>(decltype(ranges::crbegin(E))) && models<constant_iterator>(decltype(ranges::crbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crbegin"
source_module = "[range.access.crbegin]/2"
tags = ['ranges', 'crbegin', 'iterator', 'constant_iterator', 'concept', 'postcondition']
function = "ranges::crbegin"
header = "<ranges>"
signature = '''auto ranges::crbegin(E)'''
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_range_access_size_returns_integer_like_a8b1c5d9"
content = '''Whenever ranges::size(E) is a valid expression, its type is integer-like.'''
formal_spec = '''valid_expr(ranges::size(E)) => is_integer_like(decltype(ranges::size(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/4"
tags = ['ranges', 'size', 'integer_like', 'postcondition']
function = "ranges::size"
header = "<ranges>"
signature = '''auto ranges::size(E)'''

[[axioms]]
id = "cpp20_range_access_reserve_hint_returns_integer_like_b9c2d6e0"
content = '''Whenever ranges::reserve_hint(E) is a valid expression, its type is integer-like.'''
formal_spec = '''valid_expr(ranges::reserve_hint(E)) => is_integer_like(decltype(ranges::reserve_hint(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size.hint"
source_module = "[range.prim.size.hint]/2"
tags = ['ranges', 'reserve_hint', 'integer_like', 'postcondition']
function = "ranges::reserve_hint"
header = "<ranges>"
signature = '''auto ranges::reserve_hint(E)'''

[[axioms]]
id = "cpp20_range_access_empty_returns_bool_c0d3e7f1"
content = '''Whenever ranges::empty(E) is a valid expression, it has type bool.'''
formal_spec = '''valid_expr(ranges::empty(E)) => is_same<decltype(ranges::empty(E)), bool>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/4"
tags = ['ranges', 'empty', 'bool', 'postcondition']
function = "ranges::empty"
header = "<ranges>"
signature = '''bool ranges::empty(E)'''

[[axioms]]
id = "cpp20_range_access_data_returns_pointer_to_object_d1e4f8a2"
content = '''Whenever ranges::data(E) is a valid expression, it has pointer to object type.'''
formal_spec = '''valid_expr(ranges::data(E)) => is_pointer_to_object(decltype(ranges::data(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/4"
tags = ['ranges', 'data', 'pointer', 'postcondition']
function = "ranges::data"
header = "<ranges>"
signature = '''auto ranges::data(E)'''
depends_on = ['c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_range_access_cdata_returns_pointer_to_const_object_e2f5a9b3"
content = '''Whenever ranges::cdata(E) is a valid expression, it has pointer to constant object type.'''
formal_spec = '''valid_expr(ranges::cdata(E)) => is_pointer_to_const_object(decltype(ranges::cdata(E)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.cdata"
source_module = "[range.prim.cdata]/2"
tags = ['ranges', 'cdata', 'pointer', 'const', 'postcondition']
function = "ranges::cdata"
header = "<ranges>"
signature = '''const auto* ranges::cdata(E)'''
depends_on = ['cpp20_const_pointer_cast_mandates_7a8b9c0d', 'c11_cpp_translation_name_syntax_operation_95efc489', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_range_access_begin_member_models_iterator_f3a6b0c4"
content = '''For ranges::begin to use t.begin(), the expression auto(t.begin()) must be valid and its type must model input_or_output_iterator.'''
formal_spec = '''!is_array_type(T) && valid_expr(auto(t.begin())) && models<input_or_output_iterator>(decltype(auto(t.begin()))) => ranges::begin(E) == auto(t.begin())'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.4"
tags = ['ranges', 'begin', 'member', 'iterator', 'constraint']
function = "ranges::begin"
header = "<ranges>"
signature = '''auto ranges::begin(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_end_member_models_sentinel_a4b7c1d5"
content = '''For ranges::end to use t.end(), the expression auto(t.end()) must be valid and its type must model sentinel_for<iterator_t<T>>.'''
formal_spec = '''!is_array_type(T) && valid_expr(auto(t.end())) && models<sentinel_for>(decltype(auto(t.end())), iterator_t<T>) => ranges::end(E) == auto(t.end())'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.end"
source_module = "[range.access.end]/2.5"
tags = ['ranges', 'end', 'member', 'sentinel', 'constraint']
function = "ranges::end"
header = "<ranges>"
signature = '''auto ranges::end(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_size_disable_sized_range_constraint_b5c8d2e6"
content = '''For ranges::size to use t.size(), disable_sized_range<remove_cv_t<T>> must be false.'''
formal_spec = '''disable_sized_range<remove_cv_t<T>> => !use_member_size(ranges::size(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.3"
tags = ['ranges', 'size', 'disable_sized_range', 'constraint']
function = "ranges::size"
header = "<ranges>"
signature = '''auto ranges::size(E)'''

[[axioms]]
id = "cpp20_range_access_rbegin_fallback_bidirectional_c6d9e3f7"
content = '''For ranges::rbegin to fall back to make_reverse_iterator(ranges::end(t)), both ranges::begin(t) and ranges::end(t) must be valid expressions of the same type which models bidirectional_iterator.'''
formal_spec = '''valid_expr(ranges::begin(t)) && valid_expr(ranges::end(t)) && same_type(decltype(ranges::begin(t)), decltype(ranges::end(t))) && models<bidirectional_iterator>(decltype(ranges::begin(t))) => ranges::rbegin(E) == make_reverse_iterator(ranges::end(t))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.5"
tags = ['ranges', 'rbegin', 'reverse_iterator', 'bidirectional', 'fallback']
function = "ranges::rbegin"
header = "<ranges>"
signature = '''auto ranges::rbegin(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_rend_fallback_bidirectional_d7e0f4a8"
content = '''For ranges::rend to fall back to make_reverse_iterator(ranges::begin(t)), both ranges::begin(t) and ranges::end(t) must be valid expressions of the same type which models bidirectional_iterator.'''
formal_spec = '''valid_expr(ranges::begin(t)) && valid_expr(ranges::end(t)) && same_type(decltype(ranges::begin(t)), decltype(ranges::end(t))) && models<bidirectional_iterator>(decltype(ranges::begin(t))) => ranges::rend(E) == make_reverse_iterator(ranges::begin(t))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.5"
tags = ['ranges', 'rend', 'reverse_iterator', 'bidirectional', 'fallback']
function = "ranges::rend"
header = "<ranges>"
signature = '''auto ranges::rend(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_size_fallback_sized_sentinel_e8f1a5b9"
content = '''For ranges::size to use ranges::end(t) - ranges::begin(t), the iterator types must model both sized_sentinel_for and forward_iterator.'''
formal_spec = '''valid_expr(to_unsigned_like(ranges::end(t) - ranges::begin(t))) && models<sized_sentinel_for>(decltype(ranges::end(t)), decltype(ranges::begin(t))) && models<forward_iterator>(decltype(ranges::begin(t))) => ranges::size(E) == to_unsigned_like(ranges::end(t) - ranges::begin(t))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.5"
tags = ['ranges', 'size', 'sized_sentinel', 'forward_iterator', 'fallback']
function = "ranges::size"
header = "<ranges>"
signature = '''auto ranges::size(E)'''
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_range_access_empty_fallback_forward_iterator_f9a2b6c0"
content = '''For ranges::empty to use ranges::begin(t) == ranges::end(t), the type of ranges::begin(t) must model forward_iterator.'''
formal_spec = '''valid_expr(bool(ranges::begin(t) == ranges::end(t))) && models<forward_iterator>(decltype(ranges::begin(t))) => ranges::empty(E) == bool(ranges::begin(t) == ranges::end(t))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/2.4"
tags = ['ranges', 'empty', 'forward_iterator', 'fallback']
function = "ranges::empty"
header = "<ranges>"
signature = '''bool ranges::empty(E)'''
depends_on = ['for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_range_access_data_contiguous_iterator_a0b3c7d1"
content = '''For ranges::data to use to_address(ranges::begin(t)), the type of ranges::begin(t) must model contiguous_iterator.'''
formal_spec = '''valid_expr(ranges::begin(t)) && models<contiguous_iterator>(decltype(ranges::begin(t))) => ranges::data(E) == to_address(ranges::begin(t))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.4"
tags = ['ranges', 'data', 'contiguous_iterator', 'to_address']
function = "ranges::data"
header = "<ranges>"
signature = '''auto ranges::data(E)'''
depends_on = ['cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0', 'for_loop_range_impl_precond_iterator_random_access_d7e8f9a0']

[[axioms]]
id = "cpp20_thread_condition_condvar_dtor_precond_no_blocked_a1b2c3d4"
content = '''Destroying a condition_variable requires that no thread is blocked on it.'''
formal_spec = '''destroy(cv) && exists_thread(t, blocked_on(t, cv)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/4"
tags = ['concurrency', 'condition_variable', 'destructor', 'precondition']
function = "std::condition_variable::~condition_variable"
header = "<condition_variable>"
signature = '''~condition_variable()'''
depends_on = ['cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_after_dtor_ub_e5f6a7b8"
content = '''Undefined behavior ensues if a thread waits on a condition_variable once the destructor has been started.'''
formal_spec = '''dtor_started(cv) && wait_on(thread, cv) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/4"
tags = ['concurrency', 'condition_variable', 'destructor', 'lifetime', 'undefined_behavior']
function = "std::condition_variable::~condition_variable"
header = "<condition_variable>"
signature = '''~condition_variable()'''
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_precond_owns_lock_c9d0e1f2"
content = '''Calling wait() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''call(wait, cv, lock) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/7"
tags = ['concurrency', 'condition_variable', 'wait', 'precondition', 'mutex']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''void condition_variable::wait(unique_lock<mutex>& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_precond_same_mutex_a3b4c5d6"
content = '''When multiple threads wait on a condition_variable, either no other thread is waiting or all waiting threads must use lock arguments where lock.mutex() returns the same value.'''
formal_spec = '''concurrent_wait(cv, locks) => (count(locks) <= 1 || forall(l1, l2 in locks, l1.mutex() == l2.mutex()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/7"
tags = ['concurrency', 'condition_variable', 'wait', 'precondition', 'mutex']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''void condition_variable::wait(unique_lock<mutex>& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_postcond_relock_e7f8a9b0"
content = '''After wait() returns, lock.owns_lock() is true and lock.mutex() is locked by the calling thread.'''
formal_spec = '''returns(wait, cv, lock) => postcond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/9"
tags = ['concurrency', 'condition_variable', 'wait', 'postcondition', 'mutex']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''void condition_variable::wait(unique_lock<mutex>& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_relock_fail_terminate_c1d2e3f4"
content = '''If wait() fails to meet the postcondition (e.g., re-locking mutex throws), terminate() is invoked.'''
formal_spec = '''call(wait, cv, lock) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/11"
tags = ['concurrency', 'condition_variable', 'wait', 'terminate', 'exception']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''void condition_variable::wait(unique_lock<mutex>& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_pred_precond_owns_lock_a5b6c7d8"
content = '''Calling wait() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''call(wait, cv, lock, pred) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/12"
tags = ['concurrency', 'condition_variable', 'wait', 'predicate', 'precondition']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''template<class Predicate> void condition_variable::wait(unique_lock<mutex>& lock, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_pred_terminate_e9f0a1b2"
content = '''If wait() with predicate fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''call(wait, cv, lock, pred) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/16"
tags = ['concurrency', 'condition_variable', 'wait', 'predicate', 'terminate']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''template<class Predicate> void condition_variable::wait(unique_lock<mutex>& lock, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_precond_owns_lock_c3d4e5f6"
content = '''Calling wait_until() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''call(wait_until, cv, lock, abs_time) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/17"
tags = ['concurrency', 'condition_variable', 'wait_until', 'precondition', 'timeout']
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = '''template<class Clock, class Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_exception_relock_a7b8c9d0"
content = '''If wait_until() exits via an exception, lock.lock() is called prior to exiting the function.'''
formal_spec = '''call(wait_until, cv, lock, abs_time) && throws_exception(e) => before_exit(lock.lock())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/18.4"
tags = ['concurrency', 'condition_variable', 'wait_until', 'exception', 'mutex']
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = '''template<class Clock, class Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_terminate_e1f2a3b4"
content = '''If wait_until() fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''call(wait_until, cv, lock, abs_time) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/22"
tags = ['concurrency', 'condition_variable', 'wait_until', 'terminate']
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = '''template<class Clock, class Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_precond_owns_lock_c5d6e7f8"
content = '''Calling wait_for() on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''call(wait_for, cv, lock, rel_time) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/23"
tags = ['concurrency', 'condition_variable', 'wait_for', 'precondition', 'timeout']
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = '''template<class Rep, class Period> cv_status condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_terminate_a9b0c1d2"
content = '''If wait_for() fails to meet the postcondition, terminate is invoked.'''
formal_spec = '''call(wait_for, cv, lock, rel_time) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/28"
tags = ['concurrency', 'condition_variable', 'wait_for', 'terminate']
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = '''template<class Rep, class Period> cv_status condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_pred_precond_e3f4a5b6"
content = '''Calling wait_until() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''call(wait_until, cv, lock, abs_time, pred) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/29"
tags = ['concurrency', 'condition_variable', 'wait_until', 'predicate', 'precondition']
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = '''template<class Clock, class Duration, class Predicate> bool condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_pred_terminate_c7d8e9f0"
content = '''If wait_until() with predicate fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''call(wait_until, cv, lock, abs_time, pred) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/34"
tags = ['concurrency', 'condition_variable', 'wait_until', 'predicate', 'terminate']
function = "std::condition_variable::wait_until"
header = "<condition_variable>"
signature = '''template<class Clock, class Duration, class Predicate> bool condition_variable::wait_until(unique_lock<mutex>& lock, chrono::time_point<Clock, Duration> abs_time, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_pred_precond_a1b2c3d4"
content = '''Calling wait_for() with predicate on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''call(wait_for, cv, lock, rel_time, pred) => precond(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/35"
tags = ['concurrency', 'condition_variable', 'wait_for', 'predicate', 'precondition']
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = '''template<class Rep, class Period, class Predicate> bool condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_pred_terminate_e5f6a7b8"
content = '''If wait_for() with predicate fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''call(wait_for, cv, lock, rel_time, pred) && !postcond_met(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/41"
tags = ['concurrency', 'condition_variable', 'wait_for', 'predicate', 'terminate']
function = "std::condition_variable::wait_for"
header = "<condition_variable>"
signature = '''template<class Rep, class Period, class Predicate> bool condition_variable::wait_for(unique_lock<mutex>& lock, chrono::duration<Rep, Period> rel_time, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvarany_dtor_precond_no_blocked_c9d0e1f2"
content = '''Destroying a condition_variable_any requires that no thread is blocked on it.'''
formal_spec = '''destroy(cv_any) && exists_thread(t, blocked_on(t, cv_any)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/4"
tags = ['concurrency', 'condition_variable_any', 'destructor', 'precondition']
function = "std::condition_variable_any::~condition_variable_any"
header = "<condition_variable>"
signature = '''~condition_variable_any()'''
depends_on = ['cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_after_dtor_ub_a3b4c5d6"
content = '''Undefined behavior ensues if a thread waits on a condition_variable_any once the destructor has been started.'''
formal_spec = '''dtor_started(cv_any) && wait_on(thread, cv_any) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/4"
tags = ['concurrency', 'condition_variable_any', 'destructor', 'lifetime', 'undefined_behavior']
function = "std::condition_variable_any::~condition_variable_any"
header = "<condition_variable>"
signature = '''~condition_variable_any()'''
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvarany_lock_requirement_e7f8a9b0"
content = '''Template arguments for Lock in condition_variable_any shall meet the Cpp17BasicLockable requirements.'''
formal_spec = '''use(condition_variable_any, Lock) => requires(Lock, Cpp17BasicLockable)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/1"
tags = ['concurrency', 'condition_variable_any', 'requirements', 'lockable']
function = "std::condition_variable_any"
header = "<condition_variable>"
signature = '''class condition_variable_any'''
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_postcond_locked_c1d2e3f4"
content = '''After wait() returns on condition_variable_any, lock is locked by the calling thread.'''
formal_spec = '''returns(wait, cv_any, lock) => postcond(locked_by(lock, calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/2"
tags = ['concurrency', 'condition_variable_any', 'wait', 'postcondition']
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = '''template<class Lock> void condition_variable_any::wait(Lock& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_relock_fail_terminate_a5b6c7d8"
content = '''If wait() on condition_variable_any fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''call(wait, cv_any, lock) && !postcond_met(locked_by(lock, calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/4"
tags = ['concurrency', 'condition_variable_any', 'wait', 'terminate']
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = '''template<class Lock> void condition_variable_any::wait(Lock& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_until_exception_relock_e9f0a1b2"
content = '''If wait_until() on condition_variable_any exits via an exception, lock.lock() is called prior to exiting the function.'''
formal_spec = '''call(wait_until, cv_any, lock, abs_time) && throws_exception(e) => before_exit(lock.lock())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/6.4"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'exception']
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = '''template<class Lock, class Clock, class Duration> cv_status condition_variable_any::wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_until_terminate_c3d4e5f6"
content = '''If wait_until() on condition_variable_any fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''call(wait_until, cv_any, lock, abs_time) && !postcond_met(locked_by(lock, calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/10"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'terminate']
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = '''template<class Lock, class Clock, class Duration> cv_status condition_variable_any::wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_for_terminate_a7b8c9d0"
content = '''If wait_for() on condition_variable_any fails to meet the postcondition, terminate is invoked.'''
formal_spec = '''call(wait_for, cv_any, lock, rel_time) && !postcond_met(locked_by(lock, calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/15"
tags = ['concurrency', 'condition_variable_any', 'wait_for', 'terminate']
function = "std::condition_variable_any::wait_for"
header = "<condition_variable>"
signature = '''template<class Lock, class Rep, class Period> cv_status condition_variable_any::wait_for(Lock& lock, chrono::duration<Rep, Period> rel_time)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_postcond_locked_e1f2a3b4"
content = '''After interruptible wait() returns on condition_variable_any, lock is locked by the calling thread.'''
formal_spec = '''returns(wait, cv_any, lock, stoken, pred) => postcond(locked_by(lock, calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/4"
tags = ['concurrency', 'condition_variable_any', 'wait', 'interruptible', 'postcondition']
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = '''template<class Lock, class Predicate> bool condition_variable_any::wait(Lock& lock, stop_token stoken, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_terminate_c5d6e7f8"
content = '''If interruptible wait() on condition_variable_any fails to meet the postcondition, terminate is called.'''
formal_spec = '''call(wait, cv_any, lock, stoken, pred) && !postcond_met(locked_by(lock, calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/6"
tags = ['concurrency', 'condition_variable_any', 'wait', 'interruptible', 'terminate']
function = "std::condition_variable_any::wait"
header = "<condition_variable>"
signature = '''template<class Lock, class Predicate> bool condition_variable_any::wait(Lock& lock, stop_token stoken, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_until_postcond_a9b0c1d2"
content = '''After interruptible wait_until() returns on condition_variable_any, lock is locked by the calling thread.'''
formal_spec = '''returns(wait_until, cv_any, lock, stoken, abs_time, pred) => postcond(locked_by(lock, calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/10"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'interruptible', 'postcondition']
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = '''template<class Lock, class Clock, class Duration, class Predicate> bool condition_variable_any::wait_until(Lock& lock, stop_token stoken, chrono::time_point<Clock, Duration> abs_time, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_until_terminate_e3f4a5b6"
content = '''If interruptible wait_until() on condition_variable_any fails to meet the postcondition, terminate is called.'''
formal_spec = '''call(wait_until, cv_any, lock, stoken, abs_time, pred) && !postcond_met(locked_by(lock, calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/12"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'interruptible', 'terminate']
function = "std::condition_variable_any::wait_until"
header = "<condition_variable>"
signature = '''template<class Lock, class Clock, class Duration, class Predicate> bool condition_variable_any::wait_until(Lock& lock, stop_token stoken, chrono::time_point<Clock, Duration> abs_time, Predicate pred)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_precond_locked_c7d8e9f0"
content = '''notify_all_at_thread_exit() requires lk to be locked by the calling thread.'''
formal_spec = '''call(notify_all_at_thread_exit, cond, lk) => precond(locked_by(lk, calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/1"
tags = ['concurrency', 'condition_variable', 'notify', 'precondition']
function = "std::notify_all_at_thread_exit"
header = "<condition_variable>"
signature = '''void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_precond_same_mutex_a1b2c3d4"
content = '''notify_all_at_thread_exit() requires either no other thread waiting on cond, or lk.mutex() returns the same value for all concurrently waiting threads.'''
formal_spec = '''call(notify_all_at_thread_exit, cond, lk) => precond(no_other_waiters(cond) || same_mutex_for_all_waiters(cond, lk.mutex()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/1"
tags = ['concurrency', 'condition_variable', 'notify', 'precondition', 'mutex']
function = "std::notify_all_at_thread_exit"
header = "<condition_variable>"
signature = '''void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_sync_order_e5f6a7b8"
content = '''The implied lk.unlock() call from notify_all_at_thread_exit is sequenced after the destruction of all objects with thread storage duration associated with the current thread.'''
formal_spec = '''call(notify_all_at_thread_exit, cond, lk) => sequenced_after(implied_unlock(lk), destroy_all_thread_local_objects(current_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/3"
tags = ['concurrency', 'condition_variable', 'notify', 'synchronization', 'thread_local']
function = "std::notify_all_at_thread_exit"
header = "<condition_variable>"
signature = '''void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_stc_thread_thread_local_keyword_b9c0d1e2', 'cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_basic_stc_general_storage_duration_categories_a1b2c3d4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_basic_stc_static_program_duration_a3b4c5d6', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_intro_races_object_value_visibility_a3b7c9e1']

[[axioms]]
id = "cpp20_thread_condition_atomic_notify_c9d0e1f2"
content = '''The executions of notify_one and notify_all are atomic.'''
formal_spec = '''execution(notify_one) => atomic && execution(notify_all) => atomic'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/3"
tags = ['concurrency', 'condition_variable', 'notify', 'atomicity']
function = "std::condition_variable::notify_one"
header = "<condition_variable>"
signature = '''void condition_variable::notify_one() noexcept'''
depends_on = ['cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1', 'cpp20_atomics_order_timely_visibility_2f8a3b4c']

[[axioms]]
id = "cpp20_thread_condition_wait_three_atomic_parts_a3b4c5d6"
content = '''The executions of wait, wait_for, and wait_until are performed in three atomic parts: (1) release of mutex and entry into waiting state, (2) unblocking of wait, and (3) reacquisition of lock.'''
formal_spec = '''execution(wait | wait_for | wait_until) => atomic_parts(release_mutex_and_wait, unblock, reacquire_lock)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/3"
tags = ['concurrency', 'condition_variable', 'wait', 'atomicity']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''void condition_variable::wait(unique_lock<mutex>& lock)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_atomics_fences_release_op_acquire_fence_sync_c3b5f8e1', 'cpp20_atomics_fences_release_fence_acquire_op_sync_7d4e2a9f', 'cpp20_atomics_order_timely_visibility_2f8a3b4c', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_intro_races_store_release_load_acquire_sync_f8d0e2g6']

[[axioms]]
id = "cpp20_thread_condition_spurious_wakeup_e7f8a9b0"
content = '''A condition_variable wait function may unblock spuriously (without notification or timeout).'''
formal_spec = '''blocking(wait, cv) => may_unblock_spuriously()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/8.3"
tags = ['concurrency', 'condition_variable', 'wait', 'spurious_wakeup']
function = "std::condition_variable::wait"
header = "<condition_variable>"
signature = '''void condition_variable::wait(unique_lock<mutex>& lock)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_thread_condition_concurrent_permitted_c1d2e3f4"
content = '''Condition variables permit concurrent invocation of wait, wait_for, wait_until, notify_one and notify_all member functions.'''
formal_spec = '''concurrent_call(cv, {wait, wait_for, wait_until, notify_one, notify_all}) => permitted'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/2"
tags = ['concurrency', 'condition_variable', 'thread_safety']
function = "std::condition_variable"
header = "<condition_variable>"
signature = '''class condition_variable'''

[[axioms]]
id = "cpp20_thread_condition_ctor_dtor_no_sync_a5b6c7d8"
content = '''Condition variable construction and destruction need not be synchronized.'''
formal_spec = '''construction(cv) || destruction(cv) => no_synchronization_required'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/5"
tags = ['concurrency', 'condition_variable', 'constructor', 'destructor', 'synchronization']
function = "std::condition_variable"
header = "<condition_variable>"
signature = '''class condition_variable'''
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_intro_races_sync_op_categories_c5a7b9d3', 'cpp20_intro_races_fence_categories_d6b8c0e4', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_range_range_begin_end_denotes_range_a3b4c5d6"
content = '''For a type T modeling range, [ranges::begin(t), ranges::end(t)) must denote a valid range as defined in [iterator.requirements.general].'''
formal_spec = '''models<range>(T) && is_lvalue_ref<decltype((t))> => denotes_range(ranges::begin(t), ranges::end(t))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.1"
tags = ['range', 'iterator', 'sentinel', 'concept']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_range_range_begin_end_amortized_constant_7e8f9a0b"
content = '''For a type T modeling range, both ranges::begin(t) and ranges::end(t) must be amortized constant time and non-modifying.'''
formal_spec = '''models<range>(T) => amortized_O1(ranges::begin(t)) && amortized_O1(ranges::end(t)) && non_modifying(ranges::begin(t)) && non_modifying(ranges::end(t))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.2"
tags = ['range', 'complexity', 'concept']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_range_range_begin_equality_preserving_c1d2e3f4"
content = '''For a type T modeling range, if ranges::begin(t) returns a type modeling forward_iterator, then ranges::begin(t) must be equality-preserving.'''
formal_spec = '''models<range>(T) && models<forward_iterator>(decltype(ranges::begin(t))) => equality_preserving(ranges::begin(t))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.3"
tags = ['range', 'iterator', 'forward_iterator', 'equality_preserving', 'concept']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_range_borrowed_range_iterator_validity_5a6b7c8d"
content = '''A type T models borrowed_range only if the validity of iterators obtained from a variable u of type U (where U is remove_reference_t<T> if T is rvalue reference, otherwise T) is not tied to the lifetime of that variable.'''
formal_spec = '''models<borrowed_range>(T) => !tied_to_lifetime(iterators_from(u), u) where U = (is_rvalue_reference_v<T> ? remove_reference_t<T> : T)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/4"
tags = ['range', 'borrowed_range', 'iterator', 'lifetime', 'concept']
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4']

[[axioms]]
id = "cpp20_range_enable_borrowed_range_specialization_e9f0a1b2"
content = '''Users may specialize enable_borrowed_range for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions and have type const bool.'''
formal_spec = '''user_specialization(enable_borrowed_range<T>) => is_cv_unqualified(T) && program_defined_type(T) && usable_in_constant_expr(enable_borrowed_range<T>) && same_as<decltype(enable_borrowed_range<T>), const bool>'''
layer = "cpp20_language"
confidence = 0.9
source_file = "range.range"
source_module = "[range.range]/6"
tags = ['range', 'borrowed_range', 'specialization', 'constraint']

[[axioms]]
id = "cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6"
content = '''For a type T modeling approximately_sized_range, ranges::reserve_hint(t) must be amortized O(1), must not modify t, and must return a non-negative value representable in range_difference_t<T>.'''
formal_spec = '''models<approximately_sized_range>(T) => amortized_O1(ranges::reserve_hint(t)) && non_modifying(ranges::reserve_hint(t)) && ranges::reserve_hint(t) >= 0 && representable_in<range_difference_t<T>>(ranges::reserve_hint(t))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.1"
tags = ['range', 'approximately_sized_range', 'complexity', 'concept']

[[axioms]]
id = "cpp20_range_approximately_sized_forward_reserve_hint_g7h8i9j0"
content = '''For a type T modeling approximately_sized_range, if iterator_t<T> models forward_iterator, ranges::reserve_hint(t) is well-defined regardless of the evaluation of ranges::begin(t).'''
formal_spec = '''models<approximately_sized_range>(T) && models<forward_iterator>(iterator_t<T>) => well_defined_independent_of_begin(ranges::reserve_hint(t))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.2"
tags = ['range', 'approximately_sized_range', 'forward_iterator', 'concept']

[[axioms]]
id = "cpp20_range_approximately_sized_non_forward_reserve_hint_k1l2m3n4"
content = '''For an approximately_sized_range whose iterator type does not model forward_iterator, ranges::reserve_hint(t) may only be well-defined if evaluated before the first call to ranges::begin(t).'''
formal_spec = '''models<approximately_sized_range>(T) && !models<forward_iterator>(iterator_t<T>) => may_require(call_order(ranges::reserve_hint(t)) < call_order(ranges::begin(t)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.2 Note 1"
tags = ['range', 'approximately_sized_range', 'input_iterator', 'ordering', 'concept']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_range_sized_size_O1_o5p6q7r8"
content = '''For a type T modeling sized_range, ranges::size(t) must be amortized O(1), must not modify t, and must equal ranges::distance(ranges::begin(t), ranges::end(t)).'''
formal_spec = '''models<sized_range>(T) => amortized_O1(ranges::size(t)) && non_modifying(ranges::size(t)) && ranges::size(t) == ranges::distance(ranges::begin(t), ranges::end(t))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.sized"
source_module = "[range.sized]/2.1"
tags = ['range', 'sized_range', 'complexity', 'concept']

[[axioms]]
id = "cpp20_range_sized_forward_size_s9t0u1v2"
content = '''For a type T modeling sized_range, if iterator_t<T> models forward_iterator, ranges::size(t) is well-defined regardless of the evaluation of ranges::begin(t).'''
formal_spec = '''models<sized_range>(T) && models<forward_iterator>(iterator_t<T>) => well_defined_independent_of_begin(ranges::size(t))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "range.sized"
source_module = "[range.sized]/2.2"
tags = ['range', 'sized_range', 'forward_iterator', 'concept']

[[axioms]]
id = "cpp20_range_sized_non_forward_size_w3x4y5z6"
content = '''For a sized_range whose iterator type does not model forward_iterator, ranges::size(t) may only be well-defined if evaluated before the first call to ranges::begin(t).'''
formal_spec = '''models<sized_range>(T) && !models<forward_iterator>(iterator_t<T>) => may_require(call_order(ranges::size(t)) < call_order(ranges::begin(t)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "range.sized"
source_module = "[range.sized]/2.2 Note 1"
tags = ['range', 'sized_range', 'input_iterator', 'ordering', 'concept']
depends_on = ['cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_range_disable_sized_range_specialization_a7b8c9d0"
content = '''Users may specialize disable_sized_range for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions and have type const bool.'''
formal_spec = '''user_specialization(disable_sized_range<T>) => is_cv_unqualified(T) && program_defined_type(T) && usable_in_constant_expr(disable_sized_range<T>) && same_as<decltype(disable_sized_range<T>), const bool>'''
layer = "cpp20_language"
confidence = 0.9
source_file = "range.sized"
source_module = "[range.sized]/3"
tags = ['range', 'sized_range', 'specialization', 'constraint']

[[axioms]]
id = "cpp20_range_view_O1_move_construction_e1f2a3b4"
content = '''A type T models view only if T has O(1) move construction.'''
formal_spec = '''models<view>(T) => O1(move_construction(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.1"
tags = ['range', 'view', 'move', 'complexity', 'concept']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_range_view_move_assignment_complexity_c5d6e7f8"
content = '''A type T models view only if move assignment of an object of type T is no more complex than destruction followed by move construction.'''
formal_spec = '''models<view>(T) => complexity(move_assignment(T)) <= complexity(destruction(T)) + complexity(move_construction(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.2"
tags = ['range', 'view', 'move', 'complexity', 'concept']
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_weak_ptr_assignment_move_effect_c0e4a8f3', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_range_view_copy_destruction_linear_g9h0i1j2"
content = '''For a type T modeling view, if N copies and/or moves are made from an object of type T that contained M elements, then those N objects have O(N+M) destruction.'''
formal_spec = '''models<view>(T) && copies_or_moves(obj, N) && elements(obj) == M => O(N + M)(total_destruction_of_N_objects)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.3"
tags = ['range', 'view', 'destruction', 'complexity', 'concept']
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2']

[[axioms]]
id = "cpp20_range_view_O1_copy_construction_k3l4m5n6"
content = '''A type T models view only if copy_constructible<T> is false, or T has O(1) copy construction.'''
formal_spec = '''models<view>(T) => !copy_constructible<T> || O1(copy_construction(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.4"
tags = ['range', 'view', 'copy', 'complexity', 'concept']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_range_view_copy_assignment_complexity_o7p8q9r0"
content = '''A type T models view only if copyable<T> is false, or copy assignment of an object of type T is no more complex than destruction followed by copy construction.'''
formal_spec = '''models<view>(T) => !copyable<T> || complexity(copy_assignment(T)) <= complexity(destruction(T)) + complexity(copy_construction(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.5"
tags = ['range', 'view', 'copy', 'complexity', 'concept']
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_variant_copy_assign_deleted_condition_k1l2m3n4', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_range_view_moved_from_O1_destruction_s1t2u3v4"
content = '''The constraints on copying and moving for view imply that a moved-from object of type T has O(1) destruction.'''
formal_spec = '''models<view>(T) && moved_from(obj) => O1(destruction(obj))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "range.view"
source_module = "[range.view]/3 Note 1"
tags = ['range', 'view', 'move', 'destruction', 'complexity', 'concept']
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2']

[[axioms]]
id = "cpp20_range_enable_view_specialization_w5x6y7z8"
content = '''Users may specialize enable_view to true for cv-unqualified program-defined types that model view, and false for types that do not. Such specializations shall be usable in constant expressions and have type const bool.'''
formal_spec = '''user_specialization(enable_view<T>) => is_cv_unqualified(T) && program_defined_type(T) && usable_in_constant_expr(enable_view<T>) && same_as<decltype(enable_view<T>), const bool> && (enable_view<T> == true => models<view>(T))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "range.view"
source_module = "[range.view]/7"
tags = ['range', 'view', 'specialization', 'constraint']

[[axioms]]
id = "cpp20_range_contiguous_data_address_a9b0c1d2"
content = '''A type T models contiguous_range only if to_address(ranges::begin(t)) == ranges::data(t) is true.'''
formal_spec = '''models<contiguous_range>(T) => to_address(ranges::begin(t)) == ranges::data(t)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/3"
tags = ['range', 'contiguous_range', 'pointer', 'concept']
depends_on = ['cpp20_basic_stc_dynamic_alloc_unique_ptr_a7b8c9d0']

[[axioms]]
id = "cpp20_range_viewable_range_view_constructible_e3f4a5b6"
content = '''For a type T satisfying viewable_range where remove_cvref_t<T> is a view, T must be constructible_from<remove_cvref_t<T>, T>.'''
formal_spec = '''models<viewable_range>(T) && view<remove_cvref_t<T>> => constructible_from<remove_cvref_t<T>, T>'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/6"
tags = ['range', 'viewable_range', 'view', 'constructible', 'concept']
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_range_viewable_range_non_view_lvalue_or_movable_c7d8e9f0"
content = '''For a type T satisfying viewable_range where remove_cvref_t<T> is not a view, T must be an lvalue reference, or (movable<remove_reference_t<T>> and not a specialization of initializer_list).'''
formal_spec = '''models<viewable_range>(T) && !view<remove_cvref_t<T>> => is_lvalue_reference_v<T> || (movable<remove_reference_t<T>> && !is_initializer_list<T>)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/6"
tags = ['range', 'viewable_range', 'lvalue', 'movable', 'initializer_list', 'concept']
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b']

[[axioms]]
id = "cpp20_range_constant_range_non_modifiable_a1b2c3d4"
content = '''The constant_range concept specifies the requirements of a range type whose elements are not modifiable, requiring input_range and constant-iterator for iterator_t.'''
formal_spec = '''constant_range<T> <=> input_range<T> && constant_iterator<iterator_t<T>>'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/7"
tags = ['range', 'constant_range', 'const', 'iterator', 'concept']
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_concept_same_definition_symmetric_a7c3e1f2', 'cpp20_concept_same_reflexive_e8a4c7d9', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_range_common_range_same_iterator_sentinel_e5f6a7b8"
content = '''The common_range concept requires that ranges::begin and ranges::end return objects of the same type.'''
formal_spec = '''common_range<T> <=> range<T> && same_as<iterator_t<T>, sentinel_t<T>>'''
layer = "cpp20_language"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/4"
tags = ['range', 'common_range', 'iterator', 'sentinel', 'concept']
depends_on = ['cpp20_concept_same_definition_symmetric_a7c3e1f2', 'cpp20_concept_same_reflexive_e8a4c7d9']

[[axioms]]
id = "cpp20_format_string_invalid_format_3a8f2b1c"
content = '''A format string that does not conform to the format string grammar for the given arguments is ill-formed.'''
formal_spec = '''!is_format_string_for(fmt, args) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/2"
tags = ['format', 'format_string', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_string_arg_id_out_of_bounds_7c9d4e5f"
content = '''If there is no argument with the index arg-id in args, the string is not a format string for args.'''
formal_spec = '''arg_id >= sizeof...(args) => !is_format_string_for(fmt, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/2"
tags = ['format', 'format_string', 'constraint', 'argument_index']
header = "<format>"

[[axioms]]
id = "cpp20_format_string_mixed_indexing_f4a5b6c7"
content = '''A format string cannot contain a mixture of automatic and manual argument indexing.'''
formal_spec = '''(has_automatic_indexing(fmt) && has_manual_indexing(fmt)) => !is_format_string_for(fmt, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/4"
tags = ['format', 'format_string', 'constraint', 'argument_index']
header = "<format>"

[[axioms]]
id = "cpp20_format_string_invalid_format_spec_d8e9f0a1"
content = '''If format-spec does not conform to the format specifications for the argument type referred to by arg-id, the string is not a format string for args.'''
formal_spec = '''!conforms_to_format_spec(format_spec, arg_type(arg_id)) => !is_format_string_for(fmt, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/5"
tags = ['format', 'format_string', 'constraint', 'format_spec']
header = "<format>"

[[axioms]]
id = "cpp20_format_sign_option_constraint_b2c3d4e5"
content = '''The sign option is only valid for arithmetic types other than charT and bool or when an integer presentation type is specified.'''
formal_spec = '''has_sign_option(format_spec) && !(is_arithmetic(T) && !is_same(T, charT) && !is_same(T, bool)) && !has_integer_presentation_type(format_spec) => invalid_format_spec'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/5"
tags = ['format', 'format_spec', 'sign', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_alternate_form_constraint_a1b2c3d4"
content = '''The # option (alternate form) is valid for arithmetic types other than charT and bool or when an integer presentation type is specified, and not otherwise.'''
formal_spec = '''has_alternate_form(format_spec) && !(is_arithmetic(T) && !is_same(T, charT) && !is_same(T, bool)) && !has_integer_presentation_type(format_spec) => invalid_format_spec'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/7"
tags = ['format', 'format_spec', 'alternate_form', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_zero_option_constraint_e5f6a7b8"
content = '''The 0 option is valid for arithmetic types other than charT and bool, pointer types, or when an integer presentation type is specified.'''
formal_spec = '''has_zero_option(format_spec) && !(is_arithmetic(T) && !is_same(T, charT) && !is_same(T, bool)) && !is_pointer(T) && !has_integer_presentation_type(format_spec) => invalid_format_spec'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/8"
tags = ['format', 'format_spec', 'zero_padding', 'constraint']
header = "<format>"
depends_on = ['c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_format_width_negative_throws_c9d0e1f2"
content = '''If the value of a dynamic width argument is negative, an exception of type format_error is thrown.'''
formal_spec = '''is_dynamic_width(format_spec) && get_width_arg_value(args) < 0 => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = ['format', 'format_spec', 'width', 'exception']
header = "<format>"
depends_on = ['cpp20_format_err_report_throws_format_error_a7b8c9d0', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_format_precision_negative_throws_f3a4b5c6"
content = '''If the value of a dynamic precision argument is negative, an exception of type format_error is thrown.'''
formal_spec = '''is_dynamic_precision(format_spec) && get_precision_arg_value(args) < 0 => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = ['format', 'format_spec', 'precision', 'exception']
header = "<format>"
depends_on = ['cpp20_format_err_report_throws_format_error_a7b8c9d0', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']

[[axioms]]
id = "cpp20_format_width_precision_type_constraint_d7e8f9a0"
content = '''The dynamic width or precision option is valid only if the corresponding formatting argument is of standard signed or unsigned integer type.'''
formal_spec = '''(is_dynamic_width(format_spec) || is_dynamic_precision(format_spec)) && !is_standard_integer_type(arg_type(width_arg_id)) => invalid_format_spec'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = ['format', 'format_spec', 'width', 'precision', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_precision_valid_types_b1c2d3e4"
content = '''The precision option is valid for floating-point and string types only.'''
formal_spec = '''has_precision(format_spec) && !is_floating_point(T) && !is_string_type(T) => invalid_format_spec'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/15"
tags = ['format', 'format_spec', 'precision', 'constraint']
header = "<format>"
depends_on = ['c11_cpp_conversion_syntax_convertType_7e132831']

[[axioms]]
id = "cpp20_format_locale_option_constraint_a5b6c7d8"
content = '''The L option is only valid for arithmetic types.'''
formal_spec = '''has_locale_option(format_spec) && !is_arithmetic(T) => invalid_format_spec'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/17"
tags = ['format', 'format_spec', 'locale', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_locale_not_constexpr_e9f0a1b2"
content = '''A call to format on a given formatter specialization is not a constant subexpression if the locale-specific form is specified.'''
formal_spec = '''has_locale_option(format_spec) => !is_constant_subexpression(format_call)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/17"
tags = ['format', 'format_spec', 'locale', 'constexpr', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_c_type_throws_out_of_range_c3d4e5f6"
content = '''The c type presentation for integers throws format_error if value is not in the range of representable values for charT.'''
formal_spec = '''type_option == 'c' && !in_range<charT>(value) => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/21 Table 107"
tags = ['format', 'format_spec', 'type', 'exception', 'character']
header = "<format>"
depends_on = ['cpp20_format_err_report_throws_format_error_a7b8c9d0', 'cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_format_err_report_throws_format_error_a7b8c9d0"
content = '''Formatting functions throw format_error if an argument fmt is passed that is not a format string for args.'''
formal_spec = '''!is_format_string_for(fmt, args) => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.err.report"
source_module = "[format.err.report]/1"
tags = ['format', 'exception', 'format_error']
function = "std::format"
header = "<format>"
signature = '''template<class... Args> string format(format_string<Args...> fmt, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_format_err_report_propagates_exceptions_e1f2a3b4"
content = '''Formatting functions propagate exceptions thrown by operations of formatter specializations and iterators.'''
formal_spec = '''throws_from_formatter_or_iterator(op) => propagates_exception(format_call)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.err.report"
source_module = "[format.err.report]/1"
tags = ['format', 'exception', 'propagation']
header = "<format>"

[[axioms]]
id = "cpp20_basic_format_string_consteval_invalid_b5c6d7e8"
content = '''A call to basic_format_string consteval constructor is not a core constant expression unless there exist args of types Args such that str is a format string for args.'''
formal_spec = '''!exists_args_for_format_string(str, Args...) => !is_core_constant_expression(basic_format_string(s))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.fmt.string"
source_module = "[format.fmt.string]/3"
tags = ['format', 'basic_format_string', 'consteval', 'constraint']
function = "std::basic_format_string::basic_format_string"
header = "<format>"
signature = '''template<class T> consteval basic_format_string(const T& s)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_format_functions_constexpr_requirement_f9a0b1c2"
content = '''A call to any formatting function is a constant subexpression only if each of the used formatter specializations is a constexpr-enabled specialization.'''
formal_spec = '''!all_constexpr_enabled_formatters(Args...) => !is_constant_subexpression(format_call)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/1"
tags = ['format', 'constexpr', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_vformat_to_precondition_output_iterator_c3d4e5f6"
content = '''vformat_to requires that Out models output_iterator<const charT&>.'''
formal_spec = '''!models<Out, output_iterator<const charT&>> => precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/15"
tags = ['format', 'vformat_to', 'precondition', 'iterator']
function = "std::vformat_to"
header = "<format>"
signature = '''template<class Out> Out vformat_to(Out out, string_view fmt, format_args args)'''
depends_on = ['for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8']

[[axioms]]
id = "cpp20_format_to_n_precondition_output_iterator_a7b8c9d0"
content = '''format_to_n requires that Out models output_iterator<const charT&> and formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements for each Ti in Args.'''
formal_spec = '''(!models<Out, output_iterator<const charT&>> || !all_basic_formatter_requirements(Args...)) => precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/21"
tags = ['format', 'format_to_n', 'precondition', 'iterator', 'formatter']
function = "std::format_to_n"
header = "<format>"
signature = '''template<class Out, class... Args> format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n, format_string<Args...> fmt, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_formatted_size_precondition_basic_formatter_e1f2a3b4"
content = '''formatted_size requires that formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements for each Ti in Args.'''
formal_spec = '''!all_basic_formatter_requirements(Args...) => precondition_violation'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/26"
tags = ['format', 'formatted_size', 'precondition', 'formatter']
function = "std::formatted_size"
header = "<format>"
signature = '''template<class... Args> size_t formatted_size(format_string<Args...> fmt, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_formatter_parse_throws_on_invalid_b5c6d7e8"
content = '''The parse member function of a formatter throws format_error unless the whole range is parsed or the unmatched character is }.'''
formal_spec = '''!parsed_successfully(format_spec) && unmatched_char != '}' => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "formatter.requirements"
source_module = "[formatter.requirements] Table 112"
tags = ['format', 'formatter', 'parse', 'exception']
function = "formatter::parse"
header = "<format>"
signature = '''PC::iterator formatter<T, charT>::parse(basic_format_parse_context<charT>& pc)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_iterator_operations_next_effect_c5f9a2b7', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6', 'cpp20_format_err_report_throws_format_error_a7b8c9d0', 'cpp20_iterator_operations_prev_effect_d6a0b3c8']

[[axioms]]
id = "cpp20_formatter_disabled_not_constructible_f9a0b1c2"
content = '''If F is a disabled specialization of formatter, is_default_constructible_v<F>, is_copy_constructible_v<F>, is_move_constructible_v<F>, is_copy_assignable_v<F>, and is_move_assignable_v<F> are all false.'''
formal_spec = '''is_disabled_formatter<F> => (!is_default_constructible_v<F> && !is_copy_constructible_v<F> && !is_move_constructible_v<F> && !is_copy_assignable_v<F> && !is_move_assignable_v<F>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.spec"
source_module = "[format.formatter.spec]/7"
tags = ['format', 'formatter', 'disabled', 'type_traits']
header = "<format>"

[[axioms]]
id = "cpp20_formatter_enabled_meets_basic_formatter_c3d4e5f6"
content = '''An enabled specialization formatter<T, charT> meets the BasicFormatter requirements.'''
formal_spec = '''is_enabled_formatter<formatter<T, charT>> => meets_basic_formatter_requirements<formatter<T, charT>>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.spec"
source_module = "[format.formatter.spec]/8"
tags = ['format', 'formatter', 'enabled', 'requirements']
header = "<format>"

[[axioms]]
id = "cpp20_formattable_concept_requirements_a7b8c9d0"
content = '''A type T and a character type charT model formattable if formatter<remove_cvref_t<T>, charT> meets the BasicFormatter requirements and, if remove_reference_t<T> is const-qualified, the Formatter requirements.'''
formal_spec = '''formattable<T, charT> <=> (meets_basic_formatter_requirements<formatter<remove_cvref_t<T>, charT>> && (is_const<remove_reference_t<T>> => meets_formatter_requirements<formatter<remove_cvref_t<T>, charT>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formattable"
source_module = "[format.formattable]/2"
tags = ['format', 'formattable', 'concept', 'requirements']
header = "<format>"

[[axioms]]
id = "cpp20_enable_nonlocking_formatter_specialization_e1f2a3b4"
content = '''User specializations of enable_nonlocking_formatter_optimization shall be usable in constant expressions and have type const bool.'''
formal_spec = '''is_user_specialization(enable_nonlocking_formatter_optimization<T>) => (is_constexpr(enable_nonlocking_formatter_optimization<T>) && is_same<decltype(enable_nonlocking_formatter_optimization<T>), const bool>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.locking"
source_module = "[format.formatter.locking]/1"
tags = ['format', 'formatter', 'locking', 'specialization', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_fill_char_utf_scalar_b5c6d7e8"
content = '''For a format specification in UTF-8, UTF-16, or UTF-32, the fill character corresponds to a single Unicode scalar value.'''
formal_spec = '''is_utf_encoding(charT) => is_single_unicode_scalar_value(fill_char)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/3"
tags = ['format', 'format_spec', 'fill', 'unicode', 'constraint']
header = "<format>"

[[axioms]]
id = "cpp20_format_range_disabled_constraint_f9a0b1c2"
content = '''A formatter specialization for ranges is only enabled if format_kind<R> is not range_format::disabled and the range element type is formattable.'''
formal_spec = '''(format_kind<R> == range_format::disabled || !formattable<ranges::range_reference_t<R>, charT>) => !is_enabled_formatter<formatter<R, charT>>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.syn"
source_module = "[format.syn]"
tags = ['format', 'range', 'formatter', 'constraint']
header = "<format>"
depends_on = ['cpp20_range_sized_size_O1_o5p6q7r8', 'cpp20_range_approximately_sized_reserve_hint_O1_c3d4e5f6']

[[axioms]]
id = "cpp20_range_formatter_constraint_same_as_c3d4e5f6"
content = '''range_formatter requires same_as<remove_cvref_t<T>, T> and formattable<T, charT>.'''
formal_spec = '''!same_as<remove_cvref_t<T>, T> || !formattable<T, charT> => constraint_violation(range_formatter<T, charT>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.syn"
source_module = "[format.syn]"
tags = ['format', 'range_formatter', 'constraint']
header = "<format>"
depends_on = ['cpp20_concept_same_definition_symmetric_a7c3e1f2']

[[axioms]]
id = "cpp20_format_parse_context_check_dynamic_spec_a7b8c9d0"
content = '''The check_dynamic_spec member function of basic_format_parse_context validates that the argument at the specified index is one of the specified types.'''
formal_spec = '''!is_one_of_types<Ts...>(arg_type(arg_id)) => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "format.parse.ctx"
source_module = "[format.parse.ctx]"
tags = ['format', 'parse_context', 'dynamic_spec', 'constraint']
function = "std::basic_format_parse_context::check_dynamic_spec"
header = "<format>"
signature = '''template<class... Ts> constexpr void check_dynamic_spec(size_t id)'''
depends_on = ['cpp20_format_err_report_throws_format_error_a7b8c9d0']

[[axioms]]
id = "cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4"
content = '''Objects of type bad_any_cast are thrown by a failed any_cast operation.'''
formal_spec = '''any_cast_fails(operand, T) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.bad.any.cast"
source_module = "[any.bad.any.cast]/1"
tags = ['exception', 'any', 'type_erasure', 'cast']
function = "bad_any_cast"
header = "<any>"
signature = '''class bad_any_cast : public bad_cast'''
depends_on = ['cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4', 'cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2', 'cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8']

[[axioms]]
id = "cpp20_any_small_object_optimization_constraint_e5f6a7b8"
content = '''Small-object optimization for std::any shall only be applied to types T for which is_nothrow_move_constructible_v<T> is true.'''
formal_spec = '''small_object_optimization_applied(any, T) => is_nothrow_move_constructible_v<T> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.class.general"
source_module = "[any.class.general]/3"
tags = ['any', 'optimization', 'move_constructible', 'implementation']

[[axioms]]
id = "cpp20_any_template_ctor_precondition_copyconstruct_c9d0e1f2"
content = '''The template constructor any(T&& value) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.'''
formal_spec = '''call(any::any<T>, value) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/7"
tags = ['any', 'constructor', 'precondition', 'copy_constructible']
function = "std::any::any"
header = "<any>"
signature = '''template<class T> any(T&& value)'''
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_inplace_ctor_precondition_copyconstruct_f3a4b5c6"
content = '''The in-place constructor any(in_place_type_t<T>, Args&&...) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.'''
formal_spec = '''call(any::any<T, Args...>, in_place_type_t<T>, args...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/12"
tags = ['any', 'constructor', 'precondition', 'in_place', 'copy_constructible']
function = "std::any::any"
header = "<any>"
signature = '''template<class T, class... Args> explicit any(in_place_type_t<T>, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_inplace_initlist_ctor_precondition_d7e8f9a0"
content = '''The in-place constructor with initializer_list any(in_place_type_t<T>, initializer_list<U>, Args&&...) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.'''
formal_spec = '''call(any::any<T, U, Args...>, in_place_type_t<T>, il, args...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/18"
tags = ['any', 'constructor', 'precondition', 'in_place', 'initializer_list', 'copy_constructible']
function = "std::any::any"
header = "<any>"
signature = '''template<class T, class U, class... Args> explicit any(in_place_type_t<T>, initializer_list<U> il, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_template_assign_precondition_copyconstruct_b1c2d3e4"
content = '''The template assignment operator any::operator=(T&&) requires that decay_t<T> meets the Cpp17CopyConstructible requirements.'''
formal_spec = '''call(any::operator=<T>, rhs) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/9"
tags = ['any', 'assignment', 'precondition', 'copy_constructible']
function = "std::any::operator="
header = "<any>"
signature = '''template<class T> any& operator=(T&& rhs)'''
depends_on = ['for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_any_emplace_precondition_copyconstruct_f5a6b7c8"
content = '''The emplace member function requires that decay_t<T> meets the Cpp17CopyConstructible requirements.'''
formal_spec = '''call(any::emplace<T, Args...>, args...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/3"
tags = ['any', 'emplace', 'precondition', 'copy_constructible']
function = "std::any::emplace"
header = "<any>"
signature = '''template<class T, class... Args> decay_t<T>& emplace(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_any_emplace_initlist_precondition_copyconstruct_d9e0f1a2"
content = '''The emplace member function with initializer_list requires that decay_t<T> meets the Cpp17CopyConstructible requirements.'''
formal_spec = '''call(any::emplace<T, U, Args...>, il, args...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/11"
tags = ['any', 'emplace', 'precondition', 'initializer_list', 'copy_constructible']
function = "std::any::emplace"
header = "<any>"
signature = '''template<class T, class U, class... Args> decay_t<T>& emplace(initializer_list<U> il, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a']

[[axioms]]
id = "cpp20_any_emplace_exception_state_b3c4d5e6"
content = '''If an exception is thrown during emplace's call to VT's constructor, the any object does not contain a value, and any previously contained value has been destroyed.'''
formal_spec = '''call(any::emplace<T>, args...) && throws_exception(VT_constructor) => !has_value(*this) && destroyed(previous_value)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/8"
tags = ['any', 'emplace', 'exception', 'state']
function = "std::any::emplace"
header = "<any>"
signature = '''template<class T, class... Args> decay_t<T>& emplace(Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_emplace_initlist_exception_state_f7a8b9c0"
content = '''If an exception is thrown during emplace with initializer_list's call to VT's constructor, the any object does not contain a value, and any previously contained value has been destroyed.'''
formal_spec = '''call(any::emplace<T, U>, il, args...) && throws_exception(VT_constructor) => !has_value(*this) && destroyed(previous_value)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/16"
tags = ['any', 'emplace', 'exception', 'initializer_list', 'state']
function = "std::any::emplace"
header = "<any>"
signature = '''template<class T, class U, class... Args> decay_t<T>& emplace(initializer_list<U> il, Args&&... args)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4"
content = '''any_cast for reference types throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>).'''
formal_spec = '''call(any_cast<T>, operand) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = ['any', 'any_cast', 'exception', 'bad_any_cast', 'type_check']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T any_cast(const any& operand)'''
depends_on = ['cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8', 'cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4']

[[axioms]]
id = "cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8"
content = '''any_cast for lvalue reference throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>).'''
formal_spec = '''call(any_cast<T>, operand) && is_lvalue_reference(any&) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = ['any', 'any_cast', 'exception', 'bad_any_cast', 'type_check']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T any_cast(any& operand)'''
depends_on = ['cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4', 'cpp20_basic_lval_temp_materialization_b4e9f1c5', 'cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4']

[[axioms]]
id = "cpp20_any_cast_rvalue_throws_bad_any_cast_f9a0b1c2"
content = '''any_cast for rvalue reference throws bad_any_cast if operand.type() != typeid(remove_reference_t<T>).'''
formal_spec = '''call(any_cast<T>, operand) && is_rvalue_reference(any&&) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = ['any', 'any_cast', 'exception', 'bad_any_cast', 'type_check']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T any_cast(any&& operand)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_any_cast_ref_throws_bad_any_cast_d1e2f3a4', 'cpp20_expected_value_rvalue_throws_bad_access_a7b8c9d0', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_any_cast_ref_lvalue_throws_bad_any_cast_b5c6d7e8', 'cpp20_any_bad_any_cast_exception_purpose_a1b2c3d4']

[[axioms]]
id = "cpp20_any_cast_const_ref_mandates_constructible_d3e4f5a6"
content = '''any_cast<T>(const any&) mandates that is_constructible_v<T, const U&> is true where U is remove_cvref_t<T>.'''
formal_spec = '''call(any_cast<T>, const any&) => is_constructible_v<T, const remove_cvref_t<T>&> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = ['any', 'any_cast', 'mandates', 'constructible']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T any_cast(const any& operand)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_any_cast_lvalue_ref_mandates_constructible_b7c8d9e0"
content = '''any_cast<T>(any&) mandates that is_constructible_v<T, U&> is true where U is remove_cvref_t<T>.'''
formal_spec = '''call(any_cast<T>, any&) => is_constructible_v<T, remove_cvref_t<T>&> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = ['any', 'any_cast', 'mandates', 'constructible']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T any_cast(any& operand)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_any_cast_rvalue_ref_mandates_constructible_f1a2b3c4"
content = '''any_cast<T>(any&&) mandates that is_constructible_v<T, U> is true where U is remove_cvref_t<T>.'''
formal_spec = '''call(any_cast<T>, any&&) => is_constructible_v<T, remove_cvref_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = ['any', 'any_cast', 'mandates', 'constructible']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T any_cast(any&& operand)'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_any_cast_pointer_mandates_not_void_d5e6f7a8"
content = '''any_cast<T>(const any*) and any_cast<T>(any*) mandate that is_void_v<T> is false.'''
formal_spec = '''call(any_cast<T>, any*) => is_void_v<T> == false'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/9"
tags = ['any', 'any_cast', 'mandates', 'void', 'pointer']
function = "any_cast"
header = "<any>"
signature = '''template<class T> const T* any_cast(const any* operand) noexcept'''
depends_on = ['cpp20_const_pointer_cast_mandates_7a8b9c0d', 'c11_cpp_translation_name_syntax_operation_95efc489', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2']

[[axioms]]
id = "cpp20_any_cast_pointer_returns_nullptr_type_mismatch_b9c0d1e2"
content = '''any_cast<T>(any*) returns nullptr if operand is nullptr or if operand->type() != typeid(T).'''
formal_spec = '''call(any_cast<T>, operand) && (operand == nullptr || operand->type() != typeid(T)) => result == nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/10"
tags = ['any', 'any_cast', 'pointer', 'nullptr', 'type_check']
function = "any_cast"
header = "<any>"
signature = '''template<class T> T* any_cast(any* operand) noexcept'''
depends_on = ['cpp20_variant_get_if_returns_nullptr_o3p4q5r6', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2', 'cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489']

[[axioms]]
id = "cpp20_any_cast_const_pointer_returns_nullptr_type_mismatch_f3a4b5c6"
content = '''any_cast<T>(const any*) returns nullptr if operand is nullptr or if operand->type() != typeid(T).'''
formal_spec = '''call(any_cast<T>, const any* operand) && (operand == nullptr || operand->type() != typeid(T)) => result == nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/10"
tags = ['any', 'any_cast', 'pointer', 'nullptr', 'type_check', 'const']
function = "any_cast"
header = "<any>"
signature = '''template<class T> const T* any_cast(const any* operand) noexcept'''
depends_on = ['cpp20_const_pointer_cast_mandates_7a8b9c0d', 'cpp20_variant_get_if_returns_nullptr_o3p4q5r6', 'cpp20_shared_ptr_compatible_pointer_definition_c9d0e1f2', 'cpp20_expr_type_composite_ptr_nullptr_j6e9h2f5', 'c11_cpp_translation_expr_cast_operation_d3b83600', 'c11_cpp_translation_name_syntax_operation_95efc489']

[[axioms]]
id = "cpp20_any_type_returns_void_when_empty_d7e8f9a0"
content = '''any::type() returns typeid(void) if the any object has no contained value.'''
formal_spec = '''!has_value() => type() == typeid(void)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.observers"
source_module = "[any.observers]/2"
tags = ['any', 'type', 'observer', 'empty']
function = "std::any::type"
header = "<any>"
signature = '''const type_info& type() const noexcept'''
depends_on = ['cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']

[[axioms]]
id = "cpp20_any_has_value_returns_true_when_contains_b1c2d3e4"
content = '''any::has_value() returns true if the any object contains an object, otherwise false.'''
formal_spec = '''has_value() == true <=> contains_object(*this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.observers"
source_module = "[any.observers]/1"
tags = ['any', 'has_value', 'observer']
function = "std::any::has_value"
header = "<any>"
signature = '''bool has_value() const noexcept'''

[[axioms]]
id = "cpp20_any_reset_destroys_contained_value_f5a6b7c8"
content = '''any::reset() destroys the contained value if has_value() is true.'''
formal_spec = '''has_value() && call(reset) => destroyed(contained_value) && !has_value()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/17"
tags = ['any', 'reset', 'destructor', 'lifetime']
function = "std::any::reset"
header = "<any>"
signature = '''void reset() noexcept'''
depends_on = ['cpp20_basic_life_end_without_destructor_9c0d1e2f']

[[axioms]]
id = "cpp20_any_destructor_calls_reset_d9e0f1a2"
content = '''The any destructor has the effect of calling reset().'''
formal_spec = '''call(any::~any) => equivalent_to(call(reset))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/22"
tags = ['any', 'destructor', 'reset', 'lifetime']
function = "std::any::~any"
header = "<any>"
signature = '''~any()'''
depends_on = ['cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2']

[[axioms]]
id = "cpp20_any_copy_assignment_exception_safety_b3c4d5e6"
content = '''any::operator=(const any&) has no effects if an exception is thrown during copy construction.'''
formal_spec = '''call(any::operator=, const any& rhs) && throws_exception(copy_ctor) => no_effect(*this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/1"
tags = ['any', 'assignment', 'exception_safety', 'strong_guarantee']
function = "std::any::operator="
header = "<any>"
signature = '''any& operator=(const any& rhs)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_template_assignment_exception_safety_f7a8b9c0"
content = '''any::operator=(T&&) has no effects if an exception is thrown during construction.'''
formal_spec = '''call(any::operator=<T>, rhs) && throws_exception(VT_ctor) => no_effect(*this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/10"
tags = ['any', 'assignment', 'exception_safety', 'strong_guarantee', 'template']
function = "std::any::operator="
header = "<any>"
signature = '''template<class T> any& operator=(T&& rhs)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_default_ctor_postcondition_no_value_d1e2f3a4"
content = '''After default construction, any::has_value() is false.'''
formal_spec = '''call(any::any()) => !has_value()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/1"
tags = ['any', 'constructor', 'default', 'postcondition']
function = "std::any::any"
header = "<any>"
signature = '''constexpr any() noexcept'''
depends_on = ['cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_move_ctor_noexcept_b5c6d7e8"
content = '''The move constructor any(any&&) is noexcept.'''
formal_spec = '''noexcept(any::any(any&&)) == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/4"
tags = ['any', 'constructor', 'move', 'noexcept']
function = "std::any::any"
header = "<any>"
signature = '''any(any&& other) noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_any_reset_noexcept_b7c8d9e0', 'cpp20_utility_swap_array_noexcept_spec_w4x8y2z6', 'cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_expected_void_copy_ctor_deleted_a7b8c9d0']

[[axioms]]
id = "cpp20_any_move_assignment_noexcept_f9a0b1c2"
content = '''The move assignment operator any::operator=(any&&) is noexcept.'''
formal_spec = '''noexcept(any::operator=(any&&)) == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/4"
tags = ['any', 'assignment', 'move', 'noexcept']
function = "std::any::operator="
header = "<any>"
signature = '''any& operator=(any&& rhs) noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_any_reset_noexcept_b7c8d9e0', 'cpp20_weak_ptr_assignment_move_effect_c0e4a8f3', 'cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_utility_swap_array_noexcept_spec_w4x8y2z6', 'c11_cpp_translation_name_syntax_operation_018c4422']

[[axioms]]
id = "cpp20_any_swap_noexcept_d3e4f5a6"
content = '''The swap member function any::swap(any&) is noexcept.'''
formal_spec = '''noexcept(any::swap(any&)) == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/19"
tags = ['any', 'swap', 'noexcept']
function = "std::any::swap"
header = "<any>"
signature = '''void swap(any& rhs) noexcept'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_any_reset_noexcept_b7c8d9e0', 'cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_utility_swap_array_noexcept_spec_w4x8y2z6']

[[axioms]]
id = "cpp20_any_reset_noexcept_b7c8d9e0"
content = '''The reset member function any::reset() is noexcept.'''
formal_spec = '''noexcept(any::reset()) == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/17"
tags = ['any', 'reset', 'noexcept']
function = "std::any::reset"
header = "<any>"
signature = '''void reset() noexcept'''
depends_on = ['cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_utility_swap_array_noexcept_spec_w4x8y2z6']
