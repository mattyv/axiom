version = "1.0"
source = "eel.is/c++draft"
extracted_at = "2025-12-26T22:56:56.881486+00:00"

[[axioms]]
id = "cpp20_basic_life_delete_before_lifetime_7a1b2c3d"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a delete-expression is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && delete_expr(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.1"
tags = ['lifetime', 'delete', 'pointer', 'storage']

[[axioms]]
id = "cpp20_basic_life_member_access_before_lifetime_8b2c3d4e"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended to access a non-static data member or call a non-static member function is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && (access_nonstatic_member(ptr) || call_nonstatic_member_function(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.2"
tags = ['lifetime', 'member-access', 'pointer', 'storage']

[[axioms]]
id = "cpp20_basic_life_convert_to_virtual_base_ptr_9c3d4e5f"
content = '''Converting a pointer to storage where an object's lifetime has not started or has ended to a pointer to a virtual base class or base class thereof is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && (convert_to_virtual_base_ptr(ptr) || convert_to_base_of_virtual_base_ptr(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.3"
tags = ['lifetime', 'conversion', 'pointer', 'virtual-base', 'inheritance']

[[axioms]]
id = "cpp20_basic_life_dynamic_cast_ptr_before_lifetime_ad4e5f6a"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a dynamic_cast is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && dynamic_cast_operand(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.4"
tags = ['lifetime', 'dynamic_cast', 'pointer', 'storage', 'rtti']

[[axioms]]
id = "cpp20_basic_life_glvalue_access_before_lifetime_be5f6a7b"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended to access the object is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && access_object(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.1"
tags = ['lifetime', 'glvalue', 'access', 'storage']

[[axioms]]
id = "cpp20_basic_life_glvalue_call_member_before_lifetime_cf6a7b8c"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended to call a non-static member function is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && call_nonstatic_member_function(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.2"
tags = ['lifetime', 'glvalue', 'member-function', 'storage']

[[axioms]]
id = "cpp20_basic_life_glvalue_bind_virtual_base_ref_d07b8c9d"
content = '''Binding a glvalue that refers to storage where an object's lifetime has not started or has ended to a reference to a virtual base class is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && bind_to_virtual_base_ref(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.3"
tags = ['lifetime', 'glvalue', 'reference', 'virtual-base', 'binding']

[[axioms]]
id = "cpp20_basic_life_glvalue_dynamic_cast_typeid_e18c9dae"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended as the operand of dynamic_cast or typeid is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && (dynamic_cast_operand(glvalue) || typeid_operand(glvalue)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.4"
tags = ['lifetime', 'glvalue', 'dynamic_cast', 'typeid', 'rtti']

[[axioms]]
id = "cpp20_basic_life_nontrivial_destructor_not_called_f29daebf"
content = '''If a program ends the lifetime of an object with static, thread, or automatic storage duration that has a non-trivial destructor, and another object of the original type does not occupy that same storage location when the implicit destructor call takes place, the behavior is undefined.'''
formal_spec = '''has_storage_duration(obj, static | thread | automatic) && has_nontrivial_destructor(type(obj)) && lifetime_ended(obj) && !same_type_object_at_location(storage(obj), type(obj), implicit_destructor_call_time) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/11"
tags = ['lifetime', 'destructor', 'storage-duration', 'automatic', 'static', 'thread']

[[axioms]]
id = "cpp20_basic_life_create_in_const_storage_03aebfc0"
content = '''Creating a new object within the storage that a const complete object with static, thread, or automatic storage duration occupies, or within the storage that such a const object used to occupy before its lifetime ended, results in undefined behavior.'''
formal_spec = '''is_const(obj) && is_complete_object(obj) && has_storage_duration(obj, static | thread | automatic) && (create_new_object_in_storage(storage(obj)) || (lifetime_ended(obj) && create_new_object_in_former_storage(storage(obj)))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/12"
tags = ['lifetime', 'const', 'storage-duration', 'placement-new']

[[axioms]]
id = "cpp20_basic_life_storage_reuse_during_new_14bfc0d1"
content = '''When evaluating a new-expression, storage is considered reused after it is returned from the allocation function but before the evaluation of the new-initializer, making access to the original object undefined.'''
formal_spec = '''new_expression(ptr) && after_allocation_return(ptr) && before_new_initializer_eval(ptr) && access_original_object(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'new-expression', 'storage', 'initialization']

[[axioms]]
id = "cpp20_basic_life_lifetime_begin_storage_alignment_25c0d1e2"
content = '''The lifetime of an object of type T begins only when storage with the proper alignment and size for type T is obtained and its initialization is complete.'''
formal_spec = '''lifetime_begins(obj, T) <=> storage_obtained(obj, alignment(T), size(T)) && initialization_complete(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.1-2.2"
tags = ['lifetime', 'storage', 'alignment', 'initialization']

[[axioms]]
id = "cpp20_basic_life_union_member_lifetime_36d1e2f3"
content = '''For a union member or subobject thereof, its lifetime only begins if that union member is the initialized member in the union, or as described in specific clauses about union member access and copy operations.'''
formal_spec = '''is_union_member(obj) || is_subobject_of_union_member(obj) => (lifetime_begins(obj) <=> is_initialized_union_member(obj) || union_member_access_rules(obj))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'union', 'initialization', 'member']

[[axioms]]
id = "cpp20_basic_life_end_nonclass_destroy_47e2f304"
content = '''The lifetime of an object of non-class type ends when the object is destroyed.'''
formal_spec = '''!is_class_type(T) && type(obj) == T => (lifetime_ends(obj) <=> destroyed(obj))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.3"
tags = ['lifetime', 'non-class', 'destruction']

[[axioms]]
id = "cpp20_basic_life_end_class_destructor_start_58f30415"
content = '''The lifetime of an object of class type ends when the destructor call starts.'''
formal_spec = '''is_class_type(T) && type(obj) == T => (lifetime_ends(obj) <=> destructor_call_starts(obj))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.4"
tags = ['lifetime', 'class', 'destructor']

[[axioms]]
id = "cpp20_basic_life_end_storage_released_69041526"
content = '''The lifetime of an object ends when the storage which the object occupies is released or is reused by an object that is not nested within it.'''
formal_spec = '''lifetime_ends(obj) <== storage_released(storage(obj)) || (storage_reused(storage(obj), new_obj) && !nested_within(new_obj, obj))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.5"
tags = ['lifetime', 'storage', 'release', 'reuse']

[[axioms]]
id = "cpp20_basic_life_reference_lifetime_begin_7a152637"
content = '''The lifetime of a reference begins when its initialization is complete.'''
formal_spec = '''is_reference(ref) => (lifetime_begins(ref) <=> initialization_complete(ref))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/3"
tags = ['lifetime', 'reference', 'initialization']

[[axioms]]
id = "cpp20_basic_life_properties_during_lifetime_8b263748"
content = '''The properties ascribed to objects and references throughout the C++ standard apply for a given object or reference only during its lifetime.'''
formal_spec = '''object_properties_apply(obj) <=> during_lifetime(obj)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "basic.life"
source_module = "[basic.life]/5"
tags = ['lifetime', 'object', 'reference', 'properties']

[[axioms]]
id = "cpp20_basic_life_transparent_replacement_ptr_validity_9c374859"
content = '''After an object's lifetime has ended and before storage is reused or released, if a new object is created at the same storage location and the original object was transparently replaceable by the new object, pointers, references, and names that referred to the original object automatically refer to the new object.'''
formal_spec = '''lifetime_ended(obj1) && !storage_reused_or_released(storage(obj1)) && create_new_object(obj2, storage(obj1)) && transparently_replaceable(obj1, obj2) => (pointer_to(obj1) == pointer_to(obj2) && reference_to(obj1) == reference_to(obj2) && name_of(obj1) == name_of(obj2))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "basic.life"
source_module = "[basic.life]/10"
tags = ['lifetime', 'transparent-replacement', 'pointer', 'reference']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_complete_obj_ad485960"
content = '''A complete object o1 is transparently replaceable by a complete object o2 if o1 is not const, the storage that o2 occupies exactly overlays the storage that o1 occupied, and o1 and o2 are of the same type ignoring top-level cv-qualifiers.'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && !is_const(o1) && storage_exactly_overlays(o2, o1) && same_type_ignore_cv(type(o1), type(o2)) => transparently_replaceable(o1, o2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/9.1"
tags = ['lifetime', 'transparent-replacement', 'complete-object', 'const']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_subobject_be596a71"
content = '''Direct subobjects o1 and o2 are transparently replaceable if the complete object of o1 is not const, or o1 is a mutable member subobject or a subobject thereof.'''
formal_spec = '''is_direct_subobject(o1) && is_direct_subobject(o2) && corresponding_subobjects(o1, o2) && (!is_const(complete_object(o1)) || is_mutable_member_or_subobject(o1)) => transparently_replaceable(o1, o2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/9.2"
tags = ['lifetime', 'transparent-replacement', 'subobject', 'mutable']

[[axioms]]
id = "cpp20_basic_life_delete_before_lifetime_a7b3c1d2"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a delete-expression is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && delete_expr(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.1"
tags = ['lifetime', 'delete', 'pointer']

[[axioms]]
id = "cpp20_basic_life_member_access_before_lifetime_e4f5a6b7"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended to access a non-static data member or call a non-static member function is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && (access_nonstatic_member(ptr) || call_nonstatic_member_func(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.2"
tags = ['lifetime', 'member-access', 'pointer']

[[axioms]]
id = "cpp20_basic_life_ptr_conv_virtual_base_c8d9e0f1"
content = '''Converting a pointer to storage where an object's lifetime has not started or has ended to a pointer to a virtual base class or base class thereof is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && (convert_to_virtual_base(ptr) || convert_to_base_of_virtual_base(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.3"
tags = ['lifetime', 'pointer', 'conversion', 'virtual-base']

[[axioms]]
id = "cpp20_basic_life_dynamic_cast_ptr_before_lifetime_2a3b4c5d"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a dynamic_cast is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && dynamic_cast_operand(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.4"
tags = ['lifetime', 'pointer', 'dynamic_cast']

[[axioms]]
id = "cpp20_basic_life_glvalue_access_before_lifetime_6e7f8a9b"
content = '''Using a glvalue to access an object before its lifetime has started or after its lifetime has ended is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && access_object(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.1"
tags = ['lifetime', 'glvalue', 'access']

[[axioms]]
id = "cpp20_basic_life_glvalue_member_call_before_lifetime_0c1d2e3f"
content = '''Using a glvalue to call a non-static member function of an object before its lifetime has started or after its lifetime has ended is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && call_nonstatic_member_func(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.2"
tags = ['lifetime', 'glvalue', 'member-function']

[[axioms]]
id = "cpp20_basic_life_glvalue_bind_virtual_base_4a5b6c7d"
content = '''Binding a glvalue that refers to storage where an object's lifetime has not started or has ended to a reference to a virtual base class is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && bind_to_virtual_base_ref(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.3"
tags = ['lifetime', 'glvalue', 'reference', 'virtual-base']

[[axioms]]
id = "cpp20_basic_life_glvalue_dynamic_cast_typeid_8e9f0a1b"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended as the operand of dynamic_cast or typeid is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && (dynamic_cast_operand(glvalue) || typeid_operand(glvalue)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.4"
tags = ['lifetime', 'glvalue', 'dynamic_cast', 'typeid']

[[axioms]]
id = "cpp20_basic_life_implicit_destructor_no_replacement_2c3d4e5f"
content = '''If a program ends the lifetime of an object with static, thread, or automatic storage duration that has a non-trivial destructor, and another object of the original type does not occupy that storage location when the implicit destructor call takes place, the behavior is undefined.'''
formal_spec = '''(has_static_storage(obj) || has_thread_storage(obj) || has_automatic_storage(obj)) && has_nontrivial_destructor(type(obj)) && lifetime_ended(obj) && !same_type_object_occupies_storage_at_implicit_destructor_call(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/11"
tags = ['lifetime', 'destructor', 'storage-duration']

[[axioms]]
id = "cpp20_basic_life_create_in_const_storage_6a7b8c9d"
content = '''Creating a new object within the storage that a const complete object with static, thread, or automatic storage duration occupies, or within the storage that such a const object used to occupy before its lifetime ended, results in undefined behavior.'''
formal_spec = '''is_const(original_obj) && is_complete_object(original_obj) && (has_static_storage(original_obj) || has_thread_storage(original_obj) || has_automatic_storage(original_obj)) && create_new_object_in_storage(original_obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/12"
tags = ['lifetime', 'const', 'storage', 'placement-new']

[[axioms]]
id = "cpp20_basic_life_reuse_during_new_init_0e1f2a3b"
content = '''When evaluating a new-expression, accessing the storage after it is returned from the allocation function but before the evaluation of the new-initializer is complete causes undefined behavior if the access depends on the object's value.'''
formal_spec = '''new_expr_in_progress(storage) && after_allocation_return(storage) && before_new_initializer_complete(storage) && access_object_value(storage) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'new-expression', 'initialization']

[[axioms]]
id = "cpp20_basic_life_union_member_lifetime_4c5d6e7f"
content = '''The lifetime of a union member or subobject thereof only begins if that union member is the initialized member in the union, or as described in [class.union], [class.copy.ctor], and [class.copy.assign].'''
formal_spec = '''is_union_member(obj) && !is_initialized_union_member(obj) && !activated_by_class_union_rules(obj) && !activated_by_copy_rules(obj) => !lifetime_started(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'union', 'initialization']

[[axioms]]
id = "cpp20_basic_life_starts_storage_and_init_8a9b0c1d"
content = '''The lifetime of an object of type T begins only when storage with proper alignment and size for type T is obtained and its initialization is complete.'''
formal_spec = '''lifetime_started(obj, T) <=> (storage_obtained(obj, alignment(T), size(T)) && initialization_complete(obj))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'storage', 'initialization']

[[axioms]]
id = "cpp20_basic_life_ends_nonclass_destroy_2e3f4a5b"
content = '''The lifetime of an object of non-class type ends when the object is destroyed.'''
formal_spec = '''!is_class_type(T) && is_destroyed(obj, T) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.3"
tags = ['lifetime', 'destruction', 'non-class']

[[axioms]]
id = "cpp20_basic_life_ends_class_destructor_start_6c7d8e9f"
content = '''The lifetime of an object of class type ends when the destructor call starts.'''
formal_spec = '''is_class_type(T) && destructor_call_starts(obj, T) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.4"
tags = ['lifetime', 'destructor', 'class']

[[axioms]]
id = "cpp20_basic_life_ends_storage_released_0a1b2c3d"
content = '''The lifetime of an object ends when the storage which the object occupies is released.'''
formal_spec = '''storage_released(obj) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.5"
tags = ['lifetime', 'storage', 'deallocation']

[[axioms]]
id = "cpp20_basic_life_ends_storage_reused_4e5f6a7b"
content = '''The lifetime of an object ends when the storage which the object occupies is reused by an object that is not nested within it.'''
formal_spec = '''storage_reused_by_non_nested(obj, new_obj) && !nested_within(new_obj, obj) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.5"
tags = ['lifetime', 'storage', 'reuse']

[[axioms]]
id = "cpp20_basic_life_properties_during_lifetime_8c9d0e1f"
content = '''The properties ascribed to objects and references throughout the C++ standard apply for a given object or reference only during its lifetime.'''
formal_spec = '''applies_object_properties(obj) => lifetime_active(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/5"
tags = ['lifetime', 'object-properties']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_not_const_2a3b4c5d"
content = '''An object o1 is transparently replaceable by an object o2 only if (for complete objects) o1 is not const.'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && transparently_replaceable(o1, o2) => !is_const(o1)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/9.1.1"
tags = ['lifetime', 'transparent-replacement', 'const']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_same_storage_6e7f8a9b"
content = '''An object o1 is transparently replaceable by an object o2 only if (for complete objects) the storage that o2 occupies exactly overlays the storage that o1 occupied.'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && transparently_replaceable(o1, o2) => storage_exactly_overlays(o2, o1)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/9.1.2"
tags = ['lifetime', 'transparent-replacement', 'storage']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_same_type_0c1d2e3f"
content = '''An object o1 is transparently replaceable by an object o2 only if (for complete objects) o1 and o2 are of the same type (ignoring top-level cv-qualifiers).'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && transparently_replaceable(o1, o2) => same_type_ignoring_cv(o1, o2)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/9.1.3"
tags = ['lifetime', 'transparent-replacement', 'type']

[[axioms]]
id = "cpp20_basic_stc_dynamic_general_semantic_violation_ub_8f3a2b1c"
content = '''If the behavior of an allocation or deallocation function does not satisfy the semantic constraints specified in [basic.stc.dynamic.allocation] and [basic.stc.dynamic.deallocation], the behavior is undefined.'''
formal_spec = '''(is_allocation_function(F) || is_deallocation_function(F)) && !satisfies_semantic_constraints(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.general"
source_module = "[basic.stc.dynamic.general]/3"
tags = ['memory', 'allocation', 'deallocation', 'dynamic-storage']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_global_scope_d4e5f6a7"
content = '''An allocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage.'''
formal_spec = '''is_allocation_function(F) && !is_class_member_function(F) => belongs_to_global_scope(F) && !has_internal_linkage(name(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'linkage', 'scope']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_return_type_b2c3d4e5"
content = '''The return type of an allocation function shall be void*.'''
formal_spec = '''is_allocation_function(F) => return_type(F) == void_ptr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_first_param_type_c3d4e5f6"
content = '''The first parameter of an allocation function shall have type std::size_t.'''
formal_spec = '''is_allocation_function(F) => param_type(F, 0) == std_size_t'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_no_default_arg_a1b2c3d4"
content = '''The first parameter of an allocation function shall not have an associated default argument.'''
formal_spec = '''is_allocation_function(F) => !has_default_argument(param(F, 0))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'default-argument']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_zero_size_deref_ub_e5f6a7b8"
content = '''The effect of indirecting through a pointer returned from a request for zero size is undefined.'''
formal_spec = '''allocation_request_size(ptr) == 0 && successful_allocation(ptr) && dereference(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['memory', 'allocation', 'pointer', 'dereference', 'zero-size']
c_standard_refs = ['7.22.3/1']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_nothrow_null_return_f6a7b8c9"
content = '''An allocation function that has a non-throwing exception specification indicates failure by returning a null pointer value.'''
formal_spec = '''is_allocation_function(F) && has_nothrow_exception_spec(F) && allocation_fails(F) => returns_null(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['memory', 'allocation', 'exception', 'null-pointer']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_throwing_never_null_a7b8c9d0"
content = '''Any allocation function without a non-throwing exception specification never returns a null pointer value and indicates failure only by throwing an exception of a type that would match a handler of type std::bad_alloc.'''
formal_spec = '''is_allocation_function(F) && !has_nothrow_exception_spec(F) => !returns_null(F) && (allocation_fails(F) => throws_exception_matching(F, std_bad_alloc))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['memory', 'allocation', 'exception', 'bad_alloc']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_global_scope_b8c9d0e1"
content = '''A deallocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage.'''
formal_spec = '''is_deallocation_function(F) && !is_class_member_function(F) => belongs_to_global_scope(F) && !has_internal_linkage(name(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/1"
tags = ['memory', 'deallocation', 'linkage', 'scope']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_class_member_c9d0e1f2"
content = '''A destroying operator delete shall be a class member function named operator delete.'''
formal_spec = '''is_destroying_operator_delete(F) => is_class_member_function(F) && name(F) == "operator delete"'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/2"
tags = ['memory', 'deallocation', 'destroying-delete', 'class-member']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_return_void_d0e1f2a3"
content = '''Each deallocation function shall return void.'''
formal_spec = '''is_deallocation_function(F) => return_type(F) == void'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_first_param_type_e1f2a3b4"
content = '''If the deallocation function is a destroying operator delete declared in class type C, the type of its first parameter shall be C*; otherwise, the type of its first parameter shall be void*.'''
formal_spec = '''is_deallocation_function(F) && is_destroying_operator_delete(F) && declared_in_class(F, C) => param_type(F, 0) == ptr_to(C); is_deallocation_function(F) && !is_destroying_operator_delete(F) => param_type(F, 0) == void_ptr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'type-constraint', 'destroying-delete']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_usual_f2a3b4c5"
content = '''A destroying operator delete shall be a usual deallocation function.'''
formal_spec = '''is_destroying_operator_delete(F) => is_usual_deallocation_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'destroying-delete']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_exception_ub_a3b4c5d6"
content = '''If a deallocation function terminates by throwing an exception, the behavior is undefined.'''
formal_spec = '''is_deallocation_function(F) && terminates_by_throwing(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/4"
tags = ['memory', 'deallocation', 'exception']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_stdlib_nonnull_b4c5d6e7"
content = '''If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, ending the duration of the region of storage.'''
formal_spec = '''is_stdlib_deallocation_function(F) && arg(F, 0) != null_ptr => deallocates_storage(F, arg(F, 0)) && ends_storage_duration(arg(F, 0))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/5"
tags = ['memory', 'deallocation', 'stdlib']
c_standard_refs = ['7.22.3.3']

[[axioms]]
id = "cpp20_basic_stc_static_side_effects_no_eliminate_c5d6e7f8"
content = '''If a variable with static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in [class.copy.elision].'''
formal_spec = '''has_static_storage_duration(V) && (has_side_effect_initialization(V) || has_side_effect_destructor(V)) => !may_eliminate(V) || is_copy_move_elision_permitted(V)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.static"
source_module = "[basic.stc.static]/2"
tags = ['storage-duration', 'static', 'side-effects', 'optimization']

[[axioms]]
id = "cpp20_basic_stc_auto_side_effects_no_eliminate_d6e7f8a9"
content = '''If a variable with automatic storage duration has initialization or a destructor with side effects, an implementation shall not destroy it before the end of its block nor eliminate it as an optimization, even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in [class.copy.elision].'''
formal_spec = '''has_automatic_storage_duration(V) && (has_side_effect_initialization(V) || has_side_effect_destructor(V)) => (!destroyed_before_block_end(V) && !may_eliminate(V)) || is_copy_move_elision_permitted(V)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.auto"
source_module = "[basic.stc.auto]/2"
tags = ['storage-duration', 'automatic', 'side-effects', 'optimization', 'lifetime']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_template_return_first_e7f8a9b0"
content = '''An allocation function template shall declare its return type and first parameter as specified (void* return type and std::size_t first parameter) - template parameter types shall not be used in the return type and first parameter type.'''
formal_spec = '''is_allocation_function_template(F) => return_type(F) == void_ptr && param_type(F, 0) == std_size_t && !uses_template_param(return_type(F)) && !uses_template_param(param_type(F, 0))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'template', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_template_min_params_f8a9b0c1"
content = '''Allocation function templates shall have two or more parameters.'''
formal_spec = '''is_allocation_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'template']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_constraints_a9b0c1d2"
content = '''For a deallocation function template, neither the first parameter nor the return type shall depend on a template parameter.'''
formal_spec = '''is_deallocation_function_template(F) => !depends_on_template_param(param_type(F, 0)) && !depends_on_template_param(return_type(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'template', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_min_params_b0c1d2e3"
content = '''A deallocation function template shall have two or more function parameters.'''
formal_spec = '''is_deallocation_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'template']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_not_usual_c1d2e3f4"
content = '''A template instance is never a usual deallocation function, regardless of its signature.'''
formal_spec = '''is_template_instance(F) && is_deallocation_function(F) => !is_usual_deallocation_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'template']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_align_val_alignment_d2e3f4a5"
content = '''For an allocation function other than a reserved placement allocation function that takes an argument of type std::align_val_t, the storage returned on a successful call will have the alignment specified by the value of this argument.'''
formal_spec = '''is_allocation_function(F) && !is_reserved_placement_allocation(F) && has_param_type(F, std_align_val_t) && successful_call(F) => alignment(returned_storage(F)) == value_of_align_val_t_arg(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3"
tags = ['memory', 'allocation', 'alignment']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_array_alignment_e3f4a5b6"
content = '''For an allocation function named operator new[] that does not take an std::align_val_t argument, the storage returned is aligned for any object that does not have new-extended alignment and is no larger than the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new[]" && !has_param_type(F, std_align_val_t) && !is_reserved_placement_allocation(F) && successful_call(F) => aligned_for_any_object_without_new_extended_alignment_up_to_size(returned_storage(F), requested_size(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3"
tags = ['memory', 'allocation', 'alignment', 'array']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_single_alignment_f4a5b6c7"
content = '''For an allocation function named operator new that does not take an std::align_val_t argument, the storage returned is aligned for any object that does not have new-extended alignment and is of the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new" && !has_param_type(F, std_align_val_t) && !is_reserved_placement_allocation(F) && successful_call(F) => aligned_for_any_object_without_new_extended_alignment_of_size(returned_storage(F), requested_size(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3"
tags = ['memory', 'allocation', 'alignment']

[[axioms]]
id = "cpp20_basic_stc_dynamic_general_alloc_dealloc_semantics_a3f8b2c1"
content = '''If the behavior of an allocation or deallocation function does not satisfy the semantic constraints specified in [basic.stc.dynamic.allocation] and [basic.stc.dynamic.deallocation], the behavior is undefined.'''
formal_spec = '''(is_allocation_function(F) || is_deallocation_function(F)) && !satisfies_semantic_constraints(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.general"
source_module = "[basic.stc.dynamic.general]/3"
tags = ['allocation', 'deallocation', 'semantics', 'undefined-behavior']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_return_type_void_ptr_b2c3d4e5"
content = '''The return type of an allocation function shall be void*.'''
formal_spec = '''is_allocation_function(F) => return_type(F) == void_ptr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'return-type', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_first_param_size_t_c3d4e5f6"
content = '''The first parameter of an allocation function shall have type std::size_t.'''
formal_spec = '''is_allocation_function(F) => param_type(F, 0) == std_size_t'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_no_default_first_param_e5f6a7b8"
content = '''The first parameter of an allocation function shall not have an associated default argument.'''
formal_spec = '''is_allocation_function(F) => !has_default_argument(param(F, 0))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'parameter', 'default-argument', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_template_params_f6a7b8c9"
content = '''Allocation function templates shall have two or more parameters.'''
formal_spec = '''is_allocation_function(F) && is_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'template', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_zero_size_deref_ub_a7b8c9d0"
content = '''The effect of indirecting through a pointer returned from a request for zero size is undefined.'''
formal_spec = '''allocation_request_size(ptr) == 0 && dereference(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'zero-size', 'dereference', 'undefined-behavior']
c_standard_refs = ['7.22.3/1']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_nothrow_null_return_b8c9d0e1"
content = '''An allocation function that has a non-throwing exception specification indicates failure by returning a null pointer value.'''
formal_spec = '''is_allocation_function(F) && has_nothrow_spec(F) && allocation_fails(F) => returns_null(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['allocation', 'nothrow', 'null', 'exception']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_throwing_never_null_c9d0e1f2"
content = '''Any allocation function without a non-throwing exception specification never returns a null pointer value and indicates failure only by throwing an exception of a type that would match a handler of type std::bad_alloc.'''
formal_spec = '''is_allocation_function(F) && !has_nothrow_spec(F) => (!returns_null(F) && (allocation_fails(F) => throws_bad_alloc_compatible(F)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['allocation', 'exception', 'bad_alloc', 'null']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_global_scope_d0e1f2a3"
content = '''A deallocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage.'''
formal_spec = '''is_deallocation_function(F) && !is_class_member(F) => (has_global_scope(F) && !has_internal_linkage(name(F)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/1"
tags = ['deallocation', 'linkage', 'scope', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_delete_class_e1f2a3b4"
content = '''A destroying operator delete shall be a class member function named operator delete.'''
formal_spec = '''is_destroying_operator_delete(F) => (is_class_member(F) && name(F) == "operator delete")'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/2"
tags = ['deallocation', 'destroying-delete', 'class-member', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_return_void_f2a3b4c5"
content = '''Each deallocation function shall return void.'''
formal_spec = '''is_deallocation_function(F) => return_type(F) == void'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'return-type', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_first_param_type_a3b4c5d6"
content = '''If a deallocation function is a destroying operator delete declared in class type C, the type of its first parameter shall be C*; otherwise, the type of its first parameter shall be void*.'''
formal_spec = '''is_deallocation_function(F) => (is_destroying_operator_delete_in_class(F, C) ? param_type(F, 0) == ptr_to(C) : param_type(F, 0) == void_ptr)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'parameter', 'destroying-delete', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_usual_b4c5d6e7"
content = '''A destroying operator delete shall be a usual deallocation function.'''
formal_spec = '''is_destroying_operator_delete(F) => is_usual_deallocation_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'destroying-delete', 'usual', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_params_c5d6e7f8"
content = '''A deallocation function template shall have two or more function parameters.'''
formal_spec = '''is_deallocation_function(F) && is_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'template', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_first_param_d6e7f8a9"
content = '''Neither the first parameter nor the return type of a deallocation function template shall depend on a template parameter.'''
formal_spec = '''is_deallocation_function(F) && is_function_template(F) => (!depends_on_template_param(param_type(F, 0)) && !depends_on_template_param(return_type(F)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'template', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_throw_ub_e7f8a9b0"
content = '''If a deallocation function terminates by throwing an exception, the behavior is undefined.'''
formal_spec = '''is_deallocation_function(F) && terminates_by_throwing(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/4"
tags = ['deallocation', 'exception', 'undefined-behavior']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_null_no_effect_f8a9b0c1"
content = '''The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect.'''
formal_spec = '''is_deallocation_function(F) && is_stdlib_deallocation(F) && arg(F, 0) == nullptr => no_effect(call(F))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/4"
tags = ['deallocation', 'null', 'stdlib', 'semantics']
c_standard_refs = ['7.22.3.3/2']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_shall_deallocate_a9b0c1d2"
content = '''If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, ending the duration of the region of storage.'''
formal_spec = '''is_stdlib_deallocation(F) && arg(F, 0) != nullptr => (deallocates_storage(F, arg(F, 0)) && ends_storage_duration(arg(F, 0)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/5"
tags = ['deallocation', 'storage', 'stdlib', 'semantics']
c_standard_refs = ['7.22.3.3/2']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_alignment_align_val_b0c1d2e3"
content = '''For an allocation function other than a reserved placement allocation function, if the allocation function takes an argument of type std::align_val_t, the storage will have the alignment specified by the value of this argument.'''
formal_spec = '''is_allocation_function(F) && !is_reserved_placement(F) && has_param_type(F, std_align_val_t) && succeeds(F) => alignment(returned_storage(F)) == align_val_arg(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3.1"
tags = ['allocation', 'alignment', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_alignment_array_c1d2e3f4"
content = '''For an allocation function named operator new[] without std::align_val_t parameter (and not a reserved placement allocation function), the storage is aligned for any object that does not have new-extended alignment and is no larger than the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new[]" && !has_param_type(F, std_align_val_t) && !is_reserved_placement(F) && succeeds(F) => aligned_for_any_object_up_to_size(returned_storage(F), requested_size(F), !new_extended_alignment)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3.2"
tags = ['allocation', 'alignment', 'array', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_alignment_single_d2e3f4a5"
content = '''For an allocation function named operator new without std::align_val_t parameter (and not a reserved placement allocation function), the storage is aligned for any object that does not have new-extended alignment and is of the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new" && !has_param_type(F, std_align_val_t) && !is_reserved_placement(F) && succeeds(F) => aligned_for_any_object_of_size(returned_storage(F), requested_size(F), !new_extended_alignment)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3.3"
tags = ['allocation', 'alignment', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_min_size_e3f4a5b6"
content = '''If an allocation function is successful, it returns the address of the start of a block of storage whose length in bytes is at least as large as the requested size.'''
formal_spec = '''is_allocation_function(F) && succeeds(F) => storage_size(returned_storage(F)) >= requested_size(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'size', 'semantics']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_replaceable_unique_ptr_f4a5b6c7"
content = '''If the request succeeds, the value returned by a replaceable allocation function is a non-null pointer value p0 different from any previously returned value p1, unless that value p1 was subsequently passed to a replaceable deallocation function.'''
formal_spec = '''is_replaceable_allocation(F) && succeeds(F) => (returned_ptr(F) != nullptr && (forall p1. (previously_returned(p1) && !subsequently_deallocated(p1)) => returned_ptr(F) != p1))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'replaceable', 'pointer', 'uniqueness']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_disjoint_storage_a5b6c7d8"
content = '''For the library allocation functions in [new.delete.single] and [new.delete.array], the returned pointer p0 represents the address of a block of storage disjoint from the storage for any other object accessible to the caller.'''
formal_spec = '''is_stdlib_allocation(F) && succeeds(F) => disjoint_from_accessible_objects(returned_storage(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'stdlib', 'disjoint', 'storage']

[[axioms]]
id = "cpp20_expr_pre_math_undefined_result_7b3f8a2e"
content = '''If during the evaluation of an expression, the result is not mathematically defined, the behavior is undefined.'''
formal_spec = '''eval(expr) && !mathematically_defined(result(expr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.pre"
source_module = "[expr.pre]/4"
tags = ['expression', 'evaluation', 'arithmetic', 'undefined-behavior']
c_standard_refs = ['6.5/5']

[[axioms]]
id = "cpp20_expr_pre_out_of_range_result_c4d9e1f0"
content = '''If during the evaluation of an expression, the result is not in the range of representable values for its type, the behavior is undefined.'''
formal_spec = '''eval(expr) && !in_range(result(expr), type(expr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.pre"
source_module = "[expr.pre]/4"
tags = ['expression', 'evaluation', 'overflow', 'range', 'undefined-behavior']
c_standard_refs = ['6.5/5']

[[axioms]]
id = "cpp20_expr_pre_builtin_op_rules_preserved_a8c2b5d1"
content = '''Operator overloading shall not modify the rules for the built-in operators, that is, for operators applied to types for which they are defined by this Standard.'''
formal_spec = '''is_overloaded_operator(op) && is_builtin_type(operand_types(op)) => apply_builtin_rules(op)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.pre"
source_module = "[expr.pre]/3"
tags = ['operator', 'overloading', 'builtin', 'constraint']

[[axioms]]
id = "cpp20_basic_lval_prvalue_complete_type_a3f8c2d1"
content = '''A prvalue shall always have complete type or the void type; if it has a class type or array of class type, that class shall not be an abstract class.'''
formal_spec = '''is_prvalue(E) => (is_complete_type(type(E)) || is_void_type(type(E))) && (is_class_type(type(E)) || is_array_of_class_type(type(E)) => !is_abstract_class(class_of(type(E))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/9"
tags = ['expression', 'prvalue', 'complete-type', 'abstract-class']

[[axioms]]
id = "cpp20_basic_lval_glvalue_not_void_b7e4d2f9"
content = '''A glvalue shall not have type cv void.'''
formal_spec = '''is_glvalue(E) => !is_cv_void_type(type(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/9"
tags = ['expression', 'glvalue', 'void', 'type']

[[axioms]]
id = "cpp20_basic_lval_type_access_ub_c8a1e3f5"
content = '''If a program attempts to access the stored value of an object through a glvalue through which it is not type-accessible, the behavior is undefined.'''
formal_spec = '''access_stored_value(obj, glv) && !type_accessible(dynamic_type(obj), type(glv)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/11"
tags = ['aliasing', 'type-access', 'strict-aliasing', 'undefined-behavior']
c_standard_refs = ['6.5/7']

[[axioms]]
id = "cpp20_basic_lval_type_accessible_similar_d4b2c8e7"
content = '''An object of dynamic type Tobj is type-accessible through a glvalue of type Tref only if Tref is similar to Tobj, or is the signed/unsigned corresponding type, or is char, unsigned char, or std::byte.'''
formal_spec = '''type_accessible(Tobj, Tref) <=> (similar(Tref, Tobj) || is_signed_unsigned_corresponding(Tref, Tobj) || Tref == char || Tref == unsigned_char || Tref == std::byte)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/11"
tags = ['aliasing', 'type-access', 'strict-aliasing']
c_standard_refs = ['6.5/7']

[[axioms]]
id = "cpp20_basic_lval_union_copy_move_ub_e9f3a6c2"
content = '''If a program invokes a defaulted copy/move constructor or copy/move assignment operator for a union of type U with a glvalue argument that does not denote an object of type cv U within its lifetime, the behavior is undefined.'''
formal_spec = '''invoke_defaulted_copy_move(union_type(U), glv) && !(denotes_object_within_lifetime(glv, cv_qualified(U))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/11"
tags = ['union', 'copy-constructor', 'move-constructor', 'lifetime', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_type_reference_invalid_ptr_ub_f2a7b4d8"
content = '''If an expression has type "reference to T" and a pointer to the denoted object or function would be invalid in the context of the evaluation, the behavior is undefined.'''
formal_spec = '''has_reference_type(E, T) && !valid_pointer_context(pointer_to(denoted_entity(E)), eval_context(E)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.type"
source_module = "[expr.type]/1"
tags = ['reference', 'pointer', 'validity', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_type_reference_lifetime_ub_a1c5d9e3"
content = '''Before the lifetime of the reference has started or after it has ended, using the expression with reference type is undefined behavior.'''
formal_spec = '''has_reference_type(E, T) && (!lifetime_started(reference_of(E)) || lifetime_ended(reference_of(E))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.type"
source_module = "[expr.type]/1"
tags = ['reference', 'lifetime', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_type_composite_ptr_ill_formed_b3d6f8a2"
content = '''A program that necessitates the determination of a composite pointer type when no valid composite pointer type exists is ill-formed.'''
formal_spec = '''requires_composite_pointer_type(p1, p2) && !exists_composite_pointer_type(type(p1), type(p2)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.type"
source_module = "[expr.type]/3.9"
tags = ['pointer', 'composite-pointer-type', 'ill-formed']

[[axioms]]
id = "cpp20_basic_lval_modify_const_ill_formed_c7e2a4b9"
content = '''A program that attempts to modify an object through a nonmodifiable lvalue or through an rvalue is ill-formed.'''
formal_spec = '''(modify_through(lv, obj) && !modifiable_lvalue(lv)) || modify_through_rvalue(rv, obj) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.lval"
source_module = "[basic.lval]/10"
tags = ['const', 'modifiable', 'lvalue', 'rvalue', 'assignment']

[[axioms]]
id = "cpp20_basic_lval_modifiable_def_d8f1c5e6"
content = '''An lvalue is modifiable unless its type is const-qualified or is a function type.'''
formal_spec = '''modifiable_lvalue(lv) <=> is_lvalue(lv) && !is_const_qualified(type(lv)) && !is_function_type(type(lv))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/10"
tags = ['lvalue', 'modifiable', 'const', 'function-type']

[[axioms]]
id = "cpp20_basic_lval_unique_category_e4a3b7c8"
content = '''Every expression belongs to exactly one of the fundamental categories: lvalue, xvalue, or prvalue.'''
formal_spec = '''forall E: is_expression(E) => exactly_one(is_lvalue(E), is_xvalue(E), is_prvalue(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/2"
tags = ['expression', 'value-category', 'lvalue', 'xvalue', 'prvalue']

[[axioms]]
id = "cpp20_expr_prim_this_invalid_context_a1b2c3d4"
content = '''The expression 'this' shall not appear in any context other than within member function bodies, non-static data member default initializers, or contract assertion predicates of the current class.'''
formal_spec = '''appears(this_expr, context) && !valid_this_context(context) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.this"
source_module = "[expr.prim.this]/6"
tags = ['this', 'member-function', 'context']

[[axioms]]
id = "cpp20_expr_prim_this_static_member_e5f6a7b8"
content = '''The expression 'this' shall not appear within the declaration of a static or explicit object member function of the current class.'''
formal_spec = '''appears(this_expr, decl) && (is_static_member_function(decl) || is_explicit_object_member_function(decl)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.this"
source_module = "[expr.prim.this]/4"
tags = ['this', 'static', 'member-function']

[[axioms]]
id = "cpp20_expr_prim_id_ctor_pre_dtor_post_c9d0e1f2"
content = '''If the implicit transformation of an id-expression to a class member access using (*this) occurs in the predicate of a precondition assertion of a constructor or postcondition assertion of a destructor of the current class, the expression is ill-formed.'''
formal_spec = '''id_expr_transform_to_member_access(E, X) && ((in_precondition(E) && is_constructor(enclosing_function(E), X)) || (in_postcondition(E) && is_destructor(enclosing_function(E), X))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.general"
source_module = "[expr.prim.id.general]/2"
tags = ['id-expression', 'contract', 'constructor', 'destructor', 'precondition', 'postcondition']

[[axioms]]
id = "cpp20_expr_prim_id_base_class_splice_g3h4i5j6"
content = '''A splice-expression that designates a direct base class relationship shall appear only as the second operand of a class member access.'''
formal_spec = '''splice_expr_designates_base_class(E) && !is_second_operand_of_member_access(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.general"
source_module = "[expr.prim.id.general]/5"
tags = ['splice', 'base-class', 'member-access']

[[axioms]]
id = "cpp20_expr_prim_id_nonstatic_usage_k7l8m9n0"
content = '''An id-expression or splice-expression that designates a non-static data member or implicit object member function can only be used as part of a class member access, to form a pointer to member, or in an unevaluated operand (for data members only).'''
formal_spec = '''(designates_nonstatic_data_member(E) || designates_implicit_object_member_function(E)) && !is_class_member_access(E) && !forms_pointer_to_member(E) && !(designates_nonstatic_data_member(E) && is_unevaluated_operand(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.general"
source_module = "[expr.prim.id.general]/4"
tags = ['id-expression', 'non-static', 'member-access', 'pointer-to-member']

[[axioms]]
id = "cpp20_expr_prim_pack_index_must_be_pack_o1p2q3r4"
content = '''The id-expression P in a pack-index-expression shall be an identifier that denotes a pack.'''
formal_spec = '''pack_index_expression(P, idx) && !denotes_pack(P) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.pack.index"
source_module = "[expr.prim.pack.index]/1"
tags = ['pack', 'variadic', 'pack-index']

[[axioms]]
id = "cpp20_expr_prim_pack_index_bounds_s5t6u7v8"
content = '''The index in a pack-index-expression shall be a converted constant expression of type std::size_t whose value V satisfies 0 <= V < sizeof...(P).'''
formal_spec = '''pack_index_expression(P, V) && (V < 0 || V >= sizeof_pack(P)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.pack.index"
source_module = "[expr.prim.pack.index]/2"
tags = ['pack', 'variadic', 'pack-index', 'bounds']

[[axioms]]
id = "cpp20_expr_prim_dtor_pseudo_context_w9x0y1z2"
content = '''If an id-expression names a pseudo-destructor (destructor of a scalar type T), T shall be a scalar type and the id-expression shall appear as the right operand of a class member access that forms the postfix-expression of a function call.'''
formal_spec = '''names_pseudo_destructor(id_expr, T) && (!is_scalar_type(T) || !is_right_operand_of_member_access_in_function_call(id_expr)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.dtor"
source_module = "[expr.prim.id.dtor]/2"
tags = ['destructor', 'pseudo-destructor', 'scalar']

[[axioms]]
id = "cpp20_expr_prim_dtor_double_destroy_ub_a3b4c5d6"
content = '''Destroying a temporary object twice is undefined behavior.'''
formal_spec = '''is_temporary(obj) && destroyed(obj) && destroy(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.dtor"
source_module = "[expr.prim.id.dtor]/3"
tags = ['destructor', 'temporary', 'lifetime', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_prim_lambda_specifier_unique_e7f8g9h0"
content = '''A lambda-specifier-seq shall contain at most one of each lambda-specifier and shall not contain both constexpr and consteval.'''
formal_spec = '''lambda_specifier_seq(L) && (duplicate_specifier(L) || (contains(L, constexpr) && contains(L, consteval))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'constexpr', 'consteval']

[[axioms]]
id = "cpp20_expr_prim_lambda_explicit_obj_specifier_i1j2k3l4"
content = '''If the lambda-declarator contains an explicit object parameter, then no lambda-specifier in the lambda-specifier-seq shall be mutable or static.'''
formal_spec = '''has_explicit_object_parameter(lambda) && (has_specifier(lambda, mutable) || has_specifier(lambda, static)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'explicit-object-parameter', 'mutable', 'static']

[[axioms]]
id = "cpp20_expr_prim_lambda_mutable_static_m5n6o7p8"
content = '''The lambda-specifier-seq shall not contain both mutable and static.'''
formal_spec = '''lambda_specifier_seq(L) && contains(L, mutable) && contains(L, static) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'mutable', 'static']

[[axioms]]
id = "cpp20_expr_prim_lambda_static_no_capture_q9r0s1t2"
content = '''If the lambda-specifier-seq contains static, there shall be no lambda-capture.'''
formal_spec = '''has_specifier(lambda, static) && has_lambda_capture(lambda) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'static', 'capture']

[[axioms]]
id = "cpp20_expr_prim_lambda_explicit_obj_type_u3v4w5x6"
content = '''Given a lambda with a lambda-capture, the type of the explicit object parameter shall be either the closure type, a class type publicly and unambiguously derived from the closure type, or a reference to a possibly cv-qualified such type.'''
formal_spec = '''has_lambda_capture(lambda) && has_explicit_object_parameter(lambda, T) && !valid_explicit_obj_param_type(T, closure_type(lambda)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.closure"
source_module = "[expr.prim.lambda.closure]/6"
tags = ['lambda', 'explicit-object-parameter', 'closure-type']

[[axioms]]
id = "cpp20_expr_prim_lambda_contract_only_capture_y7z8a9b0"
content = '''If all potential references to a local entity implicitly captured by a lambda-expression L occur only within the function contract assertions or assertion-statements within the body of L, the program is ill-formed.'''
formal_spec = '''implicitly_captured(lambda, entity) && all_references_in_contract_assertions(lambda, entity) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.closure"
source_module = "[expr.prim.lambda.closure]/10"
tags = ['lambda', 'capture', 'contract', 'assertion']

[[axioms]]
id = "cpp20_expr_prim_lambda_member_no_specialize_c1d2e3f4"
content = '''A member of a closure type shall not be explicitly instantiated, explicitly specialized, or named in a friend declaration.'''
formal_spec = '''is_closure_type_member(M) && (explicitly_instantiated(M) || explicitly_specialized(M) || named_in_friend_decl(M)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.closure"
source_module = "[expr.prim.lambda.closure]/19"
tags = ['lambda', 'closure-type', 'instantiation', 'specialization', 'friend']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_default_amp_g5h6i7j8"
content = '''If a lambda-capture includes a capture-default that is &, no identifier in a simple-capture of that lambda-capture shall be preceded by &.'''
formal_spec = '''capture_default(lambda, by_ref) && simple_capture(lambda, id) && preceded_by_ampersand(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/2"
tags = ['lambda', 'capture', 'capture-default']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_default_eq_k9l0m1n2"
content = '''If a lambda-capture includes a capture-default that is =, each simple-capture of that lambda-capture shall be of the form "&identifier...opt", "this", or "*this".'''
formal_spec = '''capture_default(lambda, by_copy) && simple_capture(lambda, cap) && !is_ref_capture(cap) && !is_this_capture(cap) && !is_star_this_capture(cap) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/2"
tags = ['lambda', 'capture', 'capture-default']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_duplicate_o3p4q5r6"
content = '''Ignoring appearances in initializers of init-captures, an identifier or this shall not appear more than once in a lambda-capture.'''
formal_spec = '''appears_multiple_times_in_capture(lambda, id_or_this) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/2"
tags = ['lambda', 'capture', 'duplicate']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_context_s7t8u9v0"
content = '''A lambda-expression shall not have a capture-default or simple-capture in its lambda-introducer unless its innermost enclosing scope is a block scope, it appears within a default member initializer, or it appears within a contract assertion.'''
formal_spec = '''has_capture(lambda) && !in_block_scope(lambda) && !in_default_member_initializer(lambda) && !in_contract_assertion(lambda) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/3"
tags = ['lambda', 'capture', 'scope']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_local_entity_w1x2y3z4"
content = '''The identifier in a simple-capture shall denote a local entity.'''
formal_spec = '''simple_capture(lambda, id) && !denotes_local_entity(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/4"
tags = ['lambda', 'capture', 'local-entity']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_param_shadow_a5b6c7d8"
content = '''If an identifier in a capture appears as the declarator-id of a parameter of the lambda-declarator's parameter-declaration-clause or as the name of a template parameter of the lambda-expression's template-parameter-list, the program is ill-formed.'''
formal_spec = '''capture_identifier(lambda, id) && (is_parameter_name(lambda, id) || is_template_parameter_name(lambda, id)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/5"
tags = ['lambda', 'capture', 'parameter', 'shadowing']

[[axioms]]
id = "cpp20_expr_prim_qual_computed_dtor_e9f0g1h2"
content = '''A qualified-id shall not be of the form nested-name-specifier template-opt ~computed-type-specifier nor of the form computed-type-specifier::~type-name.'''
formal_spec = '''(qualified_id_form(Q, nns_template_opt_tilde_computed_type_specifier) || qualified_id_form(Q, computed_type_specifier_tilde_type_name)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/5"
tags = ['qualified-id', 'destructor', 'computed-type-specifier']

[[axioms]]
id = "cpp20_expr_prim_qual_declarative_nns_i3j4k5l6"
content = '''A declarative nested-name-specifier shall not have a computed-type-specifier or a splice-scope-specifier.'''
formal_spec = '''is_declarative_nns(nns) && (has_computed_type_specifier(nns) || has_splice_scope_specifier(nns)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/3"
tags = ['nested-name-specifier', 'declarative', 'computed-type-specifier', 'splice']

[[axioms]]
id = "cpp20_expr_prim_qual_nns_computed_class_enum_m7n8o9p0"
content = '''A nested-name-specifier with a computed-type-specifier designates a type which shall be a class or enumeration type.'''
formal_spec = '''nns_with_computed_type_specifier(nns, T) && !is_class_type(T) && !is_enumeration_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/4.2"
tags = ['nested-name-specifier', 'computed-type-specifier', 'class', 'enumeration']

[[axioms]]
id = "cpp20_expr_prim_qual_splice_class_enum_ns_q1r2s3t4"
content = '''For a nested-name-specifier of the form splice-specifier::, the splice-specifier shall designate a class or enumeration type or a namespace.'''
formal_spec = '''nns_splice_specifier(nns, splice) && !designates_class_type(splice) && !designates_enumeration_type(splice) && !designates_namespace(splice) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/4.3"
tags = ['nested-name-specifier', 'splice', 'class', 'enumeration', 'namespace']

[[axioms]]
id = "cpp20_expr_prim_qual_nns_not_template_u5v6w7x8"
content = '''If a nested-name-specifier is not declarative, the entity it designates shall not be a template.'''
formal_spec = '''!is_declarative_nns(nns) && designates_template(nns) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/4.6"
tags = ['nested-name-specifier', 'template', 'declarative']

[[axioms]]
id = "cpp20_expr_unary_op_indirection_invalid_ptr_a7c3b2d1"
content = '''Indirection through a pointer that does not point to an object or function is undefined behavior, except as specified in [expr.typeid].'''
formal_spec = '''unary_indirection(ptr) && !points_to_object(ptr) && !points_to_function(ptr) && !typeid_context() => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/1"
tags = ['pointer', 'indirection', 'dereference', 'undefined-behavior']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_unary_op_address_bitfield_e8f4a1c2"
content = '''The operand of the address-of operator (&) shall not be a bit-field.'''
formal_spec = '''address_of(operand) && is_bitfield(operand) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/5"
tags = ['address-of', 'bitfield', 'constraint']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_pre_incr_bool_constraint_b3d2e5f6"
content = '''The operand of prefix ++ or -- shall not be of type cv bool.'''
formal_spec = '''(prefix_increment(operand) || prefix_decrement(operand)) && is_cv_bool(type(operand)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.pre.incr"
source_module = "[expr.pre.incr]/1"
tags = ['increment', 'decrement', 'bool', 'constraint']

[[axioms]]
id = "cpp20_expr_sizeof_function_type_c4a5b6d7"
content = '''The sizeof operator shall not be applied to an expression that has function type.'''
formal_spec = '''sizeof_expr(E) && is_function_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/1"
tags = ['sizeof', 'function', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_sizeof_incomplete_type_d5e6f7a8"
content = '''The sizeof operator shall not be applied to an expression that has incomplete type, or to the parenthesized name of such types.'''
formal_spec = '''sizeof_expr(E) && is_incomplete_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/1"
tags = ['sizeof', 'incomplete-type', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_sizeof_bitfield_e6f7a8b9"
content = '''The sizeof operator shall not be applied to a glvalue that designates a bit-field.'''
formal_spec = '''sizeof_expr(E) && is_glvalue(E) && is_bitfield(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/1"
tags = ['sizeof', 'bitfield', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_alignof_complete_type_f7a8b9c0"
content = '''The alignof operand shall be a type-id representing a complete object type, or an array thereof, or a reference to one of those types.'''
formal_spec = '''alignof_expr(T) && !(is_complete_object_type(T) || is_array_of_complete_object_type(T) || is_reference_to_complete_object_type(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.alignof"
source_module = "[expr.alignof]/1"
tags = ['alignof', 'complete-type', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_new_complete_type_a8b9c0d1"
content = '''The allocated type of a new-expression shall be a complete object type.'''
formal_spec = '''new_expression(T) && !is_complete_object_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/1"
tags = ['new', 'complete-type', 'constraint']

[[axioms]]
id = "cpp20_expr_new_abstract_class_b9c0d1e2"
content = '''The allocated type of a new-expression shall not be an abstract class type or array thereof.'''
formal_spec = '''new_expression(T) && (is_abstract_class(T) || is_array_of_abstract_class(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/1"
tags = ['new', 'abstract-class', 'constraint']

[[axioms]]
id = "cpp20_expr_new_array_bound_positive_c0d1e2f3"
content = '''Every constant-expression in a noptr-new-declarator shall have a value greater than zero.'''
formal_spec = '''noptr_new_declarator_constant_expr(E) && value(E) <= 0 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/6"
tags = ['new', 'array', 'constraint']

[[axioms]]
id = "cpp20_expr_new_placement_null_d1e2f3a4"
content = '''If the allocation function is a non-allocating form that returns null, the behavior is undefined.'''
formal_spec = '''new_expression(E) && is_non_allocating_form(alloc_fn(E)) && returns_null(alloc_fn(E)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/22"
tags = ['new', 'placement', 'allocation', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_delete_single_invalid_ptr_e2f3a4b5"
content = '''In a single-object delete expression, if the operand value is not null, not from a previous non-array new-expression, and not a pointer to a base class subobject of such an object, the behavior is undefined.'''
formal_spec = '''delete_single(ptr) && !is_null(ptr) && !from_non_array_new(ptr) && !is_base_subobject_ptr(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/2"
tags = ['delete', 'pointer', 'undefined-behavior', 'lifetime']

[[axioms]]
id = "cpp20_expr_delete_array_invalid_ptr_f3a4b5c6"
content = '''In an array delete expression, if the operand value is not null and not from a previous array new-expression whose allocation function was not a non-allocating form, the behavior is undefined.'''
formal_spec = '''delete_array(ptr) && !is_null(ptr) && !(from_array_new(ptr) && !is_non_allocating_form(alloc_fn_of_new(ptr))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/2"
tags = ['delete', 'array', 'pointer', 'undefined-behavior', 'lifetime']

[[axioms]]
id = "cpp20_expr_delete_virtual_destructor_a4b5c6d7"
content = '''In a single-object delete expression, if the static type differs from the dynamic type, the selected deallocation function is not a destroying operator delete, and the static type does not have a virtual destructor, the behavior is undefined.'''
formal_spec = '''delete_single(ptr) && !is_null(ptr) && !similar_types(static_type(ptr), dynamic_type(ptr)) && !is_destroying_delete(dealloc_fn) && !has_virtual_destructor(static_type(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/3"
tags = ['delete', 'virtual-destructor', 'polymorphism', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_delete_array_type_mismatch_b5c6d7e8"
content = '''In an array delete expression, if the dynamic type of the object to be deleted is not similar to its static type, the behavior is undefined.'''
formal_spec = '''delete_array(ptr) && !is_null(ptr) && !similar_types(dynamic_type(ptr), static_type(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/3"
tags = ['delete', 'array', 'type-mismatch', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_delete_incomplete_class_c6d7e8f9"
content = '''If the object being deleted has incomplete class type at the point of deletion, the program is ill-formed.'''
formal_spec = '''delete_expression(ptr) && is_incomplete_class_type(pointee_type(ptr)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/4"
tags = ['delete', 'incomplete-type', 'constraint']

[[axioms]]
id = "cpp20_expr_await_context_compound_stmt_d7e8f9a0"
content = '''An await-expression shall appear only as a potentially-evaluated expression within the compound-statement of a function-body or lambda-expression, outside of a handler.'''
formal_spec = '''await_expression(E) && !(in_compound_stmt_of_function_body(E) || in_compound_stmt_of_lambda(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'constraint']

[[axioms]]
id = "cpp20_expr_await_handler_e8f9a0b1"
content = '''An await-expression shall appear outside of a handler.'''
formal_spec = '''await_expression(E) && in_handler(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'exception-handler', 'constraint']

[[axioms]]
id = "cpp20_expr_await_default_arg_f9a0b1c2"
content = '''An await-expression shall not appear in a default argument.'''
formal_spec = '''await_expression(E) && in_default_argument(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'default-argument', 'constraint']

[[axioms]]
id = "cpp20_expr_await_static_storage_a0b1c2d3"
content = '''An await-expression shall not appear in the initializer of a block variable with static or thread storage duration.'''
formal_spec = '''await_expression(E) && in_block_var_initializer(E) && (has_static_storage_duration(var) || has_thread_storage_duration(var)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'static-storage', 'constraint']

[[axioms]]
id = "cpp20_expr_await_contract_assertion_b1c2d3e4"
content = '''An await-expression shall not be a potentially-evaluated subexpression of the predicate of a contract assertion.'''
formal_spec = '''await_expression(E) && is_potentially_evaluated(E) && in_contract_assertion_predicate(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'contract', 'constraint']

[[axioms]]
id = "cpp20_expr_new_unknown_bound_initializer_c2d3e4f5"
content = '''If the type-id or new-type-id denotes an array type of unknown bound, the new-initializer shall not be omitted.'''
formal_spec = '''new_expression(T) && is_array_of_unknown_bound(T) && no_new_initializer() => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/7"
tags = ['new', 'array', 'unknown-bound', 'constraint']

[[axioms]]
id = "cpp20_expr_unary_op_indirection_prvalue_d3e4f5a6"
content = '''The operand of the unary * operator shall be a prvalue of type pointer to T, where T is an object or function type.'''
formal_spec = '''unary_indirection(operand) && !(is_prvalue(operand) && is_pointer_to_object_or_function(type(operand))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/1"
tags = ['indirection', 'pointer', 'constraint']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_unary_op_address_lvalue_e4f5a6b7"
content = '''The operand of the unary & operator shall be an lvalue of some type T.'''
formal_spec = '''address_of(operand) && !is_lvalue(operand) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/3"
tags = ['address-of', 'lvalue', 'constraint']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_unary_plus_operand_f5a6b7c8"
content = '''The operand of the unary + operator shall be a prvalue of arithmetic, unscoped enumeration, or pointer type.'''
formal_spec = '''unary_plus(operand) && !(is_prvalue(operand) && (is_arithmetic(type(operand)) || is_unscoped_enum(type(operand)) || is_pointer(type(operand)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/7"
tags = ['unary-plus', 'operand', 'constraint']
c_standard_refs = ['6.5.3.3']

[[axioms]]
id = "cpp20_expr_unary_minus_operand_a6b7c8d9"
content = '''The operand of the unary - operator shall be a prvalue of arithmetic or unscoped enumeration type.'''
formal_spec = '''unary_minus(operand) && !(is_prvalue(operand) && (is_arithmetic(type(operand)) || is_unscoped_enum(type(operand)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/8"
tags = ['unary-minus', 'operand', 'constraint']
c_standard_refs = ['6.5.3.3']

[[axioms]]
id = "cpp20_expr_unary_complement_operand_b7c8d9e0"
content = '''The operand of the ~ operator shall be a prvalue of integral or unscoped enumeration type.'''
formal_spec = '''bitwise_complement(operand) && !(is_prvalue(operand) && (is_integral(type(operand)) || is_unscoped_enum(type(operand)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/10"
tags = ['bitwise-complement', 'operand', 'constraint']
c_standard_refs = ['6.5.3.3']

[[axioms]]
id = "cpp20_expr_new_array_negative_size_c8d9e0f1"
content = '''If the expression in a noptr-new-declarator is of non-class type and its value before converting to std::size_t is less than zero, the value is invalid and results in either ill-formed program or exception/null depending on exception specification.'''
formal_spec = '''noptr_new_declarator_expr(E) && is_non_class_type(type(E)) && value_before_conversion(E) < 0 => invalid_new_array_size'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.new"
source_module = "[expr.new]/8"
tags = ['new', 'array', 'negative-size', 'constraint']

[[axioms]]
id = "cpp20_expr_new_array_size_exceeds_limit_d9e0f1a2"
content = '''If the new array size value is such that the size of the allocated object would exceed the implementation-defined limit, the value is invalid.'''
formal_spec = '''noptr_new_declarator_expr(E) && exceeds_implementation_limit(size_of_allocated_object(E)) => invalid_new_array_size'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.new"
source_module = "[expr.new]/8"
tags = ['new', 'array', 'size-limit', 'constraint']

[[axioms]]
id = "cpp20_expr_new_array_initializer_count_e0f1a2b3"
content = '''If the new-initializer provides more initializers than the number of array elements to initialize, the value is invalid.'''
formal_spec = '''new_expression_array(E) && has_new_initializer(E) && initializer_count(E) > array_element_count(E) => invalid_new_array_size'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.new"
source_module = "[expr.new]/8"
tags = ['new', 'array', 'initializer', 'constraint']

[[axioms]]
id = "cpp20_expr_delete_destructor_accessible_f1a2b3c4"
content = '''When evaluating a delete-expression that invokes a destructor, the destructor shall be accessible from the point where the delete-expression appears.'''
formal_spec = '''delete_expression(ptr) && !is_null(ptr) && has_destructor(pointee_type(ptr)) && !is_accessible(destructor(pointee_type(ptr)), delete_context) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/5"
tags = ['delete', 'destructor', 'accessibility', 'constraint']

[[axioms]]
id = "cpp20_expr_await_suspend_type_a2b3c4d5"
content = '''The await-suspend expression shall be a prvalue of type void, bool, or std::coroutine_handle<Z> for some type Z.'''
formal_spec = '''await_suspend_expr(E) && !(is_prvalue(E) && (is_void(type(E)) || is_bool(type(E)) || is_coroutine_handle(type(E)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/3.7"
tags = ['coroutine', 'await', 'suspend', 'constraint']

[[axioms]]
id = "cpp20_expr_sizeof_pack_identifier_b3c4d5e6"
content = '''The identifier in a sizeof... expression shall name a pack.'''
formal_spec = '''sizeof_variadic(id) && !is_pack(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/4"
tags = ['sizeof', 'variadic', 'pack', 'constraint']

[[axioms]]
id = "cpp20_expr_unary_op_explicit_member_qualified_c4d5e6f7"
content = '''If the operand of unary & designates an explicit object member function, the operand shall be a qualified-id or a splice-expression.'''
formal_spec = '''address_of(operand) && designates_explicit_object_member_function(operand) && !(is_qualified_id(operand) || is_splice_expression(operand)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/3.2"
tags = ['address-of', 'explicit-object', 'member-function', 'constraint']

[[axioms]]
id = "cpp20_expr_cast_undefined_conversion_illformed_a3b7c2d1"
content = '''Any type conversion not mentioned in the cast notation rules and not explicitly defined by the user is ill-formed.'''
formal_spec = '''cast_notation(T, expr) && !is_const_cast_conversion(T, expr) && !is_static_cast_conversion(T, expr) && !is_static_cast_then_const_cast_conversion(T, expr) && !is_reinterpret_cast_conversion(T, expr) && !is_reinterpret_cast_then_const_cast_conversion(T, expr) && !is_user_defined_conversion(T, expr) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/3"
tags = ['conversion', 'cast', 'ill-formed']

[[axioms]]
id = "cpp20_expr_cast_ambiguous_static_const_illformed_e5f8a9b2"
content = '''If a static_cast followed by a const_cast is used and the conversion can be interpreted in more than one way as such, the conversion is ill-formed.'''
formal_spec = '''cast_notation(T, expr) && is_static_cast_then_const_cast_conversion(T, expr) && count_valid_interpretations_as_static_const(T, expr) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/4"
tags = ['conversion', 'cast', 'static_cast', 'const_cast', 'ambiguity', 'ill-formed']

[[axioms]]
id = "cpp20_expr_cast_incomplete_class_unspecified_c4d6e7f8"
content = '''If both the operand and destination types of a cast are class types and one or both are incomplete, it is unspecified whether the static_cast or the reinterpret_cast interpretation is used, even if there is an inheritance relationship between the two classes.'''
formal_spec = '''cast_notation(T, expr) && is_class_type(T) && is_class_type(type(expr)) && (is_incomplete_type(T) || is_incomplete_type(type(expr))) => unspecified_choice(static_cast_interpretation, reinterpret_cast_interpretation)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/5"
tags = ['conversion', 'cast', 'incomplete-type', 'unspecified', 'static_cast', 'reinterpret_cast']

[[axioms]]
id = "cpp20_expr_cast_first_valid_interpretation_f1a2b3c4"
content = '''If a cast conversion can be interpreted in more than one of the listed ways (const_cast, static_cast, static_cast+const_cast, reinterpret_cast, reinterpret_cast+const_cast), the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed.'''
formal_spec = '''cast_notation(T, expr) && interpretable_as(T, expr, interp1) && interpretable_as(T, expr, interp2) && list_order(interp1) < list_order(interp2) => selected_interpretation(T, expr) == interp1'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.cast"
source_module = "[expr.cast]/4"
tags = ['conversion', 'cast', 'interpretation', 'precedence']

[[axioms]]
id = "cpp20_expr_cast_inaccessible_base_allowed_d8e9f0a1"
content = '''C-style cast allows static_cast conversions between derived and base class types even when the base class is inaccessible, unlike explicit static_cast which requires accessibility.'''
formal_spec = '''cast_notation(T, expr) && (is_derived_to_base_ptr_conversion(T, expr) || is_derived_to_base_ref_conversion(T, expr) || is_base_to_derived_ptr_conversion(T, expr) || is_base_to_derived_ref_conversion(T, expr) || is_ptr_to_member_base_derived_conversion(T, expr)) && is_unambiguous_base(base_class, derived_class) => valid_cast_even_if_inaccessible(base_class)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.cast"
source_module = "[expr.cast]/4.6-4.8"
tags = ['conversion', 'cast', 'accessibility', 'inheritance', 'static_cast']

[[axioms]]
id = "cpp20_expr_cast_result_value_category_b2c3d4e5"
content = '''The result of (T)cast-expression is an lvalue if T is an lvalue reference type or rvalue reference to function type, an xvalue if T is an rvalue reference to object type, otherwise a prvalue.'''
formal_spec = '''cast_notation(T, expr) => (is_lvalue_ref(T) || (is_rvalue_ref(T) && is_function_type(remove_reference(T)))) ? is_lvalue(result) : (is_rvalue_ref(T) && is_object_type(remove_reference(T))) ? is_xvalue(result) : is_prvalue(result)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/1"
tags = ['conversion', 'cast', 'value-category', 'lvalue', 'xvalue', 'prvalue']

[[axioms]]
id = "cpp20_expr_cast_ambiguous_base_illformed_g7h8i9j0"
content = '''In the example, casting from D* to A* where A is an ambiguous base (via both I1 and I2) is ill-formed under the static_cast interpretation.'''
formal_spec = '''cast_notation(ptr_to(A), ptr_of_type(D)) && is_ambiguous_base(A, D) && selected_interpretation == static_cast => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.cast"
source_module = "[expr.cast]/4"
tags = ['conversion', 'cast', 'ambiguous-base', 'inheritance', 'ill-formed']

[[axioms]]
id = "cpp20_expr_mptr_oper_dotstar_operand_types_a3f8b2c1"
content = '''The .* operator requires the second operand to be a prvalue of type "pointer to member of T" and the first operand to be a glvalue of class T or of a class of which T is an unambiguous and accessible base class.'''
formal_spec = '''dotstar_expr(E1, E2) => prvalue(E2) && ptr_to_member_of(type(E2), T) && glvalue(E1) && (class_type(E1) == T || (is_base_of(T, class_type(E1)) && unambiguous_base(T, class_type(E1)) && accessible_base(T, class_type(E1))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/2"
tags = ['pointer-to-member', 'operand-types', 'constraint']

[[axioms]]
id = "cpp20_expr_mptr_oper_arrowstar_operand_types_b4c9d3e2"
content = '''The ->* operator requires the second operand to be a prvalue of type "pointer to member of T" and the first operand to be of type "pointer to U" where U is either T or a class of which T is an unambiguous and accessible base class.'''
formal_spec = '''arrowstar_expr(E1, E2) => prvalue(E2) && ptr_to_member_of(type(E2), T) && pointer_to(type(E1), U) && (U == T || (is_base_of(T, U) && unambiguous_base(T, U) && accessible_base(T, U)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/3"
tags = ['pointer-to-member', 'operand-types', 'constraint']

[[axioms]]
id = "cpp20_expr_mptr_oper_object_type_mismatch_ub_c5d0e4f3"
content = '''Using .* where the result of the object expression is an object whose type is not similar to the type of the object expression causes undefined behavior.'''
formal_spec = '''dotstar_expr(E1, E2) && is_object(result(E1)) && !similar_types(type(result(E1)), type(E1)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/4"
tags = ['pointer-to-member', 'undefined-behavior', 'type-mismatch']

[[axioms]]
id = "cpp20_expr_mptr_oper_member_not_contained_ub_d6e1f5g4"
content = '''Using .* where the most derived object of the result of the object expression does not contain the member to which the second operand refers causes undefined behavior.'''
formal_spec = '''dotstar_expr(E1, E2) && is_object(result(E1)) && !contains_member(most_derived_object(result(E1)), pointee_member(E2)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/4"
tags = ['pointer-to-member', 'undefined-behavior', 'member-access', 'lifetime']

[[axioms]]
id = "cpp20_expr_mptr_oper_rvalue_lref_illformed_e7f2g6h5"
content = '''In a .* expression whose object expression is an rvalue, the program is ill-formed if the second operand is a pointer to member function whose ref-qualifier is &, unless its cv-qualifier-seq is const.'''
formal_spec = '''dotstar_expr(E1, E2) && rvalue(E1) && ptr_to_member_function(type(E2)) && ref_qualifier(pointee(E2)) == "&" && cv_qualifier_seq(pointee(E2)) != "const" => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'ref-qualifier', 'ill-formed', 'member-function']

[[axioms]]
id = "cpp20_expr_mptr_oper_lvalue_rref_illformed_f8g3h7i6"
content = '''In a .* expression whose object expression is an lvalue, the program is ill-formed if the second operand is a pointer to member function whose ref-qualifier is &&.'''
formal_spec = '''dotstar_expr(E1, E2) && lvalue(E1) && ptr_to_member_function(type(E2)) && ref_qualifier(pointee(E2)) == "&&" => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'ref-qualifier', 'ill-formed', 'member-function']

[[axioms]]
id = "cpp20_expr_mptr_oper_null_member_ptr_ub_g9h4i8j7"
content = '''If the second operand of .* or ->* is the null member pointer value, the behavior is undefined.'''
formal_spec = '''(dotstar_expr(E1, E2) || arrowstar_expr(E1, E2)) && null_member_pointer(E2) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'undefined-behavior', 'null-pointer']

[[axioms]]
id = "cpp20_expr_mptr_oper_function_result_call_only_h0i5j9k8"
content = '''If the result of .* or ->* is a function, then that result can be used only as the operand for the function call operator ().'''
formal_spec = '''(dotstar_expr(E1, E2) || arrowstar_expr(E1, E2)) && is_function(result_type(E2)) => only_usable_as_call_operand(result)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'member-function', 'constraint', 'function-call']

[[axioms]]
id = "cpp20_expr_mul_div_by_zero_ub_3f8a2b1c"
content = '''Division by zero is undefined behavior. If the second operand of the / operator is zero, the behavior is undefined.'''
formal_spec = '''(a / b) && (b == 0) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'division', 'undefined-behavior', 'operators']
c_standard_refs = ['6.5.5/5']

[[axioms]]
id = "cpp20_expr_mul_mod_by_zero_ub_7e9c4d2a"
content = '''Modulo by zero is undefined behavior. If the second operand of the % operator is zero, the behavior is undefined.'''
formal_spec = '''(a % b) && (b == 0) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'modulo', 'undefined-behavior', 'operators']
c_standard_refs = ['6.5.5/5']

[[axioms]]
id = "cpp20_expr_mul_div_overflow_ub_b2d5e8f1"
content = '''If the quotient a/b is not representable in the result type, the behavior of both a/b and a%b is undefined.'''
formal_spec = '''!representable_in_type(a / b, result_type(a, b)) => undefined_behavior(a / b) && undefined_behavior(a % b)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'division', 'overflow', 'undefined-behavior', 'operators']
c_standard_refs = ['6.5.5/6']

[[axioms]]
id = "cpp20_expr_mul_operand_type_mul_div_c4a7f3e9"
content = '''The operands of * and / shall have arithmetic or unscoped enumeration type.'''
formal_spec = '''(a * b) || (a / b) => (is_arithmetic(a) || is_unscoped_enum(a)) && (is_arithmetic(b) || is_unscoped_enum(b))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/2"
tags = ['arithmetic', 'type-constraint', 'operators', 'multiplication', 'division']
c_standard_refs = ['6.5.5/2']

[[axioms]]
id = "cpp20_expr_mul_operand_type_mod_d1b8e4c2"
content = '''The operands of % shall have integral or unscoped enumeration type.'''
formal_spec = '''(a % b) => (is_integral(a) || is_unscoped_enum(a)) && (is_integral(b) || is_unscoped_enum(b))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/2"
tags = ['arithmetic', 'type-constraint', 'operators', 'modulo']
c_standard_refs = ['6.5.5/2']

[[axioms]]
id = "cpp20_expr_mul_integral_div_identity_a5c2d9f7"
content = '''For integral operands where the quotient a/b is representable, the identity (a/b)*b + a%b equals a holds.'''
formal_spec = '''is_integral(a) && is_integral(b) && (b != 0) && representable_in_type(a / b, result_type(a, b)) => ((a / b) * b + a % b) == a'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'division', 'modulo', 'invariant', 'operators']
c_standard_refs = ['6.5.5/6']

[[axioms]]
id = "cpp20_expr_add_addition_type_req_8a3f2b1c"
content = '''For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to a completely-defined object type and the other shall have integral type.'''
formal_spec = '''binary_plus(L, R) => (arithmetic_type(L) && arithmetic_type(R)) || (pointer_to_complete_object_type(L) && integral_type(R)) || (integral_type(L) && pointer_to_complete_object_type(R))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/1"
tags = ['addition', 'pointer-arithmetic', 'type-constraint']
c_standard_refs = ['6.5.6/2']

[[axioms]]
id = "cpp20_expr_add_subtraction_arith_type_d4e5f6a7"
content = '''For subtraction, both operands have arithmetic type is one valid form.'''
formal_spec = '''binary_minus(L, R) && arithmetic_type(L) && arithmetic_type(R) => valid_subtraction'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/2.1"
tags = ['subtraction', 'type-constraint']
c_standard_refs = ['6.5.6/3']

[[axioms]]
id = "cpp20_expr_add_subtraction_ptr_same_type_b2c3d4e5"
content = '''For subtraction, both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined object type is one valid form.'''
formal_spec = '''binary_minus(L, R) && pointer_type(L) && pointer_type(R) => same_unqualified_pointee_type(L, R) && completely_defined_object_type(pointee_type(L))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/2.2"
tags = ['subtraction', 'pointer-arithmetic', 'type-constraint']
c_standard_refs = ['6.5.6/3']

[[axioms]]
id = "cpp20_expr_add_subtraction_ptr_int_c3d4e5f6"
content = '''For subtraction, the left operand is a pointer to a completely-defined object type and the right operand has integral type is one valid form.'''
formal_spec = '''binary_minus(L, R) && pointer_to_complete_object_type(L) && integral_type(R) => valid_subtraction'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/2.3"
tags = ['subtraction', 'pointer-arithmetic', 'type-constraint']
c_standard_refs = ['6.5.6/3']

[[axioms]]
id = "cpp20_expr_add_ptr_arith_bounds_ub_7f8e9d0c"
content = '''When adding or subtracting an integral value J from a pointer P to array element i of array with n elements, the result index must be in range [0, n]; otherwise behavior is undefined.'''
formal_spec = '''pointer_plus_int(P, J) && points_to_array_element(P, x, i, n) && !((0 <= i + value(J)) && (i + value(J) <= n)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'array-bounds', 'undefined-behavior']
c_standard_refs = ['6.5.6/8']

[[axioms]]
id = "cpp20_expr_add_ptr_arith_minus_bounds_ub_6e7f8a9b"
content = '''When subtracting an integral value J from a pointer P to array element i of array with n elements, the result index must be in range [0, n]; otherwise behavior is undefined.'''
formal_spec = '''pointer_minus_int(P, J) && points_to_array_element(P, x, i, n) && !((0 <= i - value(J)) && (i - value(J) <= n)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'array-bounds', 'undefined-behavior']
c_standard_refs = ['6.5.6/8']

[[axioms]]
id = "cpp20_expr_add_ptr_arith_non_array_ub_5d6e7f8a"
content = '''Adding a value other than 0 or 1 to a pointer to a base class subobject, a member subobject, or a complete object results in undefined behavior.'''
formal_spec = '''pointer_plus_int(P, J) && (points_to_base_subobject(P) || points_to_member_subobject(P) || points_to_complete_object(P)) && !(value(J) == 0 || value(J) == 1) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'subobject', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_add_ptr_subtract_diff_array_ub_4c5d6e7f"
content = '''Subtracting two pointers that do not both point to elements of the same array object (or one past the end) and are not both null pointer values is undefined behavior.'''
formal_spec = '''pointer_minus_pointer(P, Q) && !(null_pointer(P) && null_pointer(Q)) && !same_array_object(P, Q) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/5.3"
tags = ['pointer-arithmetic', 'pointer-subtraction', 'undefined-behavior']
c_standard_refs = ['6.5.6/9']

[[axioms]]
id = "cpp20_expr_add_ptr_subtract_overflow_ub_3b4c5d6e"
content = '''If the value of pointer subtraction (i - j) is not in the range of representable values of type std::ptrdiff_t, the behavior is undefined.'''
formal_spec = '''pointer_minus_pointer(P, Q) && same_array_object(P, Q) && points_to_array_element(P, x, i, n) && points_to_array_element(Q, x, j, n) && !in_range(i - j, ptrdiff_t) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.add"
source_module = "[expr.add]/5.2"
tags = ['pointer-arithmetic', 'pointer-subtraction', 'overflow', 'undefined-behavior']
c_standard_refs = ['6.5.6/9']

[[axioms]]
id = "cpp20_expr_add_ptr_type_mismatch_ub_2a3b4c5d"
content = '''For addition or subtraction, if the pointer expression P or Q has type "pointer to cv T", where T and the array element type are not similar, the behavior is undefined.'''
formal_spec = '''(pointer_plus_int(P, J) || pointer_minus_int(P, J) || pointer_minus_pointer(P, Q)) && pointer_type(P, T) && points_to_array(P, array_x) && !similar_types(T, element_type(array_x)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/6"
tags = ['pointer-arithmetic', 'type-aliasing', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_add_operand_prvalue_req_1a2b3c4d"
content = '''Each operand of additive operators shall be a prvalue.'''
formal_spec = '''additive_expression(L, R) => prvalue(L) && prvalue(R)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/1"
tags = ['value-category', 'operand-constraint']

[[axioms]]
id = "cpp20_expr_add_null_plus_zero_valid_0f1e2d3c"
content = '''If pointer P evaluates to a null pointer value and integral J evaluates to 0, the result of P+J or P-J is a null pointer value.'''
formal_spec = '''(pointer_plus_int(P, J) || pointer_minus_int(P, J)) && null_pointer(P) && value(J) == 0 => null_pointer(result)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.1"
tags = ['pointer-arithmetic', 'null-pointer']

[[axioms]]
id = "cpp20_expr_add_null_nonzero_ub_e0f1a2b3"
content = '''Adding or subtracting a non-zero integral value to/from a null pointer is undefined behavior.'''
formal_spec = '''(pointer_plus_int(P, J) || pointer_minus_int(P, J)) && null_pointer(P) && value(J) != 0 => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'null-pointer', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_shift_negative_right_operand_8f3a2b1c"
content = '''The behavior is undefined if the right operand of a shift operator is negative.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") && E2 < 0 => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'undefined-behavior', 'operators', 'bitwise']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_right_operand_exceeds_width_7d4e9c2a"
content = '''The behavior is undefined if the right operand of a shift operator is greater than or equal to the width of the promoted left operand.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") && E2 >= width(promoted_type(E1)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'undefined-behavior', 'operators', 'bitwise', 'width']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_operands_prvalue_integral_5b8c1f3e"
content = '''The operands of shift operators shall be prvalues of integral or unscoped enumeration type.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") => (is_prvalue(E1) && is_prvalue(E2) && (is_integral_type(E1) || is_unscoped_enum_type(E1)) && (is_integral_type(E2) || is_unscoped_enum_type(E2)))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'constraint', 'operators', 'type-requirements', 'prvalue']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_result_type_promoted_left_3a9d7e4f"
content = '''The type of the result of a shift operation is that of the promoted left operand.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") => type(result) == promoted_type(E1)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'operators', 'type-conversion', 'promotion']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_left_value_modulo_6c2f8a1d"
content = '''The value of E1 << E2 is the unique value congruent to E1  2^E2 modulo 2^N, where N is the width of the type of the result.'''
formal_spec = '''left_shift_expr(E1, E2) => value(E1 << E2) == (E1 * pow(2, E2)) mod pow(2, width(type(result)))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/2"
tags = ['shift', 'operators', 'left-shift', 'semantics', 'modular-arithmetic']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_right_value_floor_div_4e1b9c5a"
content = '''The value of E1 >> E2 is E1/2^E2, rounded towards negative infinity (arithmetic right shift with sign-extension for signed types).'''
formal_spec = '''right_shift_expr(E1, E2) => value(E1 >> E2) == floor(E1 / pow(2, E2))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/3"
tags = ['shift', 'operators', 'right-shift', 'semantics', 'sign-extension']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_sequencing_e1_before_e2_2d7a4f8c"
content = '''In a shift expression, the left operand E1 is sequenced before the right operand E2.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") => sequenced_before(E1, E2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.shift"
source_module = "[expr.shift]/4"
tags = ['shift', 'operators', 'sequencing', 'evaluation-order']

[[axioms]]
id = "cpp20_expr_rel_operand_type_constraint_a3f8b2c1"
content = '''The converted operands of relational operators shall have arithmetic, enumeration, or pointer type.'''
formal_spec = '''relational_op(op, lhs, rhs) && converted(lhs, lhs') && converted(rhs, rhs') => (is_arithmetic(type(lhs')) || is_enumeration(type(lhs')) || is_pointer(type(lhs'))) && (is_arithmetic(type(rhs')) || is_enumeration(type(rhs')) || is_pointer(type(rhs')))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/2"
tags = ['relational', 'operators', 'type-constraint']

[[axioms]]
id = "cpp20_expr_rel_pointer_same_type_d7e4f1a9"
content = '''After conversions, pointer operands of relational operators shall have the same type.'''
formal_spec = '''relational_op(op, lhs, rhs) && is_pointer(type(converted(lhs))) && is_pointer(type(converted(rhs))) => type(converted(lhs)) == type(converted(rhs))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/3"
tags = ['relational', 'pointers', 'type-constraint', 'conversion']

[[axioms]]
id = "cpp20_expr_rel_array_subscript_order_b2c9e5f3"
content = '''If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher subscript is required to compare greater.'''
formal_spec = '''points_to_array_element(p, arr, i) && points_to_array_element(q, arr, j) && i > j => (p > q) == true && (q < p) == true'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/4.1"
tags = ['relational', 'pointers', 'array', 'ordering']

[[axioms]]
id = "cpp20_expr_rel_member_declaration_order_c8d3a7e2"
content = '''If two pointers point to different non-static data members of the same object, or to subobjects of such members, recursively, the pointer to the later declared member is required to compare greater provided neither member is a subobject of zero size and their class is not a union.'''
formal_spec = '''points_to_member(p, obj, m1) && points_to_member(q, obj, m2) && declared_after(m2, m1) && !is_zero_size_subobject(m1) && !is_zero_size_subobject(m2) && !is_union(class_of(obj)) => (q > p) == true'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/4.2"
tags = ['relational', 'pointers', 'members', 'ordering', 'non-union']

[[axioms]]
id = "cpp20_expr_rel_unrelated_pointer_unspecified_e5f2b8a1"
content = '''For pointers that do not point to elements of the same array or members of the same object, neither pointer is required to compare greater than the other; the result is unspecified.'''
formal_spec = '''is_pointer(type(p)) && is_pointer(type(q)) && !same_array(p, q) && !same_object_members(p, q) && p != q => unspecified(p < q) && unspecified(p > q) && unspecified(p <= q) && unspecified(p >= q)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/4.3"
tags = ['relational', 'pointers', 'unspecified', 'ordering']

[[axioms]]
id = "cpp20_expr_rel_equal_pointers_result_f1a4c9d6"
content = '''If two pointer operands compare equal, p<=q and p>=q both yield true and p<q and p>q both yield false.'''
formal_spec = '''is_pointer(type(p)) && is_pointer(type(q)) && (p == q) => (p <= q) == true && (p >= q) == true && (p < q) == false && (p > q) == false'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/5"
tags = ['relational', 'pointers', 'equality', 'ordering']

[[axioms]]
id = "cpp20_expr_rel_greater_pointer_consistency_a9b7c2e4"
content = '''If a pointer to object p compares greater than a pointer q, then p>=q, p>q, q<=p, and q<p all yield true, and p<=q, p<q, q>=p, and q>p all yield false.'''
formal_spec = '''is_pointer_to_object(type(p)) && is_pointer_to_object(type(q)) && pointer_greater(p, q) => (p >= q) == true && (p > q) == true && (q <= p) == true && (q < p) == true && (p <= q) == false && (p < q) == false && (q >= p) == false && (q > p) == false'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/5"
tags = ['relational', 'pointers', 'ordering', 'consistency']

[[axioms]]
id = "cpp20_expr_rel_function_pointer_unspecified_d3e8f5b2"
content = '''A relational operator applied to unequal function pointers yields an unspecified result.'''
formal_spec = '''is_function_pointer(type(p)) && is_function_pointer(type(q)) && p != q && relational_op(op, p, q) => unspecified(result(op, p, q))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/5"
tags = ['relational', 'function-pointer', 'unspecified']

[[axioms]]
id = "cpp20_expr_rel_left_to_right_grouping_b5c1d9a7"
content = '''The relational operators group left-to-right, meaning a<b<c is interpreted as (a<b)<c.'''
formal_spec = '''parse(a < b < c) == parse((a < b) < c)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/1"
tags = ['relational', 'operators', 'associativity', 'grouping']

[[axioms]]
id = "cpp20_expr_rel_result_type_bool_e2f7a4c8"
content = '''The result type of relational operators (<, >, <=, >=) is bool.'''
formal_spec = '''relational_op(op, lhs, rhs) && op in {<, >, <=, >=} => type(result(op, lhs, rhs)) == bool'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/2"
tags = ['relational', 'operators', 'result-type', 'bool']

[[axioms]]
id = "cpp20_expr_rel_arithmetic_enum_true_false_c4d9e1b5"
content = '''If both operands (after conversions) are of arithmetic or enumeration type, each of the relational operators shall yield true if the specified relationship is true and false if it is false.'''
formal_spec = '''relational_op(op, lhs, rhs) && (is_arithmetic(type(converted(lhs))) || is_enumeration(type(converted(lhs)))) && (is_arithmetic(type(converted(rhs))) || is_enumeration(type(converted(rhs)))) => result(op, lhs, rhs) == mathematical_relation(op, value(converted(lhs)), value(converted(rhs)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/6"
tags = ['relational', 'arithmetic', 'enumeration', 'semantics']

[[axioms]]
id = "cpp20_expr_rel_zero_size_member_unspecified_f8a3b6d2"
content = '''When comparing pointers to members where one member is a subobject of zero size, the ordering result is not required (unspecified).'''
formal_spec = '''points_to_member(p, obj, m1) && points_to_member(q, obj, m2) && m1 != m2 && (is_zero_size_subobject(m1) || is_zero_size_subobject(m2)) => unspecified(p < q) && unspecified(p > q)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/4.2"
tags = ['relational', 'pointers', 'members', 'zero-size', 'unspecified']

[[axioms]]
id = "cpp20_expr_rel_union_member_unspecified_a2c5e9f1"
content = '''When comparing pointers to members of a union, the ordering result is not required (unspecified).'''
formal_spec = '''points_to_member(p, obj, m1) && points_to_member(q, obj, m2) && m1 != m2 && is_union(class_of(obj)) => unspecified(p < q) && unspecified(p > q)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/4.2"
tags = ['relational', 'pointers', 'union', 'members', 'unspecified']

[[axioms]]
id = "cpp20_expr_eq_scalar_type_required_a7c3f1b2"
content = '''The converted operands of equality operators (== and !=) shall have scalar type.'''
formal_spec = '''equality_expr(op1, op2) => scalar_type(converted(op1)) && scalar_type(converted(op2))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/2"
tags = ['constraint', 'equality', 'scalar', 'type-requirement']

[[axioms]]
id = "cpp20_expr_eq_same_type_required_b4d2e8a1"
content = '''The operands of equality operators shall have the same type after the specified conversions have been applied.'''
formal_spec = '''equality_expr(op1, op2) => type(converted(op1)) == type(converted(op2))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/2"
tags = ['constraint', 'equality', 'type-requirement', 'conversion']

[[axioms]]
id = "cpp20_expr_eq_ptr_different_objects_unspecified_c9f5d3e7"
content = '''Comparing a pointer representing the address of a complete object with a pointer representing the address one past the last element of a different complete object yields an unspecified result.'''
formal_spec = '''pointer_compare(p1, p2) && complete_object_address(p1) && one_past_end_address(p2) && different_complete_objects(p1, p2) => unspecified_result'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.1"
tags = ['pointer', 'comparison', 'unspecified', 'one-past-end']

[[axioms]]
id = "cpp20_expr_eq_ptr_null_equal_d8a4c2f6"
content = '''Two null pointers compare equal.'''
formal_spec = '''pointer_compare(p1, p2) && null_pointer(p1) && null_pointer(p2) => compare_equal(p1, p2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.2"
tags = ['pointer', 'comparison', 'null-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptr_same_function_equal_e2b7a9d4"
content = '''Two pointers that both point to the same function compare equal.'''
formal_spec = '''pointer_compare(p1, p2) && points_to_function(p1, f) && points_to_function(p2, f) => compare_equal(p1, p2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.2"
tags = ['pointer', 'comparison', 'function-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptr_same_address_equal_f1c8d5e3"
content = '''Two pointers that represent the same address compare equal.'''
formal_spec = '''pointer_compare(p1, p2) && same_address(p1, p2) => compare_equal(p1, p2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.2"
tags = ['pointer', 'comparison', 'address']

[[axioms]]
id = "cpp20_expr_eq_ptm_null_equal_a3d9b7c2"
content = '''Two pointers to members that are both the null member pointer value compare equal.'''
formal_spec = '''ptm_compare(pm1, pm2) && null_member_pointer(pm1) && null_member_pointer(pm2) => compare_equal(pm1, pm2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.1"
tags = ['pointer-to-member', 'comparison', 'null-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptm_one_null_unequal_b5e2c8d1"
content = '''If only one of two pointers to members is the null member pointer value, they compare unequal.'''
formal_spec = '''ptm_compare(pm1, pm2) && (null_member_pointer(pm1) xor null_member_pointer(pm2)) => compare_unequal(pm1, pm2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.2"
tags = ['pointer-to-member', 'comparison', 'null-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptm_virtual_unspecified_c4f1a6e9"
content = '''If either pointer to member is a pointer to a virtual member function, the result of the comparison is unspecified.'''
formal_spec = '''ptm_compare(pm1, pm2) && (pointer_to_virtual_member_function(pm1) || pointer_to_virtual_member_function(pm2)) => unspecified_result'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.3"
tags = ['pointer-to-member', 'comparison', 'virtual', 'unspecified']

[[axioms]]
id = "cpp20_expr_eq_ptm_different_class_unspecified_d7a3b5c8"
content = '''If one pointer to member refers to a member of class C1 and the other refers to a member of a different class C2, where neither is a base class of the other, the result of the comparison is unspecified.'''
formal_spec = '''ptm_compare(pm1, pm2) && member_of_class(pm1, C1) && member_of_class(pm2, C2) && C1 != C2 && !is_base_of(C1, C2) && !is_base_of(C2, C1) => unspecified_result'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.4"
tags = ['pointer-to-member', 'comparison', 'unspecified', 'class-hierarchy']

[[axioms]]
id = "cpp20_expr_eq_ptm_same_union_equal_e8b4c2a7"
content = '''Two pointers to members that both refer to (possibly different) members of the same union compare equal.'''
formal_spec = '''ptm_compare(pm1, pm2) && member_of_union(pm1, U) && member_of_union(pm2, U) => compare_equal(pm1, pm2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.5"
tags = ['pointer-to-member', 'comparison', 'union']

[[axioms]]
id = "cpp20_expr_eq_nullptr_compare_equal_f2d8a1c6"
content = '''Two operands of type std::nullptr_t or one operand of type std::nullptr_t and the other a null pointer constant compare equal.'''
formal_spec = '''(type(op1) == nullptr_t && type(op2) == nullptr_t) || (type(op1) == nullptr_t && null_pointer_constant(op2)) || (null_pointer_constant(op1) && type(op2) == nullptr_t) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/5"
tags = ['nullptr', 'comparison', 'null-pointer-constant']

[[axioms]]
id = "cpp20_expr_eq_meta_info_null_reflection_equal_a1c3d5e7"
content = '''Two operands of type std::meta::info that are both null reflection values compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && null_reflection(op1) && null_reflection(op2) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.1"
tags = ['reflection', 'meta-info', 'comparison']

[[axioms]]
id = "cpp20_expr_eq_meta_info_template_arg_equiv_equal_b2d4e6f8"
content = '''Two operands of type std::meta::info that represent values that are template-argument-equivalent compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && template_argument_equivalent(value(op1), value(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.2"
tags = ['reflection', 'meta-info', 'comparison', 'template-argument']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_object_equal_c3e5f7a9"
content = '''Two operands of type std::meta::info that represent the same object compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_object(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.3"
tags = ['reflection', 'meta-info', 'comparison', 'object']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_entity_equal_d4f6a8b1"
content = '''Two operands of type std::meta::info that represent the same entity compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_entity(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.4"
tags = ['reflection', 'meta-info', 'comparison', 'entity']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_annotation_equal_e5a7b9c2"
content = '''Two operands of type std::meta::info that represent the same annotation compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_annotation(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.5"
tags = ['reflection', 'meta-info', 'comparison', 'annotation']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_base_class_equal_f6b8c1d3"
content = '''Two operands of type std::meta::info that represent the same direct base class relationship compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_direct_base_class_relationship(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.6"
tags = ['reflection', 'meta-info', 'comparison', 'base-class']

[[axioms]]
id = "cpp20_expr_eq_meta_info_equal_data_member_equal_a7c9d2e4"
content = '''Two operands of type std::meta::info that represent equal data member descriptions compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && equal_data_member_descriptions(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.7"
tags = ['reflection', 'meta-info', 'comparison', 'data-member']

[[axioms]]
id = "cpp20_expr_eq_unspecified_result_operators_b8d1e3f5"
content = '''If the comparison result is neither equal nor unequal (i.e., unspecified), the result of both == and != operators is unspecified.'''
formal_spec = '''equality_expr(op1, op2) && !compare_equal(op1, op2) && !compare_unequal(op1, op2) => unspecified_result(op1 == op2) && unspecified_result(op1 != op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/7"
tags = ['equality', 'comparison', 'unspecified', 'operator']

[[axioms]]
id = "cpp20_dcl_init_general_linkage_block_scope_init_a3b2c1d4"
content = '''A declaration of a variable with linkage shall not have an initializer if the declaration inhabits a block scope.'''
formal_spec = '''has_linkage(var_decl) && inhabits_block_scope(var_decl) && has_initializer(var_decl) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/5"
tags = ['initialization', 'linkage', 'block-scope', 'declaration']

[[axioms]]
id = "cpp20_dcl_init_general_const_default_init_e5f6a7b8"
content = '''If a program calls for the default-initialization of an object of a const-qualified type T, T shall be a const-default-constructible type.'''
formal_spec = '''default_initialization_required(obj) && is_const_qualified(type(obj)) && !is_const_default_constructible(type(obj)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/8"
tags = ['initialization', 'const', 'default-initialization', 'constructible']

[[axioms]]
id = "cpp20_dcl_init_general_ref_default_value_init_c9d0e1f2"
content = '''A program that calls for default-initialization or value-initialization of an entity of reference type is ill-formed.'''
formal_spec = '''(default_initialization_required(entity) || value_initialization_required(entity)) && is_reference_type(type(entity)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/10"
tags = ['initialization', 'reference', 'default-initialization', 'value-initialization']

[[axioms]]
id = "cpp20_dcl_init_general_paren_init_single_expr_a1b2c3d4"
content = '''If the entity being initialized does not have class or array type, the expression-list in a parenthesized initializer shall be a single expression.'''
formal_spec = '''!is_class_type(type(entity)) && !is_array_type(type(entity)) && is_parenthesized_init(init) && expression_list_count(init) != 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/13"
tags = ['initialization', 'expression-list', 'parenthesized-initializer']

[[axioms]]
id = "cpp20_dcl_init_general_array_too_many_init_e5f6g7h8"
content = '''When initializing an array with a parenthesized expression-list, if the number of initializers k is greater than the array size n, the program is ill-formed.'''
formal_spec = '''is_array_type(dest_type) && is_parenthesized_init(init) && expression_list_count(init) > array_size(dest_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/16.5"
tags = ['initialization', 'array', 'expression-list']

[[axioms]]
id = "cpp20_dcl_init_general_duplicate_designator_i9j0k1l2"
content = '''The same identifier shall not appear in multiple designators of a designated-initializer-list.'''
formal_spec = '''is_designated_init_list(init) && has_duplicate_designator_identifiers(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/21"
tags = ['initialization', 'designated-initializer', 'identifier']

[[axioms]]
id = "cpp20_dcl_init_aggr_designator_class_type_m3n4o5p6"
content = '''If the initializer list is a brace-enclosed designated-initializer-list, the aggregate shall be of class type.'''
formal_spec = '''is_designated_init_list(init) && is_aggregate(type(obj)) && !is_class_type(type(obj)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['initialization', 'aggregate', 'designated-initializer', 'class-type']

[[axioms]]
id = "cpp20_dcl_init_aggr_designator_names_member_q7r8s9t0"
content = '''In a designated-initializer-list, each designator identifier shall name a direct non-static data member of the class.'''
formal_spec = '''is_designated_init_list(init) && exists(d in designators(init), !is_direct_nonstatic_data_member(identifier(d), class_type)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['initialization', 'aggregate', 'designated-initializer', 'data-member']

[[axioms]]
id = "cpp20_dcl_init_aggr_single_anon_union_designator_u1v2w3x4"
content = '''When an anonymous union member is initialized by a designated-initializer-list, there shall be only one designated-initializer-clause naming a member of that anonymous union.'''
formal_spec = '''is_anonymous_union_member(element) && is_designated_init_list(init) && count_designators_for_anon_union(init, element) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.1"
tags = ['initialization', 'aggregate', 'anonymous-union', 'designated-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_narrowing_designator_y5z6a7b8"
content = '''In aggregate initialization with a designated-initializer-clause of form =assignment-expression, if a narrowing conversion is required to convert the expression, the program is ill-formed.'''
formal_spec = '''is_designated_init_clause(clause) && is_assignment_expr_form(clause) && requires_narrowing_conversion(expr(clause), element_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.2"
tags = ['initialization', 'aggregate', 'designated-initializer', 'narrowing-conversion']

[[axioms]]
id = "cpp20_dcl_init_aggr_reference_no_default_c9d0e1f2"
content = '''For a non-union aggregate element that is a reference and is not explicitly initialized and has no default member initializer, the program is ill-formed.'''
formal_spec = '''is_aggregate(type(obj)) && !is_union_type(type(obj)) && is_reference_type(element_type) && !is_explicitly_initialized(element) && !has_default_member_initializer(element) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/5.3"
tags = ['initialization', 'aggregate', 'reference', 'default-member-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_unknown_bound_empty_init_g3h4i5j6"
content = '''An array of unknown bound shall not be initialized with an empty braced-init-list {}.'''
formal_spec = '''is_array_of_unknown_bound(type(obj)) && is_empty_braced_init_list(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/10"
tags = ['initialization', 'array', 'unknown-bound', 'empty-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_too_many_initializers_k7l8m9n0"
content = '''If any initializer-clause remains that does not appertain to an element of the aggregate or one of its subaggregates, the program is ill-formed.'''
formal_spec = '''is_aggregate_init(init) && has_excess_initializer_clauses(init, aggregate) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/14"
tags = ['initialization', 'aggregate', 'excess-initializers']

[[axioms]]
id = "cpp20_dcl_init_aggr_recursive_default_init_o1p2q3r4"
content = '''If a member has a default member initializer and a potentially-evaluated subexpression thereof is an aggregate initialization that would use that default member initializer, the program is ill-formed.'''
formal_spec = '''has_default_member_initializer(member) && has_potentially_evaluated_subexpr(default_init(member), agg_init) && uses_same_default_member_initializer(agg_init, member) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/12"
tags = ['initialization', 'aggregate', 'default-member-initializer', 'recursion']

[[axioms]]
id = "cpp20_dcl_init_aggr_union_multiple_explicit_init_s5t6u7v8"
content = '''When a union is initialized with an initializer list, there shall not be more than one explicitly initialized element.'''
formal_spec = '''is_union_type(type(obj)) && is_initializer_list(init) && count_explicitly_initialized_elements(init) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/20"
tags = ['initialization', 'union', 'initializer-list']

[[axioms]]
id = "cpp20_dcl_init_string_too_many_chars_w9x0y1z2"
content = '''When initializing a character array from a string literal, there shall not be more initializers than there are array elements.'''
formal_spec = '''is_char_array(type(obj)) && is_string_literal(init) && string_literal_size(init) > array_size(type(obj)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.string"
source_module = "[dcl.init.string]/2"
tags = ['initialization', 'character-array', 'string-literal']

[[axioms]]
id = "cpp20_dcl_init_ref_must_be_initialized_a3b4c5d6"
content = '''A variable whose declared type is reference to T shall be initialized, except in parameter declaration, function return type declaration, class member declaration, or with explicit extern specifier.'''
formal_spec = '''is_reference_type(declared_type(var)) && is_variable_definition(decl) && !has_initializer(decl) && !is_parameter_decl(decl) && !is_function_return_decl(decl) && !is_class_member_decl(decl) && !has_explicit_extern(decl) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/1"
tags = ['initialization', 'reference', 'declaration']

[[axioms]]
id = "cpp20_dcl_init_ref_incompatible_binding_e7f8g9h0"
content = '''In all cases where the reference-compatible relationship is used to establish reference binding validity and the standard conversion sequence would be ill-formed, the program is ill-formed.'''
formal_spec = '''is_reference_binding(binding) && !is_valid_standard_conversion_sequence(source_type, dest_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/4"
tags = ['initialization', 'reference', 'reference-compatible', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_lvalue_nonconst_volatile_i1j2k3l4"
content = '''If the reference is an lvalue reference to a type that is not const-qualified or is volatile-qualified, and cannot bind directly, the program is ill-formed.'''
formal_spec = '''is_lvalue_reference(ref) && (!is_const_qualified(referenced_type(ref)) || is_volatile_qualified(referenced_type(ref))) && !can_bind_directly(init_expr, ref) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.2"
tags = ['initialization', 'reference', 'lvalue-reference', 'const', 'volatile']

[[axioms]]
id = "cpp20_dcl_init_ref_reference_related_indirect_m5n6o7p8"
content = '''When binding a reference through user-defined conversion (not direct binding), T1 shall not be reference-related to T2.'''
formal_spec = '''is_reference_binding(binding) && !is_direct_binding(binding) && is_reference_related(T1, T2) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['initialization', 'reference', 'reference-related', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_const_cast_temporary_ub_q9r0s1t2"
content = '''Modifying a const temporary bound to a reference through const_cast is undefined behavior.'''
formal_spec = '''is_temporary(obj) && is_const_qualified(type(obj)) && bound_to_reference(obj, ref) && const_cast_modify(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.3"
tags = ['initialization', 'reference', 'const_cast', 'temporary', 'undefined-behavior']

[[axioms]]
id = "cpp20_dcl_init_list_designator_not_ref_aggregate_u3v4w5x6"
content = '''If the braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class.'''
formal_spec = '''has_designated_init_list(braced_init) && !is_reference_type(T) && !is_aggregate_class(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['initialization', 'list-initialization', 'designated-initializer', 'aggregate']

[[axioms]]
id = "cpp20_dcl_init_list_designator_order_y7z8a9b0"
content = '''The ordered identifiers in the designators of the designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of T.'''
formal_spec = '''is_designated_init_list(init) && !is_subsequence(designator_identifiers(init), member_identifiers(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['initialization', 'list-initialization', 'designated-initializer', 'order']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_not_reachable_c1d2e3f4"
content = '''If a standard library declaration of std::initializer_list is not reachable from a use of std::initializer_list, even an implicit use, the program is ill-formed.'''
formal_spec = '''uses_initializer_list(expr) && !is_reachable(std_initializer_list_decl, expr) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/2"
tags = ['initialization', 'list-initialization', 'initializer_list', 'reachability']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_constructor_g5h6i7j8"
content = '''In list-initialization, if a narrowing conversion is required to convert any of the arguments when invoking a constructor, the program is ill-formed.'''
formal_spec = '''is_list_initialization(init) && is_class_type(T) && constructor_selected(init, ctor) && requires_narrowing_conversion_for_arg(init, ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.7"
tags = ['initialization', 'list-initialization', 'narrowing-conversion', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_aggr_paren_no_lifetime_extension_k9l0m1n2"
content = '''In parenthesized aggregate initialization, a temporary object bound to a reference does not have its lifetime extended (creating a dangling reference).'''
formal_spec = '''is_parenthesized_aggregate_init(init) && is_reference_member(member) && is_temporary(init_expr(member)) => dangling_reference(member)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/16.6.2.2"
tags = ['initialization', 'aggregate', 'reference', 'lifetime', 'temporary']

[[axioms]]
id = "cpp20_dcl_init_ref_must_initialize_a3f8b2c1"
content = '''A variable declared as "reference to T" shall be initialized.'''
formal_spec = '''is_reference_type(declared_type(var)) && is_variable(var) => must_be_initialized(var)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/1"
tags = ['reference', 'initialization', 'declaration']

[[axioms]]
id = "cpp20_dcl_init_ref_omit_initializer_conditions_7e4a9d12"
content = '''A reference initializer can only be omitted in: parameter declaration, function return type declaration, class member declaration within class definition, or with explicit extern specifier.'''
formal_spec = '''is_reference_type(declared_type(decl)) && omitted_initializer(decl) => (is_parameter_decl(decl) || is_function_return_type_decl(decl) || is_class_member_within_class_def(decl) || has_explicit_extern(decl))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/3"
tags = ['reference', 'initialization', 'extern', 'parameter']

[[axioms]]
id = "cpp20_dcl_init_ref_illformed_conversion_sequence_b2c4e8f0"
content = '''When reference-compatible relationship is used to establish validity of reference binding and the standard conversion sequence would be ill-formed, the program is ill-formed.'''
formal_spec = '''uses_reference_compatible_for_binding(ref, type1, type2) && illformed_standard_conversion_sequence(type2, type1) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/4"
tags = ['reference', 'conversion', 'reference-compatible']

[[axioms]]
id = "cpp20_dcl_init_ref_lvalue_nonconst_volatile_illformed_d9a1b3c5"
content = '''Binding an lvalue reference to a type that is not const-qualified or is volatile-qualified to a non-lvalue initializer makes the program ill-formed.'''
formal_spec = '''is_lvalue_reference(ref) && (!is_const_qualified(referenced_type(ref)) || is_volatile_qualified(referenced_type(ref))) && !is_lvalue(initializer) && !direct_binding_possible(ref, initializer) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.2"
tags = ['reference', 'lvalue', 'const', 'volatile', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_bitfield_not_direct_bind_lvalue_8c2f4a1e"
content = '''An lvalue reference cannot bind directly to a bit-field lvalue even if reference-compatible.'''
formal_spec = '''is_lvalue_reference(ref) && is_bitfield(initializer) => !direct_binds_to_lvalue(ref, initializer)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.1.1"
tags = ['reference', 'lvalue', 'bitfield', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_bitfield_not_direct_bind_rvalue_3e7b9c2d"
content = '''A reference cannot bind directly to a bit-field rvalue.'''
formal_spec = '''is_rvalue_reference(ref) && is_bitfield(initializer) => !direct_binds(ref, initializer)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.3.1"
tags = ['reference', 'rvalue', 'bitfield', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_const_cast_modify_temp_ub_f5d8e2a7"
content = '''Modifying a temporary bound to a const reference via const_cast is undefined behavior.'''
formal_spec = '''is_const_reference(ref) && binds_to_temporary(ref, temp) && const_cast_to_nonconst(ref, nonconst_ref) && modify_through(nonconst_ref) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.3"
tags = ['reference', 'const', 'const_cast', 'temporary', 'undefined_behavior']

[[axioms]]
id = "cpp20_dcl_init_ref_t1_not_related_t2_otherwise_c4a9f1b8"
content = '''When none of the prior reference binding rules apply, T1 shall not be reference-related to T2.'''
formal_spec = '''reference_binding_fallthrough(ref_type_cv1_T1, init_type_cv2_T2) && !applies_rule_5_1(ref, init) && !applies_rule_5_2(ref, init) && !applies_rule_5_3(ref, init) => !is_reference_related(T1, T2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'reference-related', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_copy_init_illformed_propagates_e7b2c3d9"
content = '''When using user-defined conversions for reference initialization where T1 or T2 is a class type, if the corresponding non-reference copy-initialization would be ill-formed, the program is ill-formed.'''
formal_spec = '''reference_binding_rule_5_4_1(ref, init) && (is_class_type(T1) || is_class_type(T2)) && illformed_copy_init_of_cv1_T1(init) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4.1"
tags = ['reference', 'class', 'copy-initialization', 'user-defined-conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_rvalue_ref_lvalue_related_illformed_a1c5d8e2"
content = '''Binding an rvalue reference to an lvalue of reference-related type is ill-formed.'''
formal_spec = '''is_rvalue_reference(ref_type_T1) && is_lvalue(initializer) && is_reference_related(T1, type(initializer)) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'rvalue-reference', 'lvalue', 'reference-related']

[[axioms]]
id = "cpp20_dcl_init_ref_cv_qualifier_drop_illformed_8f3a2b4c"
content = '''Binding a reference where cv-qualifiers would be dropped from the source type is ill-formed.'''
formal_spec = '''reference_binding(ref_cv1_T1, init_cv2_T2) && cv_qualifiers_dropped(cv2, cv1) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'cv-qualifier', 'const', 'volatile']

[[axioms]]
id = "cpp20_dcl_init_ref_conversion_func_lvalue_related_illformed_2d9e7f1a"
content = '''When a conversion function result is an lvalue of reference-related type, binding an rvalue reference to it is ill-formed.'''
formal_spec = '''is_rvalue_reference(ref_T1) && conversion_function_result(init, result) && is_lvalue(result) && is_reference_related(T1, type(result)) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'rvalue-reference', 'conversion-function', 'reference-related']

[[axioms]]
id = "cpp20_dcl_init_ref_no_user_conv_direct_init_5b8c3d2e"
content = '''In the direct-initialization of a reference using the result of a conversion function (rule 5.4.1), user-defined conversions are not considered.'''
formal_spec = '''reference_binding_rule_5_4_1_direct_init(ref, conversion_result_E) => !consider_user_defined_conversions(direct_init)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4.1"
tags = ['reference', 'direct-initialization', 'user-defined-conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_immutable_binding_4a7e9c1f"
content = '''A reference cannot be changed to refer to another object after initialization.'''
formal_spec = '''initialized(ref) => !can_rebind(ref)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/2"
tags = ['reference', 'binding', 'immutability']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_not_reachable_a3f8c2d1"
content = '''If std::initializer_list is used (even implicitly) but no standard library declaration of std::initializer_list is reachable, the program is ill-formed.'''
formal_spec = '''uses_initializer_list(expr) && !reachable_declaration(std::initializer_list) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/2"
tags = ['list-initialization', 'initializer_list', 'reachability']

[[axioms]]
id = "cpp20_dcl_init_list_designated_requires_aggregate_b7e4a1c9"
content = '''If a braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class.'''
formal_spec = '''has_designated_initializer_list(init) && !is_reference_type(T) => is_aggregate_class(T)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate']

[[axioms]]
id = "cpp20_dcl_init_list_designator_order_subsequence_c8d3b2e5"
content = '''The ordered identifiers in the designators of a designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of T.'''
formal_spec = '''has_designated_initializer_list(init) && is_aggregate_class(T) => is_subsequence(designator_identifiers(init), member_identifiers(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate', 'member-order']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_constructor_arg_d9a4c3f6"
content = '''If a narrowing conversion is required to convert any of the arguments when constructors are considered for class type list-initialization, the program is ill-formed.'''
formal_spec = '''list_init_class(T, init) && constructor_overload_resolution(T, init) && requires_narrowing_conversion(arg, param) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.7"
tags = ['list-initialization', 'narrowing', 'constructor', 'overload-resolution']

[[axioms]]
id = "cpp20_dcl_init_list_enum_narrowing_e5b6d4a7"
content = '''For direct-list-initialization of an enumeration with fixed underlying type from a single scalar element, if a narrowing conversion is required to convert the element to the underlying type, the program is ill-formed.'''
formal_spec = '''is_enum_fixed_underlying(T) && direct_list_init(T, {v}) && is_scalar(v) && requires_narrowing_conversion(v, underlying_type(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'narrowing', 'direct-list-initialization']

[[axioms]]
id = "cpp20_dcl_init_list_enum_copy_list_init_f6c7e5b8"
content = '''For an enumeration with fixed underlying type, copy-list-initialization from a single scalar element is not permitted (only direct-list-initialization is allowed).'''
formal_spec = '''is_enum_fixed_underlying(T) && copy_list_init(T, {v}) && is_scalar(v) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'copy-list-initialization']

[[axioms]]
id = "cpp20_dcl_init_list_single_element_narrowing_a7d8f6c9"
content = '''When initializing from a single element where T is not a reference type or its referenced type is reference-related to E, if a narrowing conversion is required to convert the element to T, the program is ill-formed.'''
formal_spec = '''list_init(T, {e}) && !is_designated_init({e}) && type_of(e) == E && (!is_reference(T) || reference_related(referenced_type(T), E)) && requires_narrowing_conversion(e, T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.9"
tags = ['list-initialization', 'narrowing', 'single-element']

[[axioms]]
id = "cpp20_dcl_init_list_lvalue_ref_nonconst_b8e9a7d0"
content = '''Binding an lvalue reference to a non-const type to a prvalue generated from list-initialization is ill-formed.'''
formal_spec = '''is_lvalue_reference(T) && !is_const(referenced_type(T)) && list_init_generates_prvalue(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.10"
tags = ['list-initialization', 'reference', 'lvalue-reference', 'binding']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_backing_narrowing_c9f0b8e1"
content = '''If a narrowing conversion is required to initialize any of the elements of the backing array for std::initializer_list<E>, the program is ill-formed.'''
formal_spec = '''constructing_initializer_list(E, init) && exists(elem in init, requires_narrowing_conversion(elem, E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/5"
tags = ['list-initialization', 'initializer_list', 'narrowing', 'backing-array']

[[axioms]]
id = "cpp20_dcl_init_list_ctor_initializer_dangling_d0a1c9f2"
content = '''Initializing an initializer_list member in a constructor's ctor-initializer creates a dangling reference and the program is ill-formed.'''
formal_spec = '''is_initializer_list_member(member) && initialized_in_ctor_initializer(member, {init...}) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/6"
tags = ['list-initialization', 'initializer_list', 'lifetime', 'dangling-reference', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_int_e1b2d0a3"
content = '''A narrowing conversion occurs from a floating-point type to an integer type in list-initialization context.'''
formal_spec = '''is_floating_point(src_type) && is_integer_type(dst_type) && in_list_init_context => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.1"
tags = ['narrowing', 'conversion', 'floating-point', 'integer']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_lesser_rank_f2c3e1b4"
content = '''A narrowing conversion occurs from a floating-point type T to another floating-point type with lesser conversion rank, unless the result is a constant expression with finite value that did not overflow, or both values are not finite.'''
formal_spec = '''is_floating_point(T) && is_floating_point(U) && !greater_or_equal_rank(U, T) && !(is_constant_expr(v) && (is_finite(result) && !overflow || (!is_finite(v) && !is_finite(result)))) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.2"
tags = ['narrowing', 'conversion', 'floating-point', 'rank']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_float_a3d4f2c5"
content = '''A narrowing conversion occurs from an integer type or unscoped enumeration type to a floating-point type, unless the source is a constant expression and the value fits and round-trips.'''
formal_spec = '''(is_integer_type(src) || is_unscoped_enum(src)) && is_floating_point(dst) && !(is_constant_expr(src) && fits_in_target(src, dst) && roundtrips(src, dst)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.3"
tags = ['narrowing', 'conversion', 'integer', 'floating-point']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_int_b4e5a3d6"
content = '''A narrowing conversion occurs from an integer type or unscoped enumeration type to an integer type that cannot represent all values of the original type, except for bit-field or constant expression exceptions.'''
formal_spec = '''(is_integer_type(src) || is_unscoped_enum(src)) && is_integer_type(dst) && !can_represent_all_values(dst, src) && !bitfield_exception(src, dst) && !(is_constant_expr(src) && value_fits_after_promotion(src, dst)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.4"
tags = ['narrowing', 'conversion', 'integer']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_ptr_to_bool_c5f6b4e7"
content = '''A narrowing conversion occurs from a pointer type or pointer-to-member type to bool.'''
formal_spec = '''(is_pointer_type(src) || is_pointer_to_member(src)) && dst == bool => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.5"
tags = ['narrowing', 'conversion', 'pointer', 'bool']

[[axioms]]
id = "cpp20_dcl_init_list_evaluation_order_d6a7c5f8"
content = '''Within the initializer-list of a braced-init-list, initializer-clauses are evaluated in left-to-right order with sequenced-before relationship.'''
formal_spec = '''in_braced_init_list(init) && clause_i before clause_j in init => sequenced_before(effects(clause_i), effects(clause_j))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/4"
tags = ['list-initialization', 'evaluation-order', 'sequencing']

[[axioms]]
id = "cpp20_dcl_init_list_no_matching_init_e7b8d6a9"
content = '''If none of the list-initialization rules apply (rules 3.1 through 3.11), the program is ill-formed.'''
formal_spec = '''list_init(T, init) && !matches_any_rule_3_1_to_3_11(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.12"
tags = ['list-initialization', 'ill-formed']

[[axioms]]
id = "cpp20_dcl_init_list_copy_list_init_explicit_f8c9e7b0"
content = '''Copy-list-initialization cannot use an explicit constructor; selecting an explicit constructor via copy-list-initialization makes the program ill-formed.'''
formal_spec = '''copy_list_init(T, init) && selected_constructor_is_explicit(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.10"
tags = ['list-initialization', 'copy-list-initialization', 'explicit', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_aggr_designated_class_only_a7c3e2f1"
content = '''When using a designated-initializer-list, the aggregate shall be of class type.'''
formal_spec = '''is_designated_initializer_list(init) && !is_class_type(aggregate_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['aggregate', 'initialization', 'designated-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_designator_direct_member_b4d8f6e2"
content = '''In a designated-initializer-list, each identifier in a designator shall name a direct non-static data member of the class.'''
formal_spec = '''is_designated_initializer_list(init) && has_designator(d, identifier) && !is_direct_nonstatic_data_member(identifier, class_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['aggregate', 'initialization', 'designated-initializer', 'member']

[[axioms]]
id = "cpp20_dcl_init_aggr_anon_union_single_designator_c5e9a7d3"
content = '''When initializing an anonymous union member with a designated-initializer-list, there shall be only one designated-initializer-clause naming a member of the anonymous union.'''
formal_spec = '''is_anonymous_union_member(element) && is_designated_initializer_list(init) && count_designators_for_union(init, element) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.1"
tags = ['aggregate', 'initialization', 'anonymous-union', 'designated-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_narrowing_designated_d6f0b8e4"
content = '''In a designated-initializer-clause of form = assignment-expression, if a narrowing conversion is required to convert the expression, the program is ill-formed.'''
formal_spec = '''is_designated_initializer_clause(d) && form_equals_assignment_expr(d) && requires_narrowing_conversion(expr(d), target_type(d)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.2"
tags = ['aggregate', 'initialization', 'designated-initializer', 'narrowing-conversion']

[[axioms]]
id = "cpp20_dcl_init_aggr_reference_no_default_e7a1c9f5"
content = '''For a non-union aggregate, if an element is a reference and is not explicitly initialized and has no default member initializer, the program is ill-formed.'''
formal_spec = '''is_non_union_aggregate(agg) && is_reference_type(element_type(e)) && !explicitly_initialized(e) && !has_default_member_initializer(e) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/5.3"
tags = ['aggregate', 'initialization', 'reference', 'default-initialization']

[[axioms]]
id = "cpp20_dcl_init_aggr_unknown_bound_empty_f8b2dae6"
content = '''An array of unknown bound shall not be initialized with an empty braced-init-list {}.'''
formal_spec = '''is_array_unknown_bound(T) && is_empty_braced_init_list(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/10"
tags = ['aggregate', 'initialization', 'array', 'unknown-bound']

[[axioms]]
id = "cpp20_dcl_init_aggr_recursive_default_member_init_09c3ebf7"
content = '''If a member has a default member initializer and a potentially-evaluated subexpression thereof is an aggregate initialization that would use that default member initializer, the program is ill-formed.'''
formal_spec = '''has_default_member_initializer(member) && contains_potentially_evaluated_subexpr(default_init(member), subexpr) && is_aggregate_init(subexpr) && would_use_default_member_init(subexpr, member) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/12"
tags = ['aggregate', 'initialization', 'default-member-initializer', 'recursive']

[[axioms]]
id = "cpp20_dcl_init_aggr_too_many_initializers_1ad4fcg8"
content = '''If any initializer-clause remains that does not appertain to an element of the aggregate or one of its subaggregates, the program is ill-formed.'''
formal_spec = '''is_aggregate_init(init) && exists_initializer_clause(init, clause) && !appertains_to_element(clause, aggregate) && !appertains_to_subaggregate_element(clause, aggregate) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/14"
tags = ['aggregate', 'initialization', 'initializer-list', 'excess-elements']

[[axioms]]
id = "cpp20_dcl_init_aggr_union_single_element_2be5gdh9"
content = '''When a union is initialized with an initializer list, there shall not be more than one explicitly initialized element.'''
formal_spec = '''is_union_type(T) && is_initializer_list_init(init) && count_explicitly_initialized_elements(init) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/20"
tags = ['aggregate', 'initialization', 'union']

[[axioms]]
id = "cpp20_dcl_init_aggr_element_order_sequencing_3cf6hei0"
content = '''The initializations of the elements of the aggregate are evaluated in element order. All value computations and side effects associated with a given element are sequenced before those of any element that follows it in order.'''
formal_spec = '''is_aggregate_init(agg, init) && element_index(e1) < element_index(e2) => sequenced_before(value_computations(e1), value_computations(e2)) && sequenced_before(side_effects(e1), side_effects(e2))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/7"
tags = ['aggregate', 'initialization', 'sequencing', 'evaluation-order']

[[axioms]]
id = "cpp20_dcl_init_aggr_destructor_potentially_invoked_4dg7ifj1"
content = '''The destructor for each element of class type other than an anonymous union member is potentially invoked from the context where the aggregate initialization occurs.'''
formal_spec = '''is_aggregate_init(agg) && is_element(e, agg) && is_class_type(type(e)) && !is_anonymous_union_member(e) => potentially_invoked(destructor(type(e)), initialization_context(agg))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/9"
tags = ['aggregate', 'initialization', 'destructor', 'exception-safety']

[[axioms]]
id = "cpp20_dcl_init_aggr_array_bound_from_init_5eh8jgk2"
content = '''The number of elements in an array of unknown bound initialized with a brace-enclosed initializer-list is the number of explicitly initialized elements of the array.'''
formal_spec = '''is_array_unknown_bound(T) && is_braced_init_list(init) => array_bound(T) == count_explicitly_initialized_elements(init)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/10"
tags = ['aggregate', 'initialization', 'array', 'unknown-bound', 'deduction']

[[axioms]]
id = "cpp20_class_cdtor_refer_before_ctor_nontrivial_a7c3f8e2"
content = '''For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior.'''
formal_spec = '''has_nontrivial_constructor(obj) && refers_to_member_or_base(ref, obj) && !construction_started(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/1"
tags = ['lifetime', 'constructor', 'initialization', 'member-access']

[[axioms]]
id = "cpp20_class_cdtor_refer_after_dtor_nontrivial_b2d4e9f1"
content = '''For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior.'''
formal_spec = '''has_nontrivial_destructor(obj) && refers_to_member_or_base(ref, obj) && destruction_completed(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/1"
tags = ['lifetime', 'destructor', 'member-access']

[[axioms]]
id = "cpp20_class_cdtor_upcast_ctor_not_started_c8e5a1b3"
content = '''To convert a pointer or glvalue referring to an object of class X to a pointer or reference to a direct or indirect base class B of X, the construction of X and all its direct or indirect bases that derive from B shall have started, otherwise the conversion results in undefined behavior.'''
formal_spec = '''is_base_of(B, X) && convert_to_base(ptr_to_X, B) && (!construction_started(X) || exists(C, derives_from(C, B) && is_base_of(C, X) && !construction_started(C))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'constructor', 'conversion', 'pointer', 'upcast']

[[axioms]]
id = "cpp20_class_cdtor_upcast_dtor_completed_d9f6b2c4"
content = '''To convert a pointer or glvalue referring to an object of class X to a pointer or reference to a direct or indirect base class B of X, the destruction of X and all its direct or indirect bases that derive from B shall not have completed, otherwise the conversion results in undefined behavior.'''
formal_spec = '''is_base_of(B, X) && convert_to_base(ptr_to_X, B) && (destruction_completed(X) || exists(C, derives_from(C, B) && is_base_of(C, X) && destruction_completed(C))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'destructor', 'conversion', 'pointer', 'upcast']

[[axioms]]
id = "cpp20_class_cdtor_member_ptr_ctor_not_started_e1a7c3d5"
content = '''To form a pointer to or access the value of a direct non-static member of an object, the construction of the object shall have started, otherwise the computation of the pointer value or accessing the member value results in undefined behavior.'''
formal_spec = '''is_direct_nonstatic_member(member, obj) && (form_pointer_to(member) || access_value(member)) && !construction_started(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'constructor', 'member-access', 'pointer']

[[axioms]]
id = "cpp20_class_cdtor_member_ptr_dtor_completed_f2b8d4e6"
content = '''To form a pointer to or access the value of a direct non-static member of an object, the destruction of the object shall not have completed, otherwise the computation of the pointer value or accessing the member value results in undefined behavior.'''
formal_spec = '''is_direct_nonstatic_member(member, obj) && (form_pointer_to(member) || access_value(member)) && destruction_completed(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'destructor', 'member-access', 'pointer']

[[axioms]]
id = "cpp20_class_cdtor_virtual_call_wrong_object_g3c9e5f7"
content = '''During construction or destruction, if a virtual function call uses an explicit class member access and the object expression refers to the complete object or one of its base class subobjects but not the object under construction/destruction or one of its base class subobjects, the behavior is undefined.'''
formal_spec = '''(in_constructor(x) || in_destructor(x)) && virtual_call(f) && explicit_member_access(call, obj_expr) && (refers_to_complete_object(obj_expr, x) || refers_to_base_of_complete(obj_expr, x)) && !refers_to(obj_expr, x) && !refers_to_base_of(obj_expr, x) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/4"
tags = ['lifetime', 'constructor', 'destructor', 'virtual-function', 'member-access']

[[axioms]]
id = "cpp20_class_cdtor_typeid_wrong_static_type_h4d0f6a8"
content = '''When typeid is used in a constructor or destructor (or function called from them) and the operand refers to the object under construction or destruction, if the static type of the operand is neither the constructor or destructor's class nor one of its bases, the behavior is undefined.'''
formal_spec = '''(in_constructor(C) || in_destructor(C)) && typeid_operand_refers_to(operand, object_under_construction_or_destruction) && static_type(operand) != C && !is_base_of(static_type(operand), C) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/5"
tags = ['lifetime', 'constructor', 'destructor', 'typeid', 'rtti']

[[axioms]]
id = "cpp20_class_cdtor_dynamic_cast_wrong_static_type_i5e1a7b9"
content = '''When dynamic_cast is used in a constructor or destructor (or function called from them) and the operand refers to the object under construction or destruction, if the static type of the operand is not a pointer to or object of the constructor or destructor's own class or one of its bases, the dynamic_cast results in undefined behavior.'''
formal_spec = '''(in_constructor(C) || in_destructor(C)) && dynamic_cast_operand_refers_to(operand, object_under_construction_or_destruction) && !is_pointer_to_or_object_of(static_type(operand), C) && !is_pointer_to_or_object_of_base(static_type(operand), C) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/6"
tags = ['lifetime', 'constructor', 'destructor', 'dynamic_cast', 'rtti']

[[axioms]]
id = "cpp20_class_base_init_mem_init_invalid_id_a2b3c4d5"
content = '''A mem-initializer-id must name the constructor's class, a direct non-static data member of the constructor's class, or a direct or virtual base of that class; otherwise the mem-initializer is ill-formed.'''
formal_spec = '''mem_initializer_id(id) && !names_constructor_class(id) && !names_direct_nonstatic_member(id) && !names_direct_base(id) && !names_virtual_base(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/2"
tags = ['initialization', 'constructor', 'mem-initializer']

[[axioms]]
id = "cpp20_class_base_init_ambiguous_base_e5f6a7b8"
content = '''If a mem-initializer-id is ambiguous because it designates both a direct non-virtual base class and an indirect virtual base class, the mem-initializer is ill-formed.'''
formal_spec = '''mem_initializer_id(id) && designates_direct_nonvirtual_base(id, B) && designates_indirect_virtual_base(id, B) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/4"
tags = ['initialization', 'constructor', 'base-class', 'ambiguity']

[[axioms]]
id = "cpp20_class_base_init_duplicate_mem_init_c9d0e1f2"
content = '''If a ctor-initializer specifies more than one mem-initializer for the same member or for the same base class, the ctor-initializer is ill-formed.'''
formal_spec = '''ctor_initializer(ctor) && count_mem_initializers_for(ctor, target) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/5"
tags = ['initialization', 'constructor', 'mem-initializer']

[[axioms]]
id = "cpp20_class_base_init_delegating_sole_init_3a4b5c6d"
content = '''If a mem-initializer-id designates the constructor's class (delegating constructor), it shall be the only mem-initializer.'''
formal_spec = '''mem_initializer_id_designates_own_class(id, ctor) && has_other_mem_initializers(ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/6"
tags = ['initialization', 'constructor', 'delegating-constructor']

[[axioms]]
id = "cpp20_class_base_init_recursive_delegation_7e8f9a0b"
content = '''If a constructor delegates to itself directly or indirectly, the program is ill-formed, no diagnostic required.'''
formal_spec = '''is_delegating_constructor(ctor) && delegates_to_self_transitively(ctor) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/6"
tags = ['initialization', 'constructor', 'delegating-constructor', 'recursion']

[[axioms]]
id = "cpp20_class_base_init_temp_bound_to_ref_member_1c2d3e4f"
content = '''A temporary expression bound to a reference member in a mem-initializer is ill-formed.'''
formal_spec = '''mem_initializer(init) && is_reference_member(target(init)) && binds_temporary(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/8"
tags = ['initialization', 'constructor', 'reference', 'temporary', 'lifetime']

[[axioms]]
id = "cpp20_class_base_init_multiple_union_members_5g6h7i8j"
content = '''An attempt to initialize more than one non-static data member of a union renders the program ill-formed.'''
formal_spec = '''is_union(class_of(ctor)) && count_initialized_members(ctor) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/9"
tags = ['initialization', 'constructor', 'union', 'variant-member']

[[axioms]]
id = "cpp20_class_base_init_temp_bound_default_init_9k0l1m2n"
content = '''A temporary expression bound to a reference member from a default member initializer is ill-formed.'''
formal_spec = '''default_member_initializer(init) && is_reference_member(target(init)) && binds_temporary(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/11"
tags = ['initialization', 'default-member-initializer', 'reference', 'temporary', 'lifetime']

[[axioms]]
id = "cpp20_class_base_init_vfunc_before_base_init_3o4p5q6r"
content = '''Calling member functions (including virtual member functions) or using typeid/dynamic_cast during ctor-initializer evaluation before all mem-initializers for base classes have completed is undefined behavior.'''
formal_spec = '''in_ctor_initializer_evaluation(ctor) && !all_base_mem_initializers_complete(ctor) && (calls_member_function() || uses_typeid() || uses_dynamic_cast()) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/16"
tags = ['initialization', 'constructor', 'virtual-function', 'typeid', 'dynamic_cast', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_base_init_precondition_assert_ctor_7s8t9u0v"
content = '''Calling member functions or using typeid/dynamic_cast during evaluation of a precondition assertion of a constructor is undefined behavior.'''
formal_spec = '''in_precondition_assertion_of_constructor(ctor) && (calls_member_function() || uses_typeid() || uses_dynamic_cast()) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/16.2"
tags = ['initialization', 'constructor', 'contract', 'precondition', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_base_init_postcondition_assert_dtor_1w2x3y4z"
content = '''Calling member functions or using typeid/dynamic_cast during evaluation of a postcondition assertion of a destructor is undefined behavior.'''
formal_spec = '''in_postcondition_assertion_of_destructor(dtor) && (calls_member_function() || uses_typeid() || uses_dynamic_cast()) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/16.3"
tags = ['initialization', 'destructor', 'contract', 'postcondition', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_base_init_virt_base_first_order_5a6b7c8d"
content = '''In a non-delegating constructor of the most derived class, virtual base classes are initialized first in depth-first left-to-right traversal order of the base class DAG.'''
formal_spec = '''is_most_derived_class_ctor(ctor) && !is_delegating_constructor(ctor) => init_order_virtual_bases_first_dfs_ltr(ctor)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/13.1"
tags = ['initialization', 'constructor', 'virtual-base', 'initialization-order']

[[axioms]]
id = "cpp20_class_base_init_direct_base_decl_order_9e0f1g2h"
content = '''In a non-delegating constructor, direct base classes are initialized in declaration order as they appear in the base-specifier-list, regardless of mem-initializer order.'''
formal_spec = '''!is_delegating_constructor(ctor) => init_order_direct_bases_declaration_order(ctor)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/13.2"
tags = ['initialization', 'constructor', 'base-class', 'initialization-order']

[[axioms]]
id = "cpp20_class_base_init_member_decl_order_3i4j5k6l"
content = '''In a non-delegating constructor, non-static data members are initialized in the order they were declared in the class definition, regardless of mem-initializer order.'''
formal_spec = '''!is_delegating_constructor(ctor) => init_order_members_declaration_order(ctor)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/13.3"
tags = ['initialization', 'constructor', 'data-member', 'initialization-order']

[[axioms]]
id = "cpp20_class_base_init_virt_base_ignored_7m8n9o0p"
content = '''A mem-initializer where the mem-initializer-id denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.'''
formal_spec = '''mem_initializer_denotes_virtual_base(init) && !is_most_derived_class_ctor(ctor) => ignored(init)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/7"
tags = ['initialization', 'constructor', 'virtual-base']

[[axioms]]
id = "cpp20_class_base_init_default_init_override_1q2r3s4t"
content = '''If a non-static data member has both a default member initializer and a mem-initializer, the mem-initializer is performed and the default member initializer is ignored.'''
formal_spec = '''has_default_member_initializer(member) && has_mem_initializer(member, ctor) => use_mem_initializer(member) && ignore_default_member_initializer(member)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/10"
tags = ['initialization', 'constructor', 'default-member-initializer', 'mem-initializer']

[[axioms]]
id = "cpp20_class_dtor_address_not_taken_a3f8b2c1"
content = '''The address of a destructor shall not be taken.'''
formal_spec = '''address_of(destructor(C)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/5"
tags = ['destructor', 'address', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_virtual_must_define_d7e9f3a2"
content = '''If the destructor of a class is virtual and any objects of that class or any derived class are created in the program, the destructor shall be defined.'''
formal_spec = '''virtual_destructor(C) && (object_created(C) || exists(D, derived_from(D, C) && object_created(D))) => must_be_defined(destructor(C))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/11"
tags = ['destructor', 'virtual', 'definition', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_virtual_dealloc_lookup_fail_e4b2c8d1"
content = '''At the point of definition of a virtual destructor, if the non-array deallocation function lookup fails or the deallocation function has a deleted definition, the program is ill-formed.'''
formal_spec = '''virtual_destructor(C) && defined(destructor(C)) && (dealloc_lookup_fails(C) || deleted(dealloc_function(C))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/15"
tags = ['destructor', 'virtual', 'deallocation', 'delete']

[[axioms]]
id = "cpp20_class_dtor_invoke_wrong_type_ub_f5a3d9e7"
content = '''Invoking a destructor on an object that is not of the destructor's class type and not of a class derived from the destructor's class type (including when invoked via a null pointer value) is undefined behavior.'''
formal_spec = '''explicit_destructor_call(ptr, DtorClass) && !is_type_or_derived(pointee_type(ptr), DtorClass) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/16"
tags = ['destructor', 'explicit-call', 'type-mismatch', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_invoke_null_ptr_ub_c8e2b4f6"
content = '''Invoking a destructor via a null pointer value is undefined behavior.'''
formal_spec = '''explicit_destructor_call(ptr, C) && is_null(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/16"
tags = ['destructor', 'null-pointer', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_invoke_ended_lifetime_ub_b7d4e1a9"
content = '''Invoking a destructor for an object whose lifetime has ended is undefined behavior.'''
formal_spec = '''destructor_invoked(obj) && lifetime_ended(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/18"
tags = ['destructor', 'lifetime', 'double-destroy', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_double_destroy_auto_ub_a2c5f8b3"
content = '''If the destructor for an object with automatic storage duration is explicitly invoked, and the block is subsequently left in a manner that would ordinarily invoke implicit destruction of the object, the behavior is undefined.'''
formal_spec = '''automatic_storage(obj) && explicit_destructor_call(obj) && block_exit_triggers_implicit_destroy(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/18"
tags = ['destructor', 'automatic-storage', 'double-destroy', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_potentially_invoked_deleted_c9f3a7d2"
content = '''A program is ill-formed if a destructor that is potentially invoked is deleted or not accessible from the context of the invocation.'''
formal_spec = '''potentially_invoked(destructor(C), context) && (deleted(destructor(C)) || !accessible(destructor(C), context)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/14"
tags = ['destructor', 'deleted', 'accessibility', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_overload_resolution_fail_e6b8c2d4"
content = '''The program is ill-formed if overload resolution fails when selecting the destructor from prospective destructors.'''
formal_spec = '''class_definition_end(C) && overload_resolution_fails(prospective_destructors(C), empty_args) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/4"
tags = ['destructor', 'overload-resolution', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_no_arguments_d4e7f9a1"
content = '''A prospective destructor shall take no arguments.'''
formal_spec = '''prospective_destructor(D) && parameter_count(D) != 0 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/1"
tags = ['destructor', 'parameters', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_decl_specifiers_b3a6c8e5"
content = '''Each decl-specifier of the decl-specifier-seq of a prospective destructor declaration shall be friend, inline, virtual, or constexpr.'''
formal_spec = '''prospective_destructor(D) && has_decl_specifier(D, S) && S not_in {friend, inline, virtual, constexpr} => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/1"
tags = ['destructor', 'declaration', 'specifier', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_not_coroutine_f8c4d2e6"
content = '''A destructor shall not be a coroutine.'''
formal_spec = '''destructor(D) && is_coroutine(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/20"
tags = ['destructor', 'coroutine', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_lifetime_ends_on_invoke_a5d8e3b7"
content = '''Once a destructor is invoked for an object, the object's lifetime ends.'''
formal_spec = '''destructor_invoked(obj) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/18"
tags = ['destructor', 'lifetime', 'invariant']

[[axioms]]
id = "cpp20_class_dtor_const_volatile_stop_c2f6b9d8"
content = '''const and volatile semantics are not applied on an object under destruction. They stop being in effect when the destructor for the most derived object starts.'''
formal_spec = '''destructor_started(most_derived_object(obj)) => !apply_cv_semantics(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.dtor"
source_module = "[class.dtor]/5"
tags = ['destructor', 'const', 'volatile', 'cv-qualification']

[[axioms]]
id = "cpp20_class_dtor_deleted_inaccessible_subobject_d9e4a7c3"
content = '''A defaulted destructor for a non-union class X is defined as deleted if any non-variant potentially constructed subobject has class type M where M has a destructor that is deleted or inaccessible from the defaulted destructor.'''
formal_spec = '''defaulted_destructor(X) && !is_union(X) && exists(subobj, non_variant_potentially_constructed(subobj, X) && class_type(subobj, M) && (deleted(destructor(M)) || !accessible(destructor(M), destructor(X)))) => deleted(destructor(X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/7.1"
tags = ['destructor', 'defaulted', 'deleted', 'accessibility']

[[axioms]]
id = "cpp20_class_dtor_deleted_virtual_dealloc_e7f2b5a4"
content = '''A defaulted destructor for a class is defined as deleted if for a virtual destructor, lookup of the non-array deallocation function results in an ambiguity or in a function that is deleted or inaccessible from the defaulted destructor.'''
formal_spec = '''defaulted_destructor(X) && virtual(destructor(X)) && (dealloc_lookup_ambiguous(X) || deleted(dealloc_function(X)) || !accessible(dealloc_function(X), destructor(X))) => deleted(destructor(X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/7.3"
tags = ['destructor', 'virtual', 'deallocation', 'deleted']

[[axioms]]
id = "cpp20_class_dtor_destruction_order_a8c3e6f1"
content = '''Bases and members are destroyed in the reverse order of the completion of their constructor.'''
formal_spec = '''destruction_order(class_members_and_bases(X)) == reverse(construction_completion_order(class_members_and_bases(X)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/13"
tags = ['destructor', 'construction-order', 'destruction-order', 'invariant']

[[axioms]]
id = "cpp20_class_dtor_array_destruction_order_b4d7e9c2"
content = '''Destructors for elements of an array are called in reverse order of their construction.'''
formal_spec = '''array_of_class_type(arr) => destruction_order(elements(arr)) == reverse(construction_order(elements(arr)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/13"
tags = ['destructor', 'array', 'destruction-order', 'invariant']

[[axioms]]
id = "cpp20_class_virtual_multiple_final_overriders_a7d3e1f2"
content = '''In a derived class, if a virtual member function of a base class subobject has more than one final overrider, the program is ill-formed.'''
formal_spec = '''derived_class(D) && base_class_subobject(S, D) && virtual_function(V, S) && final_overrider(F1, V, D) && final_overrider(F2, V, D) && F1 != F2 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/2"
tags = ['virtual', 'override', 'inheritance', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_final_override_attempt_b8c4f2a9"
content = '''If a virtual function f in some class B is marked with the virt-specifier final and in a class D derived from B a function D::f overrides B::f, the program is ill-formed.'''
formal_spec = '''virtual_function(f, B) && has_virt_specifier(f, final) && derived_from(D, B) && overrides(D::f, B::f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/4"
tags = ['virtual', 'final', 'override', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_override_specifier_no_base_c9d5a3b1"
content = '''If a virtual function is marked with the virt-specifier override and does not override a member function of a base class, the program is ill-formed.'''
formal_spec = '''virtual_function(f) && has_virt_specifier(f, override) && NOT(exists(g, base_class_of(class_of(f)), overrides(f, g))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/5"
tags = ['virtual', 'override', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_no_requires_clause_d1e6b4c2"
content = '''A virtual function shall not have a trailing requires-clause.'''
formal_spec = '''virtual_function(f) && has_trailing_requires_clause(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/6"
tags = ['virtual', 'constraints', 'requires', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_ref_qualifier_match_e2f7c5d3"
content = '''The ref-qualifier, or lack thereof, of an overriding function shall be the same as that of the overridden function.'''
formal_spec = '''overrides(f_derived, f_base) => ref_qualifier(f_derived) == ref_qualifier(f_base)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/7"
tags = ['virtual', 'override', 'ref-qualifier', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_return_type_covariant_f3a8d6e4"
content = '''The return type of an overriding function shall be either identical to the return type of the overridden function or covariant with the classes of the functions.'''
formal_spec = '''overrides(f_derived, f_base) => (return_type(f_derived) == return_type(f_base) || covariant_return_types(f_derived, f_base))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8"
tags = ['virtual', 'override', 'return-type', 'covariant', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_covariant_pointer_ref_g4b9e7f5"
content = '''For covariant return types, both return types must be pointers to classes, both lvalue references to classes, or both rvalue references to classes.'''
formal_spec = '''covariant_return_types(f_derived, f_base) => ((is_pointer_to_class(return_type(f_base)) && is_pointer_to_class(return_type(f_derived))) || (is_lvalue_ref_to_class(return_type(f_base)) && is_lvalue_ref_to_class(return_type(f_derived))) || (is_rvalue_ref_to_class(return_type(f_base)) && is_rvalue_ref_to_class(return_type(f_derived))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8.1"
tags = ['virtual', 'covariant', 'return-type', 'pointer', 'reference']

[[axioms]]
id = "cpp20_class_virtual_covariant_base_accessible_h5c1f8a6"
content = '''For covariant return types, the class in the return type of B::f shall be the same class as or an unambiguous and accessible direct or indirect base class of the class in the return type of D::f.'''
formal_spec = '''covariant_return_types(D::f, B::f) => (class_in_return_type(B::f) == class_in_return_type(D::f) || (is_base_class_of(class_in_return_type(B::f), class_in_return_type(D::f)) && unambiguous_base(class_in_return_type(B::f), class_in_return_type(D::f)) && accessible_base(class_in_return_type(B::f), class_in_return_type(D::f))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8.2"
tags = ['virtual', 'covariant', 'return-type', 'base-class', 'accessibility']

[[axioms]]
id = "cpp20_class_virtual_covariant_cv_qualification_i6d2a9b7"
content = '''For covariant return types, both pointers or references shall have the same cv-qualification and the class type in the return type of D::f shall have the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.'''
formal_spec = '''covariant_return_types(D::f, B::f) => (cv_qual_of_ptr_or_ref(return_type(D::f)) == cv_qual_of_ptr_or_ref(return_type(B::f)) && cv_qual_of_class(return_type(D::f)) <= cv_qual_of_class(return_type(B::f)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8.3"
tags = ['virtual', 'covariant', 'return-type', 'cv-qualification']

[[axioms]]
id = "cpp20_class_virtual_covariant_complete_type_j7e3b1c8"
content = '''If the class type in the covariant return type of D::f differs from that of B::f, the class type in the return type of D::f shall be complete at the locus of the overriding declaration or shall be the class type D.'''
formal_spec = '''covariant_return_types(D::f, B::f) && class_in_return_type(D::f) != class_in_return_type(B::f) => (is_complete_at_locus(class_in_return_type(D::f), declaration_of(D::f)) || class_in_return_type(D::f) == D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/9"
tags = ['virtual', 'covariant', 'return-type', 'complete-type']

[[axioms]]
id = "cpp20_class_virtual_odr_define_or_pure_k8f4c2d9"
content = '''A virtual function declared in a class shall be defined, or declared pure in that class, or both; no diagnostic is required.'''
formal_spec = '''virtual_function(f, C) && declared_in(f, C) && NOT(defined(f)) && NOT(is_pure_virtual(f)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/12"
tags = ['virtual', 'odr', 'pure-virtual', 'definition', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_class_virtual_deleted_not_override_nondeleted_l9a5d3e1"
content = '''A deleted function shall not override a function that is not deleted.'''
formal_spec = '''is_deleted(f_derived) && overrides(f_derived, f_base) && NOT(is_deleted(f_base)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/17"
tags = ['virtual', 'override', 'deleted', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_nondeleted_not_override_deleted_m1b6e4f2"
content = '''A function that is not deleted shall not override a deleted function.'''
formal_spec = '''NOT(is_deleted(f_derived)) && overrides(f_derived, f_base) && is_deleted(f_base) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/17"
tags = ['virtual', 'override', 'deleted', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_consteval_override_nonconsteval_n2c7f5a3"
content = '''A class with a consteval virtual function that overrides a virtual function that is not consteval shall have consteval-only type.'''
formal_spec = '''class_has_member(C, f) && is_consteval(f) && virtual_function(f) && overrides(f, g) && NOT(is_consteval(g)) => is_consteval_only_type(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/18"
tags = ['virtual', 'consteval', 'override', 'consteval-only']

[[axioms]]
id = "cpp20_class_virtual_consteval_not_overridden_by_nonconsteval_o3d8a6b4"
content = '''A consteval virtual function shall not be overridden by a virtual function that is not consteval.'''
formal_spec = '''is_consteval(f_base) && virtual_function(f_base) && overrides(f_derived, f_base) && virtual_function(f_derived) && NOT(is_consteval(f_derived)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/18"
tags = ['virtual', 'consteval', 'override', 'ill-formed']

[[axioms]]
id = "cpp20_class_abstract_virtual_call_pure_from_ctor_dtor_a7c3f2e1"
content = '''Making a virtual call to a pure virtual function directly or indirectly for the object being created or destroyed from a constructor or destructor of an abstract class is undefined behavior.'''
formal_spec = '''(in_constructor(C, obj) || in_destructor(C, obj)) && is_abstract_class(C) && virtual_call(f, obj) && is_pure_virtual(final_overrider(f, dynamic_type(obj))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.abstract"
source_module = "[class.abstract]/6"
tags = ['lifetime', 'constructor', 'destructor', 'virtual', 'pure-virtual', 'abstract-class']

[[axioms]]
id = "cpp20_class_abstract_no_object_creation_b4d8e9f2"
content = '''No objects of an abstract class can be created except as subobjects of a class derived from it.'''
formal_spec = '''is_abstract_class(C) && create_object(C) && !is_subobject_of_derived(obj, C) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/2"
tags = ['abstract-class', 'object-creation', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_no_parameter_type_c5a7d3b8"
content = '''An abstract class type cannot be used as a parameter type of a function being defined or called.'''
formal_spec = '''is_abstract_class(T) && (is_parameter_type(T, func_def) || is_parameter_type(T, func_call)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/3"
tags = ['abstract-class', 'function', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_no_return_type_d6b9e4c7"
content = '''An abstract class type cannot be used as a return type of a function being defined or called.'''
formal_spec = '''is_abstract_class(T) && (is_return_type(T, func_def) || is_return_type(T, func_call)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/3"
tags = ['abstract-class', 'function', 'return-type', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_no_explicit_conversion_e8c2f5a9"
content = '''An abstract class type cannot be used as the type of an explicit type conversion because the resulting prvalue would be of abstract class type.'''
formal_spec = '''is_abstract_class(T) && (static_cast_to(T) || reinterpret_cast_to(T) || const_cast_to(T)) && is_prvalue_result => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/3"
tags = ['abstract-class', 'cast', 'conversion', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_pure_specifier_no_definition_f9d3a6b2"
content = '''A function declaration cannot provide both a pure-specifier and a definition in the same declaration.'''
formal_spec = '''has_pure_specifier(decl) && has_definition(decl) && same_declaration(decl) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.abstract"
source_module = "[class.abstract]/2"
tags = ['abstract-class', 'pure-virtual', 'declaration', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_pure_virtual_must_define_if_qualified_call_a2e7c8d4"
content = '''A pure virtual function need be defined only if called with, or as if with, the qualified-id syntax.'''
formal_spec = '''is_pure_virtual(f) && qualified_call(f) && !has_definition(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/2"
tags = ['abstract-class', 'pure-virtual', 'definition', 'qualified-id', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_definition_class_has_pure_virtual_b3f8d9e5"
content = '''A class is an abstract class if it has at least one pure virtual function for which the final overrider is pure virtual.'''
formal_spec = '''exists(f, member_of(f, C) && is_virtual(f) && is_pure_virtual(final_overrider(f, C))) => is_abstract_class(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.abstract"
source_module = "[class.abstract]/4"
tags = ['abstract-class', 'pure-virtual', 'final-overrider', 'definition']

[[axioms]]
id = "cpp20_special_no_define_implicit_decl_a7c3f2b1"
content = '''Programs shall not define implicitly-declared special member functions.'''
formal_spec = '''implicitly_declared(F) && is_special_member_function(F) && program_defines(F) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/1"
tags = ['special-member-functions', 'implicit-declaration', 'definition', 'constraint']

[[axioms]]
id = "cpp20_special_implicit_decl_at_closing_brace_d4e8f1a2"
content = '''An implicitly-declared special member function is declared at the closing } of the class-specifier.'''
formal_spec = '''implicitly_declared(F) && is_special_member_function(F) => declaration_point(F) == closing_brace(class_specifier(class_of(F)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "special"
source_module = "[special]/1"
tags = ['special-member-functions', 'implicit-declaration', 'declaration-point']

[[axioms]]
id = "cpp20_special_eligible_not_deleted_c2b9e7f3"
content = '''An eligible special member function must not be deleted.'''
formal_spec = '''eligible_special_member_function(F) => !is_deleted(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/6.1"
tags = ['special-member-functions', 'eligible', 'deleted-functions']

[[axioms]]
id = "cpp20_special_eligible_constraints_satisfied_b5a1d8c4"
content = '''An eligible special member function must have its associated constraints satisfied, if any.'''
formal_spec = '''eligible_special_member_function(F) && has_constraints(F) => constraints_satisfied(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/6.2"
tags = ['special-member-functions', 'eligible', 'constraints', 'concepts']

[[axioms]]
id = "cpp20_special_eligible_most_constrained_e9f4a2d6"
content = '''An eligible special member function must not have another special member function of the same kind that is more constrained and whose constraints are satisfied.'''
formal_spec = '''eligible_special_member_function(F) => !exists(G, same_kind(F, G) && constraints_satisfied(G) && more_constrained(G, F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/6.3"
tags = ['special-member-functions', 'eligible', 'constraints', 'overload-resolution']

[[axioms]]
id = "cpp20_special_same_kind_default_ctor_f1c7b3e8"
content = '''Two special member functions are of the same kind if they are both default constructors.'''
formal_spec = '''same_kind(F, G) <= (is_default_constructor(F) && is_default_constructor(G))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/5.1"
tags = ['special-member-functions', 'same-kind', 'default-constructor']

[[axioms]]
id = "cpp20_special_same_kind_copy_move_ctor_a3d2c9f5"
content = '''Two special member functions are of the same kind if they are both copy or move constructors with the same first parameter type.'''
formal_spec = '''same_kind(F, G) <= ((is_copy_constructor(F) || is_move_constructor(F)) && (is_copy_constructor(G) || is_move_constructor(G)) && first_param_type(F) == first_param_type(G))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/5.2"
tags = ['special-member-functions', 'same-kind', 'copy-constructor', 'move-constructor']

[[axioms]]
id = "cpp20_special_same_kind_copy_move_assign_c8e1f4b7"
content = '''Two special member functions are of the same kind if they are both copy or move assignment operators with the same first parameter type and the same cv-qualifiers and ref-qualifier, if any.'''
formal_spec = '''same_kind(F, G) <= ((is_copy_assignment(F) || is_move_assignment(F)) && (is_copy_assignment(G) || is_move_assignment(G)) && first_param_type(F) == first_param_type(G) && cv_qualifiers(F) == cv_qualifiers(G) && ref_qualifier(F) == ref_qualifier(G))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/5.3"
tags = ['special-member-functions', 'same-kind', 'copy-assignment', 'move-assignment']

[[axioms]]
id = "cpp20_special_potentially_constructed_subobjects_d5f2a8c1"
content = '''For a class, its potentially constructed subobjects are: direct non-static data members, non-virtual direct base classes, and (if the class is not abstract) its virtual base classes.'''
formal_spec = '''potentially_constructed_subobject(C, S) <=> (is_direct_nonstatic_data_member(C, S) || is_nonvirtual_direct_base(C, S) || (!is_abstract(C) && is_virtual_base(C, S)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/7"
tags = ['special-member-functions', 'subobjects', 'construction', 'abstract-class']

[[axioms]]
id = "cpp20_over_match_general_resolution_fails_illformed_a3b7c2d1"
content = '''When overload resolution fails (no best viable function exists or it is not unique), the invocation is ill-formed.'''
formal_spec = '''overload_resolution(candidates, args) && (!exists_best_viable(candidates, args) || !unique_best_viable(candidates, args)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.general"
source_module = "[over.match.general]/3"
tags = ['overload-resolution', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_general_inaccessible_illformed_e4f8a1b2"
content = '''When overload resolution succeeds but the best viable function is not accessible in the context in which it is used, the program is ill-formed.'''
formal_spec = '''overload_resolution_succeeds(f, context) && !accessible(f, context) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.general"
source_module = "[over.match.general]/3"
tags = ['overload-resolution', 'accessibility', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_funcs_single_user_conversion_c7d9e3f4"
content = '''Only one user-defined conversion is allowed in an implicit conversion sequence (except in list-initialization).'''
formal_spec = '''implicit_conversion_sequence(expr, target_type) && !is_list_initialization(context) => user_defined_conversion_count(sequence) <= 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/6"
tags = ['overload-resolution', 'user-defined-conversion', 'implicit-conversion']

[[axioms]]
id = "cpp20_over_match_funcs_deleted_move_excluded_b2c4a6d8"
content = '''A defaulted move special member function that is defined as deleted is excluded from the set of candidate functions in all contexts.'''
formal_spec = '''is_move_special_member(f) && is_defaulted(f) && is_defined_as_deleted(f) => excluded_from_candidates(f)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/9"
tags = ['overload-resolution', 'move-constructor', 'move-assignment', 'deleted-function']

[[axioms]]
id = "cpp20_over_match_funcs_inherited_ctor_excluded_f1e2d3c4"
content = '''A constructor inherited from class C with first parameter of type reference to P is excluded when constructing object of type D if argument list has exactly one argument and C is reference-related to P and P is reference-related to D.'''
formal_spec = '''inherited_constructor(ctor, C) && first_param_type(ctor) == reference_to(cv1, P) && constructing_type(D) && argument_count == 1 && reference_related(C, P) && reference_related(P, D) => excluded_from_candidates(ctor)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/9"
tags = ['overload-resolution', 'inherited-constructor', 'candidate-exclusion']

[[axioms]]
id = "cpp20_over_match_call_general_member_from_address_illformed_a5b6c7d8"
content = '''If the postfix-expression is the address of an overload set and the function selected by overload resolution is an implicit object member function, the program is ill-formed.'''
formal_spec = '''is_address_of_overload_set(postfix_expr) && overload_resolution_selects(f) && is_implicit_object_member_function(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.call.general"
source_module = "[over.match.call.general]/2"
tags = ['overload-resolution', 'function-call', 'member-function', 'ill-formed']

[[axioms]]
id = "cpp20_over_call_func_precondition_assertion_illformed_d8e9f0a1"
content = '''In an unqualified function call appearing in a precondition assertion of a constructor or postcondition assertion of a destructor, if overload resolution selects a non-static member function, the call is ill-formed.'''
formal_spec = '''unqualified_function_call(call) && (in_constructor_precondition(call) || in_destructor_postcondition(call)) && overload_resolution_selects(f) && is_non_static_member_function(f) && uses_implied_this(call) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.call.func"
source_module = "[over.call.func]/3"
tags = ['overload-resolution', 'precondition', 'postcondition', 'constructor', 'destructor', 'ill-formed']

[[axioms]]
id = "cpp20_over_call_func_contrived_object_nonstatic_illformed_b1c2d3e4"
content = '''In an unqualified function call where a contrived object becomes the implied object argument, if overload resolution selects a non-static member function, the call is ill-formed.'''
formal_spec = '''unqualified_function_call(call) && uses_contrived_object(call) && overload_resolution_selects(f) && is_non_static_member_function(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.call.func"
source_module = "[over.call.func]/3"
tags = ['overload-resolution', 'function-call', 'contrived-object', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_oper_no_class_enum_builtin_f5a6b7c8"
content = '''If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator.'''
formal_spec = '''operator_expression(op, operands) && forall(o in operands, !is_class_type(type(o)) && !is_enum_type(type(o))) => is_builtin_operator(op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/1"
tags = ['overload-resolution', 'operators', 'built-in-operator']

[[axioms]]
id = "cpp20_over_match_oper_rewritten_eq_bool_return_c9d0e1f2"
content = '''If a rewritten operator== candidate is selected by overload resolution for an operator @, its return type shall be cv bool.'''
formal_spec = '''rewritten_operator_eq_selected(f, op) => is_cv_bool(return_type(f))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/10"
tags = ['overload-resolution', 'operators', 'rewritten-candidate', 'equality-operator']

[[axioms]]
id = "cpp20_over_match_ctor_explicit_default_init_copy_list_illformed_a2b3c4d5"
content = '''For default-initialization in the context of copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.'''
formal_spec = '''default_initialization(context) && copy_list_initialization(context) && overload_resolution_selects(ctor) && is_explicit(ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.ctor"
source_module = "[over.match.ctor]/1"
tags = ['overload-resolution', 'constructor', 'explicit', 'list-initialization', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_list_explicit_copy_list_init_illformed_e6f7a8b9"
content = '''In copy-list-initialization, if an explicit constructor is chosen by overload resolution, the initialization is ill-formed.'''
formal_spec = '''copy_list_initialization(context) && overload_resolution_selects(ctor) && is_explicit(ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.list"
source_module = "[over.match.list]/1"
tags = ['overload-resolution', 'list-initialization', 'explicit-constructor', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_oper_assignment_standard_conv_only_c0d1e2f3"
content = '''For the first parameter of built-in assignment operators, only standard conversion sequences are considered (no user-defined conversions).'''
formal_spec = '''builtin_assignment_operator(op) && implicit_conversion_to_first_param(conv) => is_standard_conversion_sequence(conv)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/5"
tags = ['overload-resolution', 'assignment-operator', 'standard-conversion']

[[axioms]]
id = "cpp20_over_match_oper_builtin_no_second_user_defined_g4h5i6j7"
content = '''If a built-in candidate is selected by overload resolution, the second standard conversion sequence of a user-defined conversion sequence is not applied when converting operands of class type.'''
formal_spec = '''builtin_candidate_selected(op) && operand_of_class_type(operand) && user_defined_conversion_sequence(seq, operand) => skip_second_standard_conversion(seq)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "over.match.oper"
source_module = "[over.match.oper]/11"
tags = ['overload-resolution', 'built-in-operator', 'conversion-sequence']

[[axioms]]
id = "cpp20_over_match_funcs_no_user_conv_implicit_object_param_k8l9m0n1"
content = '''No user-defined conversions can be applied to achieve a type match with the implicit object parameter.'''
formal_spec = '''implicit_object_parameter(param) && conversion_to_match(conv, arg, param) => !is_user_defined_conversion(conv)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/5"
tags = ['overload-resolution', 'implicit-object-parameter', 'user-defined-conversion']

[[axioms]]
id = "cpp20_over_match_oper_nonmember_empty_for_assign_subscript_arrow_o2p3q4r5"
content = '''For the operators =, [], or ->, the set of non-member candidates is empty.'''
formal_spec = '''(operator_name(op) == "=" || operator_name(op) == "[]" || operator_name(op) == "->") => non_member_candidates(op) == empty_set'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/3.2"
tags = ['overload-resolution', 'operators', 'non-member-candidates']

[[axioms]]
id = "cpp20_over_match_oper_builtin_empty_for_comma_addr_arrow_s6t7u8v9"
content = '''For the operator comma, the unary operator &, or the operator ->, the built-in candidates set is empty.'''
formal_spec = '''(operator_name(op) == "," || (operator_name(op) == "&" && is_unary(op)) || operator_name(op) == "->") => builtin_candidates(op) == empty_set'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/3.3"
tags = ['overload-resolution', 'operators', 'built-in-candidates']

[[axioms]]
id = "cpp20_over_match_oper_arrow_second_operand_ignored_w0x1y2z3"
content = '''The second operand of operator-> is ignored in selecting an operator-> function, and is not an argument when the operator-> function is called.'''
formal_spec = '''operator_arrow_call(expr) => !includes_second_operand_in_resolution(expr) && !includes_second_operand_in_call(expr)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/12"
tags = ['overload-resolution', 'operators', 'arrow-operator']

[[axioms]]
id = "cpp20_over_match_oper_fallback_builtin_no_viable_a4b5c6d7"
content = '''If the operator is comma, unary &, or ->, and there are no viable functions, then the operator is assumed to be the built-in operator.'''
formal_spec = '''(operator_name(op) == "," || (operator_name(op) == "&" && is_unary(op)) || operator_name(op) == "->") && no_viable_functions(candidates) => use_builtin_operator(op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/13"
tags = ['overload-resolution', 'operators', 'built-in-operator', 'fallback']

[[axioms]]
id = "cpp20_over_match_class_deduct_no_aggregate_element_e8f9a0b1"
content = '''If there is no aggregate element for any initializer element when forming the aggregate deduction candidate, the aggregate deduction candidate is not added to the set.'''
formal_spec = '''forming_aggregate_deduction_candidate(C, init_list) && exists(xi in init_list, !has_corresponding_aggregate_element(C, xi)) => !add_aggregate_deduction_candidate(C)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "over.match.class.deduct"
source_module = "[over.match.class.deduct]/1"
tags = ['overload-resolution', 'class-template-argument-deduction', 'aggregate']

[[axioms]]
id = "cpp20_over_oper_general_class_enum_param_a7b3c2d1"
content = '''An operator function shall have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.'''
formal_spec = '''operator_function(F) => exists(P in parameters(F) union {implicit_object_param(F)}, is_class(type(P)) || is_class_ref(type(P)) || is_enum(type(P)) || is_enum_ref(type(P)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/7"
tags = ['overloading', 'operator', 'constraint']

[[axioms]]
id = "cpp20_over_oper_general_valid_form_e4f5a6b8"
content = '''An operator function shall be a prefix unary, binary, function call, subscripting, class member access, increment, or decrement operator function.'''
formal_spec = '''operator_function(F) => is_prefix_unary(F) || is_binary(F) || is_function_call(F) || is_subscripting(F) || is_class_member_access(F) || is_increment(F) || is_decrement(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/8"
tags = ['overloading', 'operator', 'constraint']

[[axioms]]
id = "cpp20_over_oper_general_no_default_args_c9d8e7f6"
content = '''An operator function cannot have default arguments, except where explicitly stated below (function call and subscripting operators).'''
formal_spec = '''operator_function(F) && !is_function_call_operator(F) && !is_subscripting_operator(F) => !has_default_arguments(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/10"
tags = ['overloading', 'operator', 'default-arguments', 'constraint']

[[axioms]]
id = "cpp20_over_oper_general_param_count_b2a1c3d4"
content = '''Operator functions cannot have more or fewer parameters than the number required for the corresponding operator.'''
formal_spec = '''operator_function(F, Op) => param_count(F) == required_param_count(Op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/10"
tags = ['overloading', 'operator', 'constraint']

[[axioms]]
id = "cpp20_over_unary_member_no_params_f1e2d3c4"
content = '''A prefix unary operator function that is a non-static member function shall have no non-object parameters.'''
formal_spec = '''prefix_unary_operator_function(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.unary"
source_module = "[over.unary]/1"
tags = ['overloading', 'operator', 'unary', 'constraint']

[[axioms]]
id = "cpp20_over_unary_nonmember_one_param_a5b6c7d8"
content = '''A prefix unary operator function that is a non-member function shall have one parameter.'''
formal_spec = '''prefix_unary_operator_function(F) && is_non_member_function(F) => param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.unary"
source_module = "[over.unary]/1"
tags = ['overloading', 'operator', 'unary', 'constraint']

[[axioms]]
id = "cpp20_over_binary_member_one_param_d4e5f6a7"
content = '''A binary operator function that is a non-static member function shall have one non-object parameter.'''
formal_spec = '''binary_operator_function(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.binary.general"
source_module = "[over.binary.general]/1"
tags = ['overloading', 'operator', 'binary', 'constraint']

[[axioms]]
id = "cpp20_over_binary_nonmember_two_params_b8c9d0e1"
content = '''A binary operator function that is a non-member function shall have two parameters.'''
formal_spec = '''binary_operator_function(F) && is_non_member_function(F) => param_count(F) == 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.binary.general"
source_module = "[over.binary.general]/1"
tags = ['overloading', 'operator', 'binary', 'constraint']

[[axioms]]
id = "cpp20_over_assign_member_only_c2d3e4f5"
content = '''A simple assignment operator function shall be a non-static member function.'''
formal_spec = '''simple_assignment_operator_function(F) => is_member_function(F) && !is_static(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.assign"
source_module = "[over.assign]/1"
tags = ['overloading', 'operator', 'assignment', 'constraint']

[[axioms]]
id = "cpp20_over_call_member_only_a1b2c3d4"
content = '''A function call operator function shall be a member function.'''
formal_spec = '''function_call_operator_function(F) => is_member_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.call"
source_module = "[over.call]/1"
tags = ['overloading', 'operator', 'function-call', 'constraint']

[[axioms]]
id = "cpp20_over_sub_member_only_e5f6a7b8"
content = '''A subscripting operator function shall be a member function.'''
formal_spec = '''subscripting_operator_function(F) => is_member_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.sub"
source_module = "[over.sub]/1"
tags = ['overloading', 'operator', 'subscript', 'constraint']

[[axioms]]
id = "cpp20_over_ref_member_no_params_c9d0e1f2"
content = '''A class member access operator function shall be a non-static member function taking no non-object parameters.'''
formal_spec = '''class_member_access_operator_function(F) => is_member_function(F) && !is_static(F) && non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.ref"
source_module = "[over.ref]/1"
tags = ['overloading', 'operator', 'member-access', 'constraint']

[[axioms]]
id = "cpp20_over_inc_prefix_member_form_a3b4c5d6"
content = '''A prefix increment operator function that is a non-static member function shall have no non-object parameters.'''
formal_spec = '''increment_operator_function(F) && is_prefix_increment(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_inc_prefix_nonmember_form_d7e8f9a0"
content = '''A prefix increment operator function that is a non-member function shall have one parameter.'''
formal_spec = '''increment_operator_function(F) && is_prefix_increment(F) && is_non_member_function(F) => param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_inc_postfix_member_int_param_b1c2d3e4"
content = '''A postfix increment operator function that is a non-static member function shall have one non-object parameter of type int.'''
formal_spec = '''increment_operator_function(F) && is_postfix_increment(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 1 && type(non_object_param(F, 0)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_inc_postfix_nonmember_int_param_f5a6b7c8"
content = '''A postfix increment operator function that is a non-member function shall have two parameters, the second of which shall be of type int.'''
formal_spec = '''increment_operator_function(F) && is_postfix_increment(F) && is_non_member_function(F) => param_count(F) == 2 && type(param(F, 1)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_dec_prefix_member_form_d9e0f1a2"
content = '''A prefix decrement operator function that is a non-static member function shall have no non-object parameters.'''
formal_spec = '''decrement_operator_function(F) && is_prefix_decrement(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_dec_prefix_nonmember_form_b3c4d5e6"
content = '''A prefix decrement operator function that is a non-member function shall have one parameter.'''
formal_spec = '''decrement_operator_function(F) && is_prefix_decrement(F) && is_non_member_function(F) => param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_dec_postfix_member_int_param_f7a8b9c0"
content = '''A postfix decrement operator function that is a non-static member function shall have one non-object parameter of type int.'''
formal_spec = '''decrement_operator_function(F) && is_postfix_decrement(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 1 && type(non_object_param(F, 0)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_dec_postfix_nonmember_int_param_d1e2f3a4"
content = '''A postfix decrement operator function that is a non-member function shall have two parameters, the second of which shall be of type int.'''
formal_spec = '''decrement_operator_function(F) && is_postfix_decrement(F) && is_non_member_function(F) => param_count(F) == 2 && type(param(F, 1)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_oper_declarator_function_b5c6d7e8"
content = '''A declaration whose declarator-id is an operator-function-id shall declare a function or function template or an explicit instantiation or specialization of a function template.'''
formal_spec = '''declarator_id_is_operator_function_id(D) => declares_function(D) || declares_function_template(D) || declares_explicit_instantiation(D) || declares_specialization(D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/1"
tags = ['overloading', 'operator', 'declaration', 'constraint']

[[axioms]]
id = "cpp20_temp_deduct_general_all_args_required_a3b7c9d1"
content = '''When a function template specialization is referenced, all of the template arguments shall have values (explicitly specified, deduced, or from defaults).'''
formal_spec = '''function_template_specialization_referenced(F) => forall(P in template_parameters(F), has_value(P))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/1"
tags = ['template', 'deduction', 'specialization']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_template_id_e4f8a2b6"
content = '''When an explicit template argument list is specified, if the given template-id or splice-specialization-specifier is not valid, type deduction fails.'''
formal_spec = '''explicit_template_arg_list(F, Args) && !valid_template_id(F, Args) => deduction_fails(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/2"
tags = ['template', 'deduction', 'template-id']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_subst_default_c7d2e5f9"
content = '''If substitution of deduced template arguments into a default argument results in an invalid type, type deduction fails.'''
formal_spec = '''substitute(default_arg(P), deduced_args) => invalid_type => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'default-argument', 'substitution']

[[axioms]]
id = "cpp20_temp_deduct_general_constraints_not_satisfied_b1c4d7e0"
content = '''If the function template has associated constraints and those constraints are not satisfied after template argument deduction, type deduction fails.'''
formal_spec = '''has_constraints(F) && !constraints_satisfied(F, deduced_args) => deduction_fails(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'constraints', 'concepts']

[[axioms]]
id = "cpp20_temp_deduct_general_no_implicit_conversion_f9a3b5c8"
content = '''In a function call context, if a non-dependent function parameter cannot receive an implicit conversion from its corresponding argument after explicit template argument substitution, type deduction fails.'''
formal_spec = '''function_call_context && non_dependent_param(P) && !implicit_convertible(arg_type(A), param_type(P)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'conversion', 'function-call']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_final_subst_d2e6f8a1"
content = '''If substitution of deduced or default argument values into the function type results in an invalid type, type deduction fails.'''
formal_spec = '''substitute(function_type(F), all_args) => invalid_type => deduction_fails(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'substitution']

[[axioms]]
id = "cpp20_temp_deduct_general_different_instantiation_order_ndr_c5d8e2f4"
content = '''If substitution into different declarations of the same function template would cause template instantiations to occur in a different order or not at all, the program is ill-formed; no diagnostic required.'''
formal_spec = '''same_function_template(decl1, decl2) && different_instantiation_order(substitute(decl1), substitute(decl2)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/7"
tags = ['template', 'deduction', 'substitution', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_type_expr_fails_a8b1c3d5"
content = '''If a substitution results in an invalid type or expression, type deduction fails.'''
formal_spec = '''substitution(expr_or_type, args) => invalid => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/8"
tags = ['template', 'deduction', 'SFINAE', 'substitution']

[[axioms]]
id = "cpp20_temp_deduct_general_immediate_context_only_e7f9a2b4"
content = '''Invalid types and expressions can result in a deduction failure only in the immediate context of the deduction substitution loci; effects outside the immediate context can result in the program being ill-formed.'''
formal_spec = '''invalid_in_immediate_context(substitution) => deduction_fails; invalid_outside_immediate_context(substitution) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/8"
tags = ['template', 'deduction', 'SFINAE', 'immediate-context']

[[axioms]]
id = "cpp20_temp_deduct_general_lambda_body_not_immediate_d4e6f8a0"
content = '''When substituting into a lambda-expression, substitution into its body is not in the immediate context, so failures in the lambda body cause ill-formed programs rather than deduction failure.'''
formal_spec = '''lambda_expression(L) && substitution_into_body(L) => !immediate_context'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/9"
tags = ['template', 'deduction', 'lambda', 'immediate-context']

[[axioms]]
id = "cpp20_temp_deduct_general_pack_different_lengths_b2c4d6e8"
content = '''Attempting to instantiate a pack expansion containing multiple packs of differing lengths causes type deduction to fail.'''
formal_spec = '''pack_expansion(packs) && exists(p1, p2 in packs, length(p1) != length(p2)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.1"
tags = ['template', 'deduction', 'parameter-pack']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_array_type_a1b3c5d7"
content = '''Attempting to create an array with element type void, function type, or reference type, or with size zero or negative, causes type deduction to fail.'''
formal_spec = '''array_type(element, size) && (element == void || is_function_type(element) || is_reference_type(element) || size <= 0) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.2"
tags = ['template', 'deduction', 'array']

[[axioms]]
id = "cpp20_temp_deduct_general_qualified_name_non_class_c3d5e7f9"
content = '''Attempting to use a type that is not a class or enumeration type in a qualified name causes type deduction to fail.'''
formal_spec = '''qualified_name(T::member) && !is_class_or_enum(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.3"
tags = ['template', 'deduction', 'qualified-name']

[[axioms]]
id = "cpp20_temp_deduct_general_missing_member_e5f7a9b1"
content = '''Attempting to use a type in a nested-name-specifier when that type does not contain the specified member causes type deduction to fail.'''
formal_spec = '''nested_name_specifier(T::member) && !has_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_member_not_type_f7a9b1c3"
content = '''Attempting to use a member as a type when the specified member is not a type causes type deduction to fail.'''
formal_spec = '''type_context(T::member) && !is_type_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4.1"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_member_not_template_a9b1c3d5"
content = '''Attempting to use a member as a template when the specified member is not a template causes type deduction to fail.'''
formal_spec = '''template_context(T::member) && !is_template_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4.2"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_member_not_nontype_b1c3d5e7"
content = '''Attempting to use a member as a non-type, non-template when the specified member is not a non-type, non-template causes type deduction to fail.'''
formal_spec = '''nontype_context(T::member) && !is_nontype_nontemplate_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4.3"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_pointer_to_reference_c3d5e7f9"
content = '''Attempting to create a pointer to reference type causes type deduction to fail.'''
formal_spec = '''pointer_type(T) && is_reference_type(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.5"
tags = ['template', 'deduction', 'pointer', 'reference']

[[axioms]]
id = "cpp20_temp_deduct_general_reference_to_void_d5e7f9a1"
content = '''Attempting to create a reference to void causes type deduction to fail.'''
formal_spec = '''reference_type(void) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.6"
tags = ['template', 'deduction', 'reference', 'void']

[[axioms]]
id = "cpp20_temp_deduct_general_ptr_to_member_non_class_e7f9a1b3"
content = '''Attempting to create "pointer to member of T" when T is not a class type causes type deduction to fail.'''
formal_spec = '''pointer_to_member_type(T, M) && !is_class_type(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.7"
tags = ['template', 'deduction', 'pointer-to-member']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_nontype_arg_f9a1b3c5"
content = '''Attempting to give an invalid type to a constant template parameter causes type deduction to fail.'''
formal_spec = '''constant_template_param(P, T) && !valid_nontype_param_type(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.8"
tags = ['template', 'deduction', 'nontype-parameter']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_conversion_a1b3c5d7"
content = '''Attempting to perform an invalid conversion in either a template argument expression or an expression used in the function declaration causes type deduction to fail.'''
formal_spec = '''(template_arg_expr(E) || function_decl_expr(E)) && !valid_conversion(E) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.9"
tags = ['template', 'deduction', 'conversion']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_function_type_b3c5d7e9"
content = '''Attempting to create a function type in which a parameter has type void, or in which the return type is a function type or array type, causes type deduction to fail.'''
formal_spec = '''function_type(params, ret) && (void in params || is_function_type(ret) || is_array_type(ret)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.10"
tags = ['template', 'deduction', 'function-type']

[[axioms]]
id = "cpp20_temp_deduct_general_lambda_explicit_object_c5d7e9f1"
content = '''Attempting to give to an explicit object parameter of a lambda's function call operator a type not permitted for such causes type deduction to fail.'''
formal_spec = '''lambda_explicit_object_param(L, P, T) && !permitted_explicit_object_type(L, T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.11"
tags = ['template', 'deduction', 'lambda', 'explicit-object']

[[axioms]]
id = "cpp20_temp_deduct_call_init_list_different_types_d7e9f1a3"
content = '''If deduction from initializer list elements leads to different deduced types for the same template parameter, type deduction fails.'''
formal_spec = '''initializer_list(elements) && deduced_types(T, elements) && !all_same(deduced_types) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/1"
tags = ['template', 'deduction', 'initializer-list']

[[axioms]]
id = "cpp20_temp_deduct_call_pack_non_deduced_e9f1a3b5"
content = '''When a function parameter pack appears in a non-deduced context, the type of that pack is never deduced.'''
formal_spec = '''function_parameter_pack(P) && non_deduced_context(P) => !deducible(P)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/1"
tags = ['template', 'deduction', 'parameter-pack', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_call_multiple_deduced_fails_f1a3b5c7"
content = '''If alternatives to make deduced A compatible with A yield more than one possible deduced A, the type deduction fails.'''
formal_spec = '''deduction_alternatives(A) && count(deduction_alternatives) > 1 => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/5"
tags = ['template', 'deduction', 'ambiguity']

[[axioms]]
id = "cpp20_temp_deduct_call_overload_set_template_a3b5c7d9"
content = '''When P is a function type and the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.'''
formal_spec = '''is_function_type(P) && overload_set_contains_template(A) => non_deduced_context(P)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/6.1"
tags = ['template', 'deduction', 'overload-set', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_call_overload_different_types_b5c7d9e1"
content = '''If an overload set argument (not containing function templates) yields different deduced A values from trial deductions, the parameter is treated as a non-deduced context.'''
formal_spec = '''overload_set(A) && !contains_template(A) && !all_same(trial_deductions(A)) => non_deduced_context'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/6.2"
tags = ['template', 'deduction', 'overload-set', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_funcaddr_placeholder_non_deduced_c7d9e1f3"
content = '''A placeholder type in the return type of a function template is a non-deduced context when taking the address of a function template.'''
formal_spec = '''taking_address_of_function_template(F) && placeholder_type(return_type(F)) => non_deduced_context(return_type(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.funcaddr"
source_module = "[temp.deduct.funcaddr]/2"
tags = ['template', 'deduction', 'auto', 'function-address']

[[axioms]]
id = "cpp20_temp_deduct_conv_multiple_deduced_fails_d9e1f3a5"
content = '''If ignoring certain attributes of A allows more than one possible deduced A in conversion function template argument deduction, the type deduction fails.'''
formal_spec = '''conversion_template_deduction && count(possible_deduced_A) > 1 => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.conv"
source_module = "[temp.deduct.conv]/5"
tags = ['template', 'deduction', 'conversion-function']

[[axioms]]
id = "cpp20_temp_deduct_type_inconsistent_deduction_e1f3a5b7"
content = '''If type deduction for any P/A pair leads to more than one possible set of deduced values, or if different pairs yield different deduced values for the same parameter, template argument deduction fails.'''
formal_spec = '''(exists(pair, count(deduced_values(pair)) > 1) || exists(p1, p2, deduced(p1, T) != deduced(p2, T))) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/2"
tags = ['template', 'deduction', 'consistency']

[[axioms]]
id = "cpp20_temp_deduct_type_undeduced_unspecified_f3a5b7c9"
content = '''If any template argument remains neither deduced nor explicitly specified, template argument deduction fails.'''
formal_spec = '''exists(P in template_params, !deduced(P) && !explicitly_specified(P) && !has_default(P)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/2"
tags = ['template', 'deduction']

[[axioms]]
id = "cpp20_temp_deduct_type_non_deduced_not_specified_a5b7c9d1"
content = '''If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails.'''
formal_spec = '''only_in_non_deduced_context(P) && !explicitly_specified(P) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/4"
tags = ['template', 'deduction', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_type_pack_expansion_not_last_b7c9d1e3"
content = '''If the template argument list of P contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context.'''
formal_spec = '''template_arg_list(P, args) && pack_expansion_in(args) && !is_last(pack_expansion, args) => non_deduced_context(args)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/9"
tags = ['template', 'deduction', 'parameter-pack', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_type_partial_order_pack_mismatch_c9d1e3f5"
content = '''During partial ordering, if Ai was originally a pack expansion and Pi is not a pack expansion, template argument deduction fails.'''
formal_spec = '''partial_ordering && was_pack_expansion(Ai) && !is_pack_expansion(Pi) && has_corresponding(P, Ai) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/9.2"
tags = ['template', 'deduction', 'partial-ordering', 'parameter-pack']

[[axioms]]
id = "cpp20_temp_deduct_type_func_param_pack_mismatch_d1e3f5a7"
content = '''During partial ordering, if Ai was originally a function parameter pack and Pi is not a function parameter pack, template argument deduction fails.'''
formal_spec = '''partial_ordering && was_function_param_pack(Ai) && !is_function_param_pack(Pi) && has_corresponding(P, Ai) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/10.2"
tags = ['template', 'deduction', 'partial-ordering', 'function-parameter-pack']

[[axioms]]
id = "cpp20_temp_deduct_partial_unused_param_ok_e3f5a7b9"
content = '''For partial ordering purposes, a template parameter may remain without a value provided it is not used in the types being used for partial ordering.'''
formal_spec = '''partial_ordering && !used_in_ordering_types(P) => !required_to_have_value(P)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.deduct.partial"
source_module = "[temp.deduct.partial]/12"
tags = ['template', 'deduction', 'partial-ordering']

[[axioms]]
id = "cpp20_temp_spec_general_one_explicit_inst_def_a3b7c9d1"
content = '''An explicit instantiation definition shall appear at most once in a program for a given template and a given set of template-arguments.'''
formal_spec = '''forall(template T, template_args Args) => count(explicit_instantiation_definition(T, Args)) <= 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/5.1"
tags = ['template', 'instantiation', 'odr']

[[axioms]]
id = "cpp20_temp_spec_general_one_explicit_spec_def_f2e8a4c6"
content = '''An explicit specialization shall be defined at most once in a program, as specified in the one-definition rule.'''
formal_spec = '''forall(template T, template_args Args) => count(explicit_specialization_definition(T, Args)) <= 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/5.2"
tags = ['template', 'specialization', 'odr']

[[axioms]]
id = "cpp20_temp_spec_general_explicit_inst_spec_reachable_c7d3e5f9"
content = '''Both an explicit instantiation and a declaration of an explicit specialization shall not appear in a program unless the explicit specialization is reachable from the explicit instantiation.'''
formal_spec = '''forall(template T, template_args Args) => (explicit_instantiation(T, Args) && explicit_specialization_decl(T, Args)) => reachable_from(explicit_specialization(T, Args), explicit_instantiation(T, Args))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/5.3"
tags = ['template', 'instantiation', 'specialization', 'reachability']

[[axioms]]
id = "cpp20_temp_spec_general_illformed_dependent_type_func_8a1b2c3d"
content = '''If a function declaration acquired its function type through a dependent type without using the syntactic form of a function declarator, the program is ill-formed.'''
formal_spec = '''function_decl(D) && acquired_type_through_dependent_type(D) && !uses_function_declarator_syntax(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/8"
tags = ['template', 'function', 'dependent-type', 'ill-formed']

[[axioms]]
id = "cpp20_temp_inst_incomplete_class_undeclared_template_e4f5a6b7"
content = '''If the template selected for the specialization has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type.'''
formal_spec = '''template_selected(T) && declared(T) && !defined(T, point_of_instantiation) => incomplete_type(instantiation(T))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.inst"
source_module = "[temp.inst]/2"
tags = ['template', 'instantiation', 'incomplete-type']

[[axioms]]
id = "cpp20_temp_inst_infinite_recursion_undefined_d8c9e0f1"
content = '''The result of an infinite recursion in instantiation is undefined.'''
formal_spec = '''infinite_recursion(template_instantiation) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.inst"
source_module = "[temp.inst]/16"
tags = ['template', 'instantiation', 'recursion', 'undefined-behavior']

[[axioms]]
id = "cpp20_temp_inst_impl_limit_recursive_depth_a2b3c4d5"
content = '''There is an implementation-defined quantity that specifies the limit on the total depth of recursive instantiations.'''
formal_spec = '''exists(impl_defined_limit(recursive_instantiation_depth))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.inst"
source_module = "[temp.inst]/16"
tags = ['template', 'instantiation', 'implementation-defined', 'recursion']

[[axioms]]
id = "cpp20_temp_explicit_no_storage_class_except_thread_local_f6a7b8c9"
content = '''An explicit instantiation shall not use a storage-class-specifier other than thread_local.'''
formal_spec = '''explicit_instantiation(E) && has_storage_class(E, S) && S != thread_local => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/3"
tags = ['template', 'explicit-instantiation', 'storage-class', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_no_inline_constexpr_consteval_d0e1f2a3"
content = '''An explicit instantiation of a function template, member function of a class template, or variable template shall not use the inline, constexpr, or consteval specifiers.'''
formal_spec = '''explicit_instantiation(E) && (is_function_template(E) || is_member_function_of_class_template(E) || is_variable_template(E)) && (has_specifier(E, inline) || has_specifier(E, constexpr) || has_specifier(E, consteval)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/3"
tags = ['template', 'explicit-instantiation', 'inline', 'constexpr', 'consteval', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_no_attribute_specifier_b4c5d6e7"
content = '''No attribute-specifier-seq shall appertain to an explicit instantiation.'''
formal_spec = '''explicit_instantiation(E) && has_attribute_specifier_seq(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/3"
tags = ['template', 'explicit-instantiation', 'attributes', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_decl_reachable_function_template_8a9b0c1d"
content = '''A declaration of a function template, variable template, member function or static data member of a class template, or a member function template of a class or class template shall be reachable from any explicit instantiation of that entity.'''
formal_spec = '''explicit_instantiation(E) && (is_function_template(E) || is_variable_template(E) || is_member_function_of_class_template(E) || is_static_data_member_of_class_template(E) || is_member_function_template(E)) => reachable(declaration(E), explicit_instantiation(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/5"
tags = ['template', 'explicit-instantiation', 'reachability']

[[axioms]]
id = "cpp20_temp_explicit_def_reachable_class_template_2e3f4a5b"
content = '''A definition of a class template, a member class of a class template, or a member class template of a class or class template shall be reachable from any explicit instantiation of that entity unless an explicit specialization of the entity with the same template arguments is reachable therefrom.'''
formal_spec = '''explicit_instantiation(E) && (is_class_template(E) || is_member_class_of_class_template(E) || is_member_class_template(E)) && !reachable(explicit_specialization(E, same_args), explicit_instantiation(E)) => reachable(definition(E), explicit_instantiation(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/5"
tags = ['template', 'explicit-instantiation', 'reachability', 'class-template']

[[axioms]]
id = "cpp20_temp_explicit_implicit_special_member_illformed_c6d7e8f9"
content = '''If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.'''
formal_spec = '''explicit_instantiation(E) && names_implicitly_declared_special_member(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/5"
tags = ['template', 'explicit-instantiation', 'special-member-function', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_def_required_present_0a1b2c3d"
content = '''For an explicit instantiation definition, the definition of a function template, a variable template, a member function template, or a member function or static data member of a class template shall be present in every translation unit in which it is explicitly instantiated.'''
formal_spec = '''explicit_instantiation_definition(E) && (is_function_template(E) || is_variable_template(E) || is_member_function_template(E) || is_member_function_of_class_template(E) || is_static_data_member_of_class_template(E)) => definition_present_in_tu(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/7"
tags = ['template', 'explicit-instantiation', 'definition']

[[axioms]]
id = "cpp20_temp_explicit_prospective_destructor_selected_4e5f6a7b"
content = '''An explicit instantiation of a prospective destructor shall correspond to the selected destructor of the class.'''
formal_spec = '''explicit_instantiation(E) && is_prospective_destructor(E) => corresponds_to_selected_destructor(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/11"
tags = ['template', 'explicit-instantiation', 'destructor']

[[axioms]]
id = "cpp20_temp_explicit_def_follows_decl_same_tu_8c9d0e1f"
content = '''If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation definition in the same translation unit, the definition shall follow the declaration.'''
formal_spec = '''explicit_instantiation_declaration(E, TU) && explicit_instantiation_definition(E, TU) => follows(definition(E), declaration(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/12"
tags = ['template', 'explicit-instantiation', 'declaration', 'definition']

[[axioms]]
id = "cpp20_temp_explicit_used_requires_def_somewhere_ndr_2a3b4c5d"
content = '''An entity that is the subject of an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit instantiation in the translation unit shall be the subject of an explicit instantiation definition somewhere in the program; otherwise the program is ill-formed, no diagnostic required.'''
formal_spec = '''explicit_instantiation_declaration(E) && used_requiring_implicit_instantiation(E) && !exists(explicit_instantiation_definition(E)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/12"
tags = ['template', 'explicit-instantiation', 'ndr', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_no_internal_linkage_6e7f8a9b"
content = '''An explicit instantiation declaration shall not name a specialization of a template with internal linkage.'''
formal_spec = '''explicit_instantiation_declaration(E) && has_internal_linkage(template_of(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/12"
tags = ['template', 'explicit-instantiation', 'linkage', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_export_declaration_0c1d2e3f"
content = '''The declaration in an explicit-specialization shall not be an export-declaration.'''
formal_spec = '''explicit_specialization(E) && is_export_declaration(declaration_of(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/2"
tags = ['template', 'explicit-specialization', 'export', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_storage_class_except_thread_local_4a5b6c7d"
content = '''An explicit specialization shall not use a storage-class-specifier other than thread_local.'''
formal_spec = '''explicit_specialization(E) && has_storage_class(E, S) && S != thread_local => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/2"
tags = ['template', 'explicit-specialization', 'storage-class', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_decl_reachable_8e9f0a1b"
content = '''A declaration of a function template, class template, or variable template being explicitly specialized shall be reachable from the declaration of the explicit specialization.'''
formal_spec = '''explicit_specialization(E) && (is_function_template(E) || is_class_template(E) || is_variable_template(E)) => reachable(primary_template_declaration(E), explicit_specialization_declaration(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/4"
tags = ['template', 'explicit-specialization', 'reachability']

[[axioms]]
id = "cpp20_temp_expl_spec_member_template_class_def_reachable_2c3d4e5f"
content = '''The definition of a class or class template shall be reachable from the declaration of an explicit specialization for a member template of the class or class template.'''
formal_spec = '''explicit_specialization(E) && is_member_template(E) && has_enclosing_class(E, C) => reachable(definition(C), explicit_specialization_declaration(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/4"
tags = ['template', 'explicit-specialization', 'member-template', 'reachability']

[[axioms]]
id = "cpp20_temp_expl_spec_implicit_special_member_illformed_6a7b8c9d"
content = '''If an explicit specialization for the member of a class template names an implicitly-declared special member function, the program is ill-formed.'''
formal_spec = '''explicit_specialization(E) && is_member_of_class_template(E) && names_implicitly_declared_special_member(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/5"
tags = ['template', 'explicit-specialization', 'special-member-function', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_member_def_reachable_0e1f2a3b"
content = '''The definition of the class template explicit specialization shall be reachable from the definition of any member of it.'''
formal_spec = '''explicit_specialization(E) && is_class_template_specialization(E) && has_member(E, M) && defined(M) => reachable(definition(E), definition(M))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/6"
tags = ['template', 'explicit-specialization', 'member', 'reachability']

[[axioms]]
id = "cpp20_temp_expl_spec_decl_reachable_from_use_ndr_4c5d6e7f"
content = '''If a template, a member template or a member of a class template is explicitly specialized, a declaration of that specialization shall be reachable from every use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required.'''
formal_spec = '''explicit_specialization(E) && use_requiring_implicit_instantiation(U, E) => reachable(explicit_specialization_declaration(E), U) || ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/7"
tags = ['template', 'explicit-specialization', 'reachability', 'ndr']

[[axioms]]
id = "cpp20_temp_expl_spec_no_def_used_or_virtual_ndr_8a9b0c1d"
content = '''If the program does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, the program is ill-formed, no diagnostic required.'''
formal_spec = '''explicit_specialization(E) && !defined(E) && (use_requiring_implicit_instantiation(E) || is_virtual_member_function(E)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/7"
tags = ['template', 'explicit-specialization', 'definition', 'virtual', 'ndr']

[[axioms]]
id = "cpp20_temp_expl_spec_enclosing_must_be_specialized_2e3f4a5b"
content = '''The declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well.'''
formal_spec = '''explicit_specialization(E) && is_class_member_template(E) && !explicitly_specialized(enclosing_class_templates(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/16"
tags = ['template', 'explicit-specialization', 'member-template', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_not_friend_declaration_6c7d8e9f"
content = '''An explicit specialization declaration shall not be a friend declaration.'''
formal_spec = '''explicit_specialization(E) && is_friend_declaration(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/18"
tags = ['template', 'explicit-specialization', 'friend', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_default_args_function_template_0a1b2c3d"
content = '''Default function arguments shall not be specified in a declaration or a definition for the explicit specialization of a function template.'''
formal_spec = '''explicit_specialization(E) && is_function_template(E) && has_default_arguments(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/19.1"
tags = ['template', 'explicit-specialization', 'default-arguments', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_default_args_member_func_template_4e5f6a7b"
content = '''Default function arguments shall not be specified in a declaration or a definition for the explicit specialization of a member function template.'''
formal_spec = '''explicit_specialization(E) && is_member_function_template(E) && has_default_arguments(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/19.2"
tags = ['template', 'explicit-specialization', 'default-arguments', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_default_args_member_func_implicit_8c9d0e1f"
content = '''Default function arguments shall not be specified in a declaration or a definition for the explicit specialization of a member function of a class template where the class template specialization to which the member function specialization belongs is implicitly instantiated.'''
formal_spec = '''explicit_specialization(E) && is_member_function_of_class_template(E) && implicitly_instantiated(class_template_specialization_of(E)) && has_default_arguments(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/19.3"
tags = ['template', 'explicit-specialization', 'default-arguments', 'implicit-instantiation', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_incomplete_type_ill_formed_3a8f2b1c"
content = '''If the type of the exception object would be an incomplete type, the program is ill-formed.'''
formal_spec = '''throw_expr(E) && incomplete_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/3"
tags = ['exception', 'throw', 'incomplete-type', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_abstract_class_ill_formed_7c4e9d2a"
content = '''If the type of the exception object would be an abstract class type, the program is ill-formed.'''
formal_spec = '''throw_expr(E) && abstract_class_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/3"
tags = ['exception', 'throw', 'abstract-class', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_ptr_incomplete_ill_formed_b5d1a8e3"
content = '''If the type of the exception object would be a pointer to an incomplete type other than cv void, the program is ill-formed.'''
formal_spec = '''throw_expr(E) && pointer_type(type(E)) && incomplete_type(pointee_type(type(E))) && !is_cv_void(pointee_type(type(E))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/3"
tags = ['exception', 'throw', 'pointer', 'incomplete-type', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_copy_init_well_formed_8f3c2d1e"
content = '''For exception object type T, copy-initialization of an object of type T from an lvalue of type const T in a context unrelated to T shall be well-formed.'''
formal_spec = '''throw_expr(E) && type(E) == T => copy_initializable(T, const_lvalue(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/5"
tags = ['exception', 'throw', 'copy-initialization', 'constraint']

[[axioms]]
id = "cpp20_except_throw_nested_exception_terminate_4e7a9c2f"
content = '''If the exception handling mechanism handling an uncaught exception directly invokes a function that exits via an exception, std::terminate is invoked.'''
formal_spec = '''handling_uncaught_exception() && direct_invocation(F) && exits_via_exception(F) => call_std_terminate()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/9"
tags = ['exception', 'terminate', 'nested-exception', 'undefined-behavior']

[[axioms]]
id = "cpp20_except_throw_destructor_unwind_terminate_6b2d8a1f"
content = '''If a destructor directly invoked by stack unwinding exits via an exception, std::terminate is invoked.'''
formal_spec = '''stack_unwinding() && destructor_invocation(D) && exits_via_exception(D) => call_std_terminate()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/9"
tags = ['exception', 'terminate', 'destructor', 'stack-unwinding']

[[axioms]]
id = "cpp20_except_throw_class_destructor_odr_used_2c5f8e4a"
content = '''If the exception object type T is a class type, the destructor of T is potentially invoked.'''
formal_spec = '''throw_expr(E) && class_type(type(E)) => potentially_invoked(destructor(type(E)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "except.throw"
source_module = "[except.throw]/5"
tags = ['exception', 'throw', 'destructor', 'odr-use']

[[axioms]]
id = "cpp20_except_throw_class_ctor_odr_used_9d3b7f2c"
content = '''If the exception object type T is a class type, the selected constructor for copy-initialization is odr-used.'''
formal_spec = '''throw_expr(E) && class_type(type(E)) => odr_used(selected_copy_constructor(type(E)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "except.throw"
source_module = "[except.throw]/5"
tags = ['exception', 'throw', 'constructor', 'odr-use']

[[axioms]]
id = "cpp20_except_ctor_auto_destroy_reverse_order_7a3b2c1d"
content = '''During stack unwinding, objects with automatic storage duration that have been constructed but not yet destroyed since the try block was entered must be destroyed in reverse order of the completion of their construction.'''
formal_spec = '''stack_unwinding(exception) && automatic_storage_duration(obj) && constructed(obj) && !destroyed(obj) && in_try_block_scope(obj) => destroy_in_reverse_construction_order(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/2"
tags = ['exception', 'stack-unwinding', 'destructor', 'automatic-storage', 'lifetime']

[[axioms]]
id = "cpp20_except_ctor_return_temp_exception_e4f5a6b7"
content = '''If an exception is thrown during the destruction of temporaries or local variables for a return statement, the destructor for the returned object (if any) is also invoked.'''
formal_spec = '''exception_during_return_cleanup(exception, return_stmt) && exists(returned_object) && constructed(returned_object) => invoke_destructor(returned_object)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/2"
tags = ['exception', 'stack-unwinding', 'destructor', 'return', 'temporary']

[[axioms]]
id = "cpp20_except_ctor_partial_init_destroy_subobjects_c8d9e0f1"
content = '''If object initialization (not by delegating constructor) is terminated by an exception, the destructor is invoked for each subobject that was known to be initialized and whose initialization has completed.'''
formal_spec = '''!delegating_constructor_init(obj) && exception_terminates_init(obj, exception) && known_to_be_initialized(subobj, obj) && initialization_completed(subobj) => invoke_destructor(subobj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'constructor', 'destructor', 'initialization', 'subobject']

[[axioms]]
id = "cpp20_except_ctor_subobject_destroy_reverse_order_2a3b4c5d"
content = '''When subobjects are destroyed due to exception during initialization, they are destroyed in the reverse order of the completion of their construction.'''
formal_spec = '''exception_terminates_init(obj, exception) && subobjects_to_destroy(obj, subobjs) => destroy_in_reverse_construction_order(subobjs)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'constructor', 'destructor', 'initialization', 'subobject']

[[axioms]]
id = "cpp20_except_ctor_dtor_exception_complete_remaining_6e7f8a9b"
content = '''If the destructor of an object is terminated by an exception, each destructor invocation that would be performed after executing the body of the destructor and that has not yet begun execution is performed.'''
formal_spec = '''exception_terminates_destructor(obj, exception) && pending_destructor_invocation(subobj, obj) && !execution_begun(destructor(subobj)) => invoke_destructor(subobj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'destructor', 'subobject', 'stack-unwinding']

[[axioms]]
id = "cpp20_except_ctor_subobj_destroy_before_handler_0c1d2e3f"
content = '''Destruction of subobjects due to exception in constructor or destructor is sequenced before entering a handler of the function-try-block, if any.'''
formal_spec = '''(exception_terminates_init(obj, exception) || exception_terminates_destructor(obj, exception)) && function_try_block(obj, handler) => sequenced_before(subobject_destruction(obj), enter_handler(handler))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'destructor', 'constructor', 'function-try-block', 'sequencing']

[[axioms]]
id = "cpp20_except_ctor_delegating_exception_destroy_4g5h6i7j"
content = '''If the compound-statement of the function-body of a delegating constructor exits via an exception, the object's destructor is invoked.'''
formal_spec = '''delegating_constructor(ctor, obj) && exception_exits_body(ctor, exception) => invoke_destructor(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/4"
tags = ['exception', 'delegating-constructor', 'destructor', 'stack-unwinding']

[[axioms]]
id = "cpp20_except_ctor_delegating_destroy_before_handler_8k9l0m1n"
content = '''Destruction of object due to exception in delegating constructor is sequenced before entering a handler of the function-try-block of that delegating constructor, if any.'''
formal_spec = '''delegating_constructor(ctor, obj) && exception_exits_body(ctor, exception) && function_try_block(ctor, handler) => sequenced_before(destruction(obj), enter_handler(handler))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/4"
tags = ['exception', 'delegating-constructor', 'function-try-block', 'sequencing']

[[axioms]]
id = "cpp20_except_ctor_anonymous_union_not_known_init_2o3p4q5r"
content = '''An anonymous union member is not considered known to be initialized for purposes of destructor invocation during exception unwinding.'''
formal_spec = '''anonymous_union_member(subobj) => !known_to_be_initialized(subobj, parent_obj)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'anonymous-union', 'initialization', 'destructor']

[[axioms]]
id = "cpp20_except_ctor_ref_member_temp_lifetime_6s7t8u9v"
content = '''If an object with a reference member that extends the lifetime of a temporary has its initialization terminated by exception, the lifetime of the reference member ends, so the temporary's lifetime is effectively not extended.'''
formal_spec = '''exception_terminates_init(obj, exception) && reference_member(obj, ref) && extends_temporary_lifetime(ref, temp) => lifetime_ends(ref) && lifetime_ends(temp)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'reference', 'temporary', 'lifetime']

[[axioms]]
id = "cpp20_except_handle_incomplete_type_decl_a3f8b2c1"
content = '''An exception-declaration shall not denote an incomplete type.'''
formal_spec = '''exception_declaration(T) && incomplete_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'incomplete-type']

[[axioms]]
id = "cpp20_except_handle_abstract_class_decl_b4e9c3d2"
content = '''An exception-declaration shall not denote an abstract class type.'''
formal_spec = '''exception_declaration(T) && abstract_class_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'abstract-class']

[[axioms]]
id = "cpp20_except_handle_rvalue_ref_decl_c5f0d4e3"
content = '''An exception-declaration shall not denote an rvalue reference type.'''
formal_spec = '''exception_declaration(T) && rvalue_reference_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'rvalue-reference']

[[axioms]]
id = "cpp20_except_handle_ptr_incomplete_decl_d6a1e5f4"
content = '''An exception-declaration shall not denote a pointer or reference to an incomplete type, other than pointer to cv void.'''
formal_spec = '''exception_declaration(T) && (pointer_to(T, U) || reference_to(T, U)) && incomplete_type(U) && !is_cv_void(U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'incomplete-type', 'pointer']

[[axioms]]
id = "cpp20_except_handle_ellipsis_last_e7b2f6a5"
content = '''If present, a ... handler shall be the last handler for its try block.'''
formal_spec = '''handler_ellipsis(H) && exists(H2, handler_after(H, H2) && same_try_block(H, H2)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/5"
tags = ['exception-handling', 'ellipsis', 'handler-order']

[[axioms]]
id = "cpp20_except_handle_noexcept_terminate_f8c3a7b6"
content = '''If the search for a handler exits the function body of a function with a non-throwing exception specification, std::terminate is invoked.'''
formal_spec = '''exception_search_exits(F) && noexcept_spec(F) => invoke_std_terminate'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/7"
tags = ['exception-handling', 'noexcept', 'terminate']

[[axioms]]
id = "cpp20_except_handle_no_match_terminate_a9d4b8c7"
content = '''If no matching handler is found, std::terminate is invoked.'''
formal_spec = '''exception_thrown(E) && !exists(H, matching_handler(H, E)) => invoke_std_terminate'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/8"
tags = ['exception-handling', 'terminate', 'unhandled-exception']

[[axioms]]
id = "cpp20_except_handle_ctor_dtor_member_ub_b0e5c9d8"
content = '''Referring to any non-static member or base class of an object in the handler for a function-try-block of a constructor or destructor for that object results in undefined behavior.'''
formal_spec = '''function_try_block_handler(H, F) && (is_constructor(F) || is_destructor(F)) && refers_to_nonstatic_member_or_base(H, object_of(F)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/11"
tags = ['exception-handling', 'function-try-block', 'constructor', 'destructor', 'undefined-behavior', 'lifetime']

[[axioms]]
id = "cpp20_except_handle_static_main_not_caught_c1f6d0e9"
content = '''Exceptions thrown in destructors of objects with static storage duration or in constructors of objects associated with non-block variables with static storage duration are not caught by a function-try-block on the main function.'''
formal_spec = '''(thrown_in_destructor(E, O) && static_storage_duration(O)) || (thrown_in_constructor(E, O) && non_block_variable(O) && static_storage_duration(O)) => !caught_by_function_try_block(E, main)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/12"
tags = ['exception-handling', 'function-try-block', 'static-storage', 'main', 'initialization', 'destruction']

[[axioms]]
id = "cpp20_except_handle_thread_init_not_caught_d2a7e1f0"
content = '''Exceptions thrown in destructors of objects with thread storage duration or in constructors of objects associated with non-block variables with thread storage duration are not caught by a function-try-block on the initial function of the thread.'''
formal_spec = '''(thrown_in_destructor(E, O) && thread_storage_duration(O)) || (thrown_in_constructor(E, O) && non_block_variable(O) && thread_storage_duration(O)) => !caught_by_function_try_block(E, thread_initial_function)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/12"
tags = ['exception-handling', 'function-try-block', 'thread-storage', 'thread', 'initialization', 'destruction']

[[axioms]]
id = "cpp20_except_handle_ctor_return_illformed_e3b8f2a1"
content = '''If a return statement appears in a handler of the function-try-block of a constructor, the program is ill-formed.'''
formal_spec = '''function_try_block_handler(H, F) && is_constructor(F) && contains_return_statement(H) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/13"
tags = ['exception-handling', 'function-try-block', 'constructor', 'return-statement']

[[axioms]]
id = "cpp20_except_handle_ctor_dtor_rethrow_f4c9a3b2"
content = '''The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block of a constructor or destructor.'''
formal_spec = '''function_try_block_handler(H, F) && (is_constructor(F) || is_destructor(F)) && control_reaches_end(H) => rethrow_current_exception'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/14"
tags = ['exception-handling', 'function-try-block', 'constructor', 'destructor', 'rethrow']

[[axioms]]
id = "cpp20_intro_races_data_race_ub_a7c3e2f1"
content = '''A data race between two potentially concurrent conflicting actions, where at least one is not atomic and neither happens before the other, results in undefined behavior.'''
formal_spec = '''potentially_concurrent(A, B) && conflict(A, B) && (!atomic(A) || !atomic(B)) && !happens_before(A, B) && !happens_before(B, A) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/17"
tags = ['concurrency', 'data-race', 'undefined-behavior', 'memory-model']
c_standard_refs = ['5.1.2.4']

[[axioms]]
id = "cpp20_intro_races_conflict_modify_read_b4d8f3a2"
content = '''Two expression evaluations conflict if one modifies a memory location and the other reads or modifies the same memory location.'''
formal_spec = '''(modifies(A, loc) && (reads(B, loc) || modifies(B, loc))) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_conflict_modify_lifetime_c5e9a4b3"
content = '''Two expression evaluations conflict if one modifies a memory location and the other starts or ends the lifetime of an object occupying storage that overlaps with that memory location.'''
formal_spec = '''(modifies(A, loc) && lifetime_change(B, obj) && overlaps(storage(obj), loc)) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'lifetime', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_conflict_lifetime_read_d6f0b5c4"
content = '''Two expression evaluations conflict if one starts or ends the lifetime of an object in a memory location and the other reads or modifies that memory location.'''
formal_spec = '''(lifetime_change(A, obj) && in_memory_location(obj, loc) && (reads(B, loc) || modifies(B, loc))) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'lifetime', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_conflict_lifetime_lifetime_e7a1c6d5"
content = '''Two expression evaluations conflict if one starts or ends the lifetime of an object in a memory location and the other starts or ends the lifetime of an object occupying storage that overlaps with that memory location.'''
formal_spec = '''(lifetime_change(A, obj1) && in_memory_location(obj1, loc) && lifetime_change(B, obj2) && overlaps(storage(obj2), loc)) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'lifetime', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_potentially_concurrent_threads_f8b2d7e6"
content = '''Two actions are potentially concurrent if they are performed by different threads.'''
formal_spec = '''(thread(A) != thread(B)) => potentially_concurrent(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/17"
tags = ['concurrency', 'threads', 'potential-concurrency']

[[axioms]]
id = "cpp20_intro_races_potentially_concurrent_signal_09c3e8f7"
content = '''Two actions are potentially concurrent if they are unsequenced, at least one is performed by a signal handler, and they are not both performed by the same signal handler invocation.'''
formal_spec = '''unsequenced(A, B) && (signal_handler(A) || signal_handler(B)) && !same_signal_handler_invocation(A, B) => potentially_concurrent(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/17"
tags = ['concurrency', 'signal-handler', 'potential-concurrency']
c_standard_refs = ['5.1.2.3']

[[axioms]]
id = "cpp20_intro_races_happens_before_sequenced_1ad4f908"
content = '''An evaluation A happens before an evaluation B if A is sequenced before B.'''
formal_spec = '''sequenced_before(A, B) => happens_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'sequencing']

[[axioms]]
id = "cpp20_intro_races_happens_before_sync_2be5a019"
content = '''An evaluation A happens before an evaluation B if A synchronizes with B.'''
formal_spec = '''synchronizes_with(A, B) => happens_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'synchronization']

[[axioms]]
id = "cpp20_intro_races_happens_before_transitive_3cf6b12a"
content = '''An evaluation A happens before an evaluation B if A happens before X and X happens before B (transitivity).'''
formal_spec = '''(happens_before(A, X) && happens_before(X, B)) => happens_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'transitivity']

[[axioms]]
id = "cpp20_intro_races_visible_side_effect_4da7c23b"
content = '''A visible side effect A on a scalar object M with respect to a value computation B satisfies: A happens before B and there is no other side effect X to M such that A happens before X and X happens before B.'''
formal_spec = '''visible_side_effect(A, M, B) <=> (side_effect(A, M) && value_computation(B, M) && happens_before(A, B) && !exists(X, side_effect(X, M) && happens_before(A, X) && happens_before(X, B)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/9"
tags = ['concurrency', 'visibility', 'side-effect', 'scalar']

[[axioms]]
id = "cpp20_intro_races_nonatomic_value_visible_5eb8d34c"
content = '''The value of a non-atomic scalar object or bit-field M, as determined by evaluation B, is the value stored by the visible side effect A.'''
formal_spec = '''(non_atomic(M) && scalar_or_bitfield(M) && value_computation(B, M)) => value(B) == value_stored_by(visible_side_effect(M, B))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/9"
tags = ['concurrency', 'visibility', 'non-atomic', 'scalar']

[[axioms]]
id = "cpp20_intro_races_atomic_value_constraint_6fc9e45d"
content = '''The value of an atomic object M, as determined by evaluation B, is the value stored by some side effect A that modifies M, where B does not happen before A.'''
formal_spec = '''(atomic(M) && value_computation(B, M)) => exists(A, side_effect(A, M) && value(B) == value_stored_by(A) && !happens_before(B, A))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/10"
tags = ['concurrency', 'atomic', 'value-computation']

[[axioms]]
id = "cpp20_intro_races_write_write_coherence_7adaf56e"
content = '''If an operation A that modifies an atomic object M happens before an operation B that modifies M, then A is earlier than B in the modification order of M (write-write coherence).'''
formal_spec = '''(atomic(M) && modifies(A, M) && modifies(B, M) && happens_before(A, B)) => earlier_in_modification_order(A, B, M)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/11"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_read_read_coherence_8bebg67f"
content = '''If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B is either the value stored by X or the value stored by a side effect Y on M where Y follows X in the modification order of M (read-read coherence).'''
formal_spec = '''(atomic(M) && value_computation(A, M) && value_computation(B, M) && happens_before(A, B) && takes_value_from(A, X) && side_effect(X, M)) => (value(B) == value_stored_by(X) || exists(Y, side_effect(Y, M) && follows_in_modification_order(Y, X, M) && value(B) == value_stored_by(Y)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/12"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_read_write_coherence_9cfch780"
content = '''If a value computation A of an atomic object M happens before an operation B that modifies M, then A takes its value from a side effect X on M where X precedes B in the modification order of M (read-write coherence).'''
formal_spec = '''(atomic(M) && value_computation(A, M) && modifies(B, M) && happens_before(A, B)) => exists(X, side_effect(X, M) && takes_value_from(A, X) && precedes_in_modification_order(X, B, M))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/13"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_write_read_coherence_0dgdi891"
content = '''If a side effect X on an atomic object M happens before a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that follows X in the modification order of M (write-read coherence).'''
formal_spec = '''(atomic(M) && side_effect(X, M) && value_computation(B, M) && happens_before(X, B)) => (takes_value_from(B, X) || exists(Y, side_effect(Y, M) && follows_in_modification_order(Y, X, M) && takes_value_from(B, Y)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/14"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_modification_order_total_1ehej9a2"
content = '''All modifications to a particular atomic object M occur in some particular total order, called the modification order of M.'''
formal_spec = '''atomic(M) => total_order(modification_order(M))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/4"
tags = ['concurrency', 'atomic', 'modification-order', 'total-order']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_seq_2fifkab3"
content = '''An evaluation A strongly happens before an evaluation D if A is sequenced before D.'''
formal_spec = '''sequenced_before(A, D) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'sequencing']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_seqcst_3gjglbc4"
content = '''An evaluation A strongly happens before an evaluation D if A synchronizes with D and both A and D are sequentially consistent atomic operations.'''
formal_spec = '''(synchronizes_with(A, D) && seq_cst_atomic(A) && seq_cst_atomic(D)) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'sequential-consistency', 'atomic']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_chain_4hkhmcd5"
content = '''An evaluation A strongly happens before an evaluation D if there are evaluations B and C such that A is sequenced before B, B happens before C, and C is sequenced before D.'''
formal_spec = '''(sequenced_before(A, B) && happens_before(B, C) && sequenced_before(C, D)) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'sequencing', 'happens-before']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_trans_5ilinde6"
content = '''An evaluation A strongly happens before an evaluation D if there is an evaluation B such that A strongly happens before B and B strongly happens before D (transitivity).'''
formal_spec = '''(strongly_happens_before(A, B) && strongly_happens_before(B, D)) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'transitivity']

[[axioms]]
id = "cpp20_intro_races_release_sequence_def_6jmjoef7"
content = '''A release sequence headed by a release operation A on an atomic object M is a maximal contiguous sub-sequence of side effects in the modification order of M, where the first operation is A and every subsequent operation is an atomic read-modify-write operation.'''
formal_spec = '''release_sequence(A, M, seq) <=> (release_operation(A, M) && first(seq) == A && contiguous_in_modification_order(seq, M) && forall(op, member(op, tail(seq)) => atomic_rmw(op)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/5"
tags = ['concurrency', 'atomic', 'release-sequence', 'synchronization']

[[axioms]]
id = "cpp20_intro_races_sig_atomic_no_race_7knkpfg8"
content = '''Two accesses to the same non-bit-field object of type volatile std::sig_atomic_t do not result in a data race if both occur in the same thread, even if one or more occurs in a signal handler.'''
formal_spec = '''(type(M) == volatile_sig_atomic_t && !bitfield(M) && same_thread(A, B) && access(A, M) && access(B, M)) => !data_race(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/18"
tags = ['concurrency', 'signal-handler', 'sig_atomic_t', 'data-race-exception']
c_standard_refs = ['7.14.1.1']

[[axioms]]
id = "cpp20_intro_races_happens_before_irreflexive_8loqgh9"
content = '''An evaluation does not happen before itself (irreflexivity of happens-before relation).'''
formal_spec = '''!happens_before(A, A)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'irreflexive']

[[axioms]]
id = "cpp20_atomics_order_rmw_read_last_value_8f3a2b1c"
content = '''Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.'''
formal_spec = '''forall rmw_op : AtomicRMWOperation, M : AtomicObject .
  is_read_modify_write(rmw_op, M) =>
  reads(rmw_op) == last_in_modification_order(M, write_of(rmw_op))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/10"
tags = ['concurrency', 'atomics', 'read-modify-write', 'modification-order']

[[axioms]]
id = "cpp20_atomics_order_release_store_semantics_c4d5e6f7"
content = '''A store operation with memory_order::release, memory_order::acq_rel, or memory_order::seq_cst performs a release operation on the affected memory location.'''
formal_spec = '''forall op : AtomicOperation, M : MemoryLocation .
  is_store(op, M) && (memory_order(op) in {release, acq_rel, seq_cst}) =>
  performs_release(op, M)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/1.2"
tags = ['concurrency', 'atomics', 'memory-order', 'release']

[[axioms]]
id = "cpp20_atomics_order_acquire_load_semantics_a1b2c3d4"
content = '''A load operation with memory_order::acquire, memory_order::acq_rel, or memory_order::seq_cst performs an acquire operation on the affected memory location.'''
formal_spec = '''forall op : AtomicOperation, M : MemoryLocation .
  is_load(op, M) && (memory_order(op) in {acquire, acq_rel, seq_cst}) =>
  performs_acquire(op, M)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/1.3"
tags = ['concurrency', 'atomics', 'memory-order', 'acquire']

[[axioms]]
id = "cpp20_atomics_order_release_acquire_sync_e5f6a7b8"
content = '''An atomic operation A that performs a release operation on an atomic object M synchronizes with an atomic operation B that performs an acquire operation on M and takes its value from any side effect in the release sequence headed by A.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  performs_release(A, M) &&
  performs_acquire(B, M) &&
  takes_value_from_release_sequence(B, A) =>
  synchronizes_with(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/2"
tags = ['concurrency', 'atomics', 'synchronization', 'release-acquire']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_total_order_exists_d9e0f1a2"
content = '''There is a single total order S on all memory_order::seq_cst operations, including fences.'''
formal_spec = '''exists S : TotalOrder .
  forall op : Operation .
    (is_atomic(op) && memory_order(op) == seq_cst) || is_seq_cst_fence(op) =>
    in_order(op, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'total-order']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_strongly_hb_b3c4d5e6"
content = '''If A and B are memory_order::seq_cst operations and A strongly happens before B, then A precedes B in the total order S.'''
formal_spec = '''forall A B : AtomicOperation, S : TotalOrder .
  memory_order(A) == seq_cst &&
  memory_order(B) == seq_cst &&
  strongly_happens_before(A, B) =>
  precedes_in(A, B, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'happens-before']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_1_f7a8b9c0"
content = '''If A and B are both memory_order::seq_cst operations on object M where A is coherence-ordered before B, then A precedes B in S.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject, S : TotalOrder .
  memory_order(A) == seq_cst &&
  memory_order(B) == seq_cst &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) =>
  precedes_in(A, B, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.1"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_2_1d2e3f4a"
content = '''If A is a memory_order::seq_cst operation coherence-ordered before B, and B happens before a memory_order::seq_cst fence Y, then A precedes Y in S.'''
formal_spec = '''forall A B : AtomicOperation, Y : Fence, M : AtomicObject, S : TotalOrder .
  memory_order(A) == seq_cst &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) &&
  is_seq_cst_fence(Y) &&
  happens_before(B, Y) =>
  precedes_in(A, Y, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.2"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'fence', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_3_5b6c7d8e"
content = '''If a memory_order::seq_cst fence X happens before A, and A is coherence-ordered before B which is a memory_order::seq_cst operation, then X precedes B in S.'''
formal_spec = '''forall A B : AtomicOperation, X : Fence, M : AtomicObject, S : TotalOrder .
  is_seq_cst_fence(X) &&
  happens_before(X, A) &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) &&
  memory_order(B) == seq_cst =>
  precedes_in(X, B, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.3"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'fence', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_4_9f0a1b2c"
content = '''If a memory_order::seq_cst fence X happens before A, A is coherence-ordered before B, and B happens before a memory_order::seq_cst fence Y, then X precedes Y in S.'''
formal_spec = '''forall A B : AtomicOperation, X Y : Fence, M : AtomicObject, S : TotalOrder .
  is_seq_cst_fence(X) &&
  happens_before(X, A) &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) &&
  is_seq_cst_fence(Y) &&
  happens_before(B, Y) =>
  precedes_in(X, Y, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.4"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'fence', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_coherence_mod_read_3_1_c3d4e5f6"
content = '''An atomic operation A on atomic object M is coherence-ordered before another atomic operation B on M if A is a modification, and B reads the value stored by A.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  is_modification(A) &&
  reads_value_stored_by(B, A) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.1"
tags = ['concurrency', 'atomics', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_atomics_order_coherence_mod_order_3_2_7a8b9c0d"
content = '''An atomic operation A on atomic object M is coherence-ordered before another atomic operation B on M if A precedes B in the modification order of M.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  precedes_in_modification_order(A, B, M) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.2"
tags = ['concurrency', 'atomics', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_atomics_order_coherence_read_mod_3_3_e1f2a3b4"
content = '''An atomic operation A on M is coherence-ordered before B on M if A and B are not the same atomic read-modify-write operation, and there exists an atomic modification X of M such that A reads the value stored by X and X precedes B in the modification order of M.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  NOT (same_rmw_operation(A, B)) &&
  (exists X : AtomicModification .
    modifies(X, M) &&
    reads_value_stored_by(A, X) &&
    precedes_in_modification_order(X, B, M)) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.3"
tags = ['concurrency', 'atomics', 'coherence', 'modification-order', 'read-modify-write']

[[axioms]]
id = "cpp20_atomics_order_coherence_transitive_3_4_5c6d7e8f"
content = '''An atomic operation A on M is coherence-ordered before B on M if there exists an atomic modification X of M such that A is coherence-ordered before X and X is coherence-ordered before B.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  (exists X : AtomicModification .
    modifies(X, M) &&
    coherence_ordered_before(A, X) &&
    coherence_ordered_before(X, B)) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.4"
tags = ['concurrency', 'atomics', 'coherence', 'transitivity']

[[axioms]]
id = "cpp20_atomics_order_relaxed_no_ordering_9a0b1c2d"
content = '''memory_order::relaxed specifies that no operation orders memory.'''
formal_spec = '''forall op : AtomicOperation .
  memory_order(op) == relaxed =>
  NOT orders_memory(op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/1.1"
tags = ['concurrency', 'atomics', 'memory-order', 'relaxed']

[[axioms]]
id = "cpp20_atomics_order_atomic_indivisibility_3e4f5a6b"
content = '''Any given atomic access to a particular atomic object must be indivisible with respect to all other atomic accesses to that object, regardless of memory ordering.'''
formal_spec = '''forall A B : AtomicAccess, M : AtomicObject .
  accesses(A, M) && accesses(B, M) && A != B =>
  indivisible(A, B)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "atomics.order"
source_module = "[atomics.order]/1 Note 1"
tags = ['concurrency', 'atomics', 'indivisibility']

[[axioms]]
id = "cpp20_atomics_order_no_oota_recommendation_7c8d9e0f"
content = '''Implementations should ensure that no "out-of-thin-air" values are computed that circularly depend on their own computation.'''
formal_spec = '''forall v : Value, computation : Execution .
  circularly_depends_on_own_computation(v, computation) =>
  should_not_produce(v)'''
layer = "cpp20_language"
confidence = 0.75
source_file = "atomics.order"
source_module = "[atomics.order]/8"
tags = ['concurrency', 'atomics', 'out-of-thin-air', 'recommendation']

[[axioms]]
id = "cpp20_atomics_fences_release_acquire_sync_condition_a7f3c2d1"
content = '''A release fence A synchronizes with an acquire fence B only if there exist atomic operations X and Y (where Y is not an atomic read-modify-write operation) both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.'''
formal_spec = '''synchronizes_with(release_fence(A), acquire_fence(B)) <=> exists(X, Y, M) where atomic_operation(X) && atomic_operation(Y) && !atomic_rmw(Y) && atomic_object(M) && operates_on(X, M) && operates_on(Y, M) && sequenced_before(A, X) && modifies(X, M) && sequenced_before(Y, B) && (reads_value_written_by(Y, X) || reads_value_in_hypothetical_release_sequence(Y, X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/2"
tags = ['concurrency', 'fences', 'synchronization', 'memory_order', 'release_fence', 'acquire_fence']

[[axioms]]
id = "cpp20_atomics_fences_release_fence_acquire_op_sync_b8e4d3f2"
content = '''A release fence A synchronizes with an atomic operation B that performs an acquire operation on atomic object M only if there exists an atomic operation X such that A is sequenced before X, X modifies M, and B reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.'''
formal_spec = '''synchronizes_with(release_fence(A), acquire_operation(B, M)) <=> exists(X) where atomic_operation(X) && sequenced_before(A, X) && modifies(X, M) && (reads_value_written_by(B, X) || reads_value_in_hypothetical_release_sequence(B, X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/3"
tags = ['concurrency', 'fences', 'synchronization', 'memory_order', 'release_fence', 'acquire_operation']

[[axioms]]
id = "cpp20_atomics_fences_release_op_acquire_fence_sync_c9f5e4a3"
content = '''An atomic operation A that is a release operation on atomic object M synchronizes with an acquire fence B only if there exists some atomic operation X on M such that X is sequenced before B and reads the value written by A or a value written by any side effect in the release sequence headed by A.'''
formal_spec = '''synchronizes_with(release_operation(A, M), acquire_fence(B)) <=> exists(X) where atomic_operation(X) && operates_on(X, M) && sequenced_before(X, B) && (reads_value_written_by(X, A) || reads_value_in_release_sequence(X, A))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/4"
tags = ['concurrency', 'fences', 'synchronization', 'memory_order', 'release_operation', 'acquire_fence']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_relaxed_no_effect_d1a6f5b4"
content = '''atomic_thread_fence with memory_order::relaxed has no synchronization effects.'''
formal_spec = '''atomic_thread_fence(memory_order::relaxed) => no_fence_effects()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.1"
tags = ['concurrency', 'fences', 'memory_order', 'relaxed']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_acquire_semantics_e2b7c6d5"
content = '''atomic_thread_fence with memory_order::acquire is an acquire fence.'''
formal_spec = '''atomic_thread_fence(memory_order::acquire) => acquire_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.2"
tags = ['concurrency', 'fences', 'memory_order', 'acquire']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_release_semantics_f3c8d7e6"
content = '''atomic_thread_fence with memory_order::release is a release fence.'''
formal_spec = '''atomic_thread_fence(memory_order::release) => release_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.3"
tags = ['concurrency', 'fences', 'memory_order', 'release']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_acq_rel_semantics_a4d9e8f7"
content = '''atomic_thread_fence with memory_order::acq_rel is both an acquire fence and a release fence.'''
formal_spec = '''atomic_thread_fence(memory_order::acq_rel) => acquire_fence() && release_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.4"
tags = ['concurrency', 'fences', 'memory_order', 'acq_rel']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_seq_cst_semantics_b5eaf9a8"
content = '''atomic_thread_fence with memory_order::seq_cst is a sequentially consistent acquire and release fence.'''
formal_spec = '''atomic_thread_fence(memory_order::seq_cst) => seq_cst_fence() && acquire_fence() && release_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.5"
tags = ['concurrency', 'fences', 'memory_order', 'seq_cst', 'sequential_consistency']

[[axioms]]
id = "cpp20_atomics_fences_signal_fence_same_thread_only_c6fba0b9"
content = '''atomic_signal_fence establishes ordering constraints only between a thread and a signal handler executed in the same thread, unlike atomic_thread_fence which establishes ordering across threads.'''
formal_spec = '''atomic_signal_fence(order) => ordering_constraints_limited_to(same_thread, signal_handler_in_same_thread) && !inter_thread_synchronization()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/6"
tags = ['concurrency', 'fences', 'signal_handler', 'memory_order', 'signal_fence']

[[axioms]]
id = "cpp20_atomics_fences_signal_fence_no_hw_fence_d7acb1ca"
content = '''atomic_signal_fence inhibits compiler optimizations and reorderings like atomic_thread_fence but does not emit hardware fence instructions.'''
formal_spec = '''atomic_signal_fence(order) => compiler_barrier(order) && !hardware_fence_instruction()'''
layer = "cpp20_language"
confidence = 0.85
source_file = "atomics.fences"
source_module = "[atomics.fences]/7"
tags = ['concurrency', 'fences', 'signal_handler', 'compiler_barrier', 'optimization']

[[axioms]]
id = "cpp20_atomics_fences_sync_requires_y_not_rmw_e8bdc2db"
content = '''For a release fence to synchronize with an acquire fence via atomic operations X and Y, the operation Y that reads from M must NOT be an atomic read-modify-write operation.'''
formal_spec = '''synchronizes_with(release_fence(A), acquire_fence(B)) via (X, Y, M) => !atomic_rmw(Y)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/2"
tags = ['concurrency', 'fences', 'synchronization', 'read_modify_write', 'constraint']

[[axioms]]
id = "cpp20_concept_same_type_equality_symmetric_7a3c1d8e"
content = '''The same_as concept is satisfied if and only if T and U are the same type, and this relationship is symmetric.'''
formal_spec = '''same_as<T, U> <=> is_same_v<T, U> && is_same_v<U, T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "concept.same"
source_module = "[concept.same]/1"
tags = ['concepts', 'type_traits', 'same_as', 'symmetry']

[[axioms]]
id = "cpp20_concept_same_subsumption_bidirectional_b2f4e9a1"
content = '''same_as<T, U> subsumes same_as<U, T> and vice versa, enabling symmetric constraint satisfaction in overload resolution.'''
formal_spec = '''subsumes(same_as<T, U>, same_as<U, T>) && subsumes(same_as<U, T>, same_as<T, U>)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "concept.same"
source_module = "[concept.same]/1"
tags = ['concepts', 'subsumption', 'same_as', 'overload_resolution']

[[axioms]]
id = "cpp20_concept_same_impl_is_same_v_c8d2f3a7"
content = '''The exposition-only same-as-impl concept is satisfied when is_same_v<T, U> is true, meaning T and U are exactly the same type after any reference and cv-qualifier adjustments by the type trait.'''
formal_spec = '''same-as-impl<T, U> <=> is_same_v<T, U>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "concept.same"
source_module = "[concept.same]/1"
tags = ['concepts', 'type_traits', 'is_same', 'implementation_detail']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_not_reachable_a7b3c2d1"
content = '''If std::initializer_list is used (even implicitly) but no standard library declaration of std::initializer_list is reachable, the program is ill-formed.'''
formal_spec = '''uses_initializer_list(expr) && !reachable_declaration(std::initializer_list) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/2"
tags = ['list-initialization', 'initializer_list', 'reachability']

[[axioms]]
id = "cpp20_dcl_init_list_designated_init_aggregate_only_f8e2a1b3"
content = '''If a braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class.'''
formal_spec = '''has_designated_initializer_list(init) && !is_reference_type(T) && !is_aggregate_class(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate']

[[axioms]]
id = "cpp20_dcl_init_list_designator_order_subsequence_c4d5e6f7"
content = '''The ordered identifiers in the designators of a designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of T.'''
formal_spec = '''has_designated_initializer_list(init) && !is_subsequence(designator_identifiers(init), member_identifiers(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate', 'member-order']

[[axioms]]
id = "cpp20_dcl_init_list_class_narrowing_conversion_b1c2d3e4"
content = '''When constructors are considered for class type list-initialization, if a narrowing conversion is required to convert any of the arguments, the program is ill-formed.'''
formal_spec = '''is_class_type(T) && list_initialization(T, init) && requires_narrowing_conversion(arg, param) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.7"
tags = ['list-initialization', 'narrowing', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_list_enum_narrowing_e5f6a7b8"
content = '''When initializing an enumeration with fixed underlying type via direct-list-initialization from a single scalar element, if a narrowing conversion is required to convert the element to the underlying type, the program is ill-formed.'''
formal_spec = '''is_enum_with_fixed_underlying_type(T, U) && direct_list_init(T, {v}) && is_scalar(v) && requires_narrowing_conversion(v, U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'narrowing']

[[axioms]]
id = "cpp20_dcl_init_list_enum_copy_list_init_c9d0e1f2"
content = '''Copy-list-initialization of an enumeration with fixed underlying type from a single scalar value is ill-formed (only direct-list-initialization is allowed).'''
formal_spec = '''is_enum_with_fixed_underlying_type(T, U) && copy_list_init(T, {v}) && is_scalar(v) && !is_type(v, T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'copy-initialization']

[[axioms]]
id = "cpp20_dcl_init_list_single_element_narrowing_a3b4c5d6"
content = '''When initializing from a single-element initializer list where the element type is reference-related to T, if a narrowing conversion is required to convert the element to T, the program is ill-formed.'''
formal_spec = '''list_init(T, {e}) && !is_designated_init(init) && (reference_related(T, type(e)) || !is_reference_type(T)) && requires_narrowing_conversion(e, T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.9"
tags = ['list-initialization', 'narrowing', 'single-element']

[[axioms]]
id = "cpp20_dcl_init_list_lvalue_ref_nonconst_e7f8a9b0"
content = '''Binding an lvalue reference to a non-const type to a prvalue generated from list-initialization is ill-formed.'''
formal_spec = '''is_lvalue_reference(T) && !is_const(referenced_type(T)) && list_init_generates_prvalue(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.10"
tags = ['list-initialization', 'reference', 'lvalue']

[[axioms]]
id = "cpp20_dcl_init_list_backing_array_narrowing_c1d2e3f4"
content = '''When constructing a std::initializer_list<E> from an initializer list, if a narrowing conversion is required to initialize any element of the backing array, the program is ill-formed.'''
formal_spec = '''is_initializer_list_type(T, E) && list_init(T, init) && exists(elem in init, requires_narrowing_conversion(elem, E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/5"
tags = ['list-initialization', 'initializer_list', 'narrowing', 'backing-array']

[[axioms]]
id = "cpp20_dcl_init_list_member_initializer_dangling_a5b6c7d8"
content = '''Initializing an initializer_list member in a constructor's ctor-initializer creates a dangling reference because the backing array has temporary lifetime, making the program ill-formed.'''
formal_spec = '''is_initializer_list_type(member_type) && initialized_in_mem_initializer(member, braced_init_list) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/6"
tags = ['list-initialization', 'initializer_list', 'lifetime', 'dangling-reference', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_int_d9e0f1a2"
content = '''A narrowing conversion is an implicit conversion from a floating-point type to an integer type.'''
formal_spec = '''is_floating_point(source_type) && is_integer_type(target_type) && implicit_conversion(source, target) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.1"
tags = ['narrowing', 'floating-point', 'integer', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_float_b3c4d5e6"
content = '''A narrowing conversion is an implicit conversion from a floating-point type T to another floating-point type with lower or incomparable conversion rank, except where the result is a constant expression with finite value that did not overflow or both values are not finite.'''
formal_spec = '''is_floating_point(T) && is_floating_point(U) && !rank_greater_or_equal(U, T) && implicit_conversion(T, U) && !(is_constant_expr(v) && ((is_finite(result) && !overflow(v, U)) || (!is_finite(v) && !is_finite(result)))) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.2"
tags = ['narrowing', 'floating-point', 'conversion', 'rank']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_float_f7a8b9c0"
content = '''A narrowing conversion is an implicit conversion from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the value after conversion fits into the target type and produces the original value when converted back.'''
formal_spec = '''(is_integer_type(T) || is_unscoped_enum(T)) && is_floating_point(U) && implicit_conversion(T, U) && !(is_constant_expr(v) && fits_exactly(v, U) && roundtrip_equal(v, U)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.3"
tags = ['narrowing', 'integer', 'floating-point', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_int_d1e2f3a4"
content = '''A narrowing conversion is an implicit conversion from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except for bit-fields or constant expressions whose promoted value fits the target type.'''
formal_spec = '''(is_integer_type(T) || is_unscoped_enum(T)) && is_integer_type(U) && !can_represent_all_values(U, T) && implicit_conversion(T, U) && !is_narrow_bitfield_exception(v, T, U) && !(is_constant_expr(v) && fits_after_promotion(v, U)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.4"
tags = ['narrowing', 'integer', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_ptr_to_bool_b5c6d7e8"
content = '''A narrowing conversion is an implicit conversion from a pointer type or a pointer-to-member type to bool.'''
formal_spec = '''(is_pointer_type(T) || is_pointer_to_member_type(T)) && target_type == bool && implicit_conversion(T, bool) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.5"
tags = ['narrowing', 'pointer', 'bool', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_no_matching_init_e9f0a1b2"
content = '''If none of the list-initialization rules apply (3.1 through 3.11), the program is ill-formed.'''
formal_spec = '''list_init(T, init) && !matches_any_list_init_rule(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.12"
tags = ['list-initialization', 'ill-formed']

[[axioms]]
id = "cpp20_dcl_init_list_evaluation_order_c3d4e5f6"
content = '''Within the initializer-list of a braced-init-list, the initializer-clauses are evaluated in the order in which they appear, with each value computation and side effect sequenced before those of subsequent clauses.'''
formal_spec = '''braced_init_list(init) && clause_i in init && clause_j in init && position(clause_i) < position(clause_j) => sequenced_before(effects(clause_i), effects(clause_j))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/4"
tags = ['list-initialization', 'evaluation-order', 'sequencing']

[[axioms]]
id = "cpp20_dcl_init_list_aggregate_narrowing_a7b8c9d0"
content = '''Aggregate initialization via list-initialization is ill-formed if a narrowing conversion is required for any element.'''
formal_spec = '''is_aggregate(T) && list_init(T, init) && exists(elem in init, requires_narrowing_conversion(elem, member_type)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.4"
tags = ['list-initialization', 'aggregate', 'narrowing']

[[axioms]]
id = "cpp20_expr_prim_req_general_no_default_arg_a7b3c2d1"
content = '''A local parameter of a requires-expression shall not have a default argument.'''
formal_spec = '''requires_expression(R) && local_parameter(P, R) && has_default_argument(P) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/4"
tags = ['requires-expression', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_expr_prim_req_general_no_ellipsis_f8e2a1b4"
content = '''The parameter-declaration-clause of a requirement-parameter-list shall not terminate with an ellipsis.'''
formal_spec = '''requires_expression(R) && parameter_declaration_clause(PDC, R) && terminates_with_ellipsis(PDC) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/4"
tags = ['requires-expression', 'parameter', 'variadic', 'constraint']

[[axioms]]
id = "cpp20_expr_prim_req_general_invalid_non_template_c3d4e5f6"
content = '''If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a templated entity, then the program is ill-formed.'''
formal_spec = '''requires_expression(R) && contains_invalid_types_or_expressions(R) && !within_templated_entity_declaration(R) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'template', 'validity', 'constraint']

[[axioms]]
id = "cpp20_expr_prim_req_general_always_failure_ndr_b2c3d4e5"
content = '''If the substitution of template arguments into a requirement would always result in a substitution failure, the program is ill-formed; no diagnostic required.'''
formal_spec = '''requirement(Req) && for_all_template_args(Args, substitution_fails(Req, Args)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'template', 'substitution', 'ndr']

[[axioms]]
id = "cpp20_expr_prim_req_compound_noexcept_check_d4e5f6a7"
content = '''In a compound-requirement with noexcept specifier, the expression shall not be a potentially-throwing expression.'''
formal_spec = '''compound_requirement(CR) && has_noexcept_specifier(CR) && expression(E, CR) && potentially_throwing(E) => requirement_not_satisfied'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1.2"
tags = ['requires-expression', 'compound-requirement', 'noexcept', 'exception']

[[axioms]]
id = "cpp20_expr_prim_req_compound_return_type_constraint_e5f6a7b8"
content = '''In a compound-requirement with return-type-requirement, the immediately-declared constraint of the type-constraint for decltype((E)) shall be satisfied.'''
formal_spec = '''compound_requirement(CR) && has_return_type_requirement(CR, RTR) && expression(E, CR) && type_constraint(TC, RTR) && !satisfies(immediately_declared_constraint(TC), decltype_parenthesized(E)) => requirement_not_satisfied'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1.3.2"
tags = ['requires-expression', 'compound-requirement', 'type-constraint', 'decltype']

[[axioms]]
id = "cpp20_expr_prim_req_nested_constraint_satisfied_f6a7b8c9"
content = '''The constraint-expression in a nested-requirement shall be satisfied by the substituted template arguments.'''
formal_spec = '''nested_requirement(NR) && constraint_expression(CE, NR) && template_arguments(Args) && substituted(CE', CE, Args) && !satisfied(CE') => requirement_not_satisfied'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.nested"
source_module = "[expr.prim.req.nested]/1"
tags = ['requires-expression', 'nested-requirement', 'constraint', 'satisfaction']

[[axioms]]
id = "cpp20_expr_prim_req_simple_unevaluated_a1b2c3d4"
content = '''The expression in a simple-requirement is an unevaluated operand.'''
formal_spec = '''simple_requirement(SR) && expression(E, SR) => unevaluated_operand(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.simple"
source_module = "[expr.prim.req.simple]/1"
tags = ['requires-expression', 'simple-requirement', 'unevaluated']

[[axioms]]
id = "cpp20_expr_prim_req_compound_unevaluated_b2c3d4e5"
content = '''The expression in a compound-requirement is an unevaluated operand.'''
formal_spec = '''compound_requirement(CR) && expression(E, CR) => unevaluated_operand(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1"
tags = ['requires-expression', 'compound-requirement', 'unevaluated']

[[axioms]]
id = "cpp20_expr_prim_req_general_substitution_false_c3d4e5f6"
content = '''Invalid type/expression formation or semantic constraint violation in requirements causes requires-expression to evaluate to false, not ill-formed.'''
formal_spec = '''requires_expression(R) && within_templated_entity(R) && (invalid_type_formation(R) || invalid_expression_formation(R) || semantic_constraint_violation(R)) => evaluates_to(R, false)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'SFINAE', 'substitution', 'template']

[[axioms]]
id = "cpp20_expr_prim_req_general_lexical_order_d4e5f6a7"
content = '''Substitution and semantic constraint checking in a requires-expression proceeds in lexical order and stops when a condition that determines the result is encountered.'''
formal_spec = '''requires_expression(R) && requirements(Reqs, R) && requirement_at_position(Req, N, Reqs) && determines_result(Req) => skip_requirements_after(N, Reqs)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'evaluation-order', 'short-circuit']

[[axioms]]
id = "cpp20_expr_prim_req_general_param_no_linkage_e5f6a7b8"
content = '''Local parameters of a requires-expression have no linkage, storage, or lifetime; they are only used as notation for defining requirements.'''
formal_spec = '''requires_expression(R) && local_parameter(P, R) => !has_linkage(P) && !has_storage(P) && !has_lifetime(P) && notation_only(P)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/4"
tags = ['requires-expression', 'parameter', 'linkage', 'storage', 'lifetime']

[[axioms]]
id = "cpp20_expr_prim_req_type_no_complete_f6a7b8c9"
content = '''A type-requirement that names a class template specialization does not require that type to be complete.'''
formal_spec = '''type_requirement(TR) && names_class_template_specialization(TR, S) => !requires_complete_type(TR, S)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.type"
source_module = "[expr.prim.req.type]/2"
tags = ['requires-expression', 'type-requirement', 'complete-type', 'template']

[[axioms]]
id = "cpp20_expr_prim_req_simple_requires_token_a7b8c9d0"
content = '''A requirement that starts with a requires token is never interpreted as a simple-requirement.'''
formal_spec = '''requirement(R) && starts_with_requires_token(R) => !simple_requirement(R)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.simple"
source_module = "[expr.prim.req.simple]/2"
tags = ['requires-expression', 'simple-requirement', 'nested-requirement', 'parsing']

[[axioms]]
id = "cpp20_expr_prim_req_compound_order_b8c9d0e1"
content = '''In a compound-requirement, substitution and verification proceed in specific order: expression substitution, noexcept check, return-type-requirement substitution, then type-constraint satisfaction.'''
formal_spec = '''compound_requirement(CR) && expression(E, CR) => order(substitution(E), noexcept_check(E), return_type_substitution(CR), type_constraint_check(CR))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1"
tags = ['requires-expression', 'compound-requirement', 'evaluation-order']

[[axioms]]
id = "cpp20_module_unit_reserved_names_std_3f8a1b2c"
content = '''Module names beginning with 'std' followed by zero or more digits are reserved and shall not be specified in a module-declaration.'''
formal_spec = '''module_declaration(name) && (starts_with(name, "std") || starts_with(name, regex("std[0-9]*"))) => ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/1"
tags = ['module', 'reserved-names', 'declaration']

[[axioms]]
id = "cpp20_module_unit_reserved_identifier_a7c2d4e1"
content = '''Module names containing a reserved identifier are reserved and shall not be specified in a module-declaration.'''
formal_spec = '''module_declaration(name) && contains_reserved_identifier(name) => ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/1"
tags = ['module', 'reserved-names', 'identifier']

[[axioms]]
id = "cpp20_module_unit_module_import_keywords_b4e5f6a2"
content = '''The identifiers "module" and "import" shall not appear as identifiers in a module-name or module-partition.'''
formal_spec = '''(module_name(name) || module_partition(name)) && (contains_identifier(name, "module") || contains_identifier(name, "import")) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/1"
tags = ['module', 'identifier', 'keyword']

[[axioms]]
id = "cpp20_module_unit_exactly_one_primary_c8d9e0f3"
content = '''A named module shall contain exactly one module interface unit with no module-partition, known as the primary module interface unit of the module.'''
formal_spec = '''named_module(M) => count(module_interface_units(M), has_no_partition) == 1 || ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/2"
tags = ['module', 'interface-unit', 'primary']

[[axioms]]
id = "cpp20_module_unit_unique_partitions_1a2b3c4d"
content = '''A named module shall not contain multiple module partitions with the same module-partition name.'''
formal_spec = '''named_module(M) && partition(P1, M) && partition(P2, M) && P1 != P2 && partition_name(P1) == partition_name(P2) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/3"
tags = ['module', 'partition', 'unique']

[[axioms]]
id = "cpp20_module_unit_export_all_partitions_5e6f7a8b"
content = '''All module partitions of a module that are module interface units shall be directly or indirectly exported by the primary module interface unit.'''
formal_spec = '''named_module(M) && partition(P, M) && is_interface_unit(P) => exported_by_primary(P, M) || ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/3"
tags = ['module', 'partition', 'export']

[[axioms]]
id = "cpp20_module_interface_namespace_scope_9c0d1e2f"
content = '''An export-declaration shall inhabit a namespace scope and appear in the purview of a module interface unit.'''
formal_spec = '''export_declaration(D) => (inhabits_namespace_scope(D) && in_purview_of_interface_unit(D)) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'namespace-scope']

[[axioms]]
id = "cpp20_module_interface_not_unnamed_ns_3a4b5c6d"
content = '''An export-declaration shall not appear directly or indirectly within an unnamed namespace.'''
formal_spec = '''export_declaration(D) && within_unnamed_namespace(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'unnamed-namespace']

[[axioms]]
id = "cpp20_module_interface_not_private_frag_7e8f9a0b"
content = '''An export-declaration shall not appear directly or indirectly within a private-module-fragment.'''
formal_spec = '''export_declaration(D) && within_private_module_fragment(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'private-fragment']

[[axioms]]
id = "cpp20_module_interface_no_partial_spec_1c2d3e4f"
content = '''The name-declaration of an export-declaration shall not declare a partial specialization.'''
formal_spec = '''export_declaration(D) && declares_partial_specialization(name_declaration(D)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'template', 'partial-specialization']

[[axioms]]
id = "cpp20_module_interface_no_nested_export_5a6b7c8d"
content = '''The declaration-seq of an export-declaration shall not contain an export-declaration or module-import-declaration.'''
formal_spec = '''export_declaration(D) && (contains_export_declaration(declaration_seq(D)) || contains_module_import(declaration_seq(D))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'nested']

[[axioms]]
id = "cpp20_module_interface_no_internal_linkage_9e0f1a2b"
content = '''If an exported declaration is not within a header unit, it shall not declare a name with internal linkage.'''
formal_spec = '''exported(D) && !within_header_unit(D) && has_internal_linkage(declared_name(D)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/3"
tags = ['module', 'export', 'linkage', 'internal']

[[axioms]]
id = "cpp20_module_interface_using_decl_linkage_3c4d5e6f"
content = '''If an exported using-declaration is not within a header unit, all entities named by the using-declarators shall either be a type alias or have been introduced with a name having external linkage.'''
formal_spec = '''exported(D) && is_using_declaration(D) && !within_header_unit(D) && entity_named_by(D, E) => (is_type_alias(E) || has_external_linkage(E)) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/5"
tags = ['module', 'export', 'using-declaration', 'linkage']

[[axioms]]
id = "cpp20_module_interface_redecl_export_7a8b9c0d"
content = '''A redeclaration of an entity that was not introduced by an exported declaration shall not be exported unless it is a type alias, a namespace, or a namespace alias.'''
formal_spec = '''redeclaration(D, X) && !introduced_by_exported(X) && exported(D) && !is_type_alias(D) && !is_namespace(D) && !is_namespace_alias(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/6"
tags = ['module', 'export', 'redeclaration']

[[axioms]]
id = "cpp20_module_import_global_scope_1e2f3a4b"
content = '''A module-import-declaration shall inhabit the global namespace scope.'''
formal_spec = '''module_import_declaration(D) => inhabits_global_namespace_scope(D) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/1"
tags = ['module', 'import', 'namespace-scope']

[[axioms]]
id = "cpp20_module_import_before_other_decls_5c6d7e8f"
content = '''In a module unit, all module-import-declarations and export-declarations exporting module-import-declarations shall appear before all other declarations in the declaration-seq.'''
formal_spec = '''module_unit(U) && module_import_declaration(D) && other_declaration(O) && appears_before(O, D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/1"
tags = ['module', 'import', 'declaration-order']

[[axioms]]
id = "cpp20_module_import_partition_same_module_9a0b1c2d"
content = '''A module-import-declaration that specifies a module-partition shall only appear after the module-declaration in a module unit of some module M.'''
formal_spec = '''module_import_declaration(D) && specifies_partition(D) => (appears_after_module_declaration(D) && in_module_unit(D)) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/4"
tags = ['module', 'import', 'partition']

[[axioms]]
id = "cpp20_module_import_header_no_module_decl_3e4f5a6b"
content = '''A header unit nominated by a header-name in a module-import-declaration shall not contain a module-declaration.'''
formal_spec = '''module_import_declaration(D) && specifies_header_name(D, H) && header_unit(H) && contains_module_declaration(H) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/5"
tags = ['module', 'import', 'header-unit']

[[axioms]]
id = "cpp20_module_import_importable_header_7c8d9e0f"
content = '''The header-name H in a module-import-declaration shall identify an importable header.'''
formal_spec = '''module_import_declaration(D) && specifies_header_name(D, H) => is_importable_header(H) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/5"
tags = ['module', 'import', 'header-unit', 'importable']

[[axioms]]
id = "cpp20_module_import_header_no_extern_def_1a2b3c4d"
content = '''A header unit shall not contain a definition of a non-inline function or variable whose name has external linkage.'''
formal_spec = '''header_unit(H) && contains_definition(H, D) && (is_function(D) || is_variable(D)) && !is_inline(D) && has_external_linkage(name(D)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/6"
tags = ['module', 'header-unit', 'definition', 'linkage']

[[axioms]]
id = "cpp20_module_import_impl_not_exported_5e6f7a8b"
content = '''A module implementation unit shall not be exported.'''
formal_spec = '''module_implementation_unit(U) && exported(U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/8"
tags = ['module', 'implementation-unit', 'export']

[[axioms]]
id = "cpp20_module_import_no_self_import_9c0d1e2f"
content = '''A module implementation unit of a module M that is not a module partition shall not contain a module-import-declaration nominating M.'''
formal_spec = '''module_implementation_unit(U, M) && !is_partition(U) && contains_import(U, M) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/9"
tags = ['module', 'import', 'self-reference']

[[axioms]]
id = "cpp20_module_import_no_cyclic_dependency_3a4b5c6d"
content = '''A translation unit shall not have an interface dependency on itself.'''
formal_spec = '''translation_unit(U) && interface_dependency(U, U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/10"
tags = ['module', 'import', 'cyclic-dependency']

[[axioms]]
id = "cpp20_module_private_frag_primary_only_7e8f9a0b"
content = '''A private-module-fragment shall appear only in a primary module interface unit.'''
formal_spec = '''private_module_fragment(F) && !in_primary_module_interface_unit(F) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.private.frag"
source_module = "[module.private.frag]/1"
tags = ['module', 'private-fragment', 'primary-interface']

[[axioms]]
id = "cpp20_module_private_frag_only_unit_1c2d3e4f"
content = '''A module unit with a private-module-fragment shall be the only module unit of its module.'''
formal_spec = '''module_unit(U) && has_private_module_fragment(U) && module_of(U, M) && count(module_units(M)) > 1 => ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.private.frag"
source_module = "[module.private.frag]/1"
tags = ['module', 'private-fragment', 'single-unit']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_variadic_params_a7f3b2c1"
content = '''The parameter-declaration-clause of a coroutine shall not terminate with an ellipsis that is not part of a parameter-declaration (i.e., C-style variadic parameters are not allowed in coroutines).'''
formal_spec = '''is_coroutine(F) && has_c_variadic_ellipsis(parameter_declaration_clause(F)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/1"
tags = ['coroutine', 'parameters', 'variadic', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_promise_type_class_d4e5f6a7"
content = '''The promise type of a coroutine shall be a class type.'''
formal_spec = '''is_coroutine(F) && promise_type(F) = std::coroutine_traits<R, P...>::promise_type => is_class_type(promise_type(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/3"
tags = ['coroutine', 'promise_type', 'constraint', 'type']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_both_return_void_value_b8c9d0e1"
content = '''If searches for the names return_void and return_value in the scope of the promise type each find any declarations, the program is ill-formed.'''
formal_spec = '''is_coroutine(F) && has_declaration(promise_type(F), "return_void") && has_declaration(promise_type(F), "return_value") => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/7"
tags = ['coroutine', 'promise_type', 'return_void', 'return_value', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_resume_not_suspended_ub_c2d3e4f5"
content = '''Invoking a resumption member function for a coroutine that is not suspended results in undefined behavior.'''
formal_spec = '''is_coroutine_handle(H) && refers_to_coroutine(H, C) && !is_suspended(C) && invoke_resumption_member_function(H) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/9"
tags = ['coroutine', 'coroutine_handle', 'resume', 'undefined_behavior', 'lifetime']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_destroy_not_suspended_ub_f6a7b8c9"
content = '''If destroy is called for a coroutine that is not suspended, the program has undefined behavior.'''
formal_spec = '''is_coroutine_handle(H) && refers_to_coroutine(H, C) && !is_suspended(C) && call_destroy(H) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/12"
tags = ['coroutine', 'coroutine_handle', 'destroy', 'undefined_behavior', 'lifetime']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_no_deallocation_func_d0e1f2a3"
content = '''If no usual deallocation function is found for coroutine state destruction, the program is ill-formed.'''
formal_spec = '''is_coroutine(F) && !exists_usual_deallocation_function(promise_type(F)) && !exists_usual_deallocation_function(global_scope) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/13"
tags = ['coroutine', 'deallocation', 'memory', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_final_suspend_nothrow_e4f5a6b7"
content = '''The expression co_await promise.final_suspend() shall not be potentially-throwing.'''
formal_spec = '''is_coroutine(F) && is_potentially_throwing(co_await_expr(promise.final_suspend())) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/16"
tags = ['coroutine', 'final_suspend', 'exception', 'noexcept', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_flowoff_no_return_void_ub_a8b9c0d1"
content = '''If return_void is not found in promise type, flowing off the end of a coroutine results in undefined behavior.'''
formal_spec = '''is_coroutine(F) && !has_declaration(promise_type(F), "return_void") && flows_off_end(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/7"
tags = ['coroutine', 'return_void', 'undefined_behavior', 'control_flow']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_ref_param_lifetime_ub_e2f3a4b5"
content = '''If a coroutine has a parameter passed by reference, resuming the coroutine after the lifetime of the entity referred to by that parameter has ended is likely to result in undefined behavior.'''
formal_spec = '''is_coroutine(F) && has_reference_parameter(F, P) && resume_coroutine(F) && !lifetime_active(referred_entity(P)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.75
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/14"
tags = ['coroutine', 'reference', 'parameter', 'lifetime', 'undefined_behavior']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_alloc_fail_nothrow_c6d7e8f9"
content = '''When get_return_object_on_allocation_failure is declared in the promise type and a global allocation function is selected, the ::operator new(size_t, nothrow_t) form is used. The allocation function used in this case shall have a non-throwing noexcept-specifier.'''
formal_spec = '''is_coroutine(F) && has_declaration(promise_type(F), "get_return_object_on_allocation_failure") && uses_global_allocation(F) => is_nothrow(allocation_function(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/11"
tags = ['coroutine', 'allocation', 'nothrow', 'constraint']

[[axioms]]
id = "cpp20_temp_constr_constr_general_satisfaction_required_a3f7b2c1"
content = '''For a constrained template to be instantiated, its associated constraints shall be satisfied.'''
formal_spec = '''constrained_template(T) && instantiate(T) => satisfied(associated_constraints(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.constr.general"
source_module = "[temp.constr.constr.general]/2"
tags = ['templates', 'constraints', 'instantiation']

[[axioms]]
id = "cpp20_temp_constr_atomic_bool_type_required_d8e4f1a9"
content = '''After substitution and lvalue-to-rvalue conversion, an atomic constraint expression E shall be a constant expression of type bool.'''
formal_spec = '''atomic_constraint(E) && substitution_valid(E) && lvalue_to_rvalue_if_needed(E) => is_constant_expr(E) && type(E) == bool'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/3"
tags = ['constraints', 'atomic', 'constant-expression', 'bool']

[[axioms]]
id = "cpp20_temp_constr_atomic_substitution_failure_not_satisfied_c2b1e5f8"
content = '''If substitution into an atomic constraint results in an invalid type or expression in the immediate context, the constraint is not satisfied.'''
formal_spec = '''atomic_constraint(C) && substitution_fails_immediate_context(C) => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/3"
tags = ['constraints', 'atomic', 'substitution', 'SFINAE']

[[axioms]]
id = "cpp20_temp_constr_atomic_satisfaction_consistency_ndr_f9a2c4d7"
content = '''If at different points in the program, the satisfaction result is different for identical atomic constraints and template arguments, the program is ill-formed, no diagnostic required.'''
formal_spec = '''identical_atomic_constraints(C1, C2) && same_template_args(A1, A2) && satisfaction(C1, A1) != satisfaction(C2, A2) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/3"
tags = ['constraints', 'atomic', 'odr', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_atomic_identity_functionally_equiv_ndr_b7c3a1e6"
content = '''If the validity or meaning of the program depends on whether two atomic constraints are equivalent, and they are functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required.'''
formal_spec = '''depends_on_equivalence(C1, C2) && functionally_equivalent(C1, C2) && NOT equivalent(C1, C2) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/2"
tags = ['constraints', 'atomic', 'equivalence', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_concept_substitution_failure_not_satisfied_e4d8f2a3"
content = '''If substitution into a concept-dependent constraint results in an invalid concept-id in the immediate context, the constraint is not satisfied.'''
formal_spec = '''concept_dependent_constraint(CD) && substitution_invalid_concept_id(CD) => NOT satisfied(CD)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.concept"
source_module = "[temp.constr.concept]/2"
tags = ['constraints', 'concept', 'substitution', 'SFINAE']

[[axioms]]
id = "cpp20_temp_constr_fold_conjunction_invalid_pack_not_satisfied_a1b9c7d5"
content = '''A fold expanded constraint with && operator is satisfied only if it is a valid pack expansion.'''
formal_spec = '''fold_constraint(C, '&&') && NOT valid_pack_expansion(C) => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/2"
tags = ['constraints', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_fold_disjunction_empty_not_satisfied_c5e3a8f2"
content = '''A fold expanded constraint with || operator is not satisfied if the pack expansion has zero elements (N=0).'''
formal_spec = '''fold_constraint(C, '||') && pack_size(C) == 0 => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/3"
tags = ['constraints', 'fold', 'pack-expansion', 'disjunction']

[[axioms]]
id = "cpp20_temp_constr_fold_disjunction_invalid_pack_not_satisfied_d2f4b6c8"
content = '''A fold expanded constraint with || operator is satisfied only if it is a valid pack expansion.'''
formal_spec = '''fold_constraint(C, '||') && NOT valid_pack_expansion(C) => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/3"
tags = ['constraints', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_fold_different_size_packs_invalid_e7a1c3d9"
content = '''If a fold expanded constraint expands packs of different sizes, the pack expansion is invalid and the constraint is not satisfied.'''
formal_spec = '''fold_constraint(C) && expands_packs_different_sizes(C) => NOT valid_pack_expansion(C) && NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/4"
tags = ['constraints', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_normal_invalid_concept_id_ndr_f8b2c4a6"
content = '''During constraint normalization of a concept-id, if substitution of non-dependent concept template arguments results in an invalid concept-id, the program is ill-formed, no diagnostic required.'''
formal_spec = '''normalizing_concept_id(CI) && substitution_invalid(non_dependent_args(CI)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.4.2"
tags = ['constraints', 'normalization', 'concept', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_normal_invalid_type_expr_ndr_a9c5e7b1"
content = '''During constraint normalization, if substitution of template parameters in parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.'''
formal_spec = '''normalizing_concept_id(CI) && substitution_in_mapping_invalid(CI) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.4.2"
tags = ['constraints', 'normalization', 'substitution', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_normal_fold_mixed_packs_error_b3d7f1c8"
content = '''In a fold expression for constraint normalization, if E contains an unexpanded concept template parameter pack, it shall not contain an unexpanded template parameter pack of another kind.'''
formal_spec = '''fold_expr_normalization(E) && has_unexpanded_concept_pack(E) && has_unexpanded_other_pack(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.5.3"
tags = ['constraints', 'normalization', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_normal_fold_pack_size_mismatch_ndr_c4e8a2f5"
content = '''During fold expression normalization, if concept template parameter packs have corresponding arguments with different counts, the program is ill-formed, no diagnostic required.'''
formal_spec = '''fold_normalization(F) && concept_pack_arg_counts_differ(F) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.5.3.1"
tags = ['constraints', 'normalization', 'fold', 'pack-expansion', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_normal_fold_substitution_invalid_ndr_d5f9b3a7"
content = '''During fold expression normalization, if substitution of concept arguments results in an invalid type or expression, the program is ill-formed, no diagnostic required.'''
formal_spec = '''fold_normalization(F) && substitution_concept_args_invalid(F) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.5.3.1"
tags = ['constraints', 'normalization', 'fold', 'substitution', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_order_concept_dependent_not_eligible_e6a2c4b8"
content = '''The associated constraints of a declaration are not eligible for subsumption if they contain a concept-dependent constraint.'''
formal_spec = '''contains_concept_dependent_constraint(associated_constraints(D)) => NOT eligible_for_subsumption(D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.order"
source_module = "[temp.constr.order]/3"
tags = ['constraints', 'subsumption', 'partial-ordering', 'concept-dependent']

[[axioms]]
id = "cpp20_cmp_categories_pre_literal_zero_arg_4f8a2b1c"
content = '''Supplying an argument other than literal 0 to comparison category type relational/equality operators is undefined behavior.'''
formal_spec = '''is_comparison_category_type(T) && is_relational_or_equality_op(op) && arg_to_unspecified_param(op, arg) && arg != literal_0 => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.categories.pre"
source_module = "[cmp.categories.pre]/3"
tags = ['comparison', 'undefined-behavior', 'literal']

[[axioms]]
id = "cpp20_cmp_result_specialization_ub_7e3d1a9f"
content = '''Adding specializations for the compare_three_way_result template is undefined behavior.'''
formal_spec = '''user_specialization(compare_three_way_result<T, U>) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.result"
source_module = "[cmp.result]/1"
tags = ['comparison', 'template-specialization', 'undefined-behavior']

[[axioms]]
id = "cpp20_compare_type_specialization_illformed_2c5f8e4a"
content = '''Declaring an explicit specialization or partial specialization of type_order makes the program ill-formed.'''
formal_spec = '''(explicit_specialization(type_order<T, U>) || partial_specialization(type_order<T, U>)) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "compare.type"
source_module = "[compare.type]/2"
tags = ['comparison', 'template-specialization', 'type-ordering']

[[axioms]]
id = "cpp20_cmp_alg_strong_order_same_type_3a9c7b2d"
content = '''strong_order(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => strong_order(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.1"
tags = ['comparison', 'customization-point', 'strong-order']

[[axioms]]
id = "cpp20_cmp_alg_weak_order_same_type_5d8e4f1a"
content = '''weak_order(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => weak_order(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.1"
tags = ['comparison', 'customization-point', 'weak-order']

[[axioms]]
id = "cpp20_cmp_alg_partial_order_same_type_8b2c3e9f"
content = '''partial_order(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => partial_order(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.1"
tags = ['comparison', 'customization-point', 'partial-order']

[[axioms]]
id = "cpp20_cmp_alg_strong_fallback_same_type_1e7f9a3b"
content = '''compare_strong_order_fallback(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => compare_strong_order_fallback(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.1"
tags = ['comparison', 'customization-point', 'fallback']

[[axioms]]
id = "cpp20_cmp_alg_weak_fallback_same_type_6c4d2e8a"
content = '''compare_weak_order_fallback(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => compare_weak_order_fallback(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.1"
tags = ['comparison', 'customization-point', 'fallback']

[[axioms]]
id = "cpp20_cmp_alg_partial_fallback_same_type_9f1b5c7d"
content = '''compare_partial_order_fallback(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => compare_partial_order_fallback(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.1"
tags = ['comparison', 'customization-point', 'fallback']

[[axioms]]
id = "cpp20_cmp_common_void_non_category_a3b8c2d1"
content = '''common_comparison_category yields void if any template argument is not a comparison category type.'''
formal_spec = '''exists(T in Ts, !is_comparison_category_type(T)) => common_comparison_category<Ts...>::type == void'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.common"
source_module = "[cmp.common]/2"
tags = ['comparison', 'type-trait', 'common-type']

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_symmetry_7d9e1f2a"
content = '''For types modeling partially-ordered-with, relational operator results must be symmetric: bool(t<u)==bool(u>t), bool(u<t)==bool(t>u), bool(t<=u)==bool(u>=t), bool(u<=t)==bool(t>=u).'''
formal_spec = '''models(partially_ordered_with<T, U>) => (bool(t<u)==bool(u>t)) && (bool(u<t)==bool(t>u)) && (bool(t<=u)==bool(u>=t)) && (bool(u<=t)==bool(t>=u))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/1"
tags = ['comparison', 'concept', 'semantic-constraint']

[[axioms]]
id = "cpp20_cmp_concept_three_way_eq_consistency_4e8f3a1b"
content = '''For types modeling three_way_comparable, (a<=>b==0)==bool(a==b) and (a<=>b!=0)==bool(a!=b) must hold.'''
formal_spec = '''models(three_way_comparable<T, Cat>) => ((a<=>b==0)==bool(a==b)) && ((a<=>b!=0)==bool(a!=b))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.1-2.2"
tags = ['comparison', 'concept', 'semantic-constraint', 'three-way']

[[axioms]]
id = "cpp20_cmp_concept_three_way_rel_consistency_5a7c9d2e"
content = '''For types modeling three_way_comparable, the three-way comparison must be consistent with relational operators.'''
formal_spec = '''models(three_way_comparable<T, Cat>) => ((a<=>b<0)==bool(a<b)) && ((a<=>b>0)==bool(a>b)) && ((a<=>b<=0)==bool(a<=b)) && ((a<=>b>=0)==bool(a>=b))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.4-2.7"
tags = ['comparison', 'concept', 'semantic-constraint', 'three-way']

[[axioms]]
id = "cpp20_cmp_concept_strong_ordering_total_8b3f1e4c"
content = '''For types modeling three_way_comparable with Cat convertible to strong_ordering, the type must also model totally_ordered.'''
formal_spec = '''models(three_way_comparable<T, Cat>) && is_convertible_v<Cat, strong_ordering> => models(totally_ordered<T>)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.8"
tags = ['comparison', 'concept', 'semantic-constraint', 'strong-ordering']

[[axioms]]
id = "cpp20_cmp_concept_three_way_with_domain_2c4e6f8a"
content = '''For types modeling three_way_comparable_with, t<=>u and u<=>t must have the same domain.'''
formal_spec = '''models(three_way_comparable_with<T, U, Cat>) => same_domain(t<=>u, u<=>t)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.1"
tags = ['comparison', 'concept', 'semantic-constraint', 'three-way']

[[axioms]]
id = "cpp20_cmp_concept_three_way_with_strong_total_9d1a3b5c"
content = '''For types modeling three_way_comparable_with with Cat convertible to strong_ordering, T and U must also model totally_ordered_with.'''
formal_spec = '''models(three_way_comparable_with<T, U, Cat>) && is_convertible_v<Cat, strong_ordering> => models(totally_ordered_with<T, U>)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.10"
tags = ['comparison', 'concept', 'semantic-constraint', 'strong-ordering']

[[axioms]]
id = "cpp20_cmp_strongord_substitutability_1f8e2d4a"
content = '''For strong_ordering, equality implies substitutability: f(a)==f(b) when a==b, where f reads only comparison-salient public const state.'''
formal_spec = '''type_uses(T, strong_ordering) && a == b => forall(f: comparison_salient_function, f(a) == f(b))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.categories.pre"
source_module = "[cmp.categories.pre]/4"
tags = ['comparison', 'strong-ordering', 'substitutability', 'semantic-constraint']

[[axioms]]
id = "cpp20_associative_reqmts_strict_weak_ordering_a1b2c3d4"
content = '''The comparison object of an associative container must induce a strict weak ordering on elements of Key.'''
formal_spec = '''is_associative_container(X) && has_compare(X, Compare) => strict_weak_ordering(Compare, Key)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/2"
tags = ['associative', 'ordering', 'comparison', 'constraint']

[[axioms]]
id = "cpp20_associative_reqmts_comp_consistency_f8e7d6c5"
content = '''For any two keys k1 and k2 in the same associative container, calling comp(k1, k2) shall always return the same value.'''
formal_spec = '''is_associative_container(a) && key_in_container(k1, a) && key_in_container(k2, a) && comparison_object(a, comp) => deterministic(comp(k1, k2))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/3"
tags = ['associative', 'comparison', 'determinism', 'constraint']

[[axioms]]
id = "cpp20_associative_reqmts_value_type_erasable_b3c4d5e6"
content = '''X::value_type must be Cpp17Erasable from X for associative containers.'''
formal_spec = '''is_associative_container(X) => Cpp17Erasable(X::value_type, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/13"
tags = ['associative', 'value_type', 'erasable', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_key_compare_copyconstructible_d4e5f6a7"
content = '''key_compare must be Cpp17CopyConstructible for associative containers.'''
formal_spec = '''is_associative_container(X) => Cpp17CopyConstructible(X::key_compare)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/15"
tags = ['associative', 'key_compare', 'copyconstructible', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_default_ctor_key_compare_e5f6a7b8"
content = '''Default construction of associative container requires key_compare to meet Cpp17DefaultConstructible requirements.'''
formal_spec = '''is_associative_container(X) && default_construct(X) => Cpp17DefaultConstructible(X::key_compare)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/20"
tags = ['associative', 'constructor', 'key_compare', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_range_ctor_emplaceable_f6a7b8c9"
content = '''Range constructor X(i, j, c) requires value_type to be Cpp17EmplaceConstructible into X from *i.'''
formal_spec = '''is_associative_container(X) && range_construct(X, i, j, c) => Cpp17EmplaceConstructible(X::value_type, X, *i)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/23"
tags = ['associative', 'constructor', 'emplaceable', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_from_range_ctor_emplaceable_a7b8c9d0"
content = '''from_range constructor requires value_type to be Cpp17EmplaceConstructible into X from *ranges::begin(rg).'''
formal_spec = '''is_associative_container(X) && from_range_construct(X, rg, c) => Cpp17EmplaceConstructible(X::value_type, X, *ranges::begin(rg))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/29"
tags = ['associative', 'constructor', 'range', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_il_assign_copyinsertable_b8c9d0e1"
content = '''Assignment from initializer_list requires value_type to be Cpp17CopyInsertable into X and Cpp17CopyAssignable.'''
formal_spec = '''is_associative_container(X) && assign_from_initializer_list(a, il) => Cpp17CopyInsertable(X::value_type, X) && Cpp17CopyAssignable(X::value_type)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/38"
tags = ['associative', 'assignment', 'initializer_list', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_emplace_emplaceable_c9d0e1f2"
content = '''emplace requires value_type to be Cpp17EmplaceConstructible into X from args.'''
formal_spec = '''is_associative_container(X) && call_emplace(a, args) => Cpp17EmplaceConstructible(X::value_type, X, args...)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/48"
tags = ['associative', 'emplace', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_insert_rvalue_moveinsertable_d0e1f2a3"
content = '''insert(t) where t is a non-const rvalue requires value_type to be Cpp17MoveInsertable into X.'''
formal_spec = '''is_associative_container(X) && call_insert(a, t) && is_nonconst_rvalue(t) => Cpp17MoveInsertable(X::value_type, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/62"
tags = ['associative', 'insert', 'move', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_insert_lvalue_copyinsertable_e1f2a3b4"
content = '''insert(t) where t is not a non-const rvalue requires value_type to be Cpp17CopyInsertable into X.'''
formal_spec = '''is_associative_container(X) && call_insert(a, t) && !is_nonconst_rvalue(t) => Cpp17CopyInsertable(X::value_type, X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/62"
tags = ['associative', 'insert', 'copy', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_range_insert_no_self_iter_f2a3b4c5"
content = '''insert(i, j) requires that neither i nor j are iterators into the container a.'''
formal_spec = '''is_associative_container(X) && call_insert_range(a, i, j) => !iterator_into(i, a) && !iterator_into(j, a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/76"
tags = ['associative', 'insert', 'range', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_insert_range_no_overlap_a3b4c5d6"
content = '''insert_range(rg) requires that rg and a do not overlap.'''
formal_spec = '''is_associative_container(X) && call_insert_range(a, rg) => !overlaps(rg, a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/80"
tags = ['associative', 'insert_range', 'overlap', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_node_handle_allocator_match_b4c5d6e7"
content = '''insert(nh) requires nh is empty or a.get_allocator() == nh.get_allocator() is true.'''
formal_spec = '''is_associative_container(X) && call_insert_node(a, nh) => empty(nh) || (a.get_allocator() == nh.get_allocator())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/85"
tags = ['associative', 'insert', 'node_handle', 'allocator', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_merge_allocator_match_c5d6e7f8"
content = '''merge(a2) requires a.get_allocator() == a2.get_allocator() is true.'''
formal_spec = '''is_associative_container(X) && call_merge(a, a2) => a.get_allocator() == a2.get_allocator()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/113"
tags = ['associative', 'merge', 'allocator', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_node_type_access_ub_d6e7f8a9"
content = '''Accessing an element through pointers and references while the element is owned by a node_type is undefined behavior.'''
formal_spec = '''element_owned_by_node_type(element, node) && access_through_ptr_or_ref(element) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/176"
tags = ['associative', 'node_handle', 'lifetime', 'undefined_behavior']

[[axioms]]
id = "cpp20_associative_reqmts_no_compare_ptr_storage_e7f8a9b0"
content = '''When an associative container is constructed by passing a comparison object, the container shall not store a pointer or reference to the passed object.'''
formal_spec = '''is_associative_container(X) && construct_with_compare(X, comp) => !stores_ptr_or_ref_to(X, comp)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/179"
tags = ['associative', 'constructor', 'comparison', 'constraint']

[[axioms]]
id = "cpp20_associative_reqmts_insert_iterator_validity_f8a9b0c1"
content = '''The insert, insert_range, and emplace members shall not affect the validity of iterators and references to the container.'''
formal_spec = '''is_associative_container(X) && (call_insert(a, ...) || call_insert_range(a, ...) || call_emplace(a, ...)) => iterators_remain_valid(a) && references_remain_valid(a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/175"
tags = ['associative', 'insert', 'iterator', 'validity', 'invariant']

[[axioms]]
id = "cpp20_associative_reqmts_erase_invalidates_only_erased_a9b0c1d2"
content = '''The erase members shall invalidate only iterators and references to the erased elements.'''
formal_spec = '''is_associative_container(X) && call_erase(a, ...) => invalidates_only(iterators_to_erased_elements) && invalidates_only(references_to_erased_elements)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/175"
tags = ['associative', 'erase', 'iterator', 'validity', 'invariant']

[[axioms]]
id = "cpp20_associative_reqmts_extract_ptr_ref_valid_b0c1d2e3"
content = '''The extract members invalidate only iterators to the removed element; pointers and references to the removed element remain valid.'''
formal_spec = '''is_associative_container(X) && call_extract(a, ...) => invalidates_only_iterators_to_extracted(a) && ptrs_refs_remain_valid_to_extracted(a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/176"
tags = ['associative', 'extract', 'iterator', 'pointer', 'validity']

[[axioms]]
id = "cpp20_associative_reqmts_nondescending_iteration_c1d2e3f4"
content = '''Iterators of associative containers iterate through the containers in the non-descending order of keys where non-descending is defined by the comparison that was used to construct them.'''
formal_spec = '''is_associative_container(a) && dereferenceable(i) && dereferenceable(j) && distance(i, j) > 0 => value_comp(*j, *i) == false'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/177"
tags = ['associative', 'iterator', 'ordering', 'invariant']

[[axioms]]
id = "cpp20_associative_reqmts_unique_keys_strict_order_d2e3f4a5"
content = '''For associative containers with unique keys, iterators satisfy the stronger condition value_comp(*i, *j) != false for any two dereferenceable iterators i and j where distance from i to j is positive.'''
formal_spec = '''is_associative_container_unique_keys(a) && dereferenceable(i) && dereferenceable(j) && distance(i, j) > 0 => value_comp(*i, *j) != false'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/178"
tags = ['associative', 'unique_keys', 'iterator', 'ordering', 'invariant']

[[axioms]]
id = "cpp20_associative_reqmts_clear_no_throw_e3f4a5b6"
content = '''For associative containers, no clear() function throws an exception.'''
formal_spec = '''is_associative_container(a) && call_clear(a) => noexcept'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.except"
source_module = "[associative.reqmts.except]/1"
tags = ['associative', 'clear', 'exception', 'noexcept']

[[axioms]]
id = "cpp20_associative_reqmts_erase_k_nothrow_unless_compare_f4a5b6c7"
content = '''erase(k) does not throw an exception unless that exception is thrown by the container's Compare object.'''
formal_spec = '''is_associative_container(a) && call_erase_key(a, k) => nothrow_unless_compare_throws(a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.except"
source_module = "[associative.reqmts.except]/1"
tags = ['associative', 'erase', 'exception', 'compare']

[[axioms]]
id = "cpp20_associative_reqmts_insert_single_strong_guarantee_a5b6c7d8"
content = '''For associative containers, if an exception is thrown by any operation from within an insert or emplace function inserting a single element, the insertion has no effect.'''
formal_spec = '''is_associative_container(a) && (call_insert_single(a, ...) || call_emplace_single(a, ...)) && throws_exception => no_effect_on_container(a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.except"
source_module = "[associative.reqmts.except]/2"
tags = ['associative', 'insert', 'emplace', 'exception', 'strong_guarantee']

[[axioms]]
id = "cpp20_associative_reqmts_swap_nothrow_unless_compare_b6c7d8e9"
content = '''For associative containers, no swap function throws an exception unless that exception is thrown by the swap of the container's Compare object.'''
formal_spec = '''is_associative_container(a) && call_swap(a, b) => nothrow_unless_compare_swap_throws(a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.except"
source_module = "[associative.reqmts.except]/3"
tags = ['associative', 'swap', 'exception', 'compare']

[[axioms]]
id = "cpp20_associative_reqmts_valid_range_ctor_c7d8e9f0"
content = '''Constructor X(i, j) requires [i, j) to be a valid range.'''
formal_spec = '''is_associative_container(X) && range_construct(X, i, j) => valid_range(i, j)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/7.10"
tags = ['associative', 'constructor', 'range', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_p_valid_const_iterator_d8e9f0a1"
content = '''The parameter p in associative container operations must be a valid constant iterator to a.'''
formal_spec = '''is_associative_container(a) && use_iterator_p(a, p) => valid_const_iterator(p, a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/7.12"
tags = ['associative', 'iterator', 'valid', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_q_dereferenceable_iterator_e9f0a1b2"
content = '''The parameter q in associative container operations must be a valid dereferenceable constant iterator to a.'''
formal_spec = '''is_associative_container(a) && use_iterator_q(a, q) => valid_dereferenceable_const_iterator(q, a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/7.13"
tags = ['associative', 'iterator', 'dereferenceable', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_q1_q2_valid_range_f0a1b2c3"
content = '''The parameters [q1, q2) in associative container operations must denote a valid range of constant iterators in a.'''
formal_spec = '''is_associative_container(a) && use_iterator_range(a, q1, q2) => valid_const_iterator_range(q1, q2, a)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/7.15"
tags = ['associative', 'iterator', 'range', 'precondition']

[[axioms]]
id = "cpp20_associative_reqmts_node_refs_invalidated_on_insert_a1b2c3d5"
content = '''References and pointers to an element obtained while it is owned by a node_type are invalidated if the element is successfully inserted.'''
formal_spec = '''owned_by_node_type(element, node) && has_ptr_or_ref(element, ptr_or_ref) && successfully_inserted(element) => invalidated(ptr_or_ref)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "associative.reqmts.general"
source_module = "[associative.reqmts.general]/176"
tags = ['associative', 'node_handle', 'insert', 'pointer', 'reference', 'invalidation']

[[axioms]]
id = "cpp20_iterator_req_invalid_range_ub_a1b2c3d4"
content = '''The result of applying library functions to invalid ranges is undefined behavior.'''
formal_spec = '''apply_library_function(range) && !valid_range(range) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/12"
tags = ['iterator', 'range', 'undefined-behavior']

[[axioms]]
id = "cpp20_iterator_req_singular_deref_ub_e5f6a7b8"
content = '''Results of most expressions are undefined for singular iterator values; exceptions are destruction, assignment of non-singular value, and for Cpp17DefaultConstructible iterators, using value-initialized iterator as copy/move source.'''
formal_spec = '''singular_value(iter) && !is_allowed_singular_operation(expr, iter) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/7"
tags = ['iterator', 'singular-value', 'undefined-behavior']

[[axioms]]
id = "cpp20_iterator_req_past_end_not_deref_c9d0e1f2"
content = '''Past-the-end iterator values are never dereferenceable; the library never assumes past-the-end values are dereferenceable.'''
formal_spec = '''past_the_end(iter) => !dereferenceable(iter)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/7"
tags = ['iterator', 'past-the-end', 'dereference']

[[axioms]]
id = "cpp20_iterator_req_invalidated_deref_ub_a3b4c5d6"
content = '''The effect of dereferencing an iterator that has been invalidated is undefined behavior.'''
formal_spec = '''invalidated(iter) && dereference(iter) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/16"
tags = ['iterator', 'invalidation', 'undefined-behavior', 'dereference']

[[axioms]]
id = "cpp20_iterator_req_destruction_invalidates_e7f8a9b0"
content = '''Destruction of an iterator may invalidate pointers and references previously obtained from that iterator if its type does not meet Cpp17ForwardIterator requirements and does not model forward_iterator.'''
formal_spec = '''destroyed(iter) && !meets_cpp17_forward_iterator(type(iter)) && !models_forward_iterator(type(iter)) => may_invalidate(pointers_and_refs_from(iter))'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/15"
tags = ['iterator', 'lifetime', 'invalidation']

[[axioms]]
id = "cpp20_iterator_req_valid_range_sentinel_reachable_c1d2e3f4"
content = '''A range [i, s) is valid if and only if sentinel s is reachable from iterator i via finite sequence of ++i applications.'''
formal_spec = '''valid_range(i, s) <=> reachable(i, s)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/10"
tags = ['iterator', 'range', 'sentinel']

[[axioms]]
id = "cpp20_iterator_req_counted_range_valid_f5a6b7c8"
content = '''A counted range i+[0,n) is valid if and only if n==0, or n is positive, i is dereferenceable, and ++i+[0,--n) is valid.'''
formal_spec = '''valid_counted_range(i, n) <=> (n == 0) || (n > 0 && dereferenceable(i) && valid_counted_range(++i, n-1))'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/11"
tags = ['iterator', 'counted-range', 'valid']

[[axioms]]
id = "cpp20_iter_move_not_equal_deref_ill_formed_d9e0f1a2"
content = '''If ranges::iter_move(E) is not equal to *E, the program is ill-formed, no diagnostic required.'''
formal_spec = '''iter_move(E) != *E => ill_formed_ndr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.cust.move"
source_module = "[iterator.cust.move]/2"
tags = ['iterator', 'iter_move', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_iter_swap_must_exchange_values_b3c4d5e6"
content = '''If the iter_swap function selected by overload resolution does not exchange the values denoted by E1 and E2, the program is ill-formed, no diagnostic required.'''
formal_spec = '''selected_iter_swap(E1, E2) && !exchanges_values(E1, E2) => ill_formed_ndr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.cust.swap"
source_module = "[iterator.cust.swap]/4.1"
tags = ['iterator', 'iter_swap', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_indirectly_readable_equality_preserving_f7a8b9c0"
content = '''For a type I to model indirectly_readable, the expression *i must be equality-preserving.'''
formal_spec = '''models_indirectly_readable(I) => equality_preserving(*i) for value i of type I'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.readable"
source_module = "[iterator.concept.readable]/2"
tags = ['iterator', 'indirectly_readable', 'equality-preserving']

[[axioms]]
id = "cpp20_indirectly_writable_assignment_semantics_d1e2f3a4"
content = '''For Out and T modeling indirectly_writable<Out, T>, if Out and T also model indirectly_readable<Out> && same_as<iter_value_t<Out>, decay_t<T>>, then *o after assignment must equal the value of E before assignment.'''
formal_spec = '''models_indirectly_writable(Out, T) && models_indirectly_readable(Out) && same_as(iter_value_t(Out), decay_t(T)) => (*o after assignment) == (E before assignment)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.writable"
source_module = "[iterator.concept.writable]/2"
tags = ['iterator', 'indirectly_writable', 'assignment']

[[axioms]]
id = "cpp20_indirectly_writable_not_dereferenceable_after_b5c6d7e8"
content = '''After evaluating an indirectly_writable assignment expression, the output iterator o is not required to be dereferenceable.'''
formal_spec = '''after_assignment_expr(o) => !required_dereferenceable(o)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "iterator.concept.writable"
source_module = "[iterator.concept.writable]/3"
tags = ['iterator', 'indirectly_writable', 'dereferenceable']

[[axioms]]
id = "cpp20_weakly_incrementable_same_domain_f9a0b1c2"
content = '''For a type I modeling weakly_incrementable, the expressions ++i and i++ must have the same domain.'''
formal_spec = '''models_weakly_incrementable(I) => domain(++i) == domain(i++)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.winc"
source_module = "[iterator.concept.winc]/14.1"
tags = ['iterator', 'weakly_incrementable', 'domain']

[[axioms]]
id = "cpp20_weakly_incrementable_advance_d3e4f5a6"
content = '''For a type I modeling weakly_incrementable, if i is incrementable, then both ++i and i++ advance i to the next element.'''
formal_spec = '''models_weakly_incrementable(I) && incrementable(i) => advances_to_next(++i) && advances_to_next(i++)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.winc"
source_module = "[iterator.concept.winc]/14.2"
tags = ['iterator', 'weakly_incrementable', 'increment']

[[axioms]]
id = "cpp20_weakly_incrementable_addressof_b7c8d9e0"
content = '''For a type I modeling weakly_incrementable, if i is incrementable, then addressof(++i) equals addressof(i).'''
formal_spec = '''models_weakly_incrementable(I) && incrementable(i) => addressof(++i) == addressof(i)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.winc"
source_module = "[iterator.concept.winc]/14.3"
tags = ['iterator', 'weakly_incrementable', 'addressof']

[[axioms]]
id = "cpp20_incrementable_equality_implies_postinc_f1a2b3c4"
content = '''For incrementable type I, if bool(a == b) then bool(a++ == b).'''
formal_spec = '''models_incrementable(I) && (a == b) => (a++ == b)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.inc"
source_module = "[iterator.concept.inc]/2.1"
tags = ['iterator', 'incrementable', 'equality']

[[axioms]]
id = "cpp20_incrementable_equality_implies_preinc_d5e6f7a8"
content = '''For incrementable type I, if bool(a == b) then bool(((void)a++, a) == ++b).'''
formal_spec = '''models_incrementable(I) && (a == b) => (((void)a++, a) == ++b)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.inc"
source_module = "[iterator.concept.inc]/2.2"
tags = ['iterator', 'incrementable', 'equality']

[[axioms]]
id = "cpp20_sentinel_for_i_eq_s_well_defined_b9c0d1e2"
content = '''For types S and I modeling sentinel_for<S, I>, if [i, s) denotes a range, then i == s must be well-defined.'''
formal_spec = '''models_sentinel_for(S, I) && denotes_range(i, s) => well_defined(i == s)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.sentinel"
source_module = "[iterator.concept.sentinel]/2.1"
tags = ['iterator', 'sentinel', 'equality']

[[axioms]]
id = "cpp20_sentinel_for_dereferenceable_if_not_end_f3a4b5c6"
content = '''For types S and I modeling sentinel_for<S, I>, if bool(i != s) then i is dereferenceable and [++i, s) denotes a range.'''
formal_spec = '''models_sentinel_for(S, I) && (i != s) => dereferenceable(i) && denotes_range(++i, s)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.sentinel"
source_module = "[iterator.concept.sentinel]/2.2"
tags = ['iterator', 'sentinel', 'dereferenceable']

[[axioms]]
id = "cpp20_sentinel_equality_domain_not_static_d7e8f9a0"
content = '''The domain of == between iterator and sentinel is not static; after incrementing any iterator equal to i, i == s is no longer required to be well-defined.'''
formal_spec = '''denotes_range(i, s) && (i != s) && incremented_equal_iterator(j, i) => !required_well_defined(i == s)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "iterator.concept.sentinel"
source_module = "[iterator.concept.sentinel]/3"
tags = ['iterator', 'sentinel', 'equality', 'domain']

[[axioms]]
id = "cpp20_sized_sentinel_difference_well_defined_b1c2d3e4"
content = '''For sized_sentinel_for<S, I>, if N (applications of ++i to reach s) is representable by iter_difference_t<I>, then s - i must be well-defined and equal N.'''
formal_spec = '''models_sized_sentinel_for(S, I) && representable(N, iter_difference_t(I)) => well_defined(s - i) && (s - i == N)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.sizedsentinel"
source_module = "[iterator.concept.sizedsentinel]/2.1"
tags = ['iterator', 'sized_sentinel', 'difference']

[[axioms]]
id = "cpp20_sized_sentinel_negative_difference_f5a6b7c8"
content = '''For sized_sentinel_for<S, I>, if -N is representable by iter_difference_t<I>, then i - s must be well-defined and equal -N.'''
formal_spec = '''models_sized_sentinel_for(S, I) && representable(-N, iter_difference_t(I)) => well_defined(i - s) && (i - s == -N)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.sizedsentinel"
source_module = "[iterator.concept.sizedsentinel]/2.2"
tags = ['iterator', 'sized_sentinel', 'difference']

[[axioms]]
id = "cpp20_output_iterator_postinc_assign_equiv_d9e0f1a2"
content = '''For output_iterator<I, T>, *i++ = E must have effects equivalent to *i = E; ++i;'''
formal_spec = '''models_output_iterator(I, T) => effects(*i++ = E) == effects(*i = E; ++i;)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.output"
source_module = "[iterator.concept.output]/2"
tags = ['iterator', 'output_iterator', 'assignment']

[[axioms]]
id = "cpp20_forward_iterator_multipass_equality_b3c4d5e6"
content = '''For forward_iterator, two dereferenceable iterators a and b offer the multi-pass guarantee: a == b implies ++a == ++b.'''
formal_spec = '''models_forward_iterator(I) && dereferenceable(a) && dereferenceable(b) && (a == b) => (++a == ++b)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.forward"
source_module = "[iterator.concept.forward]/4.1"
tags = ['iterator', 'forward_iterator', 'multi-pass']

[[axioms]]
id = "cpp20_forward_iterator_multipass_deref_f7a8b9c0"
content = '''For forward_iterator, the expression ((void)[](X x){++x;}(a), *a) is equivalent to *a.'''
formal_spec = '''models_forward_iterator(X) => equivalent(((void)[](X x){++x;}(a), *a), *a)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.forward"
source_module = "[iterator.concept.forward]/4.2"
tags = ['iterator', 'forward_iterator', 'multi-pass', 'dereference']

[[axioms]]
id = "cpp20_forward_iterator_pointers_remain_valid_d1e2f3a4"
content = '''Pointers and references obtained from a forward iterator into a range [i, s) shall remain valid while [i, s) continues to denote a range.'''
formal_spec = '''models_forward_iterator(I) && obtained_from(ptr_or_ref, i) && denotes_range(i, s) => valid(ptr_or_ref)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.forward"
source_module = "[iterator.concept.forward]/3"
tags = ['iterator', 'forward_iterator', 'validity', 'pointer', 'reference']

[[axioms]]
id = "cpp20_forward_iterator_equality_domain_b5c6d7e8"
content = '''The domain of == for forward iterators is that of iterators over the same underlying sequence. Value-initialized iterators may be compared and shall compare equal to other value-initialized iterators of the same type.'''
formal_spec = '''models_forward_iterator(I) && value_initialized(a) && value_initialized(b) && same_type(a, b) => (a == b)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.forward"
source_module = "[iterator.concept.forward]/2"
tags = ['iterator', 'forward_iterator', 'equality', 'value-initialized']

[[axioms]]
id = "cpp20_bidirectional_decrementable_domain_f9a0b1c2"
content = '''A bidirectional iterator r is decrementable if and only if there exists some q such that ++q == r. Decrementable iterators r shall be in the domain of --r and r--.'''
formal_spec = '''models_bidirectional_iterator(I) && decrementable(r) => in_domain(--r) && in_domain(r--)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.concept.bidir"
source_module = "[iterator.concept.bidir]/2"
tags = ['iterator', 'bidirectional_iterator', 'decrement', 'domain']

[[axioms]]
id = "cpp20_dereferenceable_non_singular_d3e4f5a6"
content = '''Dereferenceable iterator values are always non-singular.'''
formal_spec = '''dereferenceable(iter) => !singular(iter)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "iterator.requirements.general"
source_module = "[iterator.requirements.general]/7"
tags = ['iterator', 'dereferenceable', 'singular']

[[axioms]]
id = "cpp20_iterator_operations_advance_negative_bidirectional_only_8f3a2b1c"
content = '''Calling std::advance with a negative distance n requires the iterator to be a bidirectional iterator.'''
formal_spec = '''advance(i, n) && n < 0 && !bidirectional_iterator(decltype(i)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/2"
tags = ['iterator', 'precondition', 'advance', 'bidirectional']

[[axioms]]
id = "cpp20_iterator_operations_distance_reachability_precondition_c4d5e6f7"
content = '''Calling std::distance requires that last is reachable from first, or if InputIterator meets Cpp17RandomAccessIterator requirements, first is reachable from last.'''
formal_spec = '''distance(first, last) && !reachable(first, last) && !(random_access_iterator(decltype(first)) && reachable(last, first)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/4"
tags = ['iterator', 'precondition', 'distance', 'reachability']

[[axioms]]
id = "cpp20_iterator_operations_next_delegates_advance_a2b3c4d5"
content = '''std::next(x, n) is equivalent to calling advance(x, n) and returning x, inheriting all preconditions of advance.'''
formal_spec = '''next(x, n) => advance(x, n) && return(x)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "iterator.operations"
source_module = "[iterator.operations]/6"
tags = ['iterator', 'next', 'advance']

[[axioms]]
id = "cpp20_iterator_operations_prev_requires_bidirectional_e5f6a7b8"
content = '''std::prev requires a BidirectionalIterator because it calls advance(x, -n), which requires bidirectional capability for negative distances.'''
formal_spec = '''prev(x, n) && n > 0 && !bidirectional_iterator(decltype(x)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "iterator.operations"
source_module = "[iterator.operations]/7"
tags = ['iterator', 'precondition', 'prev', 'bidirectional']

[[axioms]]
id = "cpp20_iterator_operations_advance_valid_range_d1e2f3a4"
content = '''Calling std::advance(i, n) requires that incrementing i by n (or decrementing by -n if negative) does not move past the valid range of the underlying sequence.'''
formal_spec = '''advance(i, n) && ((n >= 0 && !can_increment_n_times(i, n)) || (n < 0 && !can_decrement_n_times(i, -n))) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "iterator.operations"
source_module = "[iterator.operations]/3"
tags = ['iterator', 'precondition', 'advance', 'range']

[[axioms]]
id = "cpp20_algorithms_requirements_no_data_race_modification_a3b4c5d6"
content = '''Algorithms shall not modify objects referenced through an iterator argument unless the specification requires such modification, for purposes of determining data races.'''
formal_spec = '''algorithm_modifies(obj, iter_arg) && !specification_requires_modification(algorithm, iter_arg) => data_race_undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/3"
tags = ['concurrency', 'data-race', 'iterator', 'algorithm']

[[axioms]]
id = "cpp20_algorithms_requirements_mutable_iterator_required_e5f6a7b8"
content = '''If an algorithm's Effects element specifies that a value pointed to by any iterator passed as an argument is modified, then the type of that argument shall meet the requirements of a mutable iterator.'''
formal_spec = '''algorithm_effects_modifies_via_iterator(algorithm, iter_arg) => mutable_iterator(type_of(iter_arg))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.1"
tags = ['iterator', 'mutable', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_inputiterator_param_c7d8e9f0"
content = '''If an algorithm's template parameter is named InputIterator, InputIterator1, or InputIterator2, the template argument shall meet the Cpp17InputIterator requirements.'''
formal_spec = '''template_param_name(param) in {"InputIterator", "InputIterator1", "InputIterator2"} => meets_cpp17_input_iterator_requirements(template_arg(param))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.2"
tags = ['iterator', 'input-iterator', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_outputiterator_param_d9e0f1a2"
content = '''If an algorithm's template parameter is named OutputIterator, OutputIterator1, or OutputIterator2, the template argument shall meet the Cpp17OutputIterator requirements.'''
formal_spec = '''template_param_name(param) in {"OutputIterator", "OutputIterator1", "OutputIterator2"} => meets_cpp17_output_iterator_requirements(template_arg(param))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.3"
tags = ['iterator', 'output-iterator', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_forwarditerator_mutable_b3c4d5e6"
content = '''If an algorithm's template parameter is named ForwardIterator, ForwardIterator1, ForwardIterator2, or NoThrowForwardIterator, the template argument shall meet the Cpp17ForwardIterator requirements if it is required to be a mutable iterator, or model forward_iterator otherwise.'''
formal_spec = '''template_param_name(param) in {"ForwardIterator", "ForwardIterator1", "ForwardIterator2", "NoThrowForwardIterator"} => (requires_mutable(param) ? meets_cpp17_forward_iterator_requirements(template_arg(param)) : models_forward_iterator(template_arg(param)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.4"
tags = ['iterator', 'forward-iterator', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_nothrow_forwarditerator_f7a8b9c0"
content = '''If an algorithm's template parameter is named NoThrowForwardIterator, the template argument is required to have the property that no exceptions are thrown from increment, assignment, or comparison of, or indirection through, valid iterators.'''
formal_spec = '''template_param_name(param) == "NoThrowForwardIterator" && valid_iterator(iter) => !throws_on_increment(iter) && !throws_on_assignment(iter) && !throws_on_comparison(iter) && !throws_on_indirection(iter)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.5"
tags = ['iterator', 'forward-iterator', 'nothrow', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_bidirectionaliterator_param_a1b2c3d4"
content = '''If an algorithm's template parameter is named BidirectionalIterator, BidirectionalIterator1, or BidirectionalIterator2, the template argument shall meet the Cpp17BidirectionalIterator requirements if it is required to be a mutable iterator, or model bidirectional_iterator otherwise.'''
formal_spec = '''template_param_name(param) in {"BidirectionalIterator", "BidirectionalIterator1", "BidirectionalIterator2"} => (requires_mutable(param) ? meets_cpp17_bidirectional_iterator_requirements(template_arg(param)) : models_bidirectional_iterator(template_arg(param)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.6"
tags = ['iterator', 'bidirectional-iterator', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_randomaccessiterator_param_e5f6a7b8"
content = '''If an algorithm's template parameter is named RandomAccessIterator, RandomAccessIterator1, or RandomAccessIterator2, the template argument shall meet the Cpp17RandomAccessIterator requirements if it is required to be a mutable iterator, or model random_access_iterator otherwise.'''
formal_spec = '''template_param_name(param) in {"RandomAccessIterator", "RandomAccessIterator1", "RandomAccessIterator2"} => (requires_mutable(param) ? meets_cpp17_random_access_iterator_requirements(template_arg(param)) : models_random_access_iterator(template_arg(param)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/4.7"
tags = ['iterator', 'random-access-iterator', 'algorithm', 'constraint']

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_wellformed_c9d0e1f2"
content = '''When an algorithm takes Predicate pred as its argument and first as its iterator argument with value type T, the expression pred(*first) shall be well-formed and the type decltype(pred(*first)) shall model boolean-testable.'''
formal_spec = '''algorithm_takes_predicate(algorithm, pred, first) && value_type(first) == T => well_formed(pred(*first)) && models_boolean_testable(decltype(pred(*first)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = ['predicate', 'algorithm', 'constraint', 'boolean-testable']

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_no_nonconstant_a3b4c5d6"
content = '''The function object pred shall not apply any non-constant function through its argument.'''
formal_spec = '''is_predicate(pred) => !applies_nonconstant_function_through_argument(pred)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = ['predicate', 'algorithm', 'constraint', 'const-correctness']

[[axioms]]
id = "cpp20_algorithms_requirements_predicate_glvalue_equivalent_e7f8a9b0"
content = '''Given a glvalue u of type (possibly const) T that designates the same object as *first, pred(u) shall be a valid expression that is equal to pred(*first).'''
formal_spec = '''is_predicate(pred) && is_glvalue(u) && (type_of(u) == T || type_of(u) == const T) && designates_same_object(u, *first) => valid_expression(pred(u)) && equal(pred(u), pred(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/6"
tags = ['predicate', 'algorithm', 'constraint', 'equivalence']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_wellformed_c1d2e3f4"
content = '''If an algorithm takes BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments with respective value types T1 and T2, the expression binary_pred(*first1, *first2) shall be well-formed and the type decltype(binary_pred(*first1, *first2)) shall model boolean-testable.'''
formal_spec = '''algorithm_takes_binary_predicate(algorithm, binary_pred, first1, first2) && value_type(first1) == T1 && value_type(first2) == T2 => well_formed(binary_pred(*first1, *first2)) && models_boolean_testable(decltype(binary_pred(*first1, *first2)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'algorithm', 'constraint', 'boolean-testable']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_value_wellformed_a5b6c7d8"
content = '''When T value is part of the signature, the expression binary_pred(*first1, value) shall be well-formed and the type decltype(binary_pred(*first1, value)) shall model boolean-testable.'''
formal_spec = '''algorithm_takes_binary_predicate(algorithm, binary_pred, first1) && has_value_param(algorithm, value, T) => well_formed(binary_pred(*first1, value)) && models_boolean_testable(decltype(binary_pred(*first1, value)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'algorithm', 'constraint', 'boolean-testable']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_no_nonconstant_e9f0a1b2"
content = '''binary_pred shall not apply any non-constant function through any of its arguments.'''
formal_spec = '''is_binary_predicate(binary_pred) => !applies_nonconstant_function_through_arguments(binary_pred)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'algorithm', 'constraint', 'const-correctness']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_glvalue_equivalent_c3d4e5f6"
content = '''Given glvalues u and v of types (possibly const) T1 and T2 that designate the same objects as *first1 and *first2 respectively, binary_pred(u, *first2), binary_pred(*first1, v), and binary_pred(u, v) shall each be valid expressions equal to binary_pred(*first1, *first2).'''
formal_spec = '''is_binary_predicate(binary_pred) && is_glvalue(u) && is_glvalue(v) && designates_same_object(u, *first1) && designates_same_object(v, *first2) => valid_expression(binary_pred(u, *first2)) && valid_expression(binary_pred(*first1, v)) && valid_expression(binary_pred(u, v)) && equal(binary_pred(u, *first2), binary_pred(*first1, *first2)) && equal(binary_pred(*first1, v), binary_pred(*first1, *first2)) && equal(binary_pred(u, v), binary_pred(*first1, *first2))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'algorithm', 'constraint', 'equivalence']

[[axioms]]
id = "cpp20_algorithms_requirements_binarypredicate_value_glvalue_equivalent_a7b8c9d0"
content = '''Given a glvalue u of type (possibly const) T1 that designates the same object as *first1, binary_pred(u, value) shall be a valid expression that is equal to binary_pred(*first1, value).'''
formal_spec = '''is_binary_predicate(binary_pred) && is_glvalue(u) && designates_same_object(u, *first1) && has_value_param(algorithm, value, T) => valid_expression(binary_pred(u, value)) && equal(binary_pred(u, value), binary_pred(*first1, value))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/7"
tags = ['binary-predicate', 'algorithm', 'constraint', 'equivalence']

[[axioms]]
id = "cpp20_algorithms_requirements_condition_boolean_context_e1f2a3b4"
content = '''When the description of an algorithm gives an expression such as *first == value for a condition, the expression shall evaluate to either true or false in boolean contexts.'''
formal_spec = '''algorithm_condition_expression(algorithm, expr) => evaluates_to_true_or_false_in_boolean_context(expr)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/10"
tags = ['algorithm', 'boolean', 'constraint', 'condition']

[[axioms]]
id = "cpp20_algorithms_requirements_explicit_template_args_unspecified_c5d6e7f8"
content = '''The well-formedness and behavior of a call to an algorithm with an explicitly-specified template argument list is unspecified, except where explicitly stated otherwise.'''
formal_spec = '''algorithm_call_with_explicit_template_args(algorithm, template_args) && !explicitly_specified_behavior(algorithm, template_args) => unspecified_wellformedness_and_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "algorithms.requirements"
source_module = "[algorithms.requirements]/15"
tags = ['algorithm', 'template', 'unspecified', 'constraint']

[[axioms]]
id = "cpp20_alg_sorting_general_strict_weak_order_3a8f2c1d"
content = '''For algorithms other than binary search, the comparator comp shall induce a strict weak ordering on the values.'''
formal_spec = '''algorithm(comp) && !binary_search_algorithm => strict_weak_ordering(comp)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.sorting.general"
source_module = "[alg.sorting.general]/3"
tags = ['sorting', 'comparator', 'strict-weak-ordering', 'constraint']

[[axioms]]
id = "cpp20_alg_sorting_general_irreflexive_e7b3d4a2"
content = '''A strict weak ordering comparator must be irreflexive: !comp(x, x) for all x.'''
formal_spec = '''strict_weak_ordering(comp) => forall x: !comp(x, x)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.sorting.general"
source_module = "[alg.sorting.general]/4"
tags = ['sorting', 'comparator', 'strict-weak-ordering', 'irreflexive']

[[axioms]]
id = "cpp20_alg_sorting_general_transitivity_comp_f1c8e5b3"
content = '''A strict weak ordering comparator must be transitive: comp(a, b) && comp(b, c) implies comp(a, c).'''
formal_spec = '''strict_weak_ordering(comp) => forall a, b, c: (comp(a, b) && comp(b, c)) => comp(a, c)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.sorting.general"
source_module = "[alg.sorting.general]/4.1"
tags = ['sorting', 'comparator', 'strict-weak-ordering', 'transitivity']

[[axioms]]
id = "cpp20_alg_sorting_general_transitivity_equiv_c9d2f6a4"
content = '''The equivalence relation induced by a strict weak ordering must be transitive: equiv(a, b) && equiv(b, c) implies equiv(a, c), where equiv(a, b) is !comp(a, b) && !comp(b, a).'''
formal_spec = '''strict_weak_ordering(comp) && equiv(a, b) := (!comp(a, b) && !comp(b, a)) => forall a, b, c: (equiv(a, b) && equiv(b, c)) => equiv(a, c)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.sorting.general"
source_module = "[alg.sorting.general]/4.2"
tags = ['sorting', 'comparator', 'strict-weak-ordering', 'equivalence', 'transitivity']

[[axioms]]
id = "cpp20_sort_precondition_valueswappable_a2b4c6d8"
content = '''For std::sort overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::sort(first, last, ...) => Cpp17ValueSwappable(RandomAccessIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sort"
source_module = "[sort]/2"
tags = ['sorting', 'sort', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_sort_precondition_moveconstructible_b3c5d7e9"
content = '''For std::sort overloads, the type of *first must meet Cpp17MoveConstructible requirements.'''
formal_spec = '''std::sort(first, last, ...) => Cpp17MoveConstructible(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sort"
source_module = "[sort]/2"
tags = ['sorting', 'sort', 'precondition', 'moveconstructible']

[[axioms]]
id = "cpp20_sort_precondition_moveassignable_c4d6e8f0"
content = '''For std::sort overloads, the type of *first must meet Cpp17MoveAssignable requirements.'''
formal_spec = '''std::sort(first, last, ...) => Cpp17MoveAssignable(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "sort"
source_module = "[sort]/2"
tags = ['sorting', 'sort', 'precondition', 'moveassignable']

[[axioms]]
id = "cpp20_stable_sort_precondition_valueswappable_d5e7f9a1"
content = '''For std::stable_sort overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::stable_sort(first, last, ...) => Cpp17ValueSwappable(RandomAccessIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stable.sort"
source_module = "[stable.sort]/2"
tags = ['sorting', 'stable_sort', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_stable_sort_precondition_moveconstructible_e6f8a0b2"
content = '''For std::stable_sort overloads, the type of *first must meet Cpp17MoveConstructible requirements.'''
formal_spec = '''std::stable_sort(first, last, ...) => Cpp17MoveConstructible(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stable.sort"
source_module = "[stable.sort]/2"
tags = ['sorting', 'stable_sort', 'precondition', 'moveconstructible']

[[axioms]]
id = "cpp20_stable_sort_precondition_moveassignable_f7a9b1c3"
content = '''For std::stable_sort overloads, the type of *first must meet Cpp17MoveAssignable requirements.'''
formal_spec = '''std::stable_sort(first, last, ...) => Cpp17MoveAssignable(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "stable.sort"
source_module = "[stable.sort]/2"
tags = ['sorting', 'stable_sort', 'precondition', 'moveassignable']

[[axioms]]
id = "cpp20_partial_sort_precondition_valid_ranges_a8b0c2d4"
content = '''For partial_sort, [first, middle) and [middle, last) must be valid ranges.'''
formal_spec = '''partial_sort(first, middle, last, ...) => valid_range(first, middle) && valid_range(middle, last)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort"
source_module = "[partial.sort]/2"
tags = ['sorting', 'partial_sort', 'precondition', 'valid-range']

[[axioms]]
id = "cpp20_partial_sort_precondition_valueswappable_b9c1d3e5"
content = '''For std::partial_sort overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::partial_sort(first, middle, last, ...) => Cpp17ValueSwappable(RandomAccessIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort"
source_module = "[partial.sort]/2"
tags = ['sorting', 'partial_sort', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_partial_sort_precondition_moveconstructible_c0d2e4f6"
content = '''For std::partial_sort overloads, the type of *first must meet Cpp17MoveConstructible requirements.'''
formal_spec = '''std::partial_sort(first, middle, last, ...) => Cpp17MoveConstructible(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort"
source_module = "[partial.sort]/2"
tags = ['sorting', 'partial_sort', 'precondition', 'moveconstructible']

[[axioms]]
id = "cpp20_partial_sort_precondition_moveassignable_d1e3f5a7"
content = '''For std::partial_sort overloads, the type of *first must meet Cpp17MoveAssignable requirements.'''
formal_spec = '''std::partial_sort(first, middle, last, ...) => Cpp17MoveAssignable(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort"
source_module = "[partial.sort]/2"
tags = ['sorting', 'partial_sort', 'precondition', 'moveassignable']

[[axioms]]
id = "cpp20_partial_sort_copy_precondition_valueswappable_e2f4a6b8"
content = '''For std::partial_sort_copy overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::partial_sort_copy(..., result_first, result_last, ...) => Cpp17ValueSwappable(RandomAccessIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort.copy"
source_module = "[partial.sort.copy]/3"
tags = ['sorting', 'partial_sort_copy', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_partial_sort_copy_precondition_moveconstructible_f3a5b7c9"
content = '''For std::partial_sort_copy overloads, the type of *result_first must meet Cpp17MoveConstructible requirements.'''
formal_spec = '''std::partial_sort_copy(..., result_first, result_last, ...) => Cpp17MoveConstructible(decltype(*result_first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort.copy"
source_module = "[partial.sort.copy]/3"
tags = ['sorting', 'partial_sort_copy', 'precondition', 'moveconstructible']

[[axioms]]
id = "cpp20_partial_sort_copy_precondition_moveassignable_a4b6c8d0"
content = '''For std::partial_sort_copy overloads, the type of *result_first must meet Cpp17MoveAssignable requirements.'''
formal_spec = '''std::partial_sort_copy(..., result_first, result_last, ...) => Cpp17MoveAssignable(decltype(*result_first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "partial.sort.copy"
source_module = "[partial.sort.copy]/3"
tags = ['sorting', 'partial_sort_copy', 'precondition', 'moveassignable']

[[axioms]]
id = "cpp20_partial_sort_copy_precondition_projection_stable_b5c7d9e1"
content = '''For partial_sort_copy, after copying an element from input to output range, the comparison result using projections must remain stable.'''
formal_spec = '''partial_sort_copy(first, last, result_first, result_last, comp, proj1, proj2) && (*y2 = *b1) && E := bool(invoke(comp, invoke(proj1, *a1), invoke(proj2, *y2))) && (*x2 = *a1) => E == bool(invoke(comp, invoke(proj2, *x2), invoke(proj2, *y2)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "partial.sort.copy"
source_module = "[partial.sort.copy]/4"
tags = ['sorting', 'partial_sort_copy', 'precondition', 'projection', 'stability']

[[axioms]]
id = "cpp20_nth_element_precondition_valid_ranges_c6d8e0f2"
content = '''For nth_element, [first, nth) and [nth, last) must be valid ranges.'''
formal_spec = '''nth_element(first, nth, last, ...) => valid_range(first, nth) && valid_range(nth, last)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.nth.element"
source_module = "[alg.nth.element]/2"
tags = ['sorting', 'nth_element', 'precondition', 'valid-range']

[[axioms]]
id = "cpp20_nth_element_precondition_valueswappable_d7e9f1a3"
content = '''For std::nth_element overloads, RandomAccessIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::nth_element(first, nth, last, ...) => Cpp17ValueSwappable(RandomAccessIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.nth.element"
source_module = "[alg.nth.element]/2"
tags = ['sorting', 'nth_element', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_nth_element_precondition_moveconstructible_e8f0a2b4"
content = '''For std::nth_element overloads, the type of *first must meet Cpp17MoveConstructible requirements.'''
formal_spec = '''std::nth_element(first, nth, last, ...) => Cpp17MoveConstructible(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.nth.element"
source_module = "[alg.nth.element]/2"
tags = ['sorting', 'nth_element', 'precondition', 'moveconstructible']

[[axioms]]
id = "cpp20_nth_element_precondition_moveassignable_f9a1b3c5"
content = '''For std::nth_element overloads, the type of *first must meet Cpp17MoveAssignable requirements.'''
formal_spec = '''std::nth_element(first, nth, last, ...) => Cpp17MoveAssignable(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.nth.element"
source_module = "[alg.nth.element]/2"
tags = ['sorting', 'nth_element', 'precondition', 'moveassignable']

[[axioms]]
id = "cpp20_lower_bound_precondition_partitioned_a0b2c4d6"
content = '''For lower_bound, the elements e of [first, last) must be partitioned with respect to the expression bool(invoke(comp, invoke(proj, e), value)).'''
formal_spec = '''lower_bound(first, last, value, comp, proj) => partitioned(first, last, [e] => bool(invoke(comp, invoke(proj, e), value)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "lower.bound"
source_module = "[lower.bound]/2"
tags = ['binary-search', 'lower_bound', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_upper_bound_precondition_partitioned_b1c3d5e7"
content = '''For upper_bound, the elements e of [first, last) must be partitioned with respect to the expression !bool(invoke(comp, value, invoke(proj, e))).'''
formal_spec = '''upper_bound(first, last, value, comp, proj) => partitioned(first, last, [e] => !bool(invoke(comp, value, invoke(proj, e))))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "upper.bound"
source_module = "[upper.bound]/2"
tags = ['binary-search', 'upper_bound', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_equal_range_precondition_partitioned_less_c2d4e6f8"
content = '''For equal_range, the elements e of [first, last) must be partitioned with respect to the expression bool(invoke(comp, invoke(proj, e), value)).'''
formal_spec = '''equal_range(first, last, value, comp, proj) => partitioned(first, last, [e] => bool(invoke(comp, invoke(proj, e), value)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "equal.range"
source_module = "[equal.range]/2"
tags = ['binary-search', 'equal_range', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_equal_range_precondition_partitioned_greater_d3e5f7a9"
content = '''For equal_range, the elements e of [first, last) must be partitioned with respect to the expression !bool(invoke(comp, value, invoke(proj, e))).'''
formal_spec = '''equal_range(first, last, value, comp, proj) => partitioned(first, last, [e] => !bool(invoke(comp, value, invoke(proj, e))))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "equal.range"
source_module = "[equal.range]/2"
tags = ['binary-search', 'equal_range', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_equal_range_precondition_antisymmetry_e4f6a8b0"
content = '''For equal_range in namespace std, for all elements e of [first, last), bool(comp(e, value)) implies !bool(comp(value, e)).'''
formal_spec = '''std::equal_range(first, last, value, comp) => forall e in [first, last): bool(comp(e, value)) => !bool(comp(value, e))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "equal.range"
source_module = "[equal.range]/2"
tags = ['binary-search', 'equal_range', 'precondition', 'antisymmetry']

[[axioms]]
id = "cpp20_binary_search_precondition_partitioned_less_f5a7b9c1"
content = '''For binary_search, the elements e of [first, last) must be partitioned with respect to the expression bool(invoke(comp, invoke(proj, e), value)).'''
formal_spec = '''binary_search(first, last, value, comp, proj) => partitioned(first, last, [e] => bool(invoke(comp, invoke(proj, e), value)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "binary.search"
source_module = "[binary.search]/2"
tags = ['binary-search', 'binary_search', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_binary_search_precondition_partitioned_greater_a6b8c0d2"
content = '''For binary_search, the elements e of [first, last) must be partitioned with respect to the expression !bool(invoke(comp, value, invoke(proj, e))).'''
formal_spec = '''binary_search(first, last, value, comp, proj) => partitioned(first, last, [e] => !bool(invoke(comp, value, invoke(proj, e))))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "binary.search"
source_module = "[binary.search]/2"
tags = ['binary-search', 'binary_search', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_binary_search_precondition_antisymmetry_b7c9d1e3"
content = '''For binary_search in namespace std, for all elements e of [first, last), bool(comp(e, value)) implies !bool(comp(value, e)).'''
formal_spec = '''std::binary_search(first, last, value, comp) => forall e in [first, last): bool(comp(e, value)) => !bool(comp(value, e))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "binary.search"
source_module = "[binary.search]/2"
tags = ['binary-search', 'binary_search', 'precondition', 'antisymmetry']

[[axioms]]
id = "cpp20_partition_precondition_valueswappable_c8d0e2f4"
content = '''For std::partition overloads, ForwardIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::partition(first, last, pred) => Cpp17ValueSwappable(ForwardIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.partitions"
source_module = "[alg.partitions]/5"
tags = ['partitions', 'partition', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_stable_partition_precondition_valueswappable_d9e1f3a5"
content = '''For std::stable_partition overloads, BidirectionalIterator must meet Cpp17ValueSwappable requirements.'''
formal_spec = '''std::stable_partition(first, last, pred) => Cpp17ValueSwappable(BidirectionalIterator)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.partitions"
source_module = "[alg.partitions]/10"
tags = ['partitions', 'stable_partition', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_stable_partition_precondition_moveconstructible_e0f2a4b6"
content = '''For std::stable_partition overloads, the type of *first must meet Cpp17MoveConstructible requirements.'''
formal_spec = '''std::stable_partition(first, last, pred) => Cpp17MoveConstructible(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.partitions"
source_module = "[alg.partitions]/10"
tags = ['partitions', 'stable_partition', 'precondition', 'moveconstructible']

[[axioms]]
id = "cpp20_stable_partition_precondition_moveassignable_f1a3b5c7"
content = '''For std::stable_partition overloads, the type of *first must meet Cpp17MoveAssignable requirements.'''
formal_spec = '''std::stable_partition(first, last, pred) => Cpp17MoveAssignable(decltype(*first))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.partitions"
source_module = "[alg.partitions]/10"
tags = ['partitions', 'stable_partition', 'precondition', 'moveassignable']

[[axioms]]
id = "cpp20_partition_copy_precondition_no_overlap_a2b4c6d8"
content = '''For partition_copy, the input range and output ranges must not overlap.'''
formal_spec = '''partition_copy(first, last, out_true, out_false, pred, ...) => !overlaps([first, last), [out_true, ...)) && !overlaps([first, last), [out_false, ...))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.partitions"
source_module = "[alg.partitions]/19"
tags = ['partitions', 'partition_copy', 'precondition', 'no-overlap']

[[axioms]]
id = "cpp20_partition_point_precondition_partitioned_b3c5d7e9"
content = '''For partition_point, the elements e of [first, last) must be partitioned with respect to bool(invoke(pred, invoke(proj, e))).'''
formal_spec = '''partition_point(first, last, pred, proj) => partitioned(first, last, [e] => bool(invoke(pred, invoke(proj, e))))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "alg.partitions"
source_module = "[alg.partitions]/24"
tags = ['partitions', 'partition_point', 'precondition', 'partitioned']

[[axioms]]
id = "cpp20_string_view_cons_nullptr_ctor_valid_range_a1b2c3d4"
content = '''The range [str, str + traits::length(str)) must be a valid range when constructing basic_string_view from const charT*.'''
formal_spec = '''basic_string_view(str) where str: const charT* => requires(valid_range(str, str + traits::length(str)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.cons"
source_module = "[string.view.cons]/2"
tags = ['string_view', 'constructor', 'precondition', 'range']

[[axioms]]
id = "cpp20_string_view_cons_ptr_len_valid_range_e5f6g7h8"
content = '''The range [str, str + len) must be a valid range when constructing basic_string_view from const charT* and size_type.'''
formal_spec = '''basic_string_view(str, len) where str: const charT*, len: size_type => requires(valid_range(str, str + len))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.cons"
source_module = "[string.view.cons]/5"
tags = ['string_view', 'constructor', 'precondition', 'range']

[[axioms]]
id = "cpp20_string_view_cons_iter_valid_range_i9j0k1l2"
content = '''The range [begin, end) must be a valid range when constructing basic_string_view from iterator pair.'''
formal_spec = '''basic_string_view(begin, end) where It: contiguous_iterator, End: sized_sentinel_for<It> => requires(valid_range(begin, end))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.cons"
source_module = "[string.view.cons]/8"
tags = ['string_view', 'constructor', 'precondition', 'range', 'iterator']

[[axioms]]
id = "cpp20_string_view_cons_iter_models_contiguous_m3n4o5p6"
content = '''Iterator It must model contiguous_iterator when constructing basic_string_view from iterator pair.'''
formal_spec = '''basic_string_view(begin, end) => requires(models_contiguous_iterator(It))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.cons"
source_module = "[string.view.cons]/8.2"
tags = ['string_view', 'constructor', 'precondition', 'iterator', 'concept']

[[axioms]]
id = "cpp20_string_view_cons_iter_models_sized_sentinel_q7r8s9t0"
content = '''End must model sized_sentinel_for<It> when constructing basic_string_view from iterator pair.'''
formal_spec = '''basic_string_view(begin, end) => requires(models_sized_sentinel_for(End, It))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.cons"
source_module = "[string.view.cons]/8.3"
tags = ['string_view', 'constructor', 'precondition', 'iterator', 'concept']

[[axioms]]
id = "cpp20_string_view_subscript_hardened_precond_u1v2w3x4"
content = '''Accessing basic_string_view via operator[] requires pos < size() to be true (hardened precondition).'''
formal_spec = '''string_view[pos] => requires(pos < size())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.access"
source_module = "[string.view.access]/1"
tags = ['string_view', 'element_access', 'hardened_precondition', 'bounds_check']

[[axioms]]
id = "cpp20_string_view_front_hardened_precond_y5z6a7b8"
content = '''Calling front() on basic_string_view requires empty() to be false (hardened precondition).'''
formal_spec = '''string_view.front() => requires(!empty())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.access"
source_module = "[string.view.access]/6"
tags = ['string_view', 'element_access', 'hardened_precondition', 'empty_check']

[[axioms]]
id = "cpp20_string_view_back_hardened_precond_c9d0e1f2"
content = '''Calling back() on basic_string_view requires empty() to be false (hardened precondition).'''
formal_spec = '''string_view.back() => requires(!empty())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.access"
source_module = "[string.view.access]/9"
tags = ['string_view', 'element_access', 'hardened_precondition', 'empty_check']

[[axioms]]
id = "cpp20_string_view_remove_prefix_hardened_precond_g3h4i5j6"
content = '''Calling remove_prefix(n) on basic_string_view requires n <= size() to be true (hardened precondition).'''
formal_spec = '''string_view.remove_prefix(n) => requires(n <= size())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.modifiers"
source_module = "[string.view.modifiers]/1"
tags = ['string_view', 'modifier', 'hardened_precondition', 'bounds_check']

[[axioms]]
id = "cpp20_string_view_remove_suffix_hardened_precond_k7l8m9n0"
content = '''Calling remove_suffix(n) on basic_string_view requires n <= size() to be true (hardened precondition).'''
formal_spec = '''string_view.remove_suffix(n) => requires(n <= size())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.modifiers"
source_module = "[string.view.modifiers]/3"
tags = ['string_view', 'modifier', 'hardened_precondition', 'bounds_check']

[[axioms]]
id = "cpp20_string_view_copy_valid_range_o1p2q3r4"
content = '''The range [s, s + rlen) must be a valid range when calling copy(), where rlen is min(n, size() - pos).'''
formal_spec = '''string_view.copy(s, n, pos) => requires(valid_range(s, s + min(n, size() - pos)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.ops"
source_module = "[string.view.ops]/2"
tags = ['string_view', 'copy', 'precondition', 'range']

[[axioms]]
id = "cpp20_string_view_copy_throws_out_of_range_s5t6u7v8"
content = '''The copy() member function throws out_of_range if pos > size().'''
formal_spec = '''string_view.copy(s, n, pos) && pos > size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.ops"
source_module = "[string.view.ops]/5"
tags = ['string_view', 'copy', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_view_substr_throws_out_of_range_w9x0y1z2"
content = '''The substr() and subview() member functions throw out_of_range if pos > size().'''
formal_spec = '''(string_view.substr(pos, n) || string_view.subview(pos, n)) && pos > size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.ops"
source_module = "[string.view.ops]/10"
tags = ['string_view', 'substr', 'subview', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_view_at_throws_out_of_range_a3b4c5d6"
content = '''The at() member function throws out_of_range if pos >= size().'''
formal_spec = '''string_view.at(pos) && pos >= size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.access"
source_module = "[string.view.access]/5"
tags = ['string_view', 'element_access', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_view_invalidation_rule_e7f8g9h0"
content = '''Any operation that invalidates a pointer in the range [str.data(), str.data() + str.size()) invalidates pointers, iterators, and references to elements of str.'''
formal_spec = '''invalidates_pointer_in_range(op, str.data(), str.data() + str.size()) => invalidates(pointers, iterators, references, str)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.template.general"
source_module = "[string.view.template.general]/2"
tags = ['string_view', 'invalidation', 'iterator', 'pointer', 'reference']

[[axioms]]
id = "cpp20_string_view_traits_requirement_i1j2k3l4"
content = '''In every specialization basic_string_view<charT, traits>, the type traits shall meet the character traits requirements.'''
formal_spec = '''basic_string_view<charT, traits> => requires(meets_character_traits_requirements(traits))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.template.general"
source_module = "[string.view.template.general]/1"
tags = ['string_view', 'traits', 'constraint', 'template']

[[axioms]]
id = "cpp20_string_view_nullptr_ctor_deleted_m5n6o7p8"
content = '''Construction of basic_string_view from nullptr_t is explicitly deleted.'''
formal_spec = '''basic_string_view(nullptr_t) => deleted'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.template.general"
source_module = "[string.view.template.general]"
tags = ['string_view', 'constructor', 'deleted', 'nullptr']

[[axioms]]
id = "cpp20_string_view_data_not_null_terminated_q9r0s1t2"
content = '''The data() member function may return a pointer to a buffer that is not null-terminated, unlike basic_string::data() and string literals. Passing data() to a function expecting a null-terminated string is typically a mistake.'''
formal_spec = '''string_view.data() => NOT guarantees(null_terminated(result))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "string.view.access"
source_module = "[string.view.access]/13"
tags = ['string_view', 'data', 'null_termination', 'warning']

[[axioms]]
id = "cpp20_string_view_comparison_category_mandates_u3v4w5x6"
content = '''For operator<=>, if traits::comparison_category is valid, it must denote a comparison category type; otherwise weak_ordering is used.'''
formal_spec = '''operator<=>(lhs, rhs) => mandates(is_comparison_category_type(R)) where R = traits::comparison_category if valid else weak_ordering'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.view.comparison"
source_module = "[string.view.comparison]/3"
tags = ['string_view', 'comparison', 'mandates', 'spaceship_operator']

[[axioms]]
id = "cpp20_string_require_size_exceeds_max_size_a3b7c8d2"
content = '''If any operation would cause size() to exceed max_size(), that operation throws an exception object of type length_error.'''
formal_spec = '''operation_causes(size() > max_size()) => throws(length_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.require"
source_module = "[string.require]/1"
tags = ['string', 'capacity', 'exception', 'length_error']

[[axioms]]
id = "cpp20_string_require_exception_no_effect_f4e2a1b9"
content = '''If any member function or operator of basic_string throws an exception, that function or operator has no other effect on the basic_string object (strong exception guarantee).'''
formal_spec = '''member_function_throws(basic_string, exception) => state(basic_string) == state_before_call(basic_string)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.require"
source_module = "[string.require]/2"
tags = ['string', 'exception', 'strong_guarantee']

[[axioms]]
id = "cpp20_string_require_traits_char_traits_c8d5e3f1"
content = '''In every specialization basic_string<charT, traits, Allocator>, the type traits shall meet the character traits requirements.'''
formal_spec = '''basic_string<charT, traits, Allocator> => meets_char_traits_requirements(traits)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.require"
source_module = "[string.require]/3"
tags = ['string', 'traits', 'constraint']

[[axioms]]
id = "cpp20_string_require_allocator_value_type_match_b2c4d6e8"
content = '''The program is ill-formed if Allocator::value_type is not the same type as charT.'''
formal_spec = '''basic_string<charT, traits, Allocator> && Allocator::value_type != charT => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.require"
source_module = "[string.require]/3"
tags = ['string', 'allocator', 'constraint', 'ill_formed']

[[axioms]]
id = "cpp20_string_require_traits_char_type_match_d9e1f3a5"
content = '''The program is ill-formed if traits::char_type is not the same type as charT.'''
formal_spec = '''basic_string<charT, traits, Allocator> && traits::char_type != charT => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.require"
source_module = "[string.require]/3"
tags = ['string', 'traits', 'constraint', 'ill_formed']

[[axioms]]
id = "cpp20_string_require_invalidation_nonconst_ref_e7f8a2b4"
content = '''References, pointers, and iterators referring to elements of a basic_string may be invalidated by passing the string as an argument to any standard library function taking a reference to non-const basic_string.'''
formal_spec = '''pass_to_function(basic_string&, non_const) => may_invalidate(references, pointers, iterators)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "string.require"
source_module = "[string.require]/4.1"
tags = ['string', 'iterator_invalidation', 'reference_invalidation']

[[axioms]]
id = "cpp20_string_require_invalidation_nonconst_member_c3d5e7f9"
content = '''References, pointers, and iterators referring to elements of a basic_string may be invalidated by calling non-const member functions, except operator[], at, data, front, back, begin, rbegin, end, and rend.'''
formal_spec = '''call_nonconst_member(basic_string, func) && func not_in {operator[], at, data, front, back, begin, rbegin, end, rend} => may_invalidate(references, pointers, iterators)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "string.require"
source_module = "[string.require]/4.2"
tags = ['string', 'iterator_invalidation', 'reference_invalidation']

[[axioms]]
id = "cpp20_string_cons_pos_out_of_range_a1b2c3d4"
content = '''Constructing basic_string from another string with position pos throws out_of_range if pos > str.size().'''
formal_spec = '''basic_string(str, pos, ...) && pos > str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.cons"
source_module = "[string.cons]/6"
tags = ['string', 'constructor', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_cons_charptr_valid_range_e5f6a7b8"
content = '''Constructing basic_string from const charT* s with size n requires [s, s+n) to be a valid range.'''
formal_spec = '''basic_string(s, n, ...) => precondition(valid_range(s, s+n))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.cons"
source_module = "[string.cons]/13"
tags = ['string', 'constructor', 'precondition', 'valid_range']

[[axioms]]
id = "cpp20_string_access_operator_bounds_c9d0e1f2"
content = '''Accessing basic_string with operator[](pos) requires pos <= size() (hardened precondition).'''
formal_spec = '''str[pos] => hardened_precondition(pos <= str.size())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.access"
source_module = "[string.access]/1"
tags = ['string', 'element_access', 'precondition', 'bounds_check']

[[axioms]]
id = "cpp20_string_access_modify_null_terminator_ub_a3b4c5d6"
content = '''If pos == size(), operator[] returns a reference to charT() (null terminator), and modifying this object to any value other than charT() leads to undefined behavior.'''
formal_spec = '''str[pos] && pos == str.size() && modify(result, value) && value != charT() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.access"
source_module = "[string.access]/2"
tags = ['string', 'element_access', 'undefined_behavior', 'null_terminator']

[[axioms]]
id = "cpp20_string_access_at_out_of_range_e7f8a9b0"
content = '''basic_string::at(pos) throws out_of_range if pos >= size().'''
formal_spec = '''str.at(pos) && pos >= str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.access"
source_module = "[string.access]/6"
tags = ['string', 'element_access', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_access_front_nonempty_c1d2e3f4"
content = '''Calling basic_string::front() requires empty() is false (hardened precondition).'''
formal_spec = '''str.front() => hardened_precondition(!str.empty())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.access"
source_module = "[string.access]/7"
tags = ['string', 'element_access', 'precondition', 'nonempty']

[[axioms]]
id = "cpp20_string_access_back_nonempty_a5b6c7d8"
content = '''Calling basic_string::back() requires empty() is false (hardened precondition).'''
formal_spec = '''str.back() => hardened_precondition(!str.empty())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.access"
source_module = "[string.access]/9"
tags = ['string', 'element_access', 'precondition', 'nonempty']

[[axioms]]
id = "cpp20_string_append_valid_range_e9f0a1b2"
content = '''basic_string::append(s, n) requires [s, s+n) to be a valid range.'''
formal_spec = '''str.append(s, n) => precondition(valid_range(s, s+n))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.append"
source_module = "[string.append]/7"
tags = ['string', 'modifier', 'precondition', 'valid_range']

[[axioms]]
id = "cpp20_string_assign_valid_range_c3d4e5f6"
content = '''basic_string::assign(s, n) requires [s, s+n) to be a valid range.'''
formal_spec = '''str.assign(s, n) => precondition(valid_range(s, s+n))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.assign"
source_module = "[string.assign]/8"
tags = ['string', 'modifier', 'precondition', 'valid_range']

[[axioms]]
id = "cpp20_string_insert_valid_range_a7b8c9d0"
content = '''basic_string::insert(pos, s, n) requires [s, s+n) to be a valid range.'''
formal_spec = '''str.insert(pos, s, n) => precondition(valid_range(s, s+n))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/7"
tags = ['string', 'modifier', 'precondition', 'valid_range']

[[axioms]]
id = "cpp20_string_insert_pos_out_of_range_e1f2a3b4"
content = '''basic_string::insert(pos, s, n) throws out_of_range if pos > size().'''
formal_spec = '''str.insert(pos, s, n) && pos > str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/10.1"
tags = ['string', 'modifier', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_insert_length_error_c5d6e7f8"
content = '''basic_string::insert(pos, s, n) throws length_error if n > max_size() - size().'''
formal_spec = '''str.insert(pos, s, n) && n > str.max_size() - str.size() => throws(length_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/10.2"
tags = ['string', 'modifier', 'exception', 'length_error']

[[axioms]]
id = "cpp20_string_insert_iterator_valid_a9b0c1d2"
content = '''basic_string::insert(p, c) requires p is a valid iterator on *this.'''
formal_spec = '''str.insert(p, c) => precondition(valid_iterator(p, str))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/15"
tags = ['string', 'modifier', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_string_insert_iterator_n_valid_e3f4a5b6"
content = '''basic_string::insert(p, n, c) requires p is a valid iterator on *this.'''
formal_spec = '''str.insert(p, n, c) => precondition(valid_iterator(p, str))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/18"
tags = ['string', 'modifier', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_string_insert_iterator_range_valid_c7d8e9f0"
content = '''basic_string::insert(p, first, last) requires p is a valid iterator on *this.'''
formal_spec = '''str.insert(p, first, last) => precondition(valid_iterator(p, str))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/22"
tags = ['string', 'modifier', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_string_insert_range_valid_iterator_a1b2c3d4"
content = '''basic_string::insert_range(p, rg) requires p is a valid iterator on *this.'''
formal_spec = '''str.insert_range(p, rg) => precondition(valid_iterator(p, str))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.insert"
source_module = "[string.insert]/25"
tags = ['string', 'modifier', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_string_erase_pos_out_of_range_e5f6a7b8"
content = '''basic_string::erase(pos, n) throws out_of_range if pos > size().'''
formal_spec = '''str.erase(pos, n) && pos > str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.erase"
source_module = "[string.erase]/3"
tags = ['string', 'modifier', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_erase_iterator_dereferenceable_c9d0e1f2"
content = '''basic_string::erase(p) requires p is a valid dereferenceable iterator on *this.'''
formal_spec = '''str.erase(p) => precondition(valid_dereferenceable_iterator(p, str))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.erase"
source_module = "[string.erase]/4"
tags = ['string', 'modifier', 'precondition', 'iterator']

[[axioms]]
id = "cpp20_string_erase_range_valid_a3b4c5d6"
content = '''basic_string::erase(first, last) requires first and last are valid iterators on *this and [first, last) is a valid range.'''
formal_spec = '''str.erase(first, last) => precondition(valid_iterator(first, str) && valid_iterator(last, str) && valid_range(first, last))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.erase"
source_module = "[string.erase]/8"
tags = ['string', 'modifier', 'precondition', 'iterator', 'valid_range']

[[axioms]]
id = "cpp20_string_pop_back_nonempty_e7f8a9b0"
content = '''Calling basic_string::pop_back() requires empty() is false (hardened precondition).'''
formal_spec = '''str.pop_back() => hardened_precondition(!str.empty())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.erase"
source_module = "[string.erase]/12"
tags = ['string', 'modifier', 'precondition', 'nonempty']

[[axioms]]
id = "cpp20_string_replace_valid_range_c1d2e3f4"
content = '''basic_string::replace(pos1, n1, s, n2) requires [s, s+n2) to be a valid range.'''
formal_spec = '''str.replace(pos1, n1, s, n2) => precondition(valid_range(s, s+n2))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.replace"
source_module = "[string.replace]/7"
tags = ['string', 'modifier', 'precondition', 'valid_range']

[[axioms]]
id = "cpp20_string_replace_length_error_a5b6c7d8"
content = '''basic_string::replace throws length_error if size() - xlen >= max_size() - n2.'''
formal_spec = '''str.replace(pos1, n1, s, n2) && (str.size() - xlen >= str.max_size() - n2) => throws(length_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.replace"
source_module = "[string.replace]/8"
tags = ['string', 'modifier', 'exception', 'length_error']

[[axioms]]
id = "cpp20_string_replace_pos_out_of_range_e9f0a1b2"
content = '''basic_string::replace(pos1, n1, s, n2) throws out_of_range if pos1 > size().'''
formal_spec = '''str.replace(pos1, n1, s, n2) && pos1 > str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.replace"
source_module = "[string.replace]/10.1"
tags = ['string', 'modifier', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_copy_valid_range_c3d4e5f6"
content = '''basic_string::copy(s, n, pos) requires s points to an array of at least n elements (destination must be valid).'''
formal_spec = '''str.copy(s, n, pos) => precondition(valid_destination_array(s, n))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "string.copy"
source_module = "[string.copy]"
tags = ['string', 'operation', 'precondition', 'valid_range']

[[axioms]]
id = "cpp20_string_resize_and_overwrite_op_no_throw_a7b8c9d0"
content = '''resize_and_overwrite operation OP must not throw an exception.'''
formal_spec = '''str.resize_and_overwrite(n, op) => precondition(!throws(std::move(op)(p, m)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.capacity"
source_module = "[string.capacity]/9.1"
tags = ['string', 'capacity', 'precondition', 'resize_and_overwrite']

[[axioms]]
id = "cpp20_string_resize_and_overwrite_op_no_modify_e1f2a3b4"
content = '''resize_and_overwrite operation OP must not modify p or m.'''
formal_spec = '''str.resize_and_overwrite(n, op) => precondition(!modifies(std::move(op)(p, m), p, m))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.capacity"
source_module = "[string.capacity]/9.1"
tags = ['string', 'capacity', 'precondition', 'resize_and_overwrite']

[[axioms]]
id = "cpp20_string_resize_and_overwrite_r_nonnegative_c5d6e7f8"
content = '''resize_and_overwrite result r must be >= 0.'''
formal_spec = '''str.resize_and_overwrite(n, op) && r = std::move(op)(p, m) => precondition(r >= 0)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.capacity"
source_module = "[string.capacity]/9.2"
tags = ['string', 'capacity', 'precondition', 'resize_and_overwrite']

[[axioms]]
id = "cpp20_string_resize_and_overwrite_r_le_m_a9b0c1d2"
content = '''resize_and_overwrite result r must be <= m.'''
formal_spec = '''str.resize_and_overwrite(n, op) && r = std::move(op)(p, m) => precondition(r <= m)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.capacity"
source_module = "[string.capacity]/9.3"
tags = ['string', 'capacity', 'precondition', 'resize_and_overwrite']

[[axioms]]
id = "cpp20_string_resize_and_overwrite_no_indeterminate_e3f4a5b6"
content = '''After evaluating resize_and_overwrite OP, there must be no indeterminate values in range [p, p+r).'''
formal_spec = '''str.resize_and_overwrite(n, op) && r = std::move(op)(p, m) => precondition(!has_indeterminate_values(p, p+r))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.capacity"
source_module = "[string.capacity]/9.4"
tags = ['string', 'capacity', 'precondition', 'resize_and_overwrite', 'indeterminate']

[[axioms]]
id = "cpp20_string_reserve_length_error_c7d8e9f0"
content = '''basic_string::reserve(res_arg) throws length_error if res_arg > max_size().'''
formal_spec = '''str.reserve(res_arg) && res_arg > str.max_size() => throws(length_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "string.capacity"
source_module = "[string.capacity]/15"
tags = ['string', 'capacity', 'exception', 'length_error']

[[axioms]]
id = "cpp20_string_general_data_range_valid_a1b2c3d4"
content = '''In all cases, [data(), data()+size()] is a valid range for basic_string.'''
formal_spec = '''basic_string str => valid_range(str.data(), str.data() + str.size())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "basic.string.general"
source_module = "[basic.string.general]/3"
tags = ['string', 'invariant', 'valid_range']

[[axioms]]
id = "cpp20_string_general_null_terminator_e5f6a7b8"
content = '''In all cases, data()+size() points at an object with value charT() (null terminator) for basic_string.'''
formal_spec = '''basic_string str => *(str.data() + str.size()) == charT()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "basic.string.general"
source_module = "[basic.string.general]/3"
tags = ['string', 'invariant', 'null_terminator']

[[axioms]]
id = "cpp20_string_general_size_le_capacity_c9d0e1f2"
content = '''In all cases, size() <= capacity() is true for basic_string.'''
formal_spec = '''basic_string str => str.size() <= str.capacity()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "basic.string.general"
source_module = "[basic.string.general]/3"
tags = ['string', 'invariant', 'capacity']

[[axioms]]
id = "cpp20_string_substr_pos_out_of_range_a3b4c5d6"
content = '''basic_string::substr(pos, n) throws out_of_range if pos > size().'''
formal_spec = '''str.substr(pos, n) && pos > str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "string.substr"
source_module = "[string.substr]"
tags = ['string', 'operation', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_string_compare_pos_out_of_range_e7f8a9b0"
content = '''basic_string::compare(pos1, n1, ...) throws out_of_range if pos1 > size().'''
formal_spec = '''str.compare(pos1, n1, ...) && pos1 > str.size() => throws(out_of_range)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "string.compare"
source_module = "[string.compare]"
tags = ['string', 'operation', 'exception', 'out_of_range']

[[axioms]]
id = "cpp20_unique_ptr_single_general_illformed_tptr_a7b3c9d2"
content = '''A program that instantiates the definition of unique_ptr<T, D> is ill-formed if T* is an invalid type.'''
formal_spec = '''instantiate(unique_ptr<T, D>) && !valid_type(pointer_type(T)) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.general"
source_module = "[unique.ptr.single.general]/1"
tags = ['unique_ptr', 'template', 'ill-formed', 'pointer']

[[axioms]]
id = "cpp20_unique_ptr_single_general_deleter_destructible_e4f2a1b8"
content = '''If the deleter's type D is not a reference type, D shall meet the Cpp17Destructible requirements.'''
formal_spec = '''!is_reference_v<D> => is_cpp17_destructible<D>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.general"
source_module = "[unique.ptr.single.general]/3"
tags = ['unique_ptr', 'deleter', 'destructible', 'requirements']

[[axioms]]
id = "cpp20_unique_ptr_single_general_pointer_nullable_c8d5e3f1"
content = '''The type unique_ptr<T, D>::pointer shall meet the Cpp17NullablePointer requirements.'''
formal_spec = '''is_cpp17_nullable_pointer<unique_ptr<T, D>::pointer>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.general"
source_module = "[unique.ptr.single.general]/4"
tags = ['unique_ptr', 'pointer', 'nullable', 'requirements']

[[axioms]]
id = "cpp20_unique_ptr_dltr_dflt_complete_type_mandates_f9a2b4c7"
content = '''Calling default_delete<T>::operator()(T* ptr) requires T to be a complete type.'''
formal_spec = '''call(default_delete<T>::operator(), ptr) => is_complete_type<T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.dltr.dflt"
source_module = "[unique.ptr.dltr.dflt]/3"
tags = ['unique_ptr', 'default_delete', 'complete_type', 'mandates']

[[axioms]]
id = "cpp20_unique_ptr_dltr_dflt1_complete_type_mandates_b3c1d8e9"
content = '''Calling default_delete<T[]>::operator()(U* ptr) requires U to be a complete type.'''
formal_spec = '''call(default_delete<T[]>::operator(), ptr) => is_complete_type<U>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.dltr.dflt1"
source_module = "[unique.ptr.dltr.dflt1]/4"
tags = ['unique_ptr', 'default_delete', 'array', 'complete_type', 'mandates']

[[axioms]]
id = "cpp20_unique_ptr_single_ctor_default_precond_d2e5f8a3"
content = '''Default constructor precondition: D meets Cpp17DefaultConstructible requirements and that construction does not throw an exception.'''
formal_spec = '''unique_ptr() => is_cpp17_default_constructible<D> && !throws(construct<D>())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.ctor"
source_module = "[unique.ptr.single.ctor]/2"
tags = ['unique_ptr', 'constructor', 'default_constructible', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_single_ctor_ptr_precond_c4b7a9d1"
content = '''Pointer constructor precondition: D meets Cpp17DefaultConstructible requirements and that construction does not throw an exception.'''
formal_spec = '''unique_ptr(p) => is_cpp17_default_constructible<D> && !throws(construct<D>())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.ctor"
source_module = "[unique.ptr.single.ctor]/6"
tags = ['unique_ptr', 'constructor', 'default_constructible', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_single_ctor_copy_deleter_precond_a8e3f2c5"
content = '''Constructor with const D& deleter precondition: if D is not a reference type, D meets Cpp17CopyConstructible requirements and such construction does not exit via an exception.'''
formal_spec = '''unique_ptr(p, const D& d) && !is_reference_v<D> => is_cpp17_copy_constructible<D> && !throws(copy_construct<D>(d))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.ctor"
source_module = "[unique.ptr.single.ctor]/10"
tags = ['unique_ptr', 'constructor', 'copy_constructible', 'preconditions', 'deleter']

[[axioms]]
id = "cpp20_unique_ptr_single_ctor_move_deleter_precond_b6d9c1e4"
content = '''Constructor with remove_reference_t<D>&& deleter precondition: if D is not a reference type, D meets Cpp17MoveConstructible requirements and such construction does not exit via an exception.'''
formal_spec = '''unique_ptr(p, remove_reference_t<D>&& d) && !is_reference_v<D> => is_cpp17_move_constructible<D> && !throws(move_construct<D>(d))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.ctor"
source_module = "[unique.ptr.single.ctor]/10"
tags = ['unique_ptr', 'constructor', 'move_constructible', 'preconditions', 'deleter']

[[axioms]]
id = "cpp20_unique_ptr_single_ctor_move_precond_e7a4b2c9"
content = '''Move constructor precondition: if D is not a reference type, D meets Cpp17MoveConstructible requirements and construction of the deleter from an rvalue of type D does not throw an exception.'''
formal_spec = '''unique_ptr(unique_ptr&& u) && !is_reference_v<D> => is_cpp17_move_constructible<D> && !throws(move_construct<D>(u.get_deleter()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.ctor"
source_module = "[unique.ptr.single.ctor]/16"
tags = ['unique_ptr', 'constructor', 'move', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_single_ctor_converting_precond_f3b8c5d2"
content = '''Converting constructor precondition: if E is not a reference type, construction of the deleter from an rvalue of type E is well-formed and does not throw an exception. Otherwise, E is a reference type and construction of the deleter from an lvalue of type E is well-formed and does not throw an exception.'''
formal_spec = '''unique_ptr(unique_ptr<U, E>&& u) && !is_reference_v<E> => well_formed(construct<D>(rvalue<E>(u.get_deleter()))) && !throws(construct<D>(rvalue<E>(u.get_deleter())))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.ctor"
source_module = "[unique.ptr.single.ctor]/20"
tags = ['unique_ptr', 'constructor', 'converting', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_single_dtor_deleter_throw_ub_a1c4e7b9"
content = '''The behavior is undefined if the evaluation of get_deleter()(get()) throws an exception in unique_ptr destructor.'''
formal_spec = '''~unique_ptr() && get() != nullptr && throws(get_deleter()(get())) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.dtor"
source_module = "[unique.ptr.single.dtor]/2"
tags = ['unique_ptr', 'destructor', 'deleter', 'undefined_behavior', 'exception']

[[axioms]]
id = "cpp20_unique_ptr_single_asgn_move_precond_d8f2a3c6"
content = '''Move assignment precondition: if D is not a reference type, D meets Cpp17MoveAssignable requirements and assignment of the deleter from an rvalue of type D does not throw an exception. Otherwise, D is a reference type and remove_reference_t<D> meets Cpp17CopyAssignable requirements and assignment of the deleter from an lvalue of type D does not throw an exception.'''
formal_spec = '''operator=(unique_ptr&& u) && !is_reference_v<D> => is_cpp17_move_assignable<D> && !throws(assign<D>(rvalue<D>(u.get_deleter())))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.asgn"
source_module = "[unique.ptr.single.asgn]/2"
tags = ['unique_ptr', 'assignment', 'move', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_single_asgn_converting_precond_e5c9b1d4"
content = '''Converting assignment precondition: if E is not a reference type, assignment of the deleter from an rvalue of type E is well-formed and does not throw an exception. Otherwise, E is a reference type and assignment of the deleter from an lvalue of type E is well-formed and does not throw an exception.'''
formal_spec = '''operator=(unique_ptr<U, E>&& u) && !is_reference_v<E> => well_formed(assign<D>(rvalue<E>(u.get_deleter()))) && !throws(assign<D>(rvalue<E>(u.get_deleter())))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.asgn"
source_module = "[unique.ptr.single.asgn]/7"
tags = ['unique_ptr', 'assignment', 'converting', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_single_observers_deref_mandates_c7a8b2f3"
content = '''Mandates for operator*: reference_converts_from_temporary_v<add_lvalue_reference_t<T>, decltype(*declval<pointer>())> is false.'''
formal_spec = '''operator*() => !reference_converts_from_temporary_v<add_lvalue_reference_t<T>, decltype(*declval<pointer>())>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.observers"
source_module = "[unique.ptr.single.observers]/1"
tags = ['unique_ptr', 'observer', 'dereference', 'mandates']

[[axioms]]
id = "cpp20_unique_ptr_single_observers_deref_precond_b4d1e9a6"
content = '''Precondition for operator*: get() != nullptr is true.'''
formal_spec = '''operator*() => get() != nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.observers"
source_module = "[unique.ptr.single.observers]/2"
tags = ['unique_ptr', 'observer', 'dereference', 'preconditions', 'nullptr']

[[axioms]]
id = "cpp20_unique_ptr_single_observers_arrow_precond_a2c5f8d3"
content = '''Precondition for operator->: get() != nullptr.'''
formal_spec = '''operator->() => get() != nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.observers"
source_module = "[unique.ptr.single.observers]/4"
tags = ['unique_ptr', 'observer', 'arrow', 'preconditions', 'nullptr']

[[axioms]]
id = "cpp20_unique_ptr_single_modifiers_reset_deleter_throw_ub_c9b3e6f1"
content = '''The behavior is undefined if the evaluation of get_deleter()(old_p) throws an exception in reset().'''
formal_spec = '''reset(p) && old_p != nullptr && throws(get_deleter()(old_p)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.modifiers"
source_module = "[unique.ptr.single.modifiers]/5"
tags = ['unique_ptr', 'modifier', 'reset', 'deleter', 'undefined_behavior', 'exception']

[[axioms]]
id = "cpp20_unique_ptr_single_modifiers_swap_precond_d7a4c2e8"
content = '''Precondition for swap: get_deleter() is swappable and does not throw an exception under swap.'''
formal_spec = '''swap(unique_ptr& u) => is_swappable<deleter_type> && !throws(swap(get_deleter(), u.get_deleter()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.single.modifiers"
source_module = "[unique.ptr.single.modifiers]/6"
tags = ['unique_ptr', 'modifier', 'swap', 'preconditions']

[[axioms]]
id = "cpp20_unique_ptr_runtime_general_complete_type_e1b4c7f2"
content = '''The template argument T for unique_ptr<T[]> shall be a complete type.'''
formal_spec = '''unique_ptr<T[], D> => is_complete_type<T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.runtime.general"
source_module = "[unique.ptr.runtime.general]/3"
tags = ['unique_ptr', 'array', 'complete_type', 'template']

[[axioms]]
id = "cpp20_unique_ptr_runtime_observers_index_precond_f8c3a5d9"
content = '''Precondition for operator[]: i < the number of elements in the array to which the stored pointer points.'''
formal_spec = '''operator[](i) => i < array_size(get())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.runtime.observers"
source_module = "[unique.ptr.runtime.observers]/1"
tags = ['unique_ptr', 'array', 'observer', 'index', 'preconditions', 'bounds']

[[axioms]]
id = "cpp20_unique_ptr_special_less_precond_a3b9c4e7"
content = '''Precondition for operator<: the specialization less<CT> is a function object type that induces a strict weak ordering on the pointer values.'''
formal_spec = '''operator<(x, y) => is_function_object_type<less<common_type_t<pointer1, pointer2>>> && induces_strict_weak_ordering<less<common_type_t<pointer1, pointer2>>>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.special"
source_module = "[unique.ptr.special]/6"
tags = ['unique_ptr', 'comparison', 'less', 'preconditions', 'strict_weak_ordering']

[[axioms]]
id = "cpp20_unique_ptr_special_nullptr_less_precond_b5d2e8f1"
content = '''Precondition for comparisons with nullptr: the specialization less<unique_ptr<T, D>::pointer> is a function object type that induces a strict weak ordering on the pointer values.'''
formal_spec = '''operator<(x, nullptr) || operator<(nullptr, x) => is_function_object_type<less<unique_ptr<T, D>::pointer>> && induces_strict_weak_ordering<less<unique_ptr<T, D>::pointer>>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "unique.ptr.special"
source_module = "[unique.ptr.special]/13"
tags = ['unique_ptr', 'comparison', 'nullptr', 'less', 'preconditions', 'strict_weak_ordering']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_complete_type_a3b7c8d2"
content = '''When constructing shared_ptr<T> from a raw pointer Y*, Y must be a complete type.'''
formal_spec = '''shared_ptr<T>::shared_ptr(Y* p) => complete_type(Y)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/4"
tags = ['shared_ptr', 'constructor', 'complete_type', 'mandates']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_delete_welldef_e4f9a1b3"
content = '''When constructing shared_ptr<T> from a raw pointer p, the expression delete[] p (for array T) or delete p (for non-array T) must have well-defined behavior and not throw exceptions.'''
formal_spec = '''shared_ptr<T>::shared_ptr(Y* p) => is_array_type(T) ? well_defined(delete[] p) && !throws(delete[] p) : well_defined(delete p) && !throws(delete p)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/5"
tags = ['shared_ptr', 'constructor', 'precondition', 'delete']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_deleter_noexcept_c5d8e2f4"
content = '''When constructing shared_ptr with a custom deleter D, construction of d and a deleter of type D initialized with std::move(d) must not throw exceptions.'''
formal_spec = '''shared_ptr(Y* p, D d) || shared_ptr(Y* p, D d, A a) || shared_ptr(nullptr_t p, D d) || shared_ptr(nullptr_t p, D d, A a) => !throws(construct(d)) && !throws(construct(D, std::move(d)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/10"
tags = ['shared_ptr', 'constructor', 'deleter', 'precondition', 'noexcept']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_deleter_expr_welldef_d6e9f3a5"
content = '''When constructing shared_ptr with a custom deleter d and pointer p, the expression d(p) must have well-defined behavior and not throw exceptions.'''
formal_spec = '''shared_ptr(Y* p, D d) || shared_ptr(nullptr_t p, D d) => well_defined(d(p)) && !throws(d(p))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/10"
tags = ['shared_ptr', 'constructor', 'deleter', 'precondition']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_allocator_req_e7f0a4b6"
content = '''When constructing shared_ptr with an allocator A, A must meet the Cpp17Allocator requirements.'''
formal_spec = '''shared_ptr(Y* p, D d, A a) || shared_ptr(nullptr_t p, D d, A a) => meets_cpp17_allocator_requirements(A)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/10"
tags = ['shared_ptr', 'constructor', 'allocator', 'precondition']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_weak_ptr_throws_f8a1b5c7"
content = '''Constructing shared_ptr from an expired weak_ptr throws bad_weak_ptr.'''
formal_spec = '''shared_ptr<T>::shared_ptr(const weak_ptr<Y>& r) && r.expired() => throws(bad_weak_ptr)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/27"
tags = ['shared_ptr', 'weak_ptr', 'constructor', 'exception', 'bad_weak_ptr']

[[axioms]]
id = "cpp20_util_smartptr_shared_obs_deref_precond_a9b2c6d8"
content = '''Dereferencing a shared_ptr via operator* requires that get() != nullptr.'''
formal_spec = '''shared_ptr<T>::operator*() => get() != nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.obs"
source_module = "[util.smartptr.shared.obs]/2"
tags = ['shared_ptr', 'dereference', 'precondition', 'nullptr']

[[axioms]]
id = "cpp20_util_smartptr_shared_obs_arrow_precond_b0c3d7e9"
content = '''Using operator-> on a shared_ptr requires that get() != nullptr.'''
formal_spec = '''shared_ptr<T>::operator->() => get() != nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.obs"
source_module = "[util.smartptr.shared.obs]/5"
tags = ['shared_ptr', 'arrow_operator', 'precondition', 'nullptr']

[[axioms]]
id = "cpp20_util_smartptr_shared_obs_subscript_precond_c1d4e8f0"
content = '''Using operator[] on a shared_ptr requires that get() != nullptr.'''
formal_spec = '''shared_ptr<T>::operator[](ptrdiff_t i) => get() != nullptr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.obs"
source_module = "[util.smartptr.shared.obs]/8"
tags = ['shared_ptr', 'subscript', 'precondition', 'nullptr']

[[axioms]]
id = "cpp20_util_smartptr_shared_obs_subscript_hardened_nonneg_d2e5f9a1"
content = '''Using operator[] on a shared_ptr has a hardened precondition that index i >= 0.'''
formal_spec = '''shared_ptr<T>::operator[](ptrdiff_t i) => i >= 0'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.obs"
source_module = "[util.smartptr.shared.obs]/9"
tags = ['shared_ptr', 'subscript', 'hardened_precondition', 'bounds']

[[axioms]]
id = "cpp20_util_smartptr_shared_obs_subscript_hardened_bound_e3f6a0b2"
content = '''Using operator[] on a shared_ptr<U[N]> has a hardened precondition that index i < N.'''
formal_spec = '''is_bounded_array(T, N) && shared_ptr<T>::operator[](ptrdiff_t i) => i < N'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.obs"
source_module = "[util.smartptr.shared.obs]/9"
tags = ['shared_ptr', 'subscript', 'hardened_precondition', 'bounds', 'array']

[[axioms]]
id = "cpp20_util_smartptr_shared_cast_dynamic_welldef_f4a7b1c3"
content = '''Using dynamic_pointer_cast requires that the expression dynamic_cast<typename shared_ptr<T>::element_type*>(r.get()) has well-defined behavior.'''
formal_spec = '''dynamic_pointer_cast<T>(shared_ptr<U>& r) => well_defined(dynamic_cast<typename shared_ptr<T>::element_type*>(r.get()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.cast"
source_module = "[util.smartptr.shared.cast]/5"
tags = ['shared_ptr', 'dynamic_pointer_cast', 'precondition', 'dynamic_cast']

[[axioms]]
id = "cpp20_util_smartptr_shared_create_allocator_req_a5b8c2d4"
content = '''For allocate_shared and allocate_shared_for_overwrite, the allocator A must meet the Cpp17Allocator requirements.'''
formal_spec = '''allocate_shared<T>(const A& a, args) || allocate_shared_for_overwrite<T>(const A& a, args) => meets_cpp17_allocator_requirements(A)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.create"
source_module = "[util.smartptr.shared.create]/2"
tags = ['shared_ptr', 'allocate_shared', 'allocator', 'precondition']

[[axioms]]
id = "cpp20_util_smartptr_shared_const_enable_shared_not_atomic_b6c9d3e5"
content = '''The assignment to the weak-this member in enable_shared_from_this is not atomic and conflicts with any potentially concurrent access to the same object.'''
formal_spec = '''enables_shared_from_this(p) && concurrent_access(p->weak_this) => data_race'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/1"
tags = ['shared_ptr', 'enable_shared_from_this', 'data_race', 'concurrency']

[[axioms]]
id = "cpp20_util_smartptr_shared_general_data_race_c7d0e4f6"
content = '''For purposes of determining the presence of a data race, shared_ptr member functions shall access and modify only the shared_ptr and weak_ptr objects themselves and not objects they refer to.'''
formal_spec = '''shared_ptr_member_function() => !data_race_on_referred_object'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "util.smartptr.shared.general"
source_module = "[util.smartptr.shared.general]/5"
tags = ['shared_ptr', 'data_race', 'concurrency', 'thread_safety']

[[axioms]]
id = "cpp20_util_smartptr_weak_bad_thrown_d8e1f5a7"
content = '''An exception of type bad_weak_ptr is thrown by the shared_ptr constructor taking a weak_ptr when the weak_ptr is expired.'''
formal_spec = '''shared_ptr<T>(const weak_ptr<Y>& r) && r.expired() => throws(bad_weak_ptr)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.weak.bad"
source_module = "[util.smartptr.weak.bad]/1"
tags = ['shared_ptr', 'weak_ptr', 'bad_weak_ptr', 'exception']

[[axioms]]
id = "cpp20_util_smartptr_shared_aliasing_dangling_e9f2a6b8"
content = '''The aliasing constructor of shared_ptr can lead to a dangling pointer unless the stored pointer p remains valid at least until the ownership group is destroyed.'''
formal_spec = '''shared_ptr(shared_ptr<Y>& r, element_type* p) && !valid_until_ownership_destroyed(p, ownership_group(r)) => dangling_pointer(p)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "util.smartptr.shared.const"
source_module = "[util.smartptr.shared.const]/16"
tags = ['shared_ptr', 'aliasing_constructor', 'dangling_pointer', 'lifetime']

[[axioms]]
id = "cpp20_util_smartptr_shared_cast_static_ub_note_f0a3b7c9"
content = '''Using shared_ptr<T>(static_cast<T*>(r.get())) instead of static_pointer_cast can result in undefined behavior, attempting to delete the same object twice.'''
formal_spec = '''shared_ptr<T>(static_cast<T*>(shared_ptr<U>::get())) => potential_double_delete => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.cast"
source_module = "[util.smartptr.shared.cast]/3"
tags = ['shared_ptr', 'static_pointer_cast', 'double_delete', 'undefined_behavior']

[[axioms]]
id = "cpp20_util_smartptr_shared_cast_dynamic_ub_note_a1b4c8d0"
content = '''Using shared_ptr<T>(dynamic_cast<T*>(r.get())) instead of dynamic_pointer_cast can result in undefined behavior, attempting to delete the same object twice.'''
formal_spec = '''shared_ptr<T>(dynamic_cast<T*>(shared_ptr<U>::get())) => potential_double_delete => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.cast"
source_module = "[util.smartptr.shared.cast]/7"
tags = ['shared_ptr', 'dynamic_pointer_cast', 'double_delete', 'undefined_behavior']

[[axioms]]
id = "cpp20_util_smartptr_shared_cast_const_ub_note_b2c5d9e1"
content = '''Using shared_ptr<T>(const_cast<T*>(r.get())) instead of const_pointer_cast can result in undefined behavior, attempting to delete the same object twice.'''
formal_spec = '''shared_ptr<T>(const_cast<T*>(shared_ptr<U>::get())) => potential_double_delete => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.cast"
source_module = "[util.smartptr.shared.cast]/10"
tags = ['shared_ptr', 'const_pointer_cast', 'double_delete', 'undefined_behavior']

[[axioms]]
id = "cpp20_util_smartptr_shared_cast_reinterpret_ub_note_c3d6e0f2"
content = '''Using shared_ptr<T>(reinterpret_cast<T*>(r.get())) instead of reinterpret_pointer_cast can result in undefined behavior, attempting to delete the same object twice.'''
formal_spec = '''shared_ptr<T>(reinterpret_cast<T*>(shared_ptr<U>::get())) => potential_double_delete => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "util.smartptr.shared.cast"
source_module = "[util.smartptr.shared.cast]/13"
tags = ['shared_ptr', 'reinterpret_pointer_cast', 'double_delete', 'undefined_behavior']

[[axioms]]
id = "cpp20_util_smartptr_shared_use_count_not_sync_d4e7f1a3"
content = '''When multiple threads might affect the return value of use_count(), the result is approximate. In particular, use_count() == 1 does not imply that accesses through a previously destroyed shared_ptr have in any sense completed.'''
formal_spec = '''concurrent_threads() && use_count() == 1 => !implies_completion_of_previous_accesses'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "util.smartptr.shared.obs"
source_module = "[util.smartptr.shared.obs]/17"
tags = ['shared_ptr', 'use_count', 'concurrency', 'thread_safety']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_convertible_to_const_pointer_a1b2c3d4"
content = '''XX::pointer must be convertible to XX::const_pointer for an allocator type X.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> => convertible_to(XX::pointer, XX::const_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/5"
tags = ['allocator', 'pointer', 'conversion', 'mandates']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_convertible_to_void_pointer_b2c3d4e5"
content = '''XX::pointer must be convertible to XX::void_pointer for an allocator type X.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> => convertible_to(XX::pointer, XX::void_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/7"
tags = ['allocator', 'pointer', 'conversion', 'mandates']

[[axioms]]
id = "cpp20_allocator_requirements_void_pointer_same_type_c3d4e5f6"
content = '''XX::void_pointer and YY::void_pointer must be the same type for related allocator types X and Y.'''
formal_spec = '''allocator_type(X) && allocator_type(Y) && rebind_related(X, Y) && XX = allocator_traits<X> && YY = allocator_traits<Y> => same_type(XX::void_pointer, YY::void_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/7"
tags = ['allocator', 'pointer', 'type-identity', 'mandates']

[[axioms]]
id = "cpp20_allocator_requirements_const_void_pointer_conversions_d4e5f6a7"
content = '''XX::pointer, XX::const_pointer, and XX::void_pointer must all be convertible to XX::const_void_pointer.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> => convertible_to(XX::pointer, XX::const_void_pointer) && convertible_to(XX::const_pointer, XX::const_void_pointer) && convertible_to(XX::void_pointer, XX::const_void_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/9"
tags = ['allocator', 'pointer', 'conversion', 'mandates']

[[axioms]]
id = "cpp20_allocator_requirements_const_void_pointer_same_type_e5f6a7b8"
content = '''XX::const_void_pointer and YY::const_void_pointer must be the same type for related allocator types X and Y.'''
formal_spec = '''allocator_type(X) && allocator_type(Y) && rebind_related(X, Y) && XX = allocator_traits<X> && YY = allocator_traits<Y> => same_type(XX::const_void_pointer, YY::const_void_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/9"
tags = ['allocator', 'pointer', 'type-identity', 'mandates']

[[axioms]]
id = "cpp20_allocator_requirements_value_type_identical_f6a7b8c9"
content = '''X::value_type must be identical to T for an allocator class X for type T.'''
formal_spec = '''allocator_for(X, T) => identical_type(X::value_type, T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/11"
tags = ['allocator', 'value_type', 'type-identity']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_arrow_precondition_a7b8c9d0"
content = '''Using p->m on an allocator pointer p requires that (*p).m is well-defined.'''
formal_spec = '''allocator_pointer(p) && member_access(p, m) => precondition(well_defined(deref(p).m))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/24"
tags = ['allocator', 'pointer', 'precondition', 'member-access']

[[axioms]]
id = "cpp20_allocator_requirements_const_pointer_arrow_precondition_b8c9d0e1"
content = '''Using q->m on an allocator const_pointer q requires that (*q).m is well-defined.'''
formal_spec = '''allocator_const_pointer(q) && member_access(q, m) => precondition(well_defined(deref(q).m))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/27"
tags = ['allocator', 'pointer', 'precondition', 'member-access']

[[axioms]]
id = "cpp20_allocator_requirements_deallocate_precondition_allocate_at_least_c9d0e1f2"
content = '''When deallocating memory obtained from allocate_at_least, p must equal ret.ptr and n must satisfy req <= n <= ret.count where ret is the returned value and req is the requested size.'''
formal_spec = '''obtained_from_allocate_at_least(p, ret, req) && deallocate(a, p, n) => precondition(p == ret.ptr && req <= n && n <= ret.count)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/48.1"
tags = ['allocator', 'deallocate', 'precondition', 'memory']

[[axioms]]
id = "cpp20_allocator_requirements_deallocate_precondition_allocate_d0e1f2a3"
content = '''When deallocating memory obtained from allocate, p must be the pointer returned by allocate, n must equal the value passed to allocate, and p must not have been invalidated by an intervening deallocate call.'''
formal_spec = '''obtained_from_allocate(p, orig_n) && deallocate(a, p, n) => precondition(n == orig_n && !invalidated(p))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/48.2"
tags = ['allocator', 'deallocate', 'precondition', 'memory']

[[axioms]]
id = "cpp20_allocator_requirements_deallocate_nothrow_e1f2a3b4"
content = '''The deallocate function of an allocator shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && call(a.deallocate(p, n)) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/49"
tags = ['allocator', 'deallocate', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_equality_reflexive_symmetric_transitive_f2a3b4c5"
content = '''Allocator operator== shall be reflexive, symmetric, and transitive.'''
formal_spec = '''allocator_type(X) && a1: X && a2: X => (a1 == a1) && ((a1 == a2) => (a2 == a1)) && ((a1 == a2) && (a2 == a3) => (a1 == a3))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/56"
tags = ['allocator', 'equality', 'operator', 'semantics']

[[axioms]]
id = "cpp20_allocator_requirements_equality_nothrow_a3b4c5d6"
content = '''Allocator comparison operator== shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && a1: X && a2: X && call(a1 == a2) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/55"
tags = ['allocator', 'equality', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_copy_constructor_nothrow_b4c5d6e7"
content = '''Allocator copy construction shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && a: X && copy_construct(u, a) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/64"
tags = ['allocator', 'copy', 'constructor', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_converting_constructor_nothrow_c5d6e7f8"
content = '''Allocator converting construction from a related allocator type shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && allocator_type(Y) && rebind_related(X, Y) && b: Y && construct(u: X, b) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/66"
tags = ['allocator', 'converting', 'constructor', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_move_constructor_nothrow_d6e7f8a9"
content = '''Allocator move construction shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && a: X && move_construct(u, std::move(a)) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/68"
tags = ['allocator', 'move', 'constructor', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_move_converting_constructor_nothrow_e7f8a9b0"
content = '''Allocator move construction from a related allocator type shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && allocator_type(Y) && rebind_related(X, Y) && b: Y && move_construct(u: X, std::move(b)) => nothrow'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/70"
tags = ['allocator', 'move', 'converting', 'constructor', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_propagate_copy_copyassignable_f8a9b0c1"
content = '''If propagate_on_container_copy_assignment is true_type, the allocator type X shall meet Cpp17CopyAssignable requirements and the copy operation shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && X::propagate_on_container_copy_assignment == true_type => cpp17_copy_assignable(X) && nothrow(copy_assign(X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/81"
tags = ['allocator', 'propagate', 'copy', 'assignment', 'nothrow']

[[axioms]]
id = "cpp20_allocator_requirements_propagate_move_moveassignable_a9b0c1d2"
content = '''If propagate_on_container_move_assignment is true_type, the allocator type X shall meet Cpp17MoveAssignable requirements and the move operation shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && X::propagate_on_container_move_assignment == true_type => cpp17_move_assignable(X) && nothrow(move_assign(X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/84"
tags = ['allocator', 'propagate', 'move', 'assignment', 'nothrow']

[[axioms]]
id = "cpp20_allocator_requirements_propagate_swap_swappable_b0c1d2e3"
content = '''If propagate_on_container_swap is true_type, the allocator type X shall meet Cpp17Swappable requirements and the swap operation shall not throw exceptions.'''
formal_spec = '''allocator_type(X) && X::propagate_on_container_swap == true_type => cpp17_swappable(X) && nothrow(swap(X))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/87"
tags = ['allocator', 'propagate', 'swap', 'nothrow']

[[axioms]]
id = "cpp20_allocator_requirements_copyconstructible_c1d2e3f4"
content = '''An allocator type X shall meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''allocator_type(X) => cpp17_copy_constructible(X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/92"
tags = ['allocator', 'copy', 'constructible', 'requirements']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_types_nullablepointer_d2e3f4a5"
content = '''The XX::pointer, XX::const_pointer, XX::void_pointer, and XX::const_void_pointer types shall meet the Cpp17NullablePointer requirements.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> => cpp17_nullable_pointer(XX::pointer) && cpp17_nullable_pointer(XX::const_pointer) && cpp17_nullable_pointer(XX::void_pointer) && cpp17_nullable_pointer(XX::const_void_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/92"
tags = ['allocator', 'pointer', 'nullable', 'requirements']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_ops_nothrow_e3f4a5b6"
content = '''No constructor, comparison operator function, copy operation, move operation, or swap operation on allocator pointer types shall exit via an exception.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> && ptr_type in {XX::pointer, XX::const_pointer, XX::void_pointer, XX::const_void_pointer} => nothrow(constructor(ptr_type)) && nothrow(comparison(ptr_type)) && nothrow(copy(ptr_type)) && nothrow(move(ptr_type)) && nothrow(swap(ptr_type))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/92"
tags = ['allocator', 'pointer', 'nothrow', 'exception']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_random_access_iterator_f4a5b6c7"
content = '''XX::pointer and XX::const_pointer shall meet the requirements for a Cpp17RandomAccessIterator.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> => cpp17_random_access_iterator(XX::pointer) && cpp17_random_access_iterator(XX::const_pointer)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/92"
tags = ['allocator', 'pointer', 'iterator', 'requirements']

[[axioms]]
id = "cpp20_allocator_requirements_pointer_addressof_contiguity_a5b6c7d8"
content = '''For allocator pointers, when p and (p+n) are dereferenceable pointer values for some integral value n, addressof(*(p+n)) == addressof(*p)+n must be true.'''
formal_spec = '''allocator_type(X) && XX = allocator_traits<X> && p: XX::pointer && dereferenceable(p) && dereferenceable(p + n) => addressof(*(p + n)) == addressof(*p) + n'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.general"
source_module = "[allocator.requirements.general]/92"
tags = ['allocator', 'pointer', 'contiguity', 'addressof']

[[axioms]]
id = "cpp20_allocator_requirements_completeness_allocator_complete_b6c7d8e9"
content = '''If X is an allocator class for type T meeting allocator completeness requirements, X must be a complete type whether or not T is complete.'''
formal_spec = '''allocator_for(X, T) && allocator_completeness_requirements(X) => complete_type(X)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.completeness"
source_module = "[allocator.requirements.completeness]/1.1"
tags = ['allocator', 'completeness', 'type']

[[axioms]]
id = "cpp20_allocator_requirements_completeness_traits_members_complete_c7d8e9f0"
content = '''If X meets allocator completeness requirements, all member types of allocator_traits<X> other than value_type must be complete types whether or not T is complete.'''
formal_spec = '''allocator_for(X, T) && allocator_completeness_requirements(X) && member_type(allocator_traits<X>, M) && M != value_type => complete_type(M)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "allocator.requirements.completeness"
source_module = "[allocator.requirements.completeness]/1.2"
tags = ['allocator', 'completeness', 'traits', 'type']

[[axioms]]
id = "cpp20_optional_optional_general_invalid_type_instantiation_a1b2c3d4"
content = '''Instantiating optional with a type T that is not a valid contained type (not an lvalue reference or complete non-array object type, or is in_place_t or nullopt_t) makes the program ill-formed.'''
formal_spec = '''instantiate(optional<T>) && !is_valid_contained_type(T) => ill_formed where is_valid_contained_type(T) := (is_lvalue_reference(T) || (is_complete_object_type(T) && !is_array_type(T))) && remove_cvref(T) != in_place_t && remove_cvref(T) != nullopt_t'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.optional.general"
source_module = "[optional.optional.general]/2"
tags = ['optional', 'type_constraint', 'instantiation']

[[axioms]]
id = "cpp20_optional_optional_general_destructible_requirement_e5f6a7b8"
content = '''If T is an object type used with optional, T shall meet the Cpp17Destructible requirements.'''
formal_spec = '''instantiate(optional<T>) && is_object_type(T) => Cpp17Destructible(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.optional.general"
source_module = "[optional.optional.general]/2"
tags = ['optional', 'type_constraint', 'destructor']

[[axioms]]
id = "cpp20_optional_observe_arrow_precondition_c3d4e5f6"
content = '''Calling operator-> on an optional requires that the optional contains a value (hardened precondition).'''
formal_spec = '''call(optional<T>::operator->(), opt) => precondition(has_value(opt) == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.observe"
source_module = "[optional.observe]/1"
tags = ['optional', 'precondition', 'observer', 'hardened']

[[axioms]]
id = "cpp20_optional_observe_deref_lvalue_precondition_b2c3d4e5"
content = '''Calling operator* on an lvalue optional requires that the optional contains a value (hardened precondition).'''
formal_spec = '''call(optional<T>::operator*(), opt, is_lvalue) => precondition(has_value(opt) == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.observe"
source_module = "[optional.observe]/4"
tags = ['optional', 'precondition', 'observer', 'hardened']

[[axioms]]
id = "cpp20_optional_observe_deref_rvalue_precondition_a1b2c3d4"
content = '''Calling operator* on an rvalue optional requires that the optional contains a value (hardened precondition).'''
formal_spec = '''call(optional<T>::operator*(), opt, is_rvalue) => precondition(has_value(opt) == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.observe"
source_module = "[optional.observe]/7"
tags = ['optional', 'precondition', 'observer', 'hardened']

[[axioms]]
id = "cpp20_optional_observe_value_throws_d4e5f6a7"
content = '''Calling value() on an optional that does not contain a value throws bad_optional_access.'''
formal_spec = '''call(optional<T>::value(), opt) && !has_value(opt) => throws(bad_optional_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.observe"
source_module = "[optional.observe]/13"
tags = ['optional', 'exception', 'observer']

[[axioms]]
id = "cpp20_optional_swap_swappable_precondition_f6a7b8c9"
content = '''Calling swap on optional requires that T meets the Cpp17Swappable requirements.'''
formal_spec = '''call(optional<T>::swap(rhs), opt) => precondition(Cpp17Swappable(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.swap"
source_module = "[optional.swap]/2"
tags = ['optional', 'precondition', 'swap']

[[axioms]]
id = "cpp20_optional_swap_move_constructible_mandates_e7f8a9b0"
content = '''Calling swap on optional mandates that is_move_constructible_v<T> is true.'''
formal_spec = '''call(optional<T>::swap(rhs), opt) => mandates(is_move_constructible_v<T> == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.swap"
source_module = "[optional.swap]/1"
tags = ['optional', 'mandates', 'swap']

[[axioms]]
id = "cpp20_optional_iterators_invalidation_c8d9e0f1"
content = '''Any operation that initializes or destroys the contained value of an optional object invalidates all iterators into that object.'''
formal_spec = '''(initialize_contained_value(opt) || destroy_contained_value(opt)) => invalidates_all_iterators(opt)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.iterators"
source_module = "[optional.iterators]/3"
tags = ['optional', 'iterator', 'invalidation']

[[axioms]]
id = "cpp20_optional_assign_emplace_mandates_d9e0f1a2"
content = '''Calling emplace(Args...) on optional mandates that is_constructible_v<T, Args...> is true.'''
formal_spec = '''call(optional<T>::emplace(args...), opt) => mandates(is_constructible_v<T, Args...> == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.assign"
source_module = "[optional.assign]/29"
tags = ['optional', 'mandates', 'emplace']

[[axioms]]
id = "cpp20_optional_assign_emplace_exception_state_e0f1a2b3"
content = '''If an exception is thrown during emplace, the optional does not contain a value and the previous value (if any) has been destroyed.'''
formal_spec = '''call(optional<T>::emplace(args...), opt) && exception_thrown_during_construction() => !has_value(opt) && destroyed(previous_value(opt))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.assign"
source_module = "[optional.assign]/34"
tags = ['optional', 'exception_safety', 'emplace']

[[axioms]]
id = "cpp20_optional_monadic_and_then_mandates_f1a2b3c4"
content = '''Calling and_then(F) on optional mandates that remove_cvref_t<invoke_result_t<F, ...>> is a specialization of optional.'''
formal_spec = '''call(optional<T>::and_then(f), opt) => mandates(is_specialization_of_optional(remove_cvref_t<invoke_result_t<F, decltype((val))>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.monadic"
source_module = "[optional.monadic]/2"
tags = ['optional', 'mandates', 'monadic']

[[axioms]]
id = "cpp20_optional_monadic_transform_mandates_type_a2b3c4d5"
content = '''Calling transform(F) on optional mandates that the result type U is a valid contained type for optional.'''
formal_spec = '''call(optional<T>::transform(f), opt) => mandates(is_valid_contained_type(remove_cv_t<invoke_result_t<F, decltype((val))>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.monadic"
source_module = "[optional.monadic]/8"
tags = ['optional', 'mandates', 'monadic', 'transform']

[[axioms]]
id = "cpp20_optional_monadic_or_else_mandates_b3c4d5e6"
content = '''Calling or_else(F) on optional mandates that is_same_v<remove_cvref_t<invoke_result_t<F>>, optional> is true.'''
formal_spec = '''call(optional<T>::or_else(f), opt) => mandates(is_same_v<remove_cvref_t<invoke_result_t<F>>, optional<T>>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.monadic"
source_module = "[optional.monadic]/14"
tags = ['optional', 'mandates', 'monadic']

[[axioms]]
id = "cpp20_optional_value_or_const_mandates_c4d5e6f7"
content = '''Calling value_or(U&&) on const& optional mandates that is_copy_constructible_v<T> && is_convertible_v<U&&, T> is true.'''
formal_spec = '''call(optional<T>::value_or(v), opt, const_lvalue) => mandates(is_copy_constructible_v<T> && is_convertible_v<U&&, T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.observe"
source_module = "[optional.observe]/15"
tags = ['optional', 'mandates', 'observer']

[[axioms]]
id = "cpp20_optional_value_or_rvalue_mandates_d5e6f7a8"
content = '''Calling value_or(U&&) on rvalue optional mandates that is_move_constructible_v<T> && is_convertible_v<U&&, T> is true.'''
formal_spec = '''call(optional<T>::value_or(v), opt, rvalue) => mandates(is_move_constructible_v<T> && is_convertible_v<U&&, T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.observe"
source_module = "[optional.observe]/17"
tags = ['optional', 'mandates', 'observer']

[[axioms]]
id = "cpp20_optional_ref_observe_arrow_precondition_e6f7a8b9"
content = '''Calling operator-> on optional<T&> requires that the optional contains a value (hardened precondition).'''
formal_spec = '''call(optional<T&>::operator->(), opt) => precondition(has_value(opt) == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.observe"
source_module = "[optional.ref.observe]/1"
tags = ['optional', 'precondition', 'reference', 'observer', 'hardened']

[[axioms]]
id = "cpp20_optional_ref_observe_deref_precondition_f7a8b9c0"
content = '''Calling operator* on optional<T&> requires that the optional contains a value (hardened precondition).'''
formal_spec = '''call(optional<T&>::operator*(), opt) => precondition(has_value(opt) == true)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.observe"
source_module = "[optional.ref.observe]/3"
tags = ['optional', 'precondition', 'reference', 'observer', 'hardened']

[[axioms]]
id = "cpp20_optional_ref_observe_value_throws_a8b9c0d1"
content = '''Calling value() on optional<T&> that does not contain a value throws bad_optional_access.'''
formal_spec = '''call(optional<T&>::value(), opt) && !has_value(opt) => throws(bad_optional_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.observe"
source_module = "[optional.ref.observe]/7"
tags = ['optional', 'exception', 'reference', 'observer']

[[axioms]]
id = "cpp20_optional_ref_value_or_constraint_b9c0d1e2"
content = '''Calling value_or on optional<T&> requires that T is a non-array object type.'''
formal_spec = '''call(optional<T&>::value_or(u), opt) => constraint(is_object_type(T) && !is_array_type(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.observe"
source_module = "[optional.ref.observe]/8"
tags = ['optional', 'constraint', 'reference', 'observer']

[[axioms]]
id = "cpp20_optional_ref_value_or_mandates_c0d1e2f3"
content = '''Calling value_or(U&&) on optional<T&> mandates that is_constructible_v<remove_cv_t<T>, T&> && is_convertible_v<U, remove_cv_t<T>> is true.'''
formal_spec = '''call(optional<T&>::value_or(u), opt) => mandates(is_constructible_v<remove_cv_t<T>, T&> && is_convertible_v<U, remove_cv_t<T>>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.observe"
source_module = "[optional.ref.observe]/10"
tags = ['optional', 'mandates', 'reference', 'observer']

[[axioms]]
id = "cpp20_optional_ref_monadic_and_then_mandates_d1e2f3a4"
content = '''Calling and_then(F) on optional<T&> mandates that remove_cvref_t<invoke_result_t<F, T&>> is a specialization of optional.'''
formal_spec = '''call(optional<T&>::and_then(f), opt) => mandates(is_specialization_of_optional(remove_cvref_t<invoke_result_t<F, T&>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.monadic"
source_module = "[optional.ref.monadic]/2"
tags = ['optional', 'mandates', 'reference', 'monadic']

[[axioms]]
id = "cpp20_optional_ref_monadic_transform_mandates_e2f3a4b5"
content = '''Calling transform(F) on optional<T&> mandates that the result type U is a valid contained type for optional.'''
formal_spec = '''call(optional<T&>::transform(f), opt) => mandates(is_valid_contained_type(remove_cv_t<invoke_result_t<F, T&>>))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.monadic"
source_module = "[optional.ref.monadic]/5"
tags = ['optional', 'mandates', 'reference', 'monadic', 'transform']

[[axioms]]
id = "cpp20_optional_ref_monadic_or_else_mandates_f3a4b5c6"
content = '''Calling or_else(F) on optional<T&> mandates that is_same_v<remove_cvref_t<invoke_result_t<F>>, optional> is true.'''
formal_spec = '''call(optional<T&>::or_else(f), opt) => mandates(is_same_v<remove_cvref_t<invoke_result_t<F>>, optional<T&>>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.monadic"
source_module = "[optional.ref.monadic]/8"
tags = ['optional', 'mandates', 'reference', 'monadic']

[[axioms]]
id = "cpp20_optional_nullopt_no_default_ctor_a4b5c6d7"
content = '''Type nullopt_t shall not have a default constructor or an initializer-list constructor, and shall not be an aggregate.'''
formal_spec = '''type(nullopt_t) => !has_default_constructor(nullopt_t) && !has_initializer_list_constructor(nullopt_t) && !is_aggregate(nullopt_t)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.nullopt"
source_module = "[optional.nullopt]/2"
tags = ['optional', 'nullopt', 'type_constraint']

[[axioms]]
id = "cpp20_optional_ref_iterators_constraint_b5c6d7e8"
content = '''Iterator support for optional<T&> is only present if T is an object type other than an array of unknown bound.'''
formal_spec = '''has_member(optional<T&>, iterator) => is_object_type(T) && !is_array_of_unknown_bound(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.iterators"
source_module = "[optional.ref.iterators]/3"
tags = ['optional', 'iterator', 'reference', 'constraint']

[[axioms]]
id = "cpp20_optional_ctor_deleted_no_temporary_c6d7e8f9"
content = '''Constructor optional<T&>(U&&) is deleted if reference_constructs_from_temporary_v<T&, U> is true.'''
formal_spec = '''reference_constructs_from_temporary_v<T&, U> => deleted(optional<T&>::optional(U&&))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.ref.ctor"
source_module = "[optional.ref.ctor]/7"
tags = ['optional', 'reference', 'constructor', 'deleted', 'dangling']

[[axioms]]
id = "cpp20_optional_assign_exception_has_value_unchanged_d7e8f9a0"
content = '''If any exception is thrown during optional copy assignment, the result of has_value() remains unchanged.'''
formal_spec = '''exception_thrown_during(optional<T>::operator=(rhs)) => has_value(this) == has_value_before(this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.assign"
source_module = "[optional.assign]/7"
tags = ['optional', 'exception_safety', 'assignment']

[[axioms]]
id = "cpp20_optional_assign_move_exception_has_value_unchanged_e8f9a0b1"
content = '''If any exception is thrown during optional move assignment, the result of has_value() remains unchanged.'''
formal_spec = '''exception_thrown_during(optional<T>::operator=(std::move(rhs))) => has_value(this) == has_value_before(this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.assign"
source_module = "[optional.assign]/13"
tags = ['optional', 'exception_safety', 'assignment', 'move']

[[axioms]]
id = "cpp20_optional_swap_exception_has_value_unchanged_f9a0b1c2"
content = '''If any exception is thrown during optional swap, the results of has_value() for both optionals remain unchanged.'''
formal_spec = '''exception_thrown_during(optional<T>::swap(rhs)) => has_value(this) == has_value_before(this) && has_value(rhs) == has_value_before(rhs)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "optional.swap"
source_module = "[optional.swap]/6"
tags = ['optional', 'exception_safety', 'swap']

[[axioms]]
id = "cpp20_variant_general_destructible_req_a1b2c3d4"
content = '''All types in a variant's template argument list must meet the Cpp17Destructible requirements.'''
formal_spec = '''forall T in Types: Cpp17Destructible(T)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/2"
tags = ['variant', 'requirements', 'destructible']

[[axioms]]
id = "cpp20_variant_no_template_args_illformed_b2c3d4e5"
content = '''A program that instantiates variant with no template arguments is ill-formed.'''
formal_spec = '''sizeof...(Types) == 0 && instantiate_definition(variant<Types...>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/3"
tags = ['variant', 'constraint', 'ill-formed']

[[axioms]]
id = "cpp20_variant_explicit_specialization_illformed_c3d4e5f6"
content = '''If a program declares an explicit or partial specialization of variant, the program is ill-formed, no diagnostic required.'''
formal_spec = '''(explicit_specialization(variant) || partial_specialization(variant)) => ill_formed_ndr'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.variant.general"
source_module = "[variant.variant.general]/4"
tags = ['variant', 'specialization', 'ill-formed', 'ndr']

[[axioms]]
id = "cpp20_variant_get_index_precondition_d4e5f6a7"
content = '''The GET exposition-only function template requires that the variant's index matches the requested index I.'''
formal_spec = '''GET<I>(v) => precondition(v.index() == I)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/4"
tags = ['variant', 'get', 'precondition', 'value-access']

[[axioms]]
id = "cpp20_variant_get_wrong_index_throws_e5f6a7b8"
content = '''Calling get<I> on a variant where v.index() != I throws bad_variant_access.'''
formal_spec = '''get<I>(v) && v.index() != I => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/7"
tags = ['variant', 'get', 'exception', 'bad_variant_access']

[[axioms]]
id = "cpp20_variant_get_type_wrong_throws_f6a7b8c9"
content = '''Calling get<T> on a variant that does not hold a value of type T throws bad_variant_access.'''
formal_spec = '''get<T>(v) && !holds_alternative<T>(v) => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/9"
tags = ['variant', 'get', 'exception', 'bad_variant_access']

[[axioms]]
id = "cpp20_variant_visit_valueless_throws_a7b8c9d1"
content = '''visit throws bad_variant_access if any of the variant arguments is valueless by exception.'''
formal_spec = '''visit(vis, vars...) && exists v in vars: v.valueless_by_exception() => throws(bad_variant_access)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.visit"
source_module = "[variant.visit]/7"
tags = ['variant', 'visit', 'exception', 'bad_variant_access', 'valueless']

[[axioms]]
id = "cpp20_variant_swap_precondition_swappable_b8c9d1e2"
content = '''Each type Ti in a variant must meet the Cpp17Swappable requirements for swap to be valid.'''
formal_spec = '''variant<Types...>::swap(rhs) => forall Ti in Types: Cpp17Swappable(Ti)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.swap"
source_module = "[variant.swap]/2"
tags = ['variant', 'swap', 'precondition', 'swappable']

[[axioms]]
id = "cpp20_variant_emplace_exception_valueless_c9d1e2f3"
content = '''If an exception is thrown during emplace initialization, the variant is permitted to not hold a value (become valueless).'''
formal_spec = '''emplace<I>(args...) && exception_thrown_during_init => permitted(valueless_by_exception())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/11"
tags = ['variant', 'emplace', 'exception', 'valueless']

[[axioms]]
id = "cpp20_variant_assign_exception_valueless_d1e2f3a4"
content = '''If an exception is thrown during type-changing assignment initialization, the variant object is permitted to not hold a value.'''
formal_spec = '''operator=(t) && type_changing && exception_thrown_during_init => permitted(valueless_by_exception())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/16.2"
tags = ['variant', 'assignment', 'exception', 'valueless']

[[axioms]]
id = "cpp20_variant_move_assign_exception_valueless_e2f3a4b5"
content = '''If an exception is thrown during Tj's move construction in move assignment, the variant will hold no value.'''
formal_spec = '''operator=(std::move(rhs)) && exception_thrown_during_move_construction(Tj) => valueless_by_exception()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.assign"
source_module = "[variant.assign]/10.1"
tags = ['variant', 'move-assignment', 'exception', 'valueless']

[[axioms]]
id = "cpp20_variant_alternative_index_mandates_f3a4b5c6"
content = '''variant_alternative<I, variant<Types...>> mandates that I < sizeof...(Types).'''
formal_spec = '''variant_alternative<I, variant<Types...>> => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.helper"
source_module = "[variant.helper]/4"
tags = ['variant', 'variant_alternative', 'mandates', 'constraint']

[[axioms]]
id = "cpp20_variant_get_index_mandates_a4b5c6d7"
content = '''get<I> for variant mandates that I < sizeof...(Types).'''
formal_spec = '''get<I>(variant<Types...>) => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/6"
tags = ['variant', 'get', 'mandates', 'constraint']

[[axioms]]
id = "cpp20_variant_get_type_mandates_unique_b5c6d7e8"
content = '''get<T> for variant mandates that type T occurs exactly once in Types.'''
formal_spec = '''get<T>(variant<Types...>) => mandates(count(T, Types...) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/8"
tags = ['variant', 'get', 'mandates', 'constraint', 'unique-type']

[[axioms]]
id = "cpp20_variant_holds_alternative_mandates_c6d7e8f9"
content = '''holds_alternative<T> mandates that type T occurs exactly once in Types.'''
formal_spec = '''holds_alternative<T>(variant<Types...>) => mandates(count(T, Types...) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/1"
tags = ['variant', 'holds_alternative', 'mandates', 'constraint']

[[axioms]]
id = "cpp20_variant_emplace_index_mandates_d7e8f9a1"
content = '''emplace<I> mandates that I < sizeof...(Types).'''
formal_spec = '''variant::emplace<I>(args...) => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/5"
tags = ['variant', 'emplace', 'mandates', 'constraint']

[[axioms]]
id = "cpp20_variant_swap_mandates_move_constructible_e8f9a1b2"
content = '''variant::swap mandates that is_move_constructible_v<Ti> is true for all i.'''
formal_spec = '''variant::swap(rhs) => mandates(forall Ti in Types: is_move_constructible_v<Ti>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.swap"
source_module = "[variant.swap]/1"
tags = ['variant', 'swap', 'mandates', 'move-constructible']

[[axioms]]
id = "cpp20_variant_visit_all_expr_same_type_f9a1b2c3"
content = '''For visit, all invocation expressions e(m) for valid packs m must be of the same type and value category.'''
formal_spec = '''visit(vis, vars...) => forall valid m1, m2: same_type_and_category(e(m1), e(m2))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.visit"
source_module = "[variant.visit]/5"
tags = ['variant', 'visit', 'mandates', 'type-consistency']

[[axioms]]
id = "cpp20_variant_in_place_type_unique_a1b2c3d5"
content = '''The in_place_type_t<T> constructor mandates that T occurs exactly once in Types.'''
formal_spec = '''variant(in_place_type_t<T>, args...) => constraint(count(T, Types...) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/20.1"
tags = ['variant', 'constructor', 'constraint', 'unique-type']

[[axioms]]
id = "cpp20_variant_in_place_index_bound_b2c3d4e6"
content = '''The in_place_index_t<I> constructor constrains I to be less than sizeof...(Types).'''
formal_spec = '''variant(in_place_index_t<I>, args...) => constraint(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.ctor"
source_module = "[variant.ctor]/30.1"
tags = ['variant', 'constructor', 'constraint', 'index-bound']

[[axioms]]
id = "cpp20_variant_emplace_type_unique_c3d4e5f7"
content = '''emplace<T> constrains that T occurs exactly once in Types.'''
formal_spec = '''variant::emplace<T>(args...) => constraint(count(T, Types...) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.mod"
source_module = "[variant.mod]/1"
tags = ['variant', 'emplace', 'constraint', 'unique-type']

[[axioms]]
id = "cpp20_variant_get_if_index_mandates_d4e5f6a8"
content = '''get_if<I> mandates that I < sizeof...(Types).'''
formal_spec = '''get_if<I>(variant<Types...>*) => mandates(I < sizeof...(Types))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/10"
tags = ['variant', 'get_if', 'mandates', 'constraint']

[[axioms]]
id = "cpp20_variant_get_if_type_mandates_unique_e5f6a7b9"
content = '''get_if<T> mandates that type T occurs exactly once in Types.'''
formal_spec = '''get_if<T>(variant<Types...>*) => mandates(count(T, Types...) == 1)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "variant.get"
source_module = "[variant.get]/12"
tags = ['variant', 'get_if', 'mandates', 'constraint', 'unique-type']

[[axioms]]
id = "cpp20_any_cons_template_copy_constructible_precond_7a3b2c1d"
content = '''When constructing std::any from a value of type T, decay_t<T> must meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''any(T&& value) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/7"
tags = ['any', 'construction', 'precondition', 'copy_constructible']

[[axioms]]
id = "cpp20_any_cons_inplace_copy_constructible_precond_8b4c3d2e"
content = '''When constructing std::any with in_place_type_t<T>, decay_t<T> must meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''any(in_place_type_t<T>, Args&&...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/12"
tags = ['any', 'construction', 'precondition', 'copy_constructible', 'in_place']

[[axioms]]
id = "cpp20_any_cons_inplace_initlist_copy_constructible_precond_9c5d4e3f"
content = '''When constructing std::any with in_place_type_t<T> and initializer_list, decay_t<T> must meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''any(in_place_type_t<T>, initializer_list<U>, Args&&...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/18"
tags = ['any', 'construction', 'precondition', 'copy_constructible', 'in_place', 'initializer_list']

[[axioms]]
id = "cpp20_any_assign_template_copy_constructible_precond_a1b2c3d4"
content = '''When assigning a value of type T to std::any, decay_t<T> must meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''any::operator=(T&& rhs) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/9"
tags = ['any', 'assignment', 'precondition', 'copy_constructible']

[[axioms]]
id = "cpp20_any_emplace_copy_constructible_precond_b2c3d4e5"
content = '''When calling emplace<T> on std::any, decay_t<T> must meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''any::emplace<T>(Args&&...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/3"
tags = ['any', 'emplace', 'precondition', 'copy_constructible']

[[axioms]]
id = "cpp20_any_emplace_initlist_copy_constructible_precond_c3d4e5f6"
content = '''When calling emplace<T> with initializer_list on std::any, decay_t<T> must meet the Cpp17CopyConstructible requirements.'''
formal_spec = '''any::emplace<T>(initializer_list<U>, Args&&...) => Cpp17CopyConstructible(decay_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/11"
tags = ['any', 'emplace', 'precondition', 'copy_constructible', 'initializer_list']

[[axioms]]
id = "cpp20_any_cast_ref_type_mismatch_throws_d4e5f6a7"
content = '''any_cast on a reference type throws bad_any_cast if the operand does not contain a value of the requested type.'''
formal_spec = '''any_cast<T>(any& operand) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = ['any', 'any_cast', 'exception', 'type_safety', 'bad_any_cast']

[[axioms]]
id = "cpp20_any_cast_const_ref_type_mismatch_throws_e5f6a7b8"
content = '''any_cast on a const reference type throws bad_any_cast if the operand does not contain a value of the requested type.'''
formal_spec = '''any_cast<T>(const any& operand) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = ['any', 'any_cast', 'exception', 'type_safety', 'bad_any_cast']

[[axioms]]
id = "cpp20_any_cast_rvalue_ref_type_mismatch_throws_f6a7b8c9"
content = '''any_cast on an rvalue reference type throws bad_any_cast if the operand does not contain a value of the requested type.'''
formal_spec = '''any_cast<T>(any&& operand) && operand.type() != typeid(remove_reference_t<T>) => throws(bad_any_cast)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/7"
tags = ['any', 'any_cast', 'exception', 'type_safety', 'bad_any_cast']

[[axioms]]
id = "cpp20_any_cast_ptr_void_forbidden_a7b8c9d0"
content = '''any_cast to pointer type shall not use void as the template argument T.'''
formal_spec = '''any_cast<T>(any*) || any_cast<T>(const any*) => is_void_v<T> == false'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/9"
tags = ['any', 'any_cast', 'constraint', 'void', 'pointer']

[[axioms]]
id = "cpp20_any_cast_const_ref_constructible_mandates_b8c9d0e1"
content = '''any_cast<T>(const any&) mandates that is_constructible_v<T, const U&> is true where U is remove_cvref_t<T>.'''
formal_spec = '''any_cast<T>(const any&) => is_constructible_v<T, const remove_cvref_t<T>&> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = ['any', 'any_cast', 'constraint', 'constructible']

[[axioms]]
id = "cpp20_any_cast_lvalue_ref_constructible_mandates_c9d0e1f2"
content = '''any_cast<T>(any&) mandates that is_constructible_v<T, U&> is true where U is remove_cvref_t<T>.'''
formal_spec = '''any_cast<T>(any&) => is_constructible_v<T, remove_cvref_t<T>&> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = ['any', 'any_cast', 'constraint', 'constructible']

[[axioms]]
id = "cpp20_any_cast_rvalue_constructible_mandates_d0e1f2a3"
content = '''any_cast<T>(any&&) mandates that is_constructible_v<T, U> is true where U is remove_cvref_t<T>.'''
formal_spec = '''any_cast<T>(any&&) => is_constructible_v<T, remove_cvref_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.nonmembers"
source_module = "[any.nonmembers]/5"
tags = ['any', 'any_cast', 'constraint', 'constructible']

[[axioms]]
id = "cpp20_any_small_object_nothrow_move_e1f2a3b4"
content = '''Small-object optimization for std::any shall only be applied to types T for which is_nothrow_move_constructible_v<T> is true.'''
formal_spec = '''any_small_object_optimization(T) => is_nothrow_move_constructible_v<T> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.class.general"
source_module = "[any.class.general]/3"
tags = ['any', 'optimization', 'small_object', 'nothrow', 'move_constructible']

[[axioms]]
id = "cpp20_any_cons_template_not_any_constraint_f2a3b4c5"
content = '''The template constructor any(T&&) is constrained such that decay_t<T> is not the same type as any.'''
formal_spec = '''any(T&& value) => !is_same_v<decay_t<T>, any>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/6"
tags = ['any', 'construction', 'constraint', 'sfinae']

[[axioms]]
id = "cpp20_any_cons_template_not_inplace_constraint_a3b4c5d6"
content = '''The template constructor any(T&&) is constrained such that decay_t<T> is not a specialization of in_place_type_t.'''
formal_spec = '''any(T&& value) => !is_specialization_of<decay_t<T>, in_place_type_t>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/6"
tags = ['any', 'construction', 'constraint', 'sfinae', 'in_place']

[[axioms]]
id = "cpp20_any_cons_template_copyable_constraint_b4c5d6e7"
content = '''The template constructor any(T&&) is constrained such that is_copy_constructible_v<decay_t<T>> is true.'''
formal_spec = '''any(T&& value) => is_copy_constructible_v<decay_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/6"
tags = ['any', 'construction', 'constraint', 'copy_constructible']

[[axioms]]
id = "cpp20_any_cons_inplace_copyable_constraint_c5d6e7f8"
content = '''The in_place_type_t constructor any(in_place_type_t<T>, Args&&...) is constrained such that is_copy_constructible_v<decay_t<T>> is true.'''
formal_spec = '''any(in_place_type_t<T>, Args&&...) => is_copy_constructible_v<decay_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/11"
tags = ['any', 'construction', 'constraint', 'copy_constructible', 'in_place']

[[axioms]]
id = "cpp20_any_cons_inplace_constructible_constraint_d6e7f8a9"
content = '''The in_place_type_t constructor any(in_place_type_t<T>, Args&&...) is constrained such that is_constructible_v<decay_t<T>, Args...> is true.'''
formal_spec = '''any(in_place_type_t<T>, Args&&...) => is_constructible_v<decay_t<T>, Args...> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/11"
tags = ['any', 'construction', 'constraint', 'constructible', 'in_place']

[[axioms]]
id = "cpp20_any_cons_inplace_initlist_copyable_constraint_e7f8a9b0"
content = '''The in_place_type_t constructor with initializer_list is constrained such that is_copy_constructible_v<decay_t<T>> is true.'''
formal_spec = '''any(in_place_type_t<T>, initializer_list<U>, Args&&...) => is_copy_constructible_v<decay_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/17"
tags = ['any', 'construction', 'constraint', 'copy_constructible', 'in_place', 'initializer_list']

[[axioms]]
id = "cpp20_any_cons_inplace_initlist_constructible_constraint_f8a9b0c1"
content = '''The in_place_type_t constructor with initializer_list is constrained such that is_constructible_v<decay_t<T>, initializer_list<U>&, Args...> is true.'''
formal_spec = '''any(in_place_type_t<T>, initializer_list<U>, Args&&...) => is_constructible_v<decay_t<T>, initializer_list<U>&, Args...> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.cons"
source_module = "[any.cons]/17"
tags = ['any', 'construction', 'constraint', 'constructible', 'in_place', 'initializer_list']

[[axioms]]
id = "cpp20_any_assign_template_not_any_constraint_a9b0c1d2"
content = '''The template assignment operator=(T&&) is constrained such that decay_t<T> is not the same type as any.'''
formal_spec = '''any::operator=(T&& rhs) => !is_same_v<decay_t<T>, any>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/8"
tags = ['any', 'assignment', 'constraint', 'sfinae']

[[axioms]]
id = "cpp20_any_assign_template_copyable_constraint_b0c1d2e3"
content = '''The template assignment operator=(T&&) is constrained such that is_copy_constructible_v<decay_t<T>> is true.'''
formal_spec = '''any::operator=(T&& rhs) => is_copy_constructible_v<decay_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/8"
tags = ['any', 'assignment', 'constraint', 'copy_constructible']

[[axioms]]
id = "cpp20_any_emplace_copyable_constraint_c1d2e3f4"
content = '''The emplace<T>(Args&&...) member function is constrained such that is_copy_constructible_v<decay_t<T>> is true.'''
formal_spec = '''any::emplace<T>(Args&&...) => is_copy_constructible_v<decay_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/2"
tags = ['any', 'emplace', 'constraint', 'copy_constructible']

[[axioms]]
id = "cpp20_any_emplace_constructible_constraint_d2e3f4a5"
content = '''The emplace<T>(Args&&...) member function is constrained such that is_constructible_v<decay_t<T>, Args...> is true.'''
formal_spec = '''any::emplace<T>(Args&&...) => is_constructible_v<decay_t<T>, Args...> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/2"
tags = ['any', 'emplace', 'constraint', 'constructible']

[[axioms]]
id = "cpp20_any_emplace_initlist_copyable_constraint_e3f4a5b6"
content = '''The emplace<T>(initializer_list<U>, Args&&...) member function is constrained such that is_copy_constructible_v<decay_t<T>> is true.'''
formal_spec = '''any::emplace<T>(initializer_list<U>, Args&&...) => is_copy_constructible_v<decay_t<T>> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/10"
tags = ['any', 'emplace', 'constraint', 'copy_constructible', 'initializer_list']

[[axioms]]
id = "cpp20_any_emplace_initlist_constructible_constraint_f4a5b6c7"
content = '''The emplace<T>(initializer_list<U>, Args&&...) member function is constrained such that is_constructible_v<decay_t<T>, initializer_list<U>&, Args...> is true.'''
formal_spec = '''any::emplace<T>(initializer_list<U>, Args&&...) => is_constructible_v<decay_t<T>, initializer_list<U>&, Args...> == true'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/10"
tags = ['any', 'emplace', 'constraint', 'constructible', 'initializer_list']

[[axioms]]
id = "cpp20_any_emplace_exception_no_value_a5b6c7d8"
content = '''If an exception is thrown during emplace construction, the any object does not contain a value and any previously contained value has been destroyed.'''
formal_spec = '''any::emplace<T>(Args&&...) throws exception => !has_value() && previous_value_destroyed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/8"
tags = ['any', 'emplace', 'exception', 'state', 'invariant']

[[axioms]]
id = "cpp20_any_emplace_initlist_exception_no_value_b6c7d8e9"
content = '''If an exception is thrown during emplace with initializer_list construction, the any object does not contain a value and any previously contained value has been destroyed.'''
formal_spec = '''any::emplace<T>(initializer_list<U>, Args&&...) throws exception => !has_value() && previous_value_destroyed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.modifiers"
source_module = "[any.modifiers]/16"
tags = ['any', 'emplace', 'exception', 'state', 'invariant', 'initializer_list']

[[axioms]]
id = "cpp20_any_copy_assign_no_effect_on_exception_c7d8e9f0"
content = '''Copy assignment operator=(const any&) has no effects if an exception is thrown.'''
formal_spec = '''any::operator=(const any& rhs) throws exception => state_unchanged(*this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/1"
tags = ['any', 'assignment', 'exception', 'strong_guarantee']

[[axioms]]
id = "cpp20_any_template_assign_no_effect_on_exception_d8e9f0a1"
content = '''Template assignment operator=(T&&) has no effects if an exception is thrown.'''
formal_spec = '''any::operator=(T&& rhs) throws exception => state_unchanged(*this)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "any.assign"
source_module = "[any.assign]/10"
tags = ['any', 'assignment', 'exception', 'strong_guarantee']

[[axioms]]
id = "cpp20_expected_un_general_illformed_types_a1b2c3d4"
content = '''A program that instantiates the definition of unexpected for a non-object type, an array type, a specialization of unexpected, or a cv-qualified type is ill-formed.'''
formal_spec = '''instantiate_unexpected<E> && (is_non_object_type(E) || is_array_type(E) || is_specialization_of_unexpected(E) || is_cv_qualified(E)) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.general"
source_module = "[expected.un.general]/2"
tags = ['unexpected', 'template', 'constraint', 'ill-formed']

[[axioms]]
id = "cpp20_expected_object_general_valid_value_type_e5f6g7h8"
content = '''A type T is a valid value type for expected if remove_cv_t<T> is void or a complete non-array object type that is not in_place_t, unexpect_t, or a specialization of unexpected. Instantiating expected<T, E> with an invalid T is ill-formed.'''
formal_spec = '''instantiate_expected<T, E> && !valid_value_type_for_expected(T) => ill_formed where valid_value_type_for_expected(T) := (is_void_v<remove_cv_t<T>> || (is_complete_object_type(remove_cv_t<T>) && !is_array_type(remove_cv_t<T>) && !is_same_v<remove_cv_t<T>, in_place_t> && !is_same_v<remove_cv_t<T>, unexpect_t> && !is_specialization_of_unexpected(remove_cv_t<T>)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/2"
tags = ['expected', 'template', 'constraint', 'ill-formed']

[[axioms]]
id = "cpp20_expected_object_general_invalid_error_type_i9j0k1l2"
content = '''A program that instantiates the definition of expected<T, E> with a type for E that is not a valid template argument for unexpected is ill-formed.'''
formal_spec = '''instantiate_expected<T, E> && !valid_template_arg_for_unexpected(E) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/2"
tags = ['expected', 'template', 'constraint', 'ill-formed']

[[axioms]]
id = "cpp20_expected_object_general_t_destructible_m3n4o5p6"
content = '''When T is not cv void, T shall meet the Cpp17Destructible requirements for expected<T, E>.'''
formal_spec = '''instantiate_expected<T, E> && !is_void_v<T> => Cpp17Destructible<T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/3"
tags = ['expected', 'template', 'constraint', 'destructible']

[[axioms]]
id = "cpp20_expected_object_general_e_destructible_q7r8s9t0"
content = '''E shall meet the Cpp17Destructible requirements for expected<T, E>.'''
formal_spec = '''instantiate_expected<T, E> => Cpp17Destructible<E>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.general"
source_module = "[expected.object.general]/3"
tags = ['expected', 'template', 'constraint', 'destructible']

[[axioms]]
id = "cpp20_expected_object_obs_arrow_precondition_u1v2w3x4"
content = '''Calling operator-> on expected<T, E> has a hardened precondition that has_value() is true.'''
formal_spec = '''expected_arrow_op(exp) && !exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/1"
tags = ['expected', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_expected_object_obs_deref_precondition_y5z6a7b8"
content = '''Calling operator* on expected<T, E> (lvalue reference overloads) has a hardened precondition that has_value() is true.'''
formal_spec = '''expected_deref_op_lref(exp) && !exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/3"
tags = ['expected', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_expected_object_obs_deref_rvalue_precondition_c9d0e1f2"
content = '''Calling operator* on expected<T, E> (rvalue reference overloads) has a hardened precondition that has_value() is true.'''
formal_spec = '''expected_deref_op_rref(exp) && !exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/5"
tags = ['expected', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_expected_object_obs_value_throws_g3h4i5j6"
content = '''Calling value() on expected<T, E> throws bad_expected_access(error()) if has_value() is false.'''
formal_spec = '''expected_value(exp) && !exp.has_value() => throws(bad_expected_access(exp.error()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/10"
tags = ['expected', 'observer', 'exception', 'bad_expected_access']

[[axioms]]
id = "cpp20_expected_object_obs_value_rvalue_throws_k7l8m9n0"
content = '''Calling value() on expected<T, E>&& throws bad_expected_access(std::move(error())) if has_value() is false.'''
formal_spec = '''expected_value_rref(exp) && !exp.has_value() => throws(bad_expected_access(std::move(exp.error())))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/13"
tags = ['expected', 'observer', 'exception', 'bad_expected_access']

[[axioms]]
id = "cpp20_expected_object_obs_error_precondition_o1p2q3r4"
content = '''Calling error() on expected<T, E> (lvalue reference overloads) has a hardened precondition that has_value() is false.'''
formal_spec = '''expected_error_lref(exp) && exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/14"
tags = ['expected', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_expected_object_obs_error_rvalue_precondition_s5t6u7v8"
content = '''Calling error() on expected<T, E> (rvalue reference overloads) has a hardened precondition that has_value() is false.'''
formal_spec = '''expected_error_rref(exp) && exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/16"
tags = ['expected', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_expected_void_general_e_valid_template_w9x0y1z2"
content = '''A program that instantiates the definition of expected<T, E> (void specialization) with a type for E that is not a valid template argument for unexpected is ill-formed.'''
formal_spec = '''instantiate_expected_void<T, E> && is_void_v<T> && !valid_template_arg_for_unexpected(E) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.general"
source_module = "[expected.void.general]/2"
tags = ['expected', 'void', 'template', 'constraint', 'ill-formed']

[[axioms]]
id = "cpp20_expected_void_general_e_destructible_a3b4c5d6"
content = '''E shall meet the requirements of Cpp17Destructible for expected<T, E> void specialization.'''
formal_spec = '''instantiate_expected_void<T, E> && is_void_v<T> => Cpp17Destructible<E>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.general"
source_module = "[expected.void.general]/3"
tags = ['expected', 'void', 'template', 'constraint', 'destructible']

[[axioms]]
id = "cpp20_expected_void_obs_value_throws_e7f8g9h0"
content = '''Calling value() on expected<void, E> throws bad_expected_access<void>() if has_value() is false.'''
formal_spec = '''expected_void_value(exp) && !exp.has_value() => throws(bad_expected_access<void>())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/5"
tags = ['expected', 'void', 'observer', 'exception', 'bad_expected_access']

[[axioms]]
id = "cpp20_expected_void_obs_error_precondition_i1j2k3l4"
content = '''Calling error() on expected<void, E> (lvalue reference overloads) has a hardened precondition that has_value() is false.'''
formal_spec = '''expected_void_error_lref(exp) && exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/7"
tags = ['expected', 'void', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_expected_void_obs_error_rvalue_precondition_m5n6o7p8"
content = '''Calling error() on expected<void, E> (rvalue reference overloads) has a hardened precondition that has_value() is false.'''
formal_spec = '''expected_void_error_rref(exp) && exp.has_value() => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/9"
tags = ['expected', 'void', 'observer', 'precondition', 'hardened']

[[axioms]]
id = "cpp20_unexpected_swap_mandates_swappable_q9r0s1t2"
content = '''The swap member function of unexpected<E> mandates that is_swappable_v<E> is true.'''
formal_spec = '''unexpected_swap(u) && !is_swappable_v<E> => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.swap"
source_module = "[expected.un.swap]/1"
tags = ['unexpected', 'swap', 'mandates']

[[axioms]]
id = "cpp20_unexpected_eq_mandates_well_formed_u3v4w5x6"
content = '''The equality operator for unexpected requires that the expression x.error() == y.error() is well-formed and its result is convertible to bool.'''
formal_spec = '''unexpected_eq(x, y) && (!well_formed(x.error() == y.error()) || !is_convertible_v<decltype(x.error() == y.error()), bool>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.un.eq"
source_module = "[expected.un.eq]/1"
tags = ['unexpected', 'equality', 'mandates']

[[axioms]]
id = "cpp20_bad_expected_access_purpose_y7z8a9b0"
content = '''bad_expected_access<E> is thrown when attempting to access the value of an expected<T, E> object for which has_value() is false.'''
formal_spec = '''access_expected_value(exp) && !exp.has_value() => throws(bad_expected_access<E>(exp.error()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.bad"
source_module = "[expected.bad]/1"
tags = ['bad_expected_access', 'exception', 'expected']

[[axioms]]
id = "cpp20_expected_object_value_mandates_copy_constructible_c1d2e3f4"
content = '''The value() const& and value()& member functions of expected<T, E> mandate that is_copy_constructible_v<E> is true.'''
formal_spec = '''expected_value_lref(exp) && !is_copy_constructible_v<E> => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/8"
tags = ['expected', 'observer', 'mandates', 'value']

[[axioms]]
id = "cpp20_expected_object_value_rvalue_mandates_g5h6i7j8"
content = '''The value()&& and value() const&& member functions of expected<T, E> mandate that is_copy_constructible_v<E> is true and is_constructible_v<E, decltype(std::move(error()))> is true.'''
formal_spec = '''expected_value_rref(exp) && (!is_copy_constructible_v<E> || !is_constructible_v<E, decltype(std::move(exp.error()))>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/11"
tags = ['expected', 'observer', 'mandates', 'value']

[[axioms]]
id = "cpp20_expected_object_value_or_const_mandates_k9l0m1n2"
content = '''The value_or(U&&) const& member function mandates that is_copy_constructible_v<T> is true and is_convertible_v<U, T> is true.'''
formal_spec = '''expected_value_or_const_lref(exp, v) && (!is_copy_constructible_v<T> || !is_convertible_v<U, T>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/18"
tags = ['expected', 'observer', 'mandates', 'value_or']

[[axioms]]
id = "cpp20_expected_object_value_or_rvalue_mandates_o3p4q5r6"
content = '''The value_or(U&&)&& member function mandates that is_move_constructible_v<T> is true and is_convertible_v<U, T> is true.'''
formal_spec = '''expected_value_or_rref(exp, v) && (!is_move_constructible_v<T> || !is_convertible_v<U, T>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/20"
tags = ['expected', 'observer', 'mandates', 'value_or']

[[axioms]]
id = "cpp20_expected_object_error_or_const_mandates_s7t8u9v0"
content = '''The error_or(G&&) const& member function mandates that is_copy_constructible_v<E> is true and is_convertible_v<G, E> is true.'''
formal_spec = '''expected_error_or_const_lref(exp, e) && (!is_copy_constructible_v<E> || !is_convertible_v<G, E>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/22"
tags = ['expected', 'observer', 'mandates', 'error_or']

[[axioms]]
id = "cpp20_expected_object_error_or_rvalue_mandates_w1x2y3z4"
content = '''The error_or(G&&)&& member function mandates that is_move_constructible_v<E> is true and is_convertible_v<G, E> is true.'''
formal_spec = '''expected_error_or_rref(exp, e) && (!is_move_constructible_v<E> || !is_convertible_v<G, E>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.obs"
source_module = "[expected.object.obs]/24"
tags = ['expected', 'observer', 'mandates', 'error_or']

[[axioms]]
id = "cpp20_expected_object_monadic_and_then_mandates_a5b6c7d8"
content = '''The and_then member functions mandate that the result type U is a specialization of expected and is_same_v<typename U::error_type, E> is true.'''
formal_spec = '''expected_and_then(exp, f) && (!is_specialization_of_expected(U) || !is_same_v<typename_U_error_type, E>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/3"
tags = ['expected', 'monadic', 'and_then', 'mandates']

[[axioms]]
id = "cpp20_expected_object_monadic_or_else_mandates_e9f0g1h2"
content = '''The or_else member functions mandate that the result type G is a specialization of expected and is_same_v<typename G::value_type, T> is true.'''
formal_spec = '''expected_or_else(exp, f) && (!is_specialization_of_expected(G) || !is_same_v<typename_G_value_type, T>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/11"
tags = ['expected', 'monadic', 'or_else', 'mandates']

[[axioms]]
id = "cpp20_expected_object_monadic_transform_mandates_i3j4k5l6"
content = '''The transform member functions mandate that U is a valid value type for expected. If is_void_v<U> is false, the declaration U u(invoke(std::forward<F>(f), val)) must be well-formed.'''
formal_spec = '''expected_transform(exp, f) && (!valid_value_type_for_expected(U) || (!is_void_v<U> && !well_formed_declaration(U, invoke(f, val)))) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/19"
tags = ['expected', 'monadic', 'transform', 'mandates']

[[axioms]]
id = "cpp20_expected_object_monadic_transform_error_mandates_m7n8o9p0"
content = '''The transform_error member functions mandate that G is a valid template argument for unexpected and the declaration G g(invoke(std::forward<F>(f), error())) is well-formed.'''
formal_spec = '''expected_transform_error(exp, f) && (!valid_template_arg_for_unexpected(G) || !well_formed_declaration(G, invoke(f, error()))) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.object.monadic"
source_module = "[expected.object.monadic]/27"
tags = ['expected', 'monadic', 'transform_error', 'mandates']

[[axioms]]
id = "cpp20_expected_void_obs_error_or_const_mandates_q1r2s3t4"
content = '''The error_or(G&&) const& member function for expected<void, E> mandates that is_copy_constructible_v<E> is true and is_convertible_v<G, E> is true.'''
formal_spec = '''expected_void_error_or_const_lref(exp, e) && (!is_copy_constructible_v<E> || !is_convertible_v<G, E>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/11"
tags = ['expected', 'void', 'observer', 'mandates', 'error_or']

[[axioms]]
id = "cpp20_expected_void_obs_error_or_rvalue_mandates_u5v6w7x8"
content = '''The error_or(G&&)&& member function for expected<void, E> mandates that is_move_constructible_v<E> is true and is_convertible_v<G, E> is true.'''
formal_spec = '''expected_void_error_or_rref(exp, e) && (!is_move_constructible_v<E> || !is_convertible_v<G, E>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.obs"
source_module = "[expected.void.obs]/13"
tags = ['expected', 'void', 'observer', 'mandates', 'error_or']

[[axioms]]
id = "cpp20_expected_void_monadic_and_then_mandates_y9z0a1b2"
content = '''The and_then member functions for expected<void, E> mandate that the result type U is a specialization of expected and is_same_v<typename U::error_type, E> is true.'''
formal_spec = '''expected_void_and_then(exp, f) && (!is_specialization_of_expected(U) || !is_same_v<typename_U_error_type, E>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/3"
tags = ['expected', 'void', 'monadic', 'and_then', 'mandates']

[[axioms]]
id = "cpp20_expected_void_monadic_or_else_mandates_c3d4e5f6"
content = '''The or_else member functions for expected<void, E> mandate that the result type G is a specialization of expected and is_same_v<typename G::value_type, T> is true.'''
formal_spec = '''expected_void_or_else(exp, f) && (!is_specialization_of_expected(G) || !is_same_v<typename_G_value_type, T>) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/11"
tags = ['expected', 'void', 'monadic', 'or_else', 'mandates']

[[axioms]]
id = "cpp20_expected_void_monadic_transform_mandates_g7h8i9j0"
content = '''The transform member functions for expected<void, E> mandate that U is a valid value type for expected. If is_void_v<U> is false, the declaration U u(invoke(std::forward<F>(f))) must be well-formed.'''
formal_spec = '''expected_void_transform(exp, f) && (!valid_value_type_for_expected(U) || (!is_void_v<U> && !well_formed_declaration(U, invoke(f)))) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/19"
tags = ['expected', 'void', 'monadic', 'transform', 'mandates']

[[axioms]]
id = "cpp20_expected_void_monadic_transform_error_mandates_k1l2m3n4"
content = '''The transform_error member functions for expected<void, E> mandate that G is a valid template argument for unexpected and the declaration G g(invoke(std::forward<F>(f), error())) is well-formed.'''
formal_spec = '''expected_void_transform_error(exp, f) && (!valid_template_arg_for_unexpected(G) || !well_formed_declaration(G, invoke(f, error()))) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "expected.void.monadic"
source_module = "[expected.void.monadic]/27"
tags = ['expected', 'void', 'monadic', 'transform_error', 'mandates']

[[axioms]]
id = "cpp20_range_access_begin_rvalue_non_borrowed_illformed_a1b2c3d4"
content = '''Calling ranges::begin on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::begin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.1"
tags = ['ranges', 'begin', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_begin_incomplete_array_ndr_e5f6a7b8"
content = '''Calling ranges::begin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array<T> && is_incomplete<remove_all_extents_t<T>> => ill_formed_ndr(ranges::begin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.begin"
source_module = "[range.access.begin]/2.2"
tags = ['ranges', 'begin', 'array', 'incomplete_type', 'ndr']

[[axioms]]
id = "cpp20_range_access_end_rvalue_non_borrowed_illformed_c9d0e1f2"
content = '''Calling ranges::end on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::end(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.1"
tags = ['ranges', 'end', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_end_incomplete_array_ndr_g3h4i5j6"
content = '''Calling ranges::end on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array<T> && is_incomplete<remove_all_extents_t<T>> => ill_formed_ndr(ranges::end(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.2"
tags = ['ranges', 'end', 'array', 'incomplete_type', 'ndr']

[[axioms]]
id = "cpp20_range_access_end_unknown_bound_illformed_k7l8m9n0"
content = '''Calling ranges::end on an array of unknown bound is ill-formed.'''
formal_spec = '''is_array_unknown_bound<T> => ill_formed(ranges::end(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.end"
source_module = "[range.access.end]/2.3"
tags = ['ranges', 'end', 'array', 'unknown_bound', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_cbegin_rvalue_non_borrowed_illformed_o1p2q3r4"
content = '''Calling ranges::cbegin on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::cbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cbegin"
source_module = "[range.access.cbegin]/1.1"
tags = ['ranges', 'cbegin', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_cend_rvalue_non_borrowed_illformed_s5t6u7v8"
content = '''Calling ranges::cend on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::cend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.cend"
source_module = "[range.access.cend]/1.1"
tags = ['ranges', 'cend', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_rbegin_rvalue_non_borrowed_illformed_w9x0y1z2"
content = '''Calling ranges::rbegin on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::rbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.1"
tags = ['ranges', 'rbegin', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_rbegin_incomplete_array_ndr_a3b4c5d6"
content = '''Calling ranges::rbegin on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array<T> && is_incomplete<remove_all_extents_t<T>> => ill_formed_ndr(ranges::rbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/2.2"
tags = ['ranges', 'rbegin', 'array', 'incomplete_type', 'ndr']

[[axioms]]
id = "cpp20_range_access_rend_rvalue_non_borrowed_illformed_e7f8g9h0"
content = '''Calling ranges::rend on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::rend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.1"
tags = ['ranges', 'rend', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_rend_incomplete_array_ndr_i1j2k3l4"
content = '''Calling ranges::rend on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array<T> && is_incomplete<remove_all_extents_t<T>> => ill_formed_ndr(ranges::rend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.rend"
source_module = "[range.access.rend]/2.2"
tags = ['ranges', 'rend', 'array', 'incomplete_type', 'ndr']

[[axioms]]
id = "cpp20_range_access_crbegin_rvalue_non_borrowed_illformed_m5n6o7p8"
content = '''Calling ranges::crbegin on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::crbegin(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crbegin"
source_module = "[range.access.crbegin]/1.1"
tags = ['ranges', 'crbegin', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_crend_rvalue_non_borrowed_illformed_q9r0s1t2"
content = '''Calling ranges::crend on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::crend(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.access.crend"
source_module = "[range.access.crend]/1.1"
tags = ['ranges', 'crend', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_prim_size_unknown_bound_illformed_u3v4w5x6"
content = '''Calling ranges::size on an array of unknown bound is ill-formed.'''
formal_spec = '''is_array_unknown_bound<T> => ill_formed(ranges::size(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.size"
source_module = "[range.prim.size]/2.1"
tags = ['ranges', 'size', 'array', 'unknown_bound', 'ill-formed']

[[axioms]]
id = "cpp20_range_prim_empty_unknown_bound_illformed_y7z8a9b0"
content = '''Calling ranges::empty on an array of unknown bound is ill-formed.'''
formal_spec = '''is_array_unknown_bound<T> => ill_formed(ranges::empty(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/2.1"
tags = ['ranges', 'empty', 'array', 'unknown_bound', 'ill-formed']

[[axioms]]
id = "cpp20_range_prim_data_rvalue_non_borrowed_illformed_c1d2e3f4"
content = '''Calling ranges::data on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::data(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.1"
tags = ['ranges', 'data', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_prim_data_incomplete_array_ndr_g5h6i7j8"
content = '''Calling ranges::data on an array type where remove_all_extents_t<T> is an incomplete type is ill-formed with no diagnostic required.'''
formal_spec = '''is_array<T> && is_incomplete<remove_all_extents_t<T>> => ill_formed_ndr(ranges::data(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.data"
source_module = "[range.prim.data]/2.2"
tags = ['ranges', 'data', 'array', 'incomplete_type', 'ndr']

[[axioms]]
id = "cpp20_range_prim_cdata_rvalue_non_borrowed_illformed_k9l0m1n2"
content = '''Calling ranges::cdata on an rvalue expression E is ill-formed if enable_borrowed_range<remove_cv_t<T>> is false.'''
formal_spec = '''is_rvalue(E) && !enable_borrowed_range<remove_cv_t<decltype(E)>> => ill_formed(ranges::cdata(E))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.prim.cdata"
source_module = "[range.prim.cdata]/1.1"
tags = ['ranges', 'cdata', 'borrowed_range', 'ill-formed']

[[axioms]]
id = "cpp20_range_access_begin_valid_models_iterator_o3p4q5r6"
content = '''Whenever ranges::begin(E) is a valid expression, its type models input_or_output_iterator.'''
formal_spec = '''valid_expr(ranges::begin(E)) => models<input_or_output_iterator>(decltype(ranges::begin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.begin"
source_module = "[range.access.begin]/4"
tags = ['ranges', 'begin', 'iterator', 'constraint']

[[axioms]]
id = "cpp20_range_access_end_valid_models_sentinel_s7t8u9v0"
content = '''Whenever ranges::end(E) is a valid expression, the types S and I of ranges::end(E) and ranges::begin(E) model sentinel_for<S, I>.'''
formal_spec = '''valid_expr(ranges::end(E)) && valid_expr(ranges::begin(E)) => models<sentinel_for>(decltype(ranges::end(E)), decltype(ranges::begin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.end"
source_module = "[range.access.end]/4"
tags = ['ranges', 'end', 'sentinel', 'constraint']

[[axioms]]
id = "cpp20_range_access_cbegin_valid_models_constant_iterator_w1x2y3z4"
content = '''Whenever ranges::cbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator.'''
formal_spec = '''valid_expr(ranges::cbegin(E)) => models<input_or_output_iterator>(decltype(ranges::cbegin(E))) && models<constant_iterator>(decltype(ranges::cbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.cbegin"
source_module = "[range.access.cbegin]/2"
tags = ['ranges', 'cbegin', 'iterator', 'constant_iterator', 'constraint']

[[axioms]]
id = "cpp20_range_access_rbegin_valid_models_iterator_a5b6c7d8"
content = '''Whenever ranges::rbegin(E) is a valid expression, its type models input_or_output_iterator.'''
formal_spec = '''valid_expr(ranges::rbegin(E)) => models<input_or_output_iterator>(decltype(ranges::rbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.rbegin"
source_module = "[range.access.rbegin]/4"
tags = ['ranges', 'rbegin', 'iterator', 'constraint']

[[axioms]]
id = "cpp20_range_access_rend_valid_models_sentinel_e9f0g1h2"
content = '''Whenever ranges::rend(E) is a valid expression, the types S and I of ranges::rend(E) and ranges::rbegin(E) model sentinel_for<S, I>.'''
formal_spec = '''valid_expr(ranges::rend(E)) && valid_expr(ranges::rbegin(E)) => models<sentinel_for>(decltype(ranges::rend(E)), decltype(ranges::rbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.rend"
source_module = "[range.access.rend]/4"
tags = ['ranges', 'rend', 'sentinel', 'constraint']

[[axioms]]
id = "cpp20_range_access_crbegin_valid_models_constant_iterator_i3j4k5l6"
content = '''Whenever ranges::crbegin(E) is a valid expression, its type models input_or_output_iterator and constant-iterator.'''
formal_spec = '''valid_expr(ranges::crbegin(E)) => models<input_or_output_iterator>(decltype(ranges::crbegin(E))) && models<constant_iterator>(decltype(ranges::crbegin(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.access.crbegin"
source_module = "[range.access.crbegin]/2"
tags = ['ranges', 'crbegin', 'iterator', 'constant_iterator', 'constraint']

[[axioms]]
id = "cpp20_range_prim_size_valid_integer_like_m7n8o9p0"
content = '''Whenever ranges::size(E) is a valid expression, its type is integer-like.'''
formal_spec = '''valid_expr(ranges::size(E)) => is_integer_like(decltype(ranges::size(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.size"
source_module = "[range.prim.size]/4"
tags = ['ranges', 'size', 'integer_like', 'constraint']

[[axioms]]
id = "cpp20_range_prim_empty_valid_bool_q1r2s3t4"
content = '''Whenever ranges::empty(E) is a valid expression, it has type bool.'''
formal_spec = '''valid_expr(ranges::empty(E)) => decltype(ranges::empty(E)) == bool'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.empty"
source_module = "[range.prim.empty]/4"
tags = ['ranges', 'empty', 'bool', 'constraint']

[[axioms]]
id = "cpp20_range_prim_data_valid_object_pointer_u5v6w7x8"
content = '''Whenever ranges::data(E) is a valid expression, it has pointer to object type.'''
formal_spec = '''valid_expr(ranges::data(E)) => is_pointer_to_object(decltype(ranges::data(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.data"
source_module = "[range.prim.data]/4"
tags = ['ranges', 'data', 'pointer', 'constraint']

[[axioms]]
id = "cpp20_range_prim_cdata_valid_const_pointer_y9z0a1b2"
content = '''Whenever ranges::cdata(E) is a valid expression, it has pointer to constant object type.'''
formal_spec = '''valid_expr(ranges::cdata(E)) => is_pointer_to_const_object(decltype(ranges::cdata(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.cdata"
source_module = "[range.prim.cdata]/2"
tags = ['ranges', 'cdata', 'pointer', 'const', 'constraint']

[[axioms]]
id = "cpp20_range_prim_reserve_hint_valid_integer_like_c3d4e5f6"
content = '''Whenever ranges::reserve_hint(E) is a valid expression, its type is integer-like.'''
formal_spec = '''valid_expr(ranges::reserve_hint(E)) => is_integer_like(decltype(ranges::reserve_hint(E)))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "range.prim.size.hint"
source_module = "[range.prim.size.hint]/2"
tags = ['ranges', 'reserve_hint', 'integer_like', 'constraint']

[[axioms]]
id = "cpp20_range_range_begin_end_denotes_range_a1b3c5d7"
content = '''For a type T to model range, [ranges::begin(t), ranges::end(t)) must denote a valid range as defined in [iterator.requirements.general].'''
formal_spec = '''models_range(T) => denotes_valid_range(ranges::begin(t), ranges::end(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.1"
tags = ['ranges', 'iterator', 'sentinel', 'concepts']

[[axioms]]
id = "cpp20_range_range_begin_end_amortized_constant_e2f4a6b8"
content = '''For a type T to model range, both ranges::begin(t) and ranges::end(t) must be amortized constant time and non-modifying.'''
formal_spec = '''models_range(T) => amortized_O1(ranges::begin(t)) && amortized_O1(ranges::end(t)) && non_modifying(ranges::begin(t)) && non_modifying(ranges::end(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.2"
tags = ['ranges', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_range_begin_equality_preserving_c3d5e7f9"
content = '''For a type T to model range, if the type of ranges::begin(t) models forward_iterator, then ranges::begin(t) must be equality-preserving.'''
formal_spec = '''models_range(T) && models_forward_iterator(decltype(ranges::begin(t))) => equality_preserving(ranges::begin(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/2.3"
tags = ['ranges', 'iterator', 'forward_iterator', 'equality_preserving', 'concepts']

[[axioms]]
id = "cpp20_range_borrowed_range_iterator_validity_d4e6f8a0"
content = '''For a type T to model borrowed_range, the validity of iterators obtained from a variable u of type U (where U is remove_reference_t<T> if T is rvalue reference, otherwise T) must not be tied to the lifetime of that variable.'''
formal_spec = '''models_borrowed_range(T) => iterator_validity_independent_of_lifetime(iterators_from(u), u)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/4"
tags = ['ranges', 'borrowed_range', 'lifetime', 'iterator', 'concepts']

[[axioms]]
id = "cpp20_range_approximately_sized_reserve_hint_O1_b5c7d9e1"
content = '''For a type T to model approximately_sized_range, ranges::reserve_hint(t) must be amortized O(1), must not modify t, and must have a non-negative value representable in range_difference_t<T>.'''
formal_spec = '''models_approximately_sized_range(T) => amortized_O1(ranges::reserve_hint(t)) && non_modifying(ranges::reserve_hint(t)) && ranges::reserve_hint(t) >= 0 && representable_in(ranges::reserve_hint(t), range_difference_t<T>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.1"
tags = ['ranges', 'approximately_sized_range', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_approximately_sized_forward_reserve_hint_c6d8e0f2"
content = '''For a type T to model approximately_sized_range, if iterator_t<T> models forward_iterator, ranges::reserve_hint(t) must be well-defined regardless of whether ranges::begin(t) has been evaluated.'''
formal_spec = '''models_approximately_sized_range(T) && models_forward_iterator(iterator_t<T>) => well_defined_regardless_of_begin(ranges::reserve_hint(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.approximately.sized"
source_module = "[range.approximately.sized]/2.2"
tags = ['ranges', 'approximately_sized_range', 'forward_iterator', 'concepts']

[[axioms]]
id = "cpp20_range_sized_range_size_O1_d7e9f1a3"
content = '''For a type T to model sized_range, ranges::size(t) must be amortized O(1), must not modify t, and must equal ranges::distance(ranges::begin(t), ranges::end(t)).'''
formal_spec = '''models_sized_range(T) => amortized_O1(ranges::size(t)) && non_modifying(ranges::size(t)) && ranges::size(t) == ranges::distance(ranges::begin(t), ranges::end(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.sized"
source_module = "[range.sized]/2.1"
tags = ['ranges', 'sized_range', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_sized_range_forward_size_e8f0a2b4"
content = '''For a type T to model sized_range, if iterator_t<T> models forward_iterator, ranges::size(t) must be well-defined regardless of whether ranges::begin(t) has been evaluated.'''
formal_spec = '''models_sized_range(T) && models_forward_iterator(iterator_t<T>) => well_defined_regardless_of_begin(ranges::size(t))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.sized"
source_module = "[range.sized]/2.2"
tags = ['ranges', 'sized_range', 'forward_iterator', 'concepts']

[[axioms]]
id = "cpp20_range_view_O1_move_construction_f9a1b3c5"
content = '''For a type T to model view, T must have O(1) move construction.'''
formal_spec = '''models_view(T) => O1_complexity(move_construction(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.1"
tags = ['ranges', 'view', 'move', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_view_move_assignment_complexity_a0b2c4d6"
content = '''For a type T to model view, move assignment of an object of type T must be no more complex than destruction followed by move construction.'''
formal_spec = '''models_view(T) => complexity(move_assignment(T)) <= complexity(destruction(T) + move_construction(T))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.2"
tags = ['ranges', 'view', 'move', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_view_linear_destruction_b1c3d5e7"
content = '''For a type T to model view, if N copies and/or moves are made from an object of type T containing M elements, then those N objects must have O(N+M) destruction.'''
formal_spec = '''models_view(T) && copies_or_moves(obj, N) && elements(obj) == M => destruction_complexity(N_objects) == O(N + M)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.3"
tags = ['ranges', 'view', 'destruction', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_view_O1_copy_construction_c2d4e6f8"
content = '''For a type T to model view, either copy_constructible<T> is false, or T must have O(1) copy construction.'''
formal_spec = '''models_view(T) => (!copy_constructible<T> || O1_complexity(copy_construction(T)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.4"
tags = ['ranges', 'view', 'copy', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_view_copy_assignment_complexity_d3e5f7a9"
content = '''For a type T to model view, either copyable<T> is false, or copy assignment of an object of type T must be no more complex than destruction followed by copy construction.'''
formal_spec = '''models_view(T) => (!copyable<T> || complexity(copy_assignment(T)) <= complexity(destruction(T) + copy_construction(T)))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/2.5"
tags = ['ranges', 'view', 'copy', 'complexity', 'concepts']

[[axioms]]
id = "cpp20_range_contiguous_range_data_equals_begin_e4f6a8b0"
content = '''For a type T to model contiguous_range, to_address(ranges::begin(t)) must equal ranges::data(t).'''
formal_spec = '''models_contiguous_range(T) => to_address(ranges::begin(t)) == ranges::data(t)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.refinements"
source_module = "[range.refinements]/3"
tags = ['ranges', 'contiguous_range', 'pointer', 'concepts']

[[axioms]]
id = "cpp20_range_enable_borrowed_range_specialization_f5a7b9c1"
content = '''User specializations of enable_borrowed_range for cv-unqualified program-defined types shall be usable in constant expressions and have type const bool.'''
formal_spec = '''user_specialization(enable_borrowed_range<T>) && cv_unqualified(T) && program_defined(T) => usable_in_constant_expr(specialization) && type_of(specialization) == const_bool'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.range"
source_module = "[range.range]/6"
tags = ['ranges', 'borrowed_range', 'specialization', 'constant_expression']

[[axioms]]
id = "cpp20_range_disable_sized_range_specialization_a6b8c0d2"
content = '''User specializations of disable_sized_range for cv-unqualified program-defined types shall be usable in constant expressions and have type const bool.'''
formal_spec = '''user_specialization(disable_sized_range<T>) && cv_unqualified(T) && program_defined(T) => usable_in_constant_expr(specialization) && type_of(specialization) == const_bool'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.sized"
source_module = "[range.sized]/3"
tags = ['ranges', 'sized_range', 'specialization', 'constant_expression']

[[axioms]]
id = "cpp20_range_enable_view_specialization_b7c9d1e3"
content = '''User specializations of enable_view to true for cv-unqualified program-defined types that model view, or false for types that do not, shall be usable in constant expressions and have type const bool.'''
formal_spec = '''user_specialization(enable_view<T>) && cv_unqualified(T) && program_defined(T) => usable_in_constant_expr(specialization) && type_of(specialization) == const_bool'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "range.view"
source_module = "[range.view]/7"
tags = ['ranges', 'view', 'specialization', 'constant_expression']

[[axioms]]
id = "cpp20_thread_condition_condvar_dtor_no_blocked_threads_a3f7c2d1"
content = '''Destroying a condition_variable while any thread is blocked on it is undefined behavior.'''
formal_spec = '''destroy(cv) && exists_thread(t, blocked_on(t, cv)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/4"
tags = ['concurrency', 'condition_variable', 'destructor', 'lifetime']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_after_dtor_started_ub_8b2e4f91"
content = '''Waiting on a condition_variable after its destructor has started is undefined behavior.'''
formal_spec = '''dtor_started(cv) && wait_call(thread, cv) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/4"
tags = ['concurrency', 'condition_variable', 'destructor', 'lifetime', 'wait']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_lock_owned_precond_c4d8a2f3"
content = '''Calling wait on condition_variable requires lock.owns_lock() to be true and lock.mutex() to be locked by the calling thread.'''
formal_spec = '''wait(cv, lock) => precondition(lock.owns_lock() == true && locked_by(lock.mutex(), calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/7"
tags = ['concurrency', 'condition_variable', 'wait', 'precondition', 'mutex']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_same_mutex_precond_e5f9b3a4"
content = '''When multiple threads wait on the same condition_variable, either no other thread is waiting or all waiting threads must use locks with the same mutex.'''
formal_spec = '''concurrent_wait(cv, lock1, lock2) => (lock1.mutex() == lock2.mutex()) || no_other_waiters(cv)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/7"
tags = ['concurrency', 'condition_variable', 'wait', 'precondition', 'mutex']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_postcond_fail_terminate_f6a0c4b5"
content = '''If condition_variable::wait fails to meet the postcondition (lock owned and locked), terminate() is invoked.'''
formal_spec = '''wait_returns(cv, lock) && !(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/11"
tags = ['concurrency', 'condition_variable', 'wait', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_pred_postcond_fail_terminate_g7b1d5c6"
content = '''If condition_variable::wait with predicate fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_pred_returns(cv, lock, pred) && !(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/16"
tags = ['concurrency', 'condition_variable', 'wait', 'predicate', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_postcond_fail_terminate_h8c2e6d7"
content = '''If condition_variable::wait_until fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_until_returns(cv, lock, abs_time) && !(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/22"
tags = ['concurrency', 'condition_variable', 'wait_until', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_postcond_fail_terminate_i9d3f7e8"
content = '''If condition_variable::wait_for fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_for_returns(cv, lock, rel_time) && !(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/28"
tags = ['concurrency', 'condition_variable', 'wait_for', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_until_pred_postcond_fail_terminate_j0e4g8f9"
content = '''If condition_variable::wait_until with predicate fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_until_pred_returns(cv, lock, abs_time, pred) && !(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/34"
tags = ['concurrency', 'condition_variable', 'wait_until', 'predicate', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvar_wait_for_pred_postcond_fail_terminate_k1f5h9g0"
content = '''If condition_variable::wait_for with predicate fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_for_pred_returns(cv, lock, rel_time, pred) && !(lock.owns_lock() && locked_by(lock.mutex(), calling_thread)) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/41"
tags = ['concurrency', 'condition_variable', 'wait_for', 'predicate', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvarany_dtor_no_blocked_threads_l2g6i0h1"
content = '''Destroying a condition_variable_any while any thread is blocked on it is undefined behavior.'''
formal_spec = '''destroy(cva) && exists_thread(t, blocked_on(t, cva)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/4"
tags = ['concurrency', 'condition_variable_any', 'destructor', 'lifetime']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_after_dtor_started_ub_m3h7j1i2"
content = '''Waiting on a condition_variable_any after its destructor has started is undefined behavior.'''
formal_spec = '''dtor_started(cva) && wait_call(thread, cva) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/4"
tags = ['concurrency', 'condition_variable_any', 'destructor', 'lifetime', 'wait']

[[axioms]]
id = "cpp20_thread_condition_condvarany_lock_basiclockable_req_n4i8k2j3"
content = '''Template argument Lock for condition_variable_any must meet Cpp17BasicLockable requirements.'''
formal_spec = '''condition_variable_any::wait<Lock>(lock, ...) => requires(Cpp17BasicLockable<Lock>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvarany.general"
source_module = "[thread.condition.condvarany.general]/1"
tags = ['concurrency', 'condition_variable_any', 'requirements', 'lockable']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_postcond_fail_terminate_o5j9l3k4"
content = '''If condition_variable_any::wait fails to meet the postcondition (lock is locked), terminate() is invoked.'''
formal_spec = '''wait_returns(cva, lock) && !locked_by(lock, calling_thread) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/4"
tags = ['concurrency', 'condition_variable_any', 'wait', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_until_postcond_fail_terminate_p6k0m4l5"
content = '''If condition_variable_any::wait_until fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_until_returns(cva, lock, abs_time) && !locked_by(lock, calling_thread) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/10"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_for_postcond_fail_terminate_q7l1n5m6"
content = '''If condition_variable_any::wait_for fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_for_returns(cva, lock, rel_time) && !locked_by(lock, calling_thread) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/15"
tags = ['concurrency', 'condition_variable_any', 'wait_for', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_postcond_fail_terminate_r8m2o6n7"
content = '''If condition_variable_any::wait with stop_token fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_stop_returns(cva, lock, stoken, pred) && !locked_by(lock, calling_thread) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/6"
tags = ['concurrency', 'condition_variable_any', 'wait', 'stop_token', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_condvarany_intwait_until_postcond_fail_terminate_s9n3p7o8"
content = '''If condition_variable_any::wait_until with stop_token fails to meet the postcondition, terminate() is invoked.'''
formal_spec = '''wait_until_stop_returns(cva, lock, stoken, abs_time, pred) && !locked_by(lock, calling_thread) => terminate()'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.intwait"
source_module = "[thread.condvarany.intwait]/12"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'stop_token', 'postcondition', 'terminate']

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_lock_precond_t0o4q8p9"
content = '''notify_all_at_thread_exit requires that lk is locked by the calling thread.'''
formal_spec = '''notify_all_at_thread_exit(cond, lk) => precondition(locked_by(lk, calling_thread))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/1"
tags = ['concurrency', 'condition_variable', 'notify', 'precondition']

[[axioms]]
id = "cpp20_thread_condition_notify_all_at_thread_exit_same_mutex_precond_u1p5r9q0"
content = '''notify_all_at_thread_exit requires either no other thread is waiting on cond, or all waiting threads use the same mutex.'''
formal_spec = '''notify_all_at_thread_exit(cond, lk) => precondition(no_waiters(cond) || all_waiters_same_mutex(cond, lk.mutex()))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.nonmember"
source_module = "[thread.condition.nonmember]/1"
tags = ['concurrency', 'condition_variable', 'notify', 'precondition', 'mutex']

[[axioms]]
id = "cpp20_thread_condition_wait_spurious_wakeup_allowed_v2q6s0r1"
content = '''Condition variable wait functions may unblock spuriously without being signaled.'''
formal_spec = '''wait(cv, lock) => may_unblock_spuriously(cv)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/8"
tags = ['concurrency', 'condition_variable', 'wait', 'spurious_wakeup']

[[axioms]]
id = "cpp20_thread_condition_notify_one_notify_all_atomic_w3r7t1s2"
content = '''The executions of notify_one and notify_all are atomic.'''
formal_spec = '''execution(notify_one) => atomic(notify_one) && execution(notify_all) => atomic(notify_all)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/3"
tags = ['concurrency', 'condition_variable', 'notify', 'atomicity']

[[axioms]]
id = "cpp20_thread_condition_wait_three_atomic_parts_x4s8u2t3"
content = '''The executions of wait, wait_for, and wait_until are performed in three atomic parts: release mutex and enter waiting, unblocking, and reacquisition of lock.'''
formal_spec = '''wait(cv, lock) => atomic_sequence(release_and_wait(lock.mutex()), unblock(), reacquire(lock))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.general"
source_module = "[thread.condition.general]/3"
tags = ['concurrency', 'condition_variable', 'wait', 'atomicity']

[[axioms]]
id = "cpp20_thread_condition_wait_until_exception_relock_y5t9v3u4"
content = '''If wait_until exits via an exception, lock.lock() is called prior to exiting the function.'''
formal_spec = '''wait_until_throws(cv, lock, abs_time) => called_before_exit(lock.lock())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condition.condvar"
source_module = "[thread.condition.condvar]/18"
tags = ['concurrency', 'condition_variable', 'wait_until', 'exception', 'lock']

[[axioms]]
id = "cpp20_thread_condition_condvarany_wait_until_exception_relock_z6u0w4v5"
content = '''If condition_variable_any::wait_until exits via an exception, lock.lock() is called prior to exiting the function.'''
formal_spec = '''wait_until_throws(cva, lock, abs_time) => called_before_exit(lock.lock())'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "thread.condvarany.wait"
source_module = "[thread.condvarany.wait]/6"
tags = ['concurrency', 'condition_variable_any', 'wait_until', 'exception', 'lock']

[[axioms]]
id = "cpp20_futures_unique_future_invalid_member_call_ub_a3b7c2d1"
content = '''Calling any member function other than destructor, move assignment operator, share, or valid on a future object for which valid() == false is undefined behavior.'''
formal_spec = '''future<R> f && f.valid() == false && member_call(f, func) && func not in {destructor, operator=, share, valid} => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.unique.future"
source_module = "[futures.unique.future]/3"
tags = ['future', 'validity', 'undefined_behavior', 'concurrency']

[[axioms]]
id = "cpp20_futures_shared_future_invalid_member_call_ub_b4c8d3e2"
content = '''Calling any member function other than destructor, move assignment operator, copy assignment operator, or valid() on a shared_future object for which valid() == false is undefined behavior.'''
formal_spec = '''shared_future<R> sf && sf.valid() == false && member_call(sf, func) && func not in {destructor, operator=, valid} => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.shared.future"
source_module = "[futures.shared.future]/3"
tags = ['shared_future', 'validity', 'undefined_behavior', 'concurrency']

[[axioms]]
id = "cpp20_futures_shared_future_get_reference_after_destroy_ub_c5d9e4f3"
content = '''Accessing a reference returned by shared_future::get() after the shared state has been destroyed produces undefined behavior.'''
formal_spec = '''shared_future<R> sf && ref = sf.get() && destroyed(shared_state(sf)) && access(ref) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.shared.future"
source_module = "[futures.shared.future]/20"
tags = ['shared_future', 'lifetime', 'reference', 'undefined_behavior']

[[axioms]]
id = "cpp20_futures_async_invalid_policy_ub_d6e0f5a4"
content = '''If no value is set in the async launch policy, or a value is set that is neither specified in the standard nor by the implementation, the behavior is undefined.'''
formal_spec = '''async(policy, f, args...) && (policy == 0 || !valid_policy(policy)) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.async"
source_module = "[futures.async]/3.3"
tags = ['async', 'launch_policy', 'undefined_behavior', 'concurrency']

[[axioms]]
id = "cpp20_futures_promise_set_exception_null_precondition_e7f1a6b5"
content = '''The exception_ptr argument to promise::set_exception must not be null.'''
formal_spec = '''promise<R>::set_exception(p) => requires(p != nullptr)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/19"
tags = ['promise', 'precondition', 'exception', 'concurrency']

[[axioms]]
id = "cpp20_futures_promise_set_exception_at_thread_exit_null_precondition_f8a2b7c6"
content = '''The exception_ptr argument to promise::set_exception_at_thread_exit must not be null.'''
formal_spec = '''promise<R>::set_exception_at_thread_exit(p) => requires(p != nullptr)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/26"
tags = ['promise', 'precondition', 'exception', 'concurrency']

[[axioms]]
id = "cpp20_futures_promise_type_constraint_a9b3c8d7"
content = '''For the primary template of promise, R shall be an object type that meets the Cpp17Destructible requirements.'''
formal_spec = '''promise<R> (primary template) => is_object_v<R> && Cpp17Destructible<R>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/1"
tags = ['promise', 'type_constraint', 'destructible']

[[axioms]]
id = "cpp20_futures_future_type_constraint_b0c4d9e8"
content = '''For the primary template of future, R shall be an object type that meets the Cpp17Destructible requirements.'''
formal_spec = '''future<R> (primary template) => is_object_v<R> && Cpp17Destructible<R>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.unique.future"
source_module = "[futures.unique.future]/4"
tags = ['future', 'type_constraint', 'destructible']

[[axioms]]
id = "cpp20_futures_shared_future_type_constraint_c1d5e0f9"
content = '''For the primary template of shared_future, R shall be an object type that meets the Cpp17Destructible requirements.'''
formal_spec = '''shared_future<R> (primary template) => is_object_v<R> && Cpp17Destructible<R>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.shared.future"
source_module = "[futures.shared.future]/4"
tags = ['shared_future', 'type_constraint', 'destructible']

[[axioms]]
id = "cpp20_futures_state_conflict_data_race_d2e6f1a0"
content = '''Access to the result of the same shared state may conflict, requiring additional synchronization for concurrent mutable access.'''
formal_spec = '''shared_state s && concurrent_access(s.result, thread1, thread2) && !read_only(access1, access2) && !synchronized(access1, access2) => data_race'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "futures.state"
source_module = "[futures.state]/11"
tags = ['shared_state', 'data_race', 'synchronization', 'concurrency']

[[axioms]]
id = "cpp20_futures_packaged_task_allocator_precondition_e3f7a2b1"
content = '''The Allocator template parameter in packaged_task constructor must meet the Cpp17Allocator requirements.'''
formal_spec = '''packaged_task(allocator_arg_t, Allocator a, F&& f) => requires(Cpp17Allocator<Allocator>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/5"
tags = ['packaged_task', 'allocator', 'precondition']

[[axioms]]
id = "cpp20_futures_async_mandates_constructible_f4a8b3c2"
content = '''For std::async, decay_t<F> must be constructible from F, each decay_t<Args> must be constructible from Args, and the decayed types must be invocable.'''
formal_spec = '''async(policy, F&& f, Args&&... args) => is_constructible_v<decay_t<F>, F> && (is_constructible_v<decay_t<Args>, Args> && ...) && is_invocable_v<decay_t<F>, decay_t<Args>...>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.async"
source_module = "[futures.async]/2"
tags = ['async', 'mandates', 'type_constraint']

[[axioms]]
id = "cpp20_futures_packaged_task_mandates_invocable_a5b9c4d3"
content = '''For packaged_task constructor with callable F, is_invocable_r_v<R, decay_t<F>&, ArgTypes...> must be true.'''
formal_spec = '''packaged_task<R(ArgTypes...)>(F&& f) => is_invocable_r_v<R, decay_t<F>&, ArgTypes...>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/4"
tags = ['packaged_task', 'mandates', 'invocable']

[[axioms]]
id = "cpp20_futures_promise_get_future_no_state_throws_b6c0d5e4"
content = '''Calling get_future on a promise with no shared state throws future_error with error condition no_state.'''
formal_spec = '''promise<R> p && !has_shared_state(p) && p.get_future() => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/14-15"
tags = ['promise', 'get_future', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_promise_get_future_already_retrieved_throws_c7d1e6f5"
content = '''Calling get_future on a promise when get_future has already been called on a promise with the same shared state throws future_error with error condition future_already_retrieved.'''
formal_spec = '''promise<R> p && has_shared_state(p) && get_future_already_called(p.shared_state) && p.get_future() => throws(future_error, future_errc::future_already_retrieved)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/14-15"
tags = ['promise', 'get_future', 'exception', 'future_already_retrieved']

[[axioms]]
id = "cpp20_futures_promise_set_value_already_satisfied_throws_d8e2f7a6"
content = '''Calling set_value on a promise whose shared state already has a stored value or exception throws future_error with error condition promise_already_satisfied.'''
formal_spec = '''promise<R> p && (has_value(p.shared_state) || has_exception(p.shared_state)) && p.set_value(...) => throws(future_error, future_errc::promise_already_satisfied)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/17-18"
tags = ['promise', 'set_value', 'exception', 'promise_already_satisfied']

[[axioms]]
id = "cpp20_futures_promise_set_exception_already_satisfied_throws_e9f3a8b7"
content = '''Calling set_exception on a promise whose shared state already has a stored value or exception throws future_error with error condition promise_already_satisfied.'''
formal_spec = '''promise<R> p && (has_value(p.shared_state) || has_exception(p.shared_state)) && p.set_exception(...) => throws(future_error, future_errc::promise_already_satisfied)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/21-22"
tags = ['promise', 'set_exception', 'exception', 'promise_already_satisfied']

[[axioms]]
id = "cpp20_futures_packaged_task_get_future_no_state_throws_f0a4b9c8"
content = '''Calling get_future on a packaged_task with no shared state throws future_error with error condition no_state.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && !has_shared_state(pt) && pt.get_future() => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/19-20"
tags = ['packaged_task', 'get_future', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_packaged_task_get_future_already_retrieved_throws_a1b5c0d9"
content = '''Calling get_future on a packaged_task when get_future has already been called on a packaged_task with the same shared state throws future_error with error condition future_already_retrieved.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && get_future_already_called(pt.shared_state) && pt.get_future() => throws(future_error, future_errc::future_already_retrieved)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/19-20"
tags = ['packaged_task', 'get_future', 'exception', 'future_already_retrieved']

[[axioms]]
id = "cpp20_futures_packaged_task_invoke_no_state_throws_b2c6d1e0"
content = '''Invoking operator() on a packaged_task with no shared state throws future_error with error condition no_state.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && !has_shared_state(pt) && pt(args...) => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/22-23"
tags = ['packaged_task', 'operator()', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_packaged_task_invoke_already_invoked_throws_c3d7e2f1"
content = '''Invoking operator() on a packaged_task whose stored task has already been invoked throws future_error with error condition promise_already_satisfied.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && already_invoked(pt) && pt(args...) => throws(future_error, future_errc::promise_already_satisfied)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/22-23"
tags = ['packaged_task', 'operator()', 'exception', 'promise_already_satisfied']

[[axioms]]
id = "cpp20_futures_packaged_task_make_ready_at_thread_exit_no_state_throws_d4e8f3a2"
content = '''Calling make_ready_at_thread_exit on a packaged_task with no shared state throws future_error with error condition no_state.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && !has_shared_state(pt) && pt.make_ready_at_thread_exit(args...) => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/25-26"
tags = ['packaged_task', 'make_ready_at_thread_exit', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_packaged_task_make_ready_already_invoked_throws_e5f9a4b3"
content = '''Calling make_ready_at_thread_exit on a packaged_task whose stored task has already been invoked throws future_error with error condition promise_already_satisfied.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && already_invoked(pt) && pt.make_ready_at_thread_exit(args...) => throws(future_error, future_errc::promise_already_satisfied)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/25-26"
tags = ['packaged_task', 'make_ready_at_thread_exit', 'exception', 'promise_already_satisfied']

[[axioms]]
id = "cpp20_futures_packaged_task_reset_no_state_throws_f6a0b5c4"
content = '''Calling reset on a packaged_task with no shared state throws future_error with error condition no_state.'''
formal_spec = '''packaged_task<R(ArgTypes...)> pt && !pt.valid() && pt.reset() => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.task.members"
source_module = "[futures.task.members]/27-28"
tags = ['packaged_task', 'reset', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_state_ready_synchronization_a7b1c6d5"
content = '''Calls to functions that successfully set the stored result of a shared state synchronize with calls to functions successfully detecting the ready state resulting from that setting.'''
formal_spec = '''set_result(shared_state, result) synchronizes_with detect_ready(shared_state)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "futures.state"
source_module = "[futures.state]/9"
tags = ['shared_state', 'synchronization', 'concurrency']

[[axioms]]
id = "cpp20_futures_state_storage_synchronization_b8c2d7e6"
content = '''The storage of the result (whether normal or exceptional) into the shared state synchronizes with the successful return from a call to a waiting function on the shared state.'''
formal_spec = '''store_result(shared_state, result) synchronizes_with wait_function_return(shared_state)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "futures.state"
source_module = "[futures.state]/9"
tags = ['shared_state', 'synchronization', 'waiting', 'concurrency']

[[axioms]]
id = "cpp20_futures_async_synchronization_c9d3e8f7"
content = '''The invocation of async synchronizes with the invocation of f. The completion of the function f is sequenced before the shared state is made ready.'''
formal_spec = '''async(policy, f, args...) synchronizes_with invoke(f, args...) && completion(f) sequenced_before ready(shared_state)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "futures.async"
source_module = "[futures.async]/4"
tags = ['async', 'synchronization', 'sequencing', 'concurrency']

[[axioms]]
id = "cpp20_futures_async_thread_completion_synchronization_d0e4f9a8"
content = '''For launch::async policy, the associated thread completion synchronizes with the return from the first function that successfully detects the ready status or the last function that releases the shared state.'''
formal_spec = '''async(launch::async, f, args...) => thread_completion synchronizes_with (detect_ready(shared_state) || last_release(shared_state))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "futures.async"
source_module = "[futures.async]/4.2"
tags = ['async', 'thread', 'synchronization', 'concurrency']

[[axioms]]
id = "cpp20_futures_promise_set_value_no_state_throws_e1f5a0b9"
content = '''Calling set_value on a promise with no shared state throws future_error with error condition no_state.'''
formal_spec = '''promise<R> p && !has_shared_state(p) && p.set_value(...) => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/17-18"
tags = ['promise', 'set_value', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_promise_set_exception_no_state_throws_f2a6b1c0"
content = '''Calling set_exception on a promise with no shared state throws future_error with error condition no_state.'''
formal_spec = '''promise<R> p && !has_shared_state(p) && p.set_exception(...) => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/21-22"
tags = ['promise', 'set_exception', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_promise_set_value_at_thread_exit_no_state_throws_a3b7c2d1"
content = '''Calling set_value_at_thread_exit on a promise with no shared state throws future_error with error condition no_state.'''
formal_spec = '''promise<R> p && !has_shared_state(p) && p.set_value_at_thread_exit(...) => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/24-25"
tags = ['promise', 'set_value_at_thread_exit', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_promise_set_value_at_thread_exit_already_satisfied_throws_b4c8d3e2"
content = '''Calling set_value_at_thread_exit on a promise whose shared state already has a stored value or exception throws future_error with error condition promise_already_satisfied.'''
formal_spec = '''promise<R> p && (has_value(p.shared_state) || has_exception(p.shared_state)) && p.set_value_at_thread_exit(...) => throws(future_error, future_errc::promise_already_satisfied)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/24-25"
tags = ['promise', 'set_value_at_thread_exit', 'exception', 'promise_already_satisfied']

[[axioms]]
id = "cpp20_futures_promise_set_exception_at_thread_exit_no_state_throws_c5d9e4f3"
content = '''Calling set_exception_at_thread_exit on a promise with no shared state throws future_error with error condition no_state.'''
formal_spec = '''promise<R> p && !has_shared_state(p) && p.set_exception_at_thread_exit(...) => throws(future_error, future_errc::no_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/28-29"
tags = ['promise', 'set_exception_at_thread_exit', 'exception', 'no_state']

[[axioms]]
id = "cpp20_futures_promise_set_exception_at_thread_exit_already_satisfied_throws_d6e0f5a4"
content = '''Calling set_exception_at_thread_exit on a promise whose shared state already has a stored value or exception throws future_error with error condition promise_already_satisfied.'''
formal_spec = '''promise<R> p && (has_value(p.shared_state) || has_exception(p.shared_state)) && p.set_exception_at_thread_exit(...) => throws(future_error, future_errc::promise_already_satisfied)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.promise"
source_module = "[futures.promise]/28-29"
tags = ['promise', 'set_exception_at_thread_exit', 'exception', 'promise_already_satisfied']

[[axioms]]
id = "cpp20_futures_abandon_sets_broken_promise_e7f1a6b5"
content = '''When an asynchronous provider abandons its shared state that is not ready, it stores a future_error exception with error condition broken_promise and makes the state ready.'''
formal_spec = '''abandon(provider) && !ready(provider.shared_state) => store_exception(provider.shared_state, future_error(future_errc::broken_promise)) && make_ready(provider.shared_state)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "futures.state"
source_module = "[futures.state]/7"
tags = ['shared_state', 'abandon', 'broken_promise', 'concurrency']

[[axioms]]
id = "cpp20_futures_future_errc_distinct_nonzero_f8a2b7c6"
content = '''The enum values of future_errc are distinct and not zero.'''
formal_spec = '''forall e1, e2 in future_errc: (e1 != e2 => static_cast<int>(e1) != static_cast<int>(e2)) && static_cast<int>(e) != 0'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "future.syn"
source_module = "[future.syn]/2"
tags = ['future_errc', 'enum', 'constraint']

[[axioms]]
id = "cpp20_format_string_invalid_arg_id_a1b2c3d4"
content = '''If there is no argument with the index arg-id in args, the string is not a format string for args (ill-formed).'''
formal_spec = '''format_string(fmt, args) && contains_arg_id(fmt, id) && id >= count(args) => not_format_string(fmt, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/2"
tags = ['format', 'format_string', 'argument_index']

[[axioms]]
id = "cpp20_format_string_mixed_indexing_e5f6a7b8"
content = '''A format string cannot contain a mixture of automatic and manual argument indexing. If some arg-ids are omitted and some are present, the string is not a format string.'''
formal_spec = '''format_string(fmt) && has_automatic_indexing(fmt) && has_manual_indexing(fmt) => not_format_string(fmt)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/4"
tags = ['format', 'format_string', 'argument_index']

[[axioms]]
id = "cpp20_format_string_invalid_format_spec_c9d0e1f2"
content = '''If format-spec does not conform to the format specifications for the argument type referred to by arg-id, the string is not a format string for args.'''
formal_spec = '''format_string(fmt, args) && has_format_spec(fmt, id, spec) && !valid_format_spec(spec, type_of_arg(args, id)) => not_format_string(fmt, args)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/5"
tags = ['format', 'format_string', 'format_spec']

[[axioms]]
id = "cpp20_format_sign_option_arithmetic_only_a3b4c5d6"
content = '''The sign option is only valid for arithmetic types other than charT and bool or when an integer presentation type is specified.'''
formal_spec = '''format_spec_has_sign(spec) && !is_arithmetic_type(T) || T == charT || T == bool => invalid_format_spec(spec, T) unless integer_presentation_type_specified(spec)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/5"
tags = ['format', 'format_spec', 'sign']

[[axioms]]
id = "cpp20_format_alt_form_arithmetic_only_e7f8a9b0"
content = '''The # option (alternate form) is valid for arithmetic types other than charT and bool or when an integer presentation type is specified, and not otherwise.'''
formal_spec = '''format_spec_has_alt_form(spec) && (!is_arithmetic_type(T) || T == charT || T == bool) && !integer_presentation_type_specified(spec) => invalid_format_spec(spec, T)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/7"
tags = ['format', 'format_spec', 'alternate_form']

[[axioms]]
id = "cpp20_format_zero_option_valid_types_c1d2e3f4"
content = '''The 0 option is valid for arithmetic types other than charT and bool, pointer types, or when an integer presentation type is specified.'''
formal_spec = '''format_spec_has_zero_pad(spec) && !is_pointer_type(T) && (!is_arithmetic_type(T) || T == charT || T == bool) && !integer_presentation_type_specified(spec) => invalid_format_spec(spec, T)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/8"
tags = ['format', 'format_spec', 'zero_padding']

[[axioms]]
id = "cpp20_format_width_arg_negative_throws_a5b6c7d8"
content = '''If {arg-id} is used in a width or precision option and the value of the corresponding formatting argument is negative, an exception of type format_error is thrown.'''
formal_spec = '''format_spec_uses_arg_for_width_or_precision(spec, id) && value_of_arg(args, id) < 0 => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = ['format', 'format_spec', 'width', 'precision', 'exception']

[[axioms]]
id = "cpp20_format_width_arg_integer_type_e9f0a1b2"
content = '''If {arg-id} is used in a width or precision option, the option is valid only if the corresponding formatting argument is of standard signed or unsigned integer type.'''
formal_spec = '''format_spec_uses_arg_for_width_or_precision(spec, id) && !is_standard_integer_type(type_of_arg(args, id)) => invalid_format_spec(spec)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/10"
tags = ['format', 'format_spec', 'width', 'precision']

[[axioms]]
id = "cpp20_format_precision_valid_types_c3d4e5f6"
content = '''The precision option is valid for floating-point and string types only.'''
formal_spec = '''format_spec_has_precision(spec) && !is_floating_point_type(T) && !is_string_type(T) => invalid_format_spec(spec, T)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/15"
tags = ['format', 'format_spec', 'precision']

[[axioms]]
id = "cpp20_format_locale_option_arithmetic_only_a7b8c9d0"
content = '''The L option is only valid for arithmetic types.'''
formal_spec = '''format_spec_has_locale(spec) && !is_arithmetic_type(T) => invalid_format_spec(spec, T)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/17"
tags = ['format', 'format_spec', 'locale']

[[axioms]]
id = "cpp20_format_c_type_throws_out_of_range_e1f2a3b4"
content = '''For integer type with c presentation type, throws format_error if value is not in the range of representable values for charT.'''
formal_spec = '''format_spec_type(spec) == 'c' && is_integer_type(T) && !in_range(static_cast<charT>(value), charT) => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/21"
tags = ['format', 'format_spec', 'type', 'character', 'exception']

[[axioms]]
id = "cpp20_format_err_report_invalid_format_c5d6e7f8"
content = '''Formatting functions throw format_error if an argument fmt is passed that is not a format string for args.'''
formal_spec = '''call_format_function(fmt, args) && !is_format_string(fmt, args) => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.err.report"
source_module = "[format.err.report]/1"
tags = ['format', 'exception', 'format_error']

[[axioms]]
id = "cpp20_format_err_report_propagate_exceptions_a9b0c1d2"
content = '''Formatting functions propagate exceptions thrown by operations of formatter specializations and iterators.'''
formal_spec = '''call_format_function(fmt, args) && (formatter_throws(E) || iterator_throws(E)) => throws(E)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.err.report"
source_module = "[format.err.report]/1"
tags = ['format', 'exception', 'propagation']

[[axioms]]
id = "cpp20_format_string_consteval_validation_e3f4a5b6"
content = '''A call to basic_format_string constructor is not a core constant expression unless there exist args of types Args such that str is a format string for args.'''
formal_spec = '''consteval_context && basic_format_string(s) && !exists_args_such_that_format_string(s, Args) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.fmt.string"
source_module = "[format.fmt.string]/3"
tags = ['format', 'consteval', 'format_string', 'validation']

[[axioms]]
id = "cpp20_format_vformat_to_precondition_c7d8e9f0"
content = '''For vformat_to, Out must model output_iterator<const charT&>.'''
formal_spec = '''call_vformat_to(out, fmt, args) && !models_output_iterator<Out, const charT&> => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/15"
tags = ['format', 'precondition', 'iterator', 'vformat_to']

[[axioms]]
id = "cpp20_format_to_n_basic_formatter_precondition_a1b2c3d4"
content = '''For format_to_n, formatter<remove_cvref_t<Ti>, charT> must meet the BasicFormatter requirements for each Ti in Args.'''
formal_spec = '''call_format_to_n(out, n, fmt, args...) && exists_Ti_in_Args(!meets_basic_formatter_requirements<formatter<remove_cvref_t<Ti>, charT>>) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/21"
tags = ['format', 'precondition', 'formatter', 'format_to_n']

[[axioms]]
id = "cpp20_format_formatted_size_basic_formatter_precondition_e5f6a7b8"
content = '''For formatted_size, formatter<remove_cvref_t<Ti>, charT> must meet the BasicFormatter requirements for each Ti in Args.'''
formal_spec = '''call_formatted_size(fmt, args...) && exists_Ti_in_Args(!meets_basic_formatter_requirements<formatter<remove_cvref_t<Ti>, charT>>) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.functions"
source_module = "[format.functions]/26"
tags = ['format', 'precondition', 'formatter', 'formatted_size']

[[axioms]]
id = "cpp20_formatter_parse_throw_on_invalid_c9d0e1f2"
content = '''Formatter parse member function throws format_error unless the whole range is parsed or the unmatched character is }.'''
formal_spec = '''formatter_parse(g, pc) && !whole_range_parsed(pc) && unmatched_char(pc) != '}' => throws(format_error)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "formatter.requirements"
source_module = "[formatter.requirements]/Table112"
tags = ['format', 'formatter', 'parse', 'exception']

[[axioms]]
id = "cpp20_format_fill_char_utf_single_scalar_a3b4c5d6"
content = '''For a format specification in UTF-8, UTF-16, or UTF-32, the fill character corresponds to a single Unicode scalar value.'''
formal_spec = '''format_spec_in_utf_encoding(spec) && fill_char_not_single_unicode_scalar(spec) => invalid_format_spec(spec)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "format.string.std"
source_module = "[format.string.std]/3"
tags = ['format', 'format_spec', 'fill', 'unicode']

[[axioms]]
id = "cpp20_format_fill_char_not_brace_e7f8a9b0"
content = '''The fill character can be any character other than { or }.'''
formal_spec = '''fill_char(spec) == '{' || fill_char(spec) == '}' => invalid_format_spec(spec)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.std"
source_module = "[format.string.std]/1"
tags = ['format', 'format_spec', 'fill']

[[axioms]]
id = "cpp20_format_locale_not_constant_expr_c1d2e3f4"
content = '''A call to format on a given formatter specialization is not a constant subexpression if the locale-specific form (L option) is specified.'''
formal_spec = '''constant_expression_context && format_spec_has_locale(spec) => not_constant_subexpression'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.std"
source_module = "[format.string.std]/17"
tags = ['format', 'format_spec', 'locale', 'constexpr']

[[axioms]]
id = "cpp20_format_disabled_formatter_not_constructible_a5b6c7d8"
content = '''If F is a disabled specialization of formatter, is_default_constructible_v<F>, is_copy_constructible_v<F>, is_move_constructible_v<F>, is_copy_assignable_v<F>, and is_move_assignable_v<F> are all false.'''
formal_spec = '''disabled_formatter_specialization(F) => !is_default_constructible_v<F> && !is_copy_constructible_v<F> && !is_move_constructible_v<F> && !is_copy_assignable_v<F> && !is_move_assignable_v<F>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.spec"
source_module = "[format.formatter.spec]/7"
tags = ['format', 'formatter', 'disabled', 'type_traits']

[[axioms]]
id = "cpp20_format_no_specialization_disabled_e9f0a1b2"
content = '''For any types T and charT for which neither the library nor the user provides an explicit or partial specialization of the class template formatter, formatter<T, charT> is disabled.'''
formal_spec = '''!has_formatter_specialization(T, charT) => disabled_formatter_specialization(formatter<T, charT>)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.formatter.spec"
source_module = "[format.formatter.spec]/5"
tags = ['format', 'formatter', 'disabled']

[[axioms]]
id = "cpp20_format_escape_sequence_only_braces_c3d4e5f6"
content = '''An escape sequence in a format string is one of {{ or }}. It is replaced with { or }, respectively, in the output.'''
formal_spec = '''format_string_char(c) == '{' && !escape_sequence(c) && !replacement_field_start(c) => invalid_format_string'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "format.string.general"
source_module = "[format.string.general]/1"
tags = ['format', 'format_string', 'escape_sequence']

[[axioms]]
id = "cpp20_format_spec_no_close_brace_start_a7b8c9d0"
content = '''The format-spec in a replacement field cannot start with }.'''
formal_spec = '''format_spec_starts_with(spec, '}') => invalid_format_spec(spec)'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "format.string.general"
source_module = "[format.string.general]/1"
tags = ['format', 'format_string', 'format_spec']
