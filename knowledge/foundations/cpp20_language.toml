version = "1.0"
source = "eel.is/c++draft"
extracted_at = "2025-12-26T22:56:56.881486+00:00"

[[axioms]]
id = "cpp20_basic_life_delete_before_lifetime_7a1b2c3d"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a delete-expression is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && delete_expr(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.1"
tags = ['lifetime', 'delete', 'pointer', 'storage']

[[axioms]]
id = "cpp20_basic_life_member_access_before_lifetime_8b2c3d4e"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended to access a non-static data member or call a non-static member function is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && (access_nonstatic_member(ptr) || call_nonstatic_member_function(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.2"
tags = ['lifetime', 'member-access', 'pointer', 'storage']

[[axioms]]
id = "cpp20_basic_life_convert_to_virtual_base_ptr_9c3d4e5f"
content = '''Converting a pointer to storage where an object's lifetime has not started or has ended to a pointer to a virtual base class or base class thereof is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && (convert_to_virtual_base_ptr(ptr) || convert_to_base_of_virtual_base_ptr(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.3"
tags = ['lifetime', 'conversion', 'pointer', 'virtual-base', 'inheritance']

[[axioms]]
id = "cpp20_basic_life_dynamic_cast_ptr_before_lifetime_ad4e5f6a"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a dynamic_cast is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr, obj) || after_lifetime_end(ptr, obj)) && storage_allocated(ptr) && dynamic_cast_operand(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.4"
tags = ['lifetime', 'dynamic_cast', 'pointer', 'storage', 'rtti']

[[axioms]]
id = "cpp20_basic_life_glvalue_access_before_lifetime_be5f6a7b"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended to access the object is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && access_object(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.1"
tags = ['lifetime', 'glvalue', 'access', 'storage']

[[axioms]]
id = "cpp20_basic_life_glvalue_call_member_before_lifetime_cf6a7b8c"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended to call a non-static member function is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && call_nonstatic_member_function(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.2"
tags = ['lifetime', 'glvalue', 'member-function', 'storage']

[[axioms]]
id = "cpp20_basic_life_glvalue_bind_virtual_base_ref_d07b8c9d"
content = '''Binding a glvalue that refers to storage where an object's lifetime has not started or has ended to a reference to a virtual base class is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && bind_to_virtual_base_ref(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.3"
tags = ['lifetime', 'glvalue', 'reference', 'virtual-base', 'binding']

[[axioms]]
id = "cpp20_basic_life_glvalue_dynamic_cast_typeid_e18c9dae"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended as the operand of dynamic_cast or typeid is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue, obj) || after_lifetime_end(glvalue, obj)) && storage_allocated(glvalue) && (dynamic_cast_operand(glvalue) || typeid_operand(glvalue)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.4"
tags = ['lifetime', 'glvalue', 'dynamic_cast', 'typeid', 'rtti']

[[axioms]]
id = "cpp20_basic_life_nontrivial_destructor_not_called_f29daebf"
content = '''If a program ends the lifetime of an object with static, thread, or automatic storage duration that has a non-trivial destructor, and another object of the original type does not occupy that same storage location when the implicit destructor call takes place, the behavior is undefined.'''
formal_spec = '''has_storage_duration(obj, static | thread | automatic) && has_nontrivial_destructor(type(obj)) && lifetime_ended(obj) && !same_type_object_at_location(storage(obj), type(obj), implicit_destructor_call_time) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/11"
tags = ['lifetime', 'destructor', 'storage-duration', 'automatic', 'static', 'thread']

[[axioms]]
id = "cpp20_basic_life_create_in_const_storage_03aebfc0"
content = '''Creating a new object within the storage that a const complete object with static, thread, or automatic storage duration occupies, or within the storage that such a const object used to occupy before its lifetime ended, results in undefined behavior.'''
formal_spec = '''is_const(obj) && is_complete_object(obj) && has_storage_duration(obj, static | thread | automatic) && (create_new_object_in_storage(storage(obj)) || (lifetime_ended(obj) && create_new_object_in_former_storage(storage(obj)))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/12"
tags = ['lifetime', 'const', 'storage-duration', 'placement-new']

[[axioms]]
id = "cpp20_basic_life_storage_reuse_during_new_14bfc0d1"
content = '''When evaluating a new-expression, storage is considered reused after it is returned from the allocation function but before the evaluation of the new-initializer, making access to the original object undefined.'''
formal_spec = '''new_expression(ptr) && after_allocation_return(ptr) && before_new_initializer_eval(ptr) && access_original_object(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'new-expression', 'storage', 'initialization']

[[axioms]]
id = "cpp20_basic_life_lifetime_begin_storage_alignment_25c0d1e2"
content = '''The lifetime of an object of type T begins only when storage with the proper alignment and size for type T is obtained and its initialization is complete.'''
formal_spec = '''lifetime_begins(obj, T) <=> storage_obtained(obj, alignment(T), size(T)) && initialization_complete(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.1-2.2"
tags = ['lifetime', 'storage', 'alignment', 'initialization']

[[axioms]]
id = "cpp20_basic_life_union_member_lifetime_36d1e2f3"
content = '''For a union member or subobject thereof, its lifetime only begins if that union member is the initialized member in the union, or as described in specific clauses about union member access and copy operations.'''
formal_spec = '''is_union_member(obj) || is_subobject_of_union_member(obj) => (lifetime_begins(obj) <=> is_initialized_union_member(obj) || union_member_access_rules(obj))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'union', 'initialization', 'member']

[[axioms]]
id = "cpp20_basic_life_end_nonclass_destroy_47e2f304"
content = '''The lifetime of an object of non-class type ends when the object is destroyed.'''
formal_spec = '''!is_class_type(T) && type(obj) == T => (lifetime_ends(obj) <=> destroyed(obj))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.3"
tags = ['lifetime', 'non-class', 'destruction']

[[axioms]]
id = "cpp20_basic_life_end_class_destructor_start_58f30415"
content = '''The lifetime of an object of class type ends when the destructor call starts.'''
formal_spec = '''is_class_type(T) && type(obj) == T => (lifetime_ends(obj) <=> destructor_call_starts(obj))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.4"
tags = ['lifetime', 'class', 'destructor']

[[axioms]]
id = "cpp20_basic_life_end_storage_released_69041526"
content = '''The lifetime of an object ends when the storage which the object occupies is released or is reused by an object that is not nested within it.'''
formal_spec = '''lifetime_ends(obj) <== storage_released(storage(obj)) || (storage_reused(storage(obj), new_obj) && !nested_within(new_obj, obj))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/2.5"
tags = ['lifetime', 'storage', 'release', 'reuse']

[[axioms]]
id = "cpp20_basic_life_reference_lifetime_begin_7a152637"
content = '''The lifetime of a reference begins when its initialization is complete.'''
formal_spec = '''is_reference(ref) => (lifetime_begins(ref) <=> initialization_complete(ref))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/3"
tags = ['lifetime', 'reference', 'initialization']

[[axioms]]
id = "cpp20_basic_life_properties_during_lifetime_8b263748"
content = '''The properties ascribed to objects and references throughout the C++ standard apply for a given object or reference only during its lifetime.'''
formal_spec = '''object_properties_apply(obj) <=> during_lifetime(obj)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "basic.life"
source_module = "[basic.life]/5"
tags = ['lifetime', 'object', 'reference', 'properties']

[[axioms]]
id = "cpp20_basic_life_transparent_replacement_ptr_validity_9c374859"
content = '''After an object's lifetime has ended and before storage is reused or released, if a new object is created at the same storage location and the original object was transparently replaceable by the new object, pointers, references, and names that referred to the original object automatically refer to the new object.'''
formal_spec = '''lifetime_ended(obj1) && !storage_reused_or_released(storage(obj1)) && create_new_object(obj2, storage(obj1)) && transparently_replaceable(obj1, obj2) => (pointer_to(obj1) == pointer_to(obj2) && reference_to(obj1) == reference_to(obj2) && name_of(obj1) == name_of(obj2))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "basic.life"
source_module = "[basic.life]/10"
tags = ['lifetime', 'transparent-replacement', 'pointer', 'reference']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_complete_obj_ad485960"
content = '''A complete object o1 is transparently replaceable by a complete object o2 if o1 is not const, the storage that o2 occupies exactly overlays the storage that o1 occupied, and o1 and o2 are of the same type ignoring top-level cv-qualifiers.'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && !is_const(o1) && storage_exactly_overlays(o2, o1) && same_type_ignore_cv(type(o1), type(o2)) => transparently_replaceable(o1, o2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/9.1"
tags = ['lifetime', 'transparent-replacement', 'complete-object', 'const']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_subobject_be596a71"
content = '''Direct subobjects o1 and o2 are transparently replaceable if the complete object of o1 is not const, or o1 is a mutable member subobject or a subobject thereof.'''
formal_spec = '''is_direct_subobject(o1) && is_direct_subobject(o2) && corresponding_subobjects(o1, o2) && (!is_const(complete_object(o1)) || is_mutable_member_or_subobject(o1)) => transparently_replaceable(o1, o2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/9.2"
tags = ['lifetime', 'transparent-replacement', 'subobject', 'mutable']

[[axioms]]
id = "cpp20_basic_life_delete_before_lifetime_a7b3c1d2"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a delete-expression is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && delete_expr(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.1"
tags = ['lifetime', 'delete', 'pointer']

[[axioms]]
id = "cpp20_basic_life_member_access_before_lifetime_e4f5a6b7"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended to access a non-static data member or call a non-static member function is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && (access_nonstatic_member(ptr) || call_nonstatic_member_func(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.2"
tags = ['lifetime', 'member-access', 'pointer']

[[axioms]]
id = "cpp20_basic_life_ptr_conv_virtual_base_c8d9e0f1"
content = '''Converting a pointer to storage where an object's lifetime has not started or has ended to a pointer to a virtual base class or base class thereof is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && (convert_to_virtual_base(ptr) || convert_to_base_of_virtual_base(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.3"
tags = ['lifetime', 'pointer', 'conversion', 'virtual-base']

[[axioms]]
id = "cpp20_basic_life_dynamic_cast_ptr_before_lifetime_2a3b4c5d"
content = '''Using a pointer to storage where an object's lifetime has not started or has ended as the operand of a dynamic_cast is undefined behavior.'''
formal_spec = '''(before_lifetime_start(ptr) || after_lifetime_end(ptr)) && dynamic_cast_operand(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/7.4"
tags = ['lifetime', 'pointer', 'dynamic_cast']

[[axioms]]
id = "cpp20_basic_life_glvalue_access_before_lifetime_6e7f8a9b"
content = '''Using a glvalue to access an object before its lifetime has started or after its lifetime has ended is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && access_object(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.1"
tags = ['lifetime', 'glvalue', 'access']

[[axioms]]
id = "cpp20_basic_life_glvalue_member_call_before_lifetime_0c1d2e3f"
content = '''Using a glvalue to call a non-static member function of an object before its lifetime has started or after its lifetime has ended is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && call_nonstatic_member_func(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.2"
tags = ['lifetime', 'glvalue', 'member-function']

[[axioms]]
id = "cpp20_basic_life_glvalue_bind_virtual_base_4a5b6c7d"
content = '''Binding a glvalue that refers to storage where an object's lifetime has not started or has ended to a reference to a virtual base class is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && bind_to_virtual_base_ref(glvalue) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.3"
tags = ['lifetime', 'glvalue', 'reference', 'virtual-base']

[[axioms]]
id = "cpp20_basic_life_glvalue_dynamic_cast_typeid_8e9f0a1b"
content = '''Using a glvalue that refers to storage where an object's lifetime has not started or has ended as the operand of dynamic_cast or typeid is undefined behavior.'''
formal_spec = '''(before_lifetime_start(glvalue) || after_lifetime_end(glvalue)) && (dynamic_cast_operand(glvalue) || typeid_operand(glvalue)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/8.4"
tags = ['lifetime', 'glvalue', 'dynamic_cast', 'typeid']

[[axioms]]
id = "cpp20_basic_life_implicit_destructor_no_replacement_2c3d4e5f"
content = '''If a program ends the lifetime of an object with static, thread, or automatic storage duration that has a non-trivial destructor, and another object of the original type does not occupy that storage location when the implicit destructor call takes place, the behavior is undefined.'''
formal_spec = '''(has_static_storage(obj) || has_thread_storage(obj) || has_automatic_storage(obj)) && has_nontrivial_destructor(type(obj)) && lifetime_ended(obj) && !same_type_object_occupies_storage_at_implicit_destructor_call(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/11"
tags = ['lifetime', 'destructor', 'storage-duration']

[[axioms]]
id = "cpp20_basic_life_create_in_const_storage_6a7b8c9d"
content = '''Creating a new object within the storage that a const complete object with static, thread, or automatic storage duration occupies, or within the storage that such a const object used to occupy before its lifetime ended, results in undefined behavior.'''
formal_spec = '''is_const(original_obj) && is_complete_object(original_obj) && (has_static_storage(original_obj) || has_thread_storage(original_obj) || has_automatic_storage(original_obj)) && create_new_object_in_storage(original_obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.life"
source_module = "[basic.life]/12"
tags = ['lifetime', 'const', 'storage', 'placement-new']

[[axioms]]
id = "cpp20_basic_life_reuse_during_new_init_0e1f2a3b"
content = '''When evaluating a new-expression, accessing the storage after it is returned from the allocation function but before the evaluation of the new-initializer is complete causes undefined behavior if the access depends on the object's value.'''
formal_spec = '''new_expr_in_progress(storage) && after_allocation_return(storage) && before_new_initializer_complete(storage) && access_object_value(storage) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'new-expression', 'initialization']

[[axioms]]
id = "cpp20_basic_life_union_member_lifetime_4c5d6e7f"
content = '''The lifetime of a union member or subobject thereof only begins if that union member is the initialized member in the union, or as described in [class.union], [class.copy.ctor], and [class.copy.assign].'''
formal_spec = '''is_union_member(obj) && !is_initialized_union_member(obj) && !activated_by_class_union_rules(obj) && !activated_by_copy_rules(obj) => !lifetime_started(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'union', 'initialization']

[[axioms]]
id = "cpp20_basic_life_starts_storage_and_init_8a9b0c1d"
content = '''The lifetime of an object of type T begins only when storage with proper alignment and size for type T is obtained and its initialization is complete.'''
formal_spec = '''lifetime_started(obj, T) <=> (storage_obtained(obj, alignment(T), size(T)) && initialization_complete(obj))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2"
tags = ['lifetime', 'storage', 'initialization']

[[axioms]]
id = "cpp20_basic_life_ends_nonclass_destroy_2e3f4a5b"
content = '''The lifetime of an object of non-class type ends when the object is destroyed.'''
formal_spec = '''!is_class_type(T) && is_destroyed(obj, T) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.3"
tags = ['lifetime', 'destruction', 'non-class']

[[axioms]]
id = "cpp20_basic_life_ends_class_destructor_start_6c7d8e9f"
content = '''The lifetime of an object of class type ends when the destructor call starts.'''
formal_spec = '''is_class_type(T) && destructor_call_starts(obj, T) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.4"
tags = ['lifetime', 'destructor', 'class']

[[axioms]]
id = "cpp20_basic_life_ends_storage_released_0a1b2c3d"
content = '''The lifetime of an object ends when the storage which the object occupies is released.'''
formal_spec = '''storage_released(obj) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.5"
tags = ['lifetime', 'storage', 'deallocation']

[[axioms]]
id = "cpp20_basic_life_ends_storage_reused_4e5f6a7b"
content = '''The lifetime of an object ends when the storage which the object occupies is reused by an object that is not nested within it.'''
formal_spec = '''storage_reused_by_non_nested(obj, new_obj) && !nested_within(new_obj, obj) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/2.5"
tags = ['lifetime', 'storage', 'reuse']

[[axioms]]
id = "cpp20_basic_life_properties_during_lifetime_8c9d0e1f"
content = '''The properties ascribed to objects and references throughout the C++ standard apply for a given object or reference only during its lifetime.'''
formal_spec = '''applies_object_properties(obj) => lifetime_active(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/5"
tags = ['lifetime', 'object-properties']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_not_const_2a3b4c5d"
content = '''An object o1 is transparently replaceable by an object o2 only if (for complete objects) o1 is not const.'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && transparently_replaceable(o1, o2) => !is_const(o1)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/9.1.1"
tags = ['lifetime', 'transparent-replacement', 'const']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_same_storage_6e7f8a9b"
content = '''An object o1 is transparently replaceable by an object o2 only if (for complete objects) the storage that o2 occupies exactly overlays the storage that o1 occupied.'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && transparently_replaceable(o1, o2) => storage_exactly_overlays(o2, o1)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/9.1.2"
tags = ['lifetime', 'transparent-replacement', 'storage']

[[axioms]]
id = "cpp20_basic_life_transparent_replace_same_type_0c1d2e3f"
content = '''An object o1 is transparently replaceable by an object o2 only if (for complete objects) o1 and o2 are of the same type (ignoring top-level cv-qualifiers).'''
formal_spec = '''is_complete_object(o1) && is_complete_object(o2) && transparently_replaceable(o1, o2) => same_type_ignoring_cv(o1, o2)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.life"
source_module = "[basic.life]/9.1.3"
tags = ['lifetime', 'transparent-replacement', 'type']

[[axioms]]
id = "cpp20_basic_stc_dynamic_general_semantic_violation_ub_8f3a2b1c"
content = '''If the behavior of an allocation or deallocation function does not satisfy the semantic constraints specified in [basic.stc.dynamic.allocation] and [basic.stc.dynamic.deallocation], the behavior is undefined.'''
formal_spec = '''(is_allocation_function(F) || is_deallocation_function(F)) && !satisfies_semantic_constraints(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.general"
source_module = "[basic.stc.dynamic.general]/3"
tags = ['memory', 'allocation', 'deallocation', 'dynamic-storage']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_global_scope_d4e5f6a7"
content = '''An allocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage.'''
formal_spec = '''is_allocation_function(F) && !is_class_member_function(F) => belongs_to_global_scope(F) && !has_internal_linkage(name(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'linkage', 'scope']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_return_type_b2c3d4e5"
content = '''The return type of an allocation function shall be void*.'''
formal_spec = '''is_allocation_function(F) => return_type(F) == void_ptr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_first_param_type_c3d4e5f6"
content = '''The first parameter of an allocation function shall have type std::size_t.'''
formal_spec = '''is_allocation_function(F) => param_type(F, 0) == std_size_t'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_no_default_arg_a1b2c3d4"
content = '''The first parameter of an allocation function shall not have an associated default argument.'''
formal_spec = '''is_allocation_function(F) => !has_default_argument(param(F, 0))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'default-argument']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_zero_size_deref_ub_e5f6a7b8"
content = '''The effect of indirecting through a pointer returned from a request for zero size is undefined.'''
formal_spec = '''allocation_request_size(ptr) == 0 && successful_allocation(ptr) && dereference(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['memory', 'allocation', 'pointer', 'dereference', 'zero-size']
c_standard_refs = ['7.22.3/1']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_nothrow_null_return_f6a7b8c9"
content = '''An allocation function that has a non-throwing exception specification indicates failure by returning a null pointer value.'''
formal_spec = '''is_allocation_function(F) && has_nothrow_exception_spec(F) && allocation_fails(F) => returns_null(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['memory', 'allocation', 'exception', 'null-pointer']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_throwing_never_null_a7b8c9d0"
content = '''Any allocation function without a non-throwing exception specification never returns a null pointer value and indicates failure only by throwing an exception of a type that would match a handler of type std::bad_alloc.'''
formal_spec = '''is_allocation_function(F) && !has_nothrow_exception_spec(F) => !returns_null(F) && (allocation_fails(F) => throws_exception_matching(F, std_bad_alloc))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['memory', 'allocation', 'exception', 'bad_alloc']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_global_scope_b8c9d0e1"
content = '''A deallocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage.'''
formal_spec = '''is_deallocation_function(F) && !is_class_member_function(F) => belongs_to_global_scope(F) && !has_internal_linkage(name(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/1"
tags = ['memory', 'deallocation', 'linkage', 'scope']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_class_member_c9d0e1f2"
content = '''A destroying operator delete shall be a class member function named operator delete.'''
formal_spec = '''is_destroying_operator_delete(F) => is_class_member_function(F) && name(F) == "operator delete"'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/2"
tags = ['memory', 'deallocation', 'destroying-delete', 'class-member']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_return_void_d0e1f2a3"
content = '''Each deallocation function shall return void.'''
formal_spec = '''is_deallocation_function(F) => return_type(F) == void'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_first_param_type_e1f2a3b4"
content = '''If the deallocation function is a destroying operator delete declared in class type C, the type of its first parameter shall be C*; otherwise, the type of its first parameter shall be void*.'''
formal_spec = '''is_deallocation_function(F) && is_destroying_operator_delete(F) && declared_in_class(F, C) => param_type(F, 0) == ptr_to(C); is_deallocation_function(F) && !is_destroying_operator_delete(F) => param_type(F, 0) == void_ptr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'type-constraint', 'destroying-delete']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_usual_f2a3b4c5"
content = '''A destroying operator delete shall be a usual deallocation function.'''
formal_spec = '''is_destroying_operator_delete(F) => is_usual_deallocation_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'destroying-delete']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_exception_ub_a3b4c5d6"
content = '''If a deallocation function terminates by throwing an exception, the behavior is undefined.'''
formal_spec = '''is_deallocation_function(F) && terminates_by_throwing(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/4"
tags = ['memory', 'deallocation', 'exception']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_stdlib_nonnull_b4c5d6e7"
content = '''If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, ending the duration of the region of storage.'''
formal_spec = '''is_stdlib_deallocation_function(F) && arg(F, 0) != null_ptr => deallocates_storage(F, arg(F, 0)) && ends_storage_duration(arg(F, 0))'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/5"
tags = ['memory', 'deallocation', 'stdlib']
c_standard_refs = ['7.22.3.3']

[[axioms]]
id = "cpp20_basic_stc_static_side_effects_no_eliminate_c5d6e7f8"
content = '''If a variable with static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in [class.copy.elision].'''
formal_spec = '''has_static_storage_duration(V) && (has_side_effect_initialization(V) || has_side_effect_destructor(V)) => !may_eliminate(V) || is_copy_move_elision_permitted(V)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.static"
source_module = "[basic.stc.static]/2"
tags = ['storage-duration', 'static', 'side-effects', 'optimization']

[[axioms]]
id = "cpp20_basic_stc_auto_side_effects_no_eliminate_d6e7f8a9"
content = '''If a variable with automatic storage duration has initialization or a destructor with side effects, an implementation shall not destroy it before the end of its block nor eliminate it as an optimization, even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in [class.copy.elision].'''
formal_spec = '''has_automatic_storage_duration(V) && (has_side_effect_initialization(V) || has_side_effect_destructor(V)) => (!destroyed_before_block_end(V) && !may_eliminate(V)) || is_copy_move_elision_permitted(V)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.auto"
source_module = "[basic.stc.auto]/2"
tags = ['storage-duration', 'automatic', 'side-effects', 'optimization', 'lifetime']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_template_return_first_e7f8a9b0"
content = '''An allocation function template shall declare its return type and first parameter as specified (void* return type and std::size_t first parameter) - template parameter types shall not be used in the return type and first parameter type.'''
formal_spec = '''is_allocation_function_template(F) => return_type(F) == void_ptr && param_type(F, 0) == std_size_t && !uses_template_param(return_type(F)) && !uses_template_param(param_type(F, 0))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'template', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_template_min_params_f8a9b0c1"
content = '''Allocation function templates shall have two or more parameters.'''
formal_spec = '''is_allocation_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['memory', 'allocation', 'template']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_constraints_a9b0c1d2"
content = '''For a deallocation function template, neither the first parameter nor the return type shall depend on a template parameter.'''
formal_spec = '''is_deallocation_function_template(F) => !depends_on_template_param(param_type(F, 0)) && !depends_on_template_param(return_type(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'template', 'type-constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_min_params_b0c1d2e3"
content = '''A deallocation function template shall have two or more function parameters.'''
formal_spec = '''is_deallocation_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'template']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_not_usual_c1d2e3f4"
content = '''A template instance is never a usual deallocation function, regardless of its signature.'''
formal_spec = '''is_template_instance(F) && is_deallocation_function(F) => !is_usual_deallocation_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['memory', 'deallocation', 'template']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_align_val_alignment_d2e3f4a5"
content = '''For an allocation function other than a reserved placement allocation function that takes an argument of type std::align_val_t, the storage returned on a successful call will have the alignment specified by the value of this argument.'''
formal_spec = '''is_allocation_function(F) && !is_reserved_placement_allocation(F) && has_param_type(F, std_align_val_t) && successful_call(F) => alignment(returned_storage(F)) == value_of_align_val_t_arg(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3"
tags = ['memory', 'allocation', 'alignment']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_array_alignment_e3f4a5b6"
content = '''For an allocation function named operator new[] that does not take an std::align_val_t argument, the storage returned is aligned for any object that does not have new-extended alignment and is no larger than the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new[]" && !has_param_type(F, std_align_val_t) && !is_reserved_placement_allocation(F) && successful_call(F) => aligned_for_any_object_without_new_extended_alignment_up_to_size(returned_storage(F), requested_size(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3"
tags = ['memory', 'allocation', 'alignment', 'array']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_single_alignment_f4a5b6c7"
content = '''For an allocation function named operator new that does not take an std::align_val_t argument, the storage returned is aligned for any object that does not have new-extended alignment and is of the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new" && !has_param_type(F, std_align_val_t) && !is_reserved_placement_allocation(F) && successful_call(F) => aligned_for_any_object_without_new_extended_alignment_of_size(returned_storage(F), requested_size(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3"
tags = ['memory', 'allocation', 'alignment']

[[axioms]]
id = "cpp20_basic_stc_dynamic_general_alloc_dealloc_semantics_a3f8b2c1"
content = '''If the behavior of an allocation or deallocation function does not satisfy the semantic constraints specified in [basic.stc.dynamic.allocation] and [basic.stc.dynamic.deallocation], the behavior is undefined.'''
formal_spec = '''(is_allocation_function(F) || is_deallocation_function(F)) && !satisfies_semantic_constraints(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.general"
source_module = "[basic.stc.dynamic.general]/3"
tags = ['allocation', 'deallocation', 'semantics', 'undefined-behavior']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_return_type_void_ptr_b2c3d4e5"
content = '''The return type of an allocation function shall be void*.'''
formal_spec = '''is_allocation_function(F) => return_type(F) == void_ptr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'return-type', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_first_param_size_t_c3d4e5f6"
content = '''The first parameter of an allocation function shall have type std::size_t.'''
formal_spec = '''is_allocation_function(F) => param_type(F, 0) == std_size_t'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_no_default_first_param_e5f6a7b8"
content = '''The first parameter of an allocation function shall not have an associated default argument.'''
formal_spec = '''is_allocation_function(F) => !has_default_argument(param(F, 0))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'parameter', 'default-argument', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_template_params_f6a7b8c9"
content = '''Allocation function templates shall have two or more parameters.'''
formal_spec = '''is_allocation_function(F) && is_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/1"
tags = ['allocation', 'template', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_zero_size_deref_ub_a7b8c9d0"
content = '''The effect of indirecting through a pointer returned from a request for zero size is undefined.'''
formal_spec = '''allocation_request_size(ptr) == 0 && dereference(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'zero-size', 'dereference', 'undefined-behavior']
c_standard_refs = ['7.22.3/1']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_nothrow_null_return_b8c9d0e1"
content = '''An allocation function that has a non-throwing exception specification indicates failure by returning a null pointer value.'''
formal_spec = '''is_allocation_function(F) && has_nothrow_spec(F) && allocation_fails(F) => returns_null(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['allocation', 'nothrow', 'null', 'exception']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_throwing_never_null_c9d0e1f2"
content = '''Any allocation function without a non-throwing exception specification never returns a null pointer value and indicates failure only by throwing an exception of a type that would match a handler of type std::bad_alloc.'''
formal_spec = '''is_allocation_function(F) && !has_nothrow_spec(F) => (!returns_null(F) && (allocation_fails(F) => throws_bad_alloc_compatible(F)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/4"
tags = ['allocation', 'exception', 'bad_alloc', 'null']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_global_scope_d0e1f2a3"
content = '''A deallocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage.'''
formal_spec = '''is_deallocation_function(F) && !is_class_member(F) => (has_global_scope(F) && !has_internal_linkage(name(F)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/1"
tags = ['deallocation', 'linkage', 'scope', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_delete_class_e1f2a3b4"
content = '''A destroying operator delete shall be a class member function named operator delete.'''
formal_spec = '''is_destroying_operator_delete(F) => (is_class_member(F) && name(F) == "operator delete")'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/2"
tags = ['deallocation', 'destroying-delete', 'class-member', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_return_void_f2a3b4c5"
content = '''Each deallocation function shall return void.'''
formal_spec = '''is_deallocation_function(F) => return_type(F) == void'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'return-type', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_first_param_type_a3b4c5d6"
content = '''If a deallocation function is a destroying operator delete declared in class type C, the type of its first parameter shall be C*; otherwise, the type of its first parameter shall be void*.'''
formal_spec = '''is_deallocation_function(F) => (is_destroying_operator_delete_in_class(F, C) ? param_type(F, 0) == ptr_to(C) : param_type(F, 0) == void_ptr)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'parameter', 'destroying-delete', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_destroying_usual_b4c5d6e7"
content = '''A destroying operator delete shall be a usual deallocation function.'''
formal_spec = '''is_destroying_operator_delete(F) => is_usual_deallocation_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'destroying-delete', 'usual', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_params_c5d6e7f8"
content = '''A deallocation function template shall have two or more function parameters.'''
formal_spec = '''is_deallocation_function(F) && is_function_template(F) => param_count(F) >= 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'template', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_template_first_param_d6e7f8a9"
content = '''Neither the first parameter nor the return type of a deallocation function template shall depend on a template parameter.'''
formal_spec = '''is_deallocation_function(F) && is_function_template(F) => (!depends_on_template_param(param_type(F, 0)) && !depends_on_template_param(return_type(F)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/3"
tags = ['deallocation', 'template', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_throw_ub_e7f8a9b0"
content = '''If a deallocation function terminates by throwing an exception, the behavior is undefined.'''
formal_spec = '''is_deallocation_function(F) && terminates_by_throwing(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/4"
tags = ['deallocation', 'exception', 'undefined-behavior']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_null_no_effect_f8a9b0c1"
content = '''The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect.'''
formal_spec = '''is_deallocation_function(F) && is_stdlib_deallocation(F) && arg(F, 0) == nullptr => no_effect(call(F))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/4"
tags = ['deallocation', 'null', 'stdlib', 'semantics']
c_standard_refs = ['7.22.3.3/2']

[[axioms]]
id = "cpp20_basic_stc_dynamic_deallocation_shall_deallocate_a9b0c1d2"
content = '''If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, ending the duration of the region of storage.'''
formal_spec = '''is_stdlib_deallocation(F) && arg(F, 0) != nullptr => (deallocates_storage(F, arg(F, 0)) && ends_storage_duration(arg(F, 0)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.deallocation"
source_module = "[basic.stc.dynamic.deallocation]/5"
tags = ['deallocation', 'storage', 'stdlib', 'semantics']
c_standard_refs = ['7.22.3.3/2']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_alignment_align_val_b0c1d2e3"
content = '''For an allocation function other than a reserved placement allocation function, if the allocation function takes an argument of type std::align_val_t, the storage will have the alignment specified by the value of this argument.'''
formal_spec = '''is_allocation_function(F) && !is_reserved_placement(F) && has_param_type(F, std_align_val_t) && succeeds(F) => alignment(returned_storage(F)) == align_val_arg(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3.1"
tags = ['allocation', 'alignment', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_alignment_array_c1d2e3f4"
content = '''For an allocation function named operator new[] without std::align_val_t parameter (and not a reserved placement allocation function), the storage is aligned for any object that does not have new-extended alignment and is no larger than the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new[]" && !has_param_type(F, std_align_val_t) && !is_reserved_placement(F) && succeeds(F) => aligned_for_any_object_up_to_size(returned_storage(F), requested_size(F), !new_extended_alignment)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3.2"
tags = ['allocation', 'alignment', 'array', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_alignment_single_d2e3f4a5"
content = '''For an allocation function named operator new without std::align_val_t parameter (and not a reserved placement allocation function), the storage is aligned for any object that does not have new-extended alignment and is of the requested size.'''
formal_spec = '''is_allocation_function(F) && name(F) == "operator new" && !has_param_type(F, std_align_val_t) && !is_reserved_placement(F) && succeeds(F) => aligned_for_any_object_of_size(returned_storage(F), requested_size(F), !new_extended_alignment)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/3.3"
tags = ['allocation', 'alignment', 'constraint']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_min_size_e3f4a5b6"
content = '''If an allocation function is successful, it returns the address of the start of a block of storage whose length in bytes is at least as large as the requested size.'''
formal_spec = '''is_allocation_function(F) && succeeds(F) => storage_size(returned_storage(F)) >= requested_size(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'size', 'semantics']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_replaceable_unique_ptr_f4a5b6c7"
content = '''If the request succeeds, the value returned by a replaceable allocation function is a non-null pointer value p0 different from any previously returned value p1, unless that value p1 was subsequently passed to a replaceable deallocation function.'''
formal_spec = '''is_replaceable_allocation(F) && succeeds(F) => (returned_ptr(F) != nullptr && (forall p1. (previously_returned(p1) && !subsequently_deallocated(p1)) => returned_ptr(F) != p1))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'replaceable', 'pointer', 'uniqueness']

[[axioms]]
id = "cpp20_basic_stc_dynamic_allocation_disjoint_storage_a5b6c7d8"
content = '''For the library allocation functions in [new.delete.single] and [new.delete.array], the returned pointer p0 represents the address of a block of storage disjoint from the storage for any other object accessible to the caller.'''
formal_spec = '''is_stdlib_allocation(F) && succeeds(F) => disjoint_from_accessible_objects(returned_storage(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.stc.dynamic.allocation"
source_module = "[basic.stc.dynamic.allocation]/2"
tags = ['allocation', 'stdlib', 'disjoint', 'storage']

[[axioms]]
id = "cpp20_expr_pre_math_undefined_result_7b3f8a2e"
content = '''If during the evaluation of an expression, the result is not mathematically defined, the behavior is undefined.'''
formal_spec = '''eval(expr) && !mathematically_defined(result(expr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.pre"
source_module = "[expr.pre]/4"
tags = ['expression', 'evaluation', 'arithmetic', 'undefined-behavior']
c_standard_refs = ['6.5/5']

[[axioms]]
id = "cpp20_expr_pre_out_of_range_result_c4d9e1f0"
content = '''If during the evaluation of an expression, the result is not in the range of representable values for its type, the behavior is undefined.'''
formal_spec = '''eval(expr) && !in_range(result(expr), type(expr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.pre"
source_module = "[expr.pre]/4"
tags = ['expression', 'evaluation', 'overflow', 'range', 'undefined-behavior']
c_standard_refs = ['6.5/5']

[[axioms]]
id = "cpp20_expr_pre_builtin_op_rules_preserved_a8c2b5d1"
content = '''Operator overloading shall not modify the rules for the built-in operators, that is, for operators applied to types for which they are defined by this Standard.'''
formal_spec = '''is_overloaded_operator(op) && is_builtin_type(operand_types(op)) => apply_builtin_rules(op)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.pre"
source_module = "[expr.pre]/3"
tags = ['operator', 'overloading', 'builtin', 'constraint']

[[axioms]]
id = "cpp20_basic_lval_prvalue_complete_type_a3f8c2d1"
content = '''A prvalue shall always have complete type or the void type; if it has a class type or array of class type, that class shall not be an abstract class.'''
formal_spec = '''is_prvalue(E) => (is_complete_type(type(E)) || is_void_type(type(E))) && (is_class_type(type(E)) || is_array_of_class_type(type(E)) => !is_abstract_class(class_of(type(E))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/9"
tags = ['expression', 'prvalue', 'complete-type', 'abstract-class']

[[axioms]]
id = "cpp20_basic_lval_glvalue_not_void_b7e4d2f9"
content = '''A glvalue shall not have type cv void.'''
formal_spec = '''is_glvalue(E) => !is_cv_void_type(type(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/9"
tags = ['expression', 'glvalue', 'void', 'type']

[[axioms]]
id = "cpp20_basic_lval_type_access_ub_c8a1e3f5"
content = '''If a program attempts to access the stored value of an object through a glvalue through which it is not type-accessible, the behavior is undefined.'''
formal_spec = '''access_stored_value(obj, glv) && !type_accessible(dynamic_type(obj), type(glv)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/11"
tags = ['aliasing', 'type-access', 'strict-aliasing', 'undefined-behavior']
c_standard_refs = ['6.5/7']

[[axioms]]
id = "cpp20_basic_lval_type_accessible_similar_d4b2c8e7"
content = '''An object of dynamic type Tobj is type-accessible through a glvalue of type Tref only if Tref is similar to Tobj, or is the signed/unsigned corresponding type, or is char, unsigned char, or std::byte.'''
formal_spec = '''type_accessible(Tobj, Tref) <=> (similar(Tref, Tobj) || is_signed_unsigned_corresponding(Tref, Tobj) || Tref == char || Tref == unsigned_char || Tref == std::byte)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/11"
tags = ['aliasing', 'type-access', 'strict-aliasing']
c_standard_refs = ['6.5/7']

[[axioms]]
id = "cpp20_basic_lval_union_copy_move_ub_e9f3a6c2"
content = '''If a program invokes a defaulted copy/move constructor or copy/move assignment operator for a union of type U with a glvalue argument that does not denote an object of type cv U within its lifetime, the behavior is undefined.'''
formal_spec = '''invoke_defaulted_copy_move(union_type(U), glv) && !(denotes_object_within_lifetime(glv, cv_qualified(U))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/11"
tags = ['union', 'copy-constructor', 'move-constructor', 'lifetime', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_type_reference_invalid_ptr_ub_f2a7b4d8"
content = '''If an expression has type "reference to T" and a pointer to the denoted object or function would be invalid in the context of the evaluation, the behavior is undefined.'''
formal_spec = '''has_reference_type(E, T) && !valid_pointer_context(pointer_to(denoted_entity(E)), eval_context(E)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.type"
source_module = "[expr.type]/1"
tags = ['reference', 'pointer', 'validity', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_type_reference_lifetime_ub_a1c5d9e3"
content = '''Before the lifetime of the reference has started or after it has ended, using the expression with reference type is undefined behavior.'''
formal_spec = '''has_reference_type(E, T) && (!lifetime_started(reference_of(E)) || lifetime_ended(reference_of(E))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.type"
source_module = "[expr.type]/1"
tags = ['reference', 'lifetime', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_type_composite_ptr_ill_formed_b3d6f8a2"
content = '''A program that necessitates the determination of a composite pointer type when no valid composite pointer type exists is ill-formed.'''
formal_spec = '''requires_composite_pointer_type(p1, p2) && !exists_composite_pointer_type(type(p1), type(p2)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.type"
source_module = "[expr.type]/3.9"
tags = ['pointer', 'composite-pointer-type', 'ill-formed']

[[axioms]]
id = "cpp20_basic_lval_modify_const_ill_formed_c7e2a4b9"
content = '''A program that attempts to modify an object through a nonmodifiable lvalue or through an rvalue is ill-formed.'''
formal_spec = '''(modify_through(lv, obj) && !modifiable_lvalue(lv)) || modify_through_rvalue(rv, obj) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "basic.lval"
source_module = "[basic.lval]/10"
tags = ['const', 'modifiable', 'lvalue', 'rvalue', 'assignment']

[[axioms]]
id = "cpp20_basic_lval_modifiable_def_d8f1c5e6"
content = '''An lvalue is modifiable unless its type is const-qualified or is a function type.'''
formal_spec = '''modifiable_lvalue(lv) <=> is_lvalue(lv) && !is_const_qualified(type(lv)) && !is_function_type(type(lv))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/10"
tags = ['lvalue', 'modifiable', 'const', 'function-type']

[[axioms]]
id = "cpp20_basic_lval_unique_category_e4a3b7c8"
content = '''Every expression belongs to exactly one of the fundamental categories: lvalue, xvalue, or prvalue.'''
formal_spec = '''forall E: is_expression(E) => exactly_one(is_lvalue(E), is_xvalue(E), is_prvalue(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "basic.lval"
source_module = "[basic.lval]/2"
tags = ['expression', 'value-category', 'lvalue', 'xvalue', 'prvalue']

[[axioms]]
id = "cpp20_expr_prim_this_invalid_context_a1b2c3d4"
content = '''The expression 'this' shall not appear in any context other than within member function bodies, non-static data member default initializers, or contract assertion predicates of the current class.'''
formal_spec = '''appears(this_expr, context) && !valid_this_context(context) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.this"
source_module = "[expr.prim.this]/6"
tags = ['this', 'member-function', 'context']

[[axioms]]
id = "cpp20_expr_prim_this_static_member_e5f6a7b8"
content = '''The expression 'this' shall not appear within the declaration of a static or explicit object member function of the current class.'''
formal_spec = '''appears(this_expr, decl) && (is_static_member_function(decl) || is_explicit_object_member_function(decl)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.this"
source_module = "[expr.prim.this]/4"
tags = ['this', 'static', 'member-function']

[[axioms]]
id = "cpp20_expr_prim_id_ctor_pre_dtor_post_c9d0e1f2"
content = '''If the implicit transformation of an id-expression to a class member access using (*this) occurs in the predicate of a precondition assertion of a constructor or postcondition assertion of a destructor of the current class, the expression is ill-formed.'''
formal_spec = '''id_expr_transform_to_member_access(E, X) && ((in_precondition(E) && is_constructor(enclosing_function(E), X)) || (in_postcondition(E) && is_destructor(enclosing_function(E), X))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.general"
source_module = "[expr.prim.id.general]/2"
tags = ['id-expression', 'contract', 'constructor', 'destructor', 'precondition', 'postcondition']

[[axioms]]
id = "cpp20_expr_prim_id_base_class_splice_g3h4i5j6"
content = '''A splice-expression that designates a direct base class relationship shall appear only as the second operand of a class member access.'''
formal_spec = '''splice_expr_designates_base_class(E) && !is_second_operand_of_member_access(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.general"
source_module = "[expr.prim.id.general]/5"
tags = ['splice', 'base-class', 'member-access']

[[axioms]]
id = "cpp20_expr_prim_id_nonstatic_usage_k7l8m9n0"
content = '''An id-expression or splice-expression that designates a non-static data member or implicit object member function can only be used as part of a class member access, to form a pointer to member, or in an unevaluated operand (for data members only).'''
formal_spec = '''(designates_nonstatic_data_member(E) || designates_implicit_object_member_function(E)) && !is_class_member_access(E) && !forms_pointer_to_member(E) && !(designates_nonstatic_data_member(E) && is_unevaluated_operand(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.general"
source_module = "[expr.prim.id.general]/4"
tags = ['id-expression', 'non-static', 'member-access', 'pointer-to-member']

[[axioms]]
id = "cpp20_expr_prim_pack_index_must_be_pack_o1p2q3r4"
content = '''The id-expression P in a pack-index-expression shall be an identifier that denotes a pack.'''
formal_spec = '''pack_index_expression(P, idx) && !denotes_pack(P) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.pack.index"
source_module = "[expr.prim.pack.index]/1"
tags = ['pack', 'variadic', 'pack-index']

[[axioms]]
id = "cpp20_expr_prim_pack_index_bounds_s5t6u7v8"
content = '''The index in a pack-index-expression shall be a converted constant expression of type std::size_t whose value V satisfies 0 <= V < sizeof...(P).'''
formal_spec = '''pack_index_expression(P, V) && (V < 0 || V >= sizeof_pack(P)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.pack.index"
source_module = "[expr.prim.pack.index]/2"
tags = ['pack', 'variadic', 'pack-index', 'bounds']

[[axioms]]
id = "cpp20_expr_prim_dtor_pseudo_context_w9x0y1z2"
content = '''If an id-expression names a pseudo-destructor (destructor of a scalar type T), T shall be a scalar type and the id-expression shall appear as the right operand of a class member access that forms the postfix-expression of a function call.'''
formal_spec = '''names_pseudo_destructor(id_expr, T) && (!is_scalar_type(T) || !is_right_operand_of_member_access_in_function_call(id_expr)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.dtor"
source_module = "[expr.prim.id.dtor]/2"
tags = ['destructor', 'pseudo-destructor', 'scalar']

[[axioms]]
id = "cpp20_expr_prim_dtor_double_destroy_ub_a3b4c5d6"
content = '''Destroying a temporary object twice is undefined behavior.'''
formal_spec = '''is_temporary(obj) && destroyed(obj) && destroy(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.dtor"
source_module = "[expr.prim.id.dtor]/3"
tags = ['destructor', 'temporary', 'lifetime', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_prim_lambda_specifier_unique_e7f8g9h0"
content = '''A lambda-specifier-seq shall contain at most one of each lambda-specifier and shall not contain both constexpr and consteval.'''
formal_spec = '''lambda_specifier_seq(L) && (duplicate_specifier(L) || (contains(L, constexpr) && contains(L, consteval))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'constexpr', 'consteval']

[[axioms]]
id = "cpp20_expr_prim_lambda_explicit_obj_specifier_i1j2k3l4"
content = '''If the lambda-declarator contains an explicit object parameter, then no lambda-specifier in the lambda-specifier-seq shall be mutable or static.'''
formal_spec = '''has_explicit_object_parameter(lambda) && (has_specifier(lambda, mutable) || has_specifier(lambda, static)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'explicit-object-parameter', 'mutable', 'static']

[[axioms]]
id = "cpp20_expr_prim_lambda_mutable_static_m5n6o7p8"
content = '''The lambda-specifier-seq shall not contain both mutable and static.'''
formal_spec = '''lambda_specifier_seq(L) && contains(L, mutable) && contains(L, static) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'mutable', 'static']

[[axioms]]
id = "cpp20_expr_prim_lambda_static_no_capture_q9r0s1t2"
content = '''If the lambda-specifier-seq contains static, there shall be no lambda-capture.'''
formal_spec = '''has_specifier(lambda, static) && has_lambda_capture(lambda) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.general"
source_module = "[expr.prim.lambda.general]/4"
tags = ['lambda', 'static', 'capture']

[[axioms]]
id = "cpp20_expr_prim_lambda_explicit_obj_type_u3v4w5x6"
content = '''Given a lambda with a lambda-capture, the type of the explicit object parameter shall be either the closure type, a class type publicly and unambiguously derived from the closure type, or a reference to a possibly cv-qualified such type.'''
formal_spec = '''has_lambda_capture(lambda) && has_explicit_object_parameter(lambda, T) && !valid_explicit_obj_param_type(T, closure_type(lambda)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.closure"
source_module = "[expr.prim.lambda.closure]/6"
tags = ['lambda', 'explicit-object-parameter', 'closure-type']

[[axioms]]
id = "cpp20_expr_prim_lambda_contract_only_capture_y7z8a9b0"
content = '''If all potential references to a local entity implicitly captured by a lambda-expression L occur only within the function contract assertions or assertion-statements within the body of L, the program is ill-formed.'''
formal_spec = '''implicitly_captured(lambda, entity) && all_references_in_contract_assertions(lambda, entity) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.closure"
source_module = "[expr.prim.lambda.closure]/10"
tags = ['lambda', 'capture', 'contract', 'assertion']

[[axioms]]
id = "cpp20_expr_prim_lambda_member_no_specialize_c1d2e3f4"
content = '''A member of a closure type shall not be explicitly instantiated, explicitly specialized, or named in a friend declaration.'''
formal_spec = '''is_closure_type_member(M) && (explicitly_instantiated(M) || explicitly_specialized(M) || named_in_friend_decl(M)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.closure"
source_module = "[expr.prim.lambda.closure]/19"
tags = ['lambda', 'closure-type', 'instantiation', 'specialization', 'friend']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_default_amp_g5h6i7j8"
content = '''If a lambda-capture includes a capture-default that is &, no identifier in a simple-capture of that lambda-capture shall be preceded by &.'''
formal_spec = '''capture_default(lambda, by_ref) && simple_capture(lambda, id) && preceded_by_ampersand(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/2"
tags = ['lambda', 'capture', 'capture-default']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_default_eq_k9l0m1n2"
content = '''If a lambda-capture includes a capture-default that is =, each simple-capture of that lambda-capture shall be of the form "&identifier...opt", "this", or "*this".'''
formal_spec = '''capture_default(lambda, by_copy) && simple_capture(lambda, cap) && !is_ref_capture(cap) && !is_this_capture(cap) && !is_star_this_capture(cap) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/2"
tags = ['lambda', 'capture', 'capture-default']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_duplicate_o3p4q5r6"
content = '''Ignoring appearances in initializers of init-captures, an identifier or this shall not appear more than once in a lambda-capture.'''
formal_spec = '''appears_multiple_times_in_capture(lambda, id_or_this) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/2"
tags = ['lambda', 'capture', 'duplicate']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_context_s7t8u9v0"
content = '''A lambda-expression shall not have a capture-default or simple-capture in its lambda-introducer unless its innermost enclosing scope is a block scope, it appears within a default member initializer, or it appears within a contract assertion.'''
formal_spec = '''has_capture(lambda) && !in_block_scope(lambda) && !in_default_member_initializer(lambda) && !in_contract_assertion(lambda) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/3"
tags = ['lambda', 'capture', 'scope']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_local_entity_w1x2y3z4"
content = '''The identifier in a simple-capture shall denote a local entity.'''
formal_spec = '''simple_capture(lambda, id) && !denotes_local_entity(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/4"
tags = ['lambda', 'capture', 'local-entity']

[[axioms]]
id = "cpp20_expr_prim_lambda_capture_param_shadow_a5b6c7d8"
content = '''If an identifier in a capture appears as the declarator-id of a parameter of the lambda-declarator's parameter-declaration-clause or as the name of a template parameter of the lambda-expression's template-parameter-list, the program is ill-formed.'''
formal_spec = '''capture_identifier(lambda, id) && (is_parameter_name(lambda, id) || is_template_parameter_name(lambda, id)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.lambda.capture"
source_module = "[expr.prim.lambda.capture]/5"
tags = ['lambda', 'capture', 'parameter', 'shadowing']

[[axioms]]
id = "cpp20_expr_prim_qual_computed_dtor_e9f0g1h2"
content = '''A qualified-id shall not be of the form nested-name-specifier template-opt ~computed-type-specifier nor of the form computed-type-specifier::~type-name.'''
formal_spec = '''(qualified_id_form(Q, nns_template_opt_tilde_computed_type_specifier) || qualified_id_form(Q, computed_type_specifier_tilde_type_name)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/5"
tags = ['qualified-id', 'destructor', 'computed-type-specifier']

[[axioms]]
id = "cpp20_expr_prim_qual_declarative_nns_i3j4k5l6"
content = '''A declarative nested-name-specifier shall not have a computed-type-specifier or a splice-scope-specifier.'''
formal_spec = '''is_declarative_nns(nns) && (has_computed_type_specifier(nns) || has_splice_scope_specifier(nns)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/3"
tags = ['nested-name-specifier', 'declarative', 'computed-type-specifier', 'splice']

[[axioms]]
id = "cpp20_expr_prim_qual_nns_computed_class_enum_m7n8o9p0"
content = '''A nested-name-specifier with a computed-type-specifier designates a type which shall be a class or enumeration type.'''
formal_spec = '''nns_with_computed_type_specifier(nns, T) && !is_class_type(T) && !is_enumeration_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/4.2"
tags = ['nested-name-specifier', 'computed-type-specifier', 'class', 'enumeration']

[[axioms]]
id = "cpp20_expr_prim_qual_splice_class_enum_ns_q1r2s3t4"
content = '''For a nested-name-specifier of the form splice-specifier::, the splice-specifier shall designate a class or enumeration type or a namespace.'''
formal_spec = '''nns_splice_specifier(nns, splice) && !designates_class_type(splice) && !designates_enumeration_type(splice) && !designates_namespace(splice) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/4.3"
tags = ['nested-name-specifier', 'splice', 'class', 'enumeration', 'namespace']

[[axioms]]
id = "cpp20_expr_prim_qual_nns_not_template_u5v6w7x8"
content = '''If a nested-name-specifier is not declarative, the entity it designates shall not be a template.'''
formal_spec = '''!is_declarative_nns(nns) && designates_template(nns) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.id.qual"
source_module = "[expr.prim.id.qual]/4.6"
tags = ['nested-name-specifier', 'template', 'declarative']

[[axioms]]
id = "cpp20_expr_unary_op_indirection_invalid_ptr_a7c3b2d1"
content = '''Indirection through a pointer that does not point to an object or function is undefined behavior, except as specified in [expr.typeid].'''
formal_spec = '''unary_indirection(ptr) && !points_to_object(ptr) && !points_to_function(ptr) && !typeid_context() => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/1"
tags = ['pointer', 'indirection', 'dereference', 'undefined-behavior']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_unary_op_address_bitfield_e8f4a1c2"
content = '''The operand of the address-of operator (&) shall not be a bit-field.'''
formal_spec = '''address_of(operand) && is_bitfield(operand) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/5"
tags = ['address-of', 'bitfield', 'constraint']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_pre_incr_bool_constraint_b3d2e5f6"
content = '''The operand of prefix ++ or -- shall not be of type cv bool.'''
formal_spec = '''(prefix_increment(operand) || prefix_decrement(operand)) && is_cv_bool(type(operand)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.pre.incr"
source_module = "[expr.pre.incr]/1"
tags = ['increment', 'decrement', 'bool', 'constraint']

[[axioms]]
id = "cpp20_expr_sizeof_function_type_c4a5b6d7"
content = '''The sizeof operator shall not be applied to an expression that has function type.'''
formal_spec = '''sizeof_expr(E) && is_function_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/1"
tags = ['sizeof', 'function', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_sizeof_incomplete_type_d5e6f7a8"
content = '''The sizeof operator shall not be applied to an expression that has incomplete type, or to the parenthesized name of such types.'''
formal_spec = '''sizeof_expr(E) && is_incomplete_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/1"
tags = ['sizeof', 'incomplete-type', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_sizeof_bitfield_e6f7a8b9"
content = '''The sizeof operator shall not be applied to a glvalue that designates a bit-field.'''
formal_spec = '''sizeof_expr(E) && is_glvalue(E) && is_bitfield(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/1"
tags = ['sizeof', 'bitfield', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_alignof_complete_type_f7a8b9c0"
content = '''The alignof operand shall be a type-id representing a complete object type, or an array thereof, or a reference to one of those types.'''
formal_spec = '''alignof_expr(T) && !(is_complete_object_type(T) || is_array_of_complete_object_type(T) || is_reference_to_complete_object_type(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.alignof"
source_module = "[expr.alignof]/1"
tags = ['alignof', 'complete-type', 'constraint']
c_standard_refs = ['6.5.3.4']

[[axioms]]
id = "cpp20_expr_new_complete_type_a8b9c0d1"
content = '''The allocated type of a new-expression shall be a complete object type.'''
formal_spec = '''new_expression(T) && !is_complete_object_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/1"
tags = ['new', 'complete-type', 'constraint']

[[axioms]]
id = "cpp20_expr_new_abstract_class_b9c0d1e2"
content = '''The allocated type of a new-expression shall not be an abstract class type or array thereof.'''
formal_spec = '''new_expression(T) && (is_abstract_class(T) || is_array_of_abstract_class(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/1"
tags = ['new', 'abstract-class', 'constraint']

[[axioms]]
id = "cpp20_expr_new_array_bound_positive_c0d1e2f3"
content = '''Every constant-expression in a noptr-new-declarator shall have a value greater than zero.'''
formal_spec = '''noptr_new_declarator_constant_expr(E) && value(E) <= 0 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/6"
tags = ['new', 'array', 'constraint']

[[axioms]]
id = "cpp20_expr_new_placement_null_d1e2f3a4"
content = '''If the allocation function is a non-allocating form that returns null, the behavior is undefined.'''
formal_spec = '''new_expression(E) && is_non_allocating_form(alloc_fn(E)) && returns_null(alloc_fn(E)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/22"
tags = ['new', 'placement', 'allocation', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_delete_single_invalid_ptr_e2f3a4b5"
content = '''In a single-object delete expression, if the operand value is not null, not from a previous non-array new-expression, and not a pointer to a base class subobject of such an object, the behavior is undefined.'''
formal_spec = '''delete_single(ptr) && !is_null(ptr) && !from_non_array_new(ptr) && !is_base_subobject_ptr(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/2"
tags = ['delete', 'pointer', 'undefined-behavior', 'lifetime']

[[axioms]]
id = "cpp20_expr_delete_array_invalid_ptr_f3a4b5c6"
content = '''In an array delete expression, if the operand value is not null and not from a previous array new-expression whose allocation function was not a non-allocating form, the behavior is undefined.'''
formal_spec = '''delete_array(ptr) && !is_null(ptr) && !(from_array_new(ptr) && !is_non_allocating_form(alloc_fn_of_new(ptr))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/2"
tags = ['delete', 'array', 'pointer', 'undefined-behavior', 'lifetime']

[[axioms]]
id = "cpp20_expr_delete_virtual_destructor_a4b5c6d7"
content = '''In a single-object delete expression, if the static type differs from the dynamic type, the selected deallocation function is not a destroying operator delete, and the static type does not have a virtual destructor, the behavior is undefined.'''
formal_spec = '''delete_single(ptr) && !is_null(ptr) && !similar_types(static_type(ptr), dynamic_type(ptr)) && !is_destroying_delete(dealloc_fn) && !has_virtual_destructor(static_type(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/3"
tags = ['delete', 'virtual-destructor', 'polymorphism', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_delete_array_type_mismatch_b5c6d7e8"
content = '''In an array delete expression, if the dynamic type of the object to be deleted is not similar to its static type, the behavior is undefined.'''
formal_spec = '''delete_array(ptr) && !is_null(ptr) && !similar_types(dynamic_type(ptr), static_type(ptr)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/3"
tags = ['delete', 'array', 'type-mismatch', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_delete_incomplete_class_c6d7e8f9"
content = '''If the object being deleted has incomplete class type at the point of deletion, the program is ill-formed.'''
formal_spec = '''delete_expression(ptr) && is_incomplete_class_type(pointee_type(ptr)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/4"
tags = ['delete', 'incomplete-type', 'constraint']

[[axioms]]
id = "cpp20_expr_await_context_compound_stmt_d7e8f9a0"
content = '''An await-expression shall appear only as a potentially-evaluated expression within the compound-statement of a function-body or lambda-expression, outside of a handler.'''
formal_spec = '''await_expression(E) && !(in_compound_stmt_of_function_body(E) || in_compound_stmt_of_lambda(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'constraint']

[[axioms]]
id = "cpp20_expr_await_handler_e8f9a0b1"
content = '''An await-expression shall appear outside of a handler.'''
formal_spec = '''await_expression(E) && in_handler(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'exception-handler', 'constraint']

[[axioms]]
id = "cpp20_expr_await_default_arg_f9a0b1c2"
content = '''An await-expression shall not appear in a default argument.'''
formal_spec = '''await_expression(E) && in_default_argument(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'default-argument', 'constraint']

[[axioms]]
id = "cpp20_expr_await_static_storage_a0b1c2d3"
content = '''An await-expression shall not appear in the initializer of a block variable with static or thread storage duration.'''
formal_spec = '''await_expression(E) && in_block_var_initializer(E) && (has_static_storage_duration(var) || has_thread_storage_duration(var)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'static-storage', 'constraint']

[[axioms]]
id = "cpp20_expr_await_contract_assertion_b1c2d3e4"
content = '''An await-expression shall not be a potentially-evaluated subexpression of the predicate of a contract assertion.'''
formal_spec = '''await_expression(E) && is_potentially_evaluated(E) && in_contract_assertion_predicate(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/2"
tags = ['coroutine', 'await', 'contract', 'constraint']

[[axioms]]
id = "cpp20_expr_new_unknown_bound_initializer_c2d3e4f5"
content = '''If the type-id or new-type-id denotes an array type of unknown bound, the new-initializer shall not be omitted.'''
formal_spec = '''new_expression(T) && is_array_of_unknown_bound(T) && no_new_initializer() => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.new"
source_module = "[expr.new]/7"
tags = ['new', 'array', 'unknown-bound', 'constraint']

[[axioms]]
id = "cpp20_expr_unary_op_indirection_prvalue_d3e4f5a6"
content = '''The operand of the unary * operator shall be a prvalue of type pointer to T, where T is an object or function type.'''
formal_spec = '''unary_indirection(operand) && !(is_prvalue(operand) && is_pointer_to_object_or_function(type(operand))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/1"
tags = ['indirection', 'pointer', 'constraint']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_unary_op_address_lvalue_e4f5a6b7"
content = '''The operand of the unary & operator shall be an lvalue of some type T.'''
formal_spec = '''address_of(operand) && !is_lvalue(operand) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/3"
tags = ['address-of', 'lvalue', 'constraint']
c_standard_refs = ['6.5.3.2']

[[axioms]]
id = "cpp20_expr_unary_plus_operand_f5a6b7c8"
content = '''The operand of the unary + operator shall be a prvalue of arithmetic, unscoped enumeration, or pointer type.'''
formal_spec = '''unary_plus(operand) && !(is_prvalue(operand) && (is_arithmetic(type(operand)) || is_unscoped_enum(type(operand)) || is_pointer(type(operand)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/7"
tags = ['unary-plus', 'operand', 'constraint']
c_standard_refs = ['6.5.3.3']

[[axioms]]
id = "cpp20_expr_unary_minus_operand_a6b7c8d9"
content = '''The operand of the unary - operator shall be a prvalue of arithmetic or unscoped enumeration type.'''
formal_spec = '''unary_minus(operand) && !(is_prvalue(operand) && (is_arithmetic(type(operand)) || is_unscoped_enum(type(operand)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/8"
tags = ['unary-minus', 'operand', 'constraint']
c_standard_refs = ['6.5.3.3']

[[axioms]]
id = "cpp20_expr_unary_complement_operand_b7c8d9e0"
content = '''The operand of the ~ operator shall be a prvalue of integral or unscoped enumeration type.'''
formal_spec = '''bitwise_complement(operand) && !(is_prvalue(operand) && (is_integral(type(operand)) || is_unscoped_enum(type(operand)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/10"
tags = ['bitwise-complement', 'operand', 'constraint']
c_standard_refs = ['6.5.3.3']

[[axioms]]
id = "cpp20_expr_new_array_negative_size_c8d9e0f1"
content = '''If the expression in a noptr-new-declarator is of non-class type and its value before converting to std::size_t is less than zero, the value is invalid and results in either ill-formed program or exception/null depending on exception specification.'''
formal_spec = '''noptr_new_declarator_expr(E) && is_non_class_type(type(E)) && value_before_conversion(E) < 0 => invalid_new_array_size'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.new"
source_module = "[expr.new]/8"
tags = ['new', 'array', 'negative-size', 'constraint']

[[axioms]]
id = "cpp20_expr_new_array_size_exceeds_limit_d9e0f1a2"
content = '''If the new array size value is such that the size of the allocated object would exceed the implementation-defined limit, the value is invalid.'''
formal_spec = '''noptr_new_declarator_expr(E) && exceeds_implementation_limit(size_of_allocated_object(E)) => invalid_new_array_size'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.new"
source_module = "[expr.new]/8"
tags = ['new', 'array', 'size-limit', 'constraint']

[[axioms]]
id = "cpp20_expr_new_array_initializer_count_e0f1a2b3"
content = '''If the new-initializer provides more initializers than the number of array elements to initialize, the value is invalid.'''
formal_spec = '''new_expression_array(E) && has_new_initializer(E) && initializer_count(E) > array_element_count(E) => invalid_new_array_size'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.new"
source_module = "[expr.new]/8"
tags = ['new', 'array', 'initializer', 'constraint']

[[axioms]]
id = "cpp20_expr_delete_destructor_accessible_f1a2b3c4"
content = '''When evaluating a delete-expression that invokes a destructor, the destructor shall be accessible from the point where the delete-expression appears.'''
formal_spec = '''delete_expression(ptr) && !is_null(ptr) && has_destructor(pointee_type(ptr)) && !is_accessible(destructor(pointee_type(ptr)), delete_context) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.delete"
source_module = "[expr.delete]/5"
tags = ['delete', 'destructor', 'accessibility', 'constraint']

[[axioms]]
id = "cpp20_expr_await_suspend_type_a2b3c4d5"
content = '''The await-suspend expression shall be a prvalue of type void, bool, or std::coroutine_handle<Z> for some type Z.'''
formal_spec = '''await_suspend_expr(E) && !(is_prvalue(E) && (is_void(type(E)) || is_bool(type(E)) || is_coroutine_handle(type(E)))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.await"
source_module = "[expr.await]/3.7"
tags = ['coroutine', 'await', 'suspend', 'constraint']

[[axioms]]
id = "cpp20_expr_sizeof_pack_identifier_b3c4d5e6"
content = '''The identifier in a sizeof... expression shall name a pack.'''
formal_spec = '''sizeof_variadic(id) && !is_pack(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.sizeof"
source_module = "[expr.sizeof]/4"
tags = ['sizeof', 'variadic', 'pack', 'constraint']

[[axioms]]
id = "cpp20_expr_unary_op_explicit_member_qualified_c4d5e6f7"
content = '''If the operand of unary & designates an explicit object member function, the operand shall be a qualified-id or a splice-expression.'''
formal_spec = '''address_of(operand) && designates_explicit_object_member_function(operand) && !(is_qualified_id(operand) || is_splice_expression(operand)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.unary.op"
source_module = "[expr.unary.op]/3.2"
tags = ['address-of', 'explicit-object', 'member-function', 'constraint']

[[axioms]]
id = "cpp20_expr_cast_undefined_conversion_illformed_a3b7c2d1"
content = '''Any type conversion not mentioned in the cast notation rules and not explicitly defined by the user is ill-formed.'''
formal_spec = '''cast_notation(T, expr) && !is_const_cast_conversion(T, expr) && !is_static_cast_conversion(T, expr) && !is_static_cast_then_const_cast_conversion(T, expr) && !is_reinterpret_cast_conversion(T, expr) && !is_reinterpret_cast_then_const_cast_conversion(T, expr) && !is_user_defined_conversion(T, expr) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/3"
tags = ['conversion', 'cast', 'ill-formed']

[[axioms]]
id = "cpp20_expr_cast_ambiguous_static_const_illformed_e5f8a9b2"
content = '''If a static_cast followed by a const_cast is used and the conversion can be interpreted in more than one way as such, the conversion is ill-formed.'''
formal_spec = '''cast_notation(T, expr) && is_static_cast_then_const_cast_conversion(T, expr) && count_valid_interpretations_as_static_const(T, expr) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/4"
tags = ['conversion', 'cast', 'static_cast', 'const_cast', 'ambiguity', 'ill-formed']

[[axioms]]
id = "cpp20_expr_cast_incomplete_class_unspecified_c4d6e7f8"
content = '''If both the operand and destination types of a cast are class types and one or both are incomplete, it is unspecified whether the static_cast or the reinterpret_cast interpretation is used, even if there is an inheritance relationship between the two classes.'''
formal_spec = '''cast_notation(T, expr) && is_class_type(T) && is_class_type(type(expr)) && (is_incomplete_type(T) || is_incomplete_type(type(expr))) => unspecified_choice(static_cast_interpretation, reinterpret_cast_interpretation)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/5"
tags = ['conversion', 'cast', 'incomplete-type', 'unspecified', 'static_cast', 'reinterpret_cast']

[[axioms]]
id = "cpp20_expr_cast_first_valid_interpretation_f1a2b3c4"
content = '''If a cast conversion can be interpreted in more than one of the listed ways (const_cast, static_cast, static_cast+const_cast, reinterpret_cast, reinterpret_cast+const_cast), the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed.'''
formal_spec = '''cast_notation(T, expr) && interpretable_as(T, expr, interp1) && interpretable_as(T, expr, interp2) && list_order(interp1) < list_order(interp2) => selected_interpretation(T, expr) == interp1'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.cast"
source_module = "[expr.cast]/4"
tags = ['conversion', 'cast', 'interpretation', 'precedence']

[[axioms]]
id = "cpp20_expr_cast_inaccessible_base_allowed_d8e9f0a1"
content = '''C-style cast allows static_cast conversions between derived and base class types even when the base class is inaccessible, unlike explicit static_cast which requires accessibility.'''
formal_spec = '''cast_notation(T, expr) && (is_derived_to_base_ptr_conversion(T, expr) || is_derived_to_base_ref_conversion(T, expr) || is_base_to_derived_ptr_conversion(T, expr) || is_base_to_derived_ref_conversion(T, expr) || is_ptr_to_member_base_derived_conversion(T, expr)) && is_unambiguous_base(base_class, derived_class) => valid_cast_even_if_inaccessible(base_class)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.cast"
source_module = "[expr.cast]/4.6-4.8"
tags = ['conversion', 'cast', 'accessibility', 'inheritance', 'static_cast']

[[axioms]]
id = "cpp20_expr_cast_result_value_category_b2c3d4e5"
content = '''The result of (T)cast-expression is an lvalue if T is an lvalue reference type or rvalue reference to function type, an xvalue if T is an rvalue reference to object type, otherwise a prvalue.'''
formal_spec = '''cast_notation(T, expr) => (is_lvalue_ref(T) || (is_rvalue_ref(T) && is_function_type(remove_reference(T)))) ? is_lvalue(result) : (is_rvalue_ref(T) && is_object_type(remove_reference(T))) ? is_xvalue(result) : is_prvalue(result)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.cast"
source_module = "[expr.cast]/1"
tags = ['conversion', 'cast', 'value-category', 'lvalue', 'xvalue', 'prvalue']

[[axioms]]
id = "cpp20_expr_cast_ambiguous_base_illformed_g7h8i9j0"
content = '''In the example, casting from D* to A* where A is an ambiguous base (via both I1 and I2) is ill-formed under the static_cast interpretation.'''
formal_spec = '''cast_notation(ptr_to(A), ptr_of_type(D)) && is_ambiguous_base(A, D) && selected_interpretation == static_cast => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.cast"
source_module = "[expr.cast]/4"
tags = ['conversion', 'cast', 'ambiguous-base', 'inheritance', 'ill-formed']

[[axioms]]
id = "cpp20_expr_mptr_oper_dotstar_operand_types_a3f8b2c1"
content = '''The .* operator requires the second operand to be a prvalue of type "pointer to member of T" and the first operand to be a glvalue of class T or of a class of which T is an unambiguous and accessible base class.'''
formal_spec = '''dotstar_expr(E1, E2) => prvalue(E2) && ptr_to_member_of(type(E2), T) && glvalue(E1) && (class_type(E1) == T || (is_base_of(T, class_type(E1)) && unambiguous_base(T, class_type(E1)) && accessible_base(T, class_type(E1))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/2"
tags = ['pointer-to-member', 'operand-types', 'constraint']

[[axioms]]
id = "cpp20_expr_mptr_oper_arrowstar_operand_types_b4c9d3e2"
content = '''The ->* operator requires the second operand to be a prvalue of type "pointer to member of T" and the first operand to be of type "pointer to U" where U is either T or a class of which T is an unambiguous and accessible base class.'''
formal_spec = '''arrowstar_expr(E1, E2) => prvalue(E2) && ptr_to_member_of(type(E2), T) && pointer_to(type(E1), U) && (U == T || (is_base_of(T, U) && unambiguous_base(T, U) && accessible_base(T, U)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/3"
tags = ['pointer-to-member', 'operand-types', 'constraint']

[[axioms]]
id = "cpp20_expr_mptr_oper_object_type_mismatch_ub_c5d0e4f3"
content = '''Using .* where the result of the object expression is an object whose type is not similar to the type of the object expression causes undefined behavior.'''
formal_spec = '''dotstar_expr(E1, E2) && is_object(result(E1)) && !similar_types(type(result(E1)), type(E1)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/4"
tags = ['pointer-to-member', 'undefined-behavior', 'type-mismatch']

[[axioms]]
id = "cpp20_expr_mptr_oper_member_not_contained_ub_d6e1f5g4"
content = '''Using .* where the most derived object of the result of the object expression does not contain the member to which the second operand refers causes undefined behavior.'''
formal_spec = '''dotstar_expr(E1, E2) && is_object(result(E1)) && !contains_member(most_derived_object(result(E1)), pointee_member(E2)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/4"
tags = ['pointer-to-member', 'undefined-behavior', 'member-access', 'lifetime']

[[axioms]]
id = "cpp20_expr_mptr_oper_rvalue_lref_illformed_e7f2g6h5"
content = '''In a .* expression whose object expression is an rvalue, the program is ill-formed if the second operand is a pointer to member function whose ref-qualifier is &, unless its cv-qualifier-seq is const.'''
formal_spec = '''dotstar_expr(E1, E2) && rvalue(E1) && ptr_to_member_function(type(E2)) && ref_qualifier(pointee(E2)) == "&" && cv_qualifier_seq(pointee(E2)) != "const" => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'ref-qualifier', 'ill-formed', 'member-function']

[[axioms]]
id = "cpp20_expr_mptr_oper_lvalue_rref_illformed_f8g3h7i6"
content = '''In a .* expression whose object expression is an lvalue, the program is ill-formed if the second operand is a pointer to member function whose ref-qualifier is &&.'''
formal_spec = '''dotstar_expr(E1, E2) && lvalue(E1) && ptr_to_member_function(type(E2)) && ref_qualifier(pointee(E2)) == "&&" => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'ref-qualifier', 'ill-formed', 'member-function']

[[axioms]]
id = "cpp20_expr_mptr_oper_null_member_ptr_ub_g9h4i8j7"
content = '''If the second operand of .* or ->* is the null member pointer value, the behavior is undefined.'''
formal_spec = '''(dotstar_expr(E1, E2) || arrowstar_expr(E1, E2)) && null_member_pointer(E2) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'undefined-behavior', 'null-pointer']

[[axioms]]
id = "cpp20_expr_mptr_oper_function_result_call_only_h0i5j9k8"
content = '''If the result of .* or ->* is a function, then that result can be used only as the operand for the function call operator ().'''
formal_spec = '''(dotstar_expr(E1, E2) || arrowstar_expr(E1, E2)) && is_function(result_type(E2)) => only_usable_as_call_operand(result)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.mptr.oper"
source_module = "[expr.mptr.oper]/6"
tags = ['pointer-to-member', 'member-function', 'constraint', 'function-call']

[[axioms]]
id = "cpp20_expr_mul_div_by_zero_ub_3f8a2b1c"
content = '''Division by zero is undefined behavior. If the second operand of the / operator is zero, the behavior is undefined.'''
formal_spec = '''(a / b) && (b == 0) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'division', 'undefined-behavior', 'operators']
c_standard_refs = ['6.5.5/5']

[[axioms]]
id = "cpp20_expr_mul_mod_by_zero_ub_7e9c4d2a"
content = '''Modulo by zero is undefined behavior. If the second operand of the % operator is zero, the behavior is undefined.'''
formal_spec = '''(a % b) && (b == 0) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'modulo', 'undefined-behavior', 'operators']
c_standard_refs = ['6.5.5/5']

[[axioms]]
id = "cpp20_expr_mul_div_overflow_ub_b2d5e8f1"
content = '''If the quotient a/b is not representable in the result type, the behavior of both a/b and a%b is undefined.'''
formal_spec = '''!representable_in_type(a / b, result_type(a, b)) => undefined_behavior(a / b) && undefined_behavior(a % b)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'division', 'overflow', 'undefined-behavior', 'operators']
c_standard_refs = ['6.5.5/6']

[[axioms]]
id = "cpp20_expr_mul_operand_type_mul_div_c4a7f3e9"
content = '''The operands of * and / shall have arithmetic or unscoped enumeration type.'''
formal_spec = '''(a * b) || (a / b) => (is_arithmetic(a) || is_unscoped_enum(a)) && (is_arithmetic(b) || is_unscoped_enum(b))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/2"
tags = ['arithmetic', 'type-constraint', 'operators', 'multiplication', 'division']
c_standard_refs = ['6.5.5/2']

[[axioms]]
id = "cpp20_expr_mul_operand_type_mod_d1b8e4c2"
content = '''The operands of % shall have integral or unscoped enumeration type.'''
formal_spec = '''(a % b) => (is_integral(a) || is_unscoped_enum(a)) && (is_integral(b) || is_unscoped_enum(b))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/2"
tags = ['arithmetic', 'type-constraint', 'operators', 'modulo']
c_standard_refs = ['6.5.5/2']

[[axioms]]
id = "cpp20_expr_mul_integral_div_identity_a5c2d9f7"
content = '''For integral operands where the quotient a/b is representable, the identity (a/b)*b + a%b equals a holds.'''
formal_spec = '''is_integral(a) && is_integral(b) && (b != 0) && representable_in_type(a / b, result_type(a, b)) => ((a / b) * b + a % b) == a'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.mul"
source_module = "[expr.mul]/4"
tags = ['arithmetic', 'division', 'modulo', 'invariant', 'operators']
c_standard_refs = ['6.5.5/6']

[[axioms]]
id = "cpp20_expr_add_addition_type_req_8a3f2b1c"
content = '''For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to a completely-defined object type and the other shall have integral type.'''
formal_spec = '''binary_plus(L, R) => (arithmetic_type(L) && arithmetic_type(R)) || (pointer_to_complete_object_type(L) && integral_type(R)) || (integral_type(L) && pointer_to_complete_object_type(R))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/1"
tags = ['addition', 'pointer-arithmetic', 'type-constraint']
c_standard_refs = ['6.5.6/2']

[[axioms]]
id = "cpp20_expr_add_subtraction_arith_type_d4e5f6a7"
content = '''For subtraction, both operands have arithmetic type is one valid form.'''
formal_spec = '''binary_minus(L, R) && arithmetic_type(L) && arithmetic_type(R) => valid_subtraction'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/2.1"
tags = ['subtraction', 'type-constraint']
c_standard_refs = ['6.5.6/3']

[[axioms]]
id = "cpp20_expr_add_subtraction_ptr_same_type_b2c3d4e5"
content = '''For subtraction, both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined object type is one valid form.'''
formal_spec = '''binary_minus(L, R) && pointer_type(L) && pointer_type(R) => same_unqualified_pointee_type(L, R) && completely_defined_object_type(pointee_type(L))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/2.2"
tags = ['subtraction', 'pointer-arithmetic', 'type-constraint']
c_standard_refs = ['6.5.6/3']

[[axioms]]
id = "cpp20_expr_add_subtraction_ptr_int_c3d4e5f6"
content = '''For subtraction, the left operand is a pointer to a completely-defined object type and the right operand has integral type is one valid form.'''
formal_spec = '''binary_minus(L, R) && pointer_to_complete_object_type(L) && integral_type(R) => valid_subtraction'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/2.3"
tags = ['subtraction', 'pointer-arithmetic', 'type-constraint']
c_standard_refs = ['6.5.6/3']

[[axioms]]
id = "cpp20_expr_add_ptr_arith_bounds_ub_7f8e9d0c"
content = '''When adding or subtracting an integral value J from a pointer P to array element i of array with n elements, the result index must be in range [0, n]; otherwise behavior is undefined.'''
formal_spec = '''pointer_plus_int(P, J) && points_to_array_element(P, x, i, n) && !((0 <= i + value(J)) && (i + value(J) <= n)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'array-bounds', 'undefined-behavior']
c_standard_refs = ['6.5.6/8']

[[axioms]]
id = "cpp20_expr_add_ptr_arith_minus_bounds_ub_6e7f8a9b"
content = '''When subtracting an integral value J from a pointer P to array element i of array with n elements, the result index must be in range [0, n]; otherwise behavior is undefined.'''
formal_spec = '''pointer_minus_int(P, J) && points_to_array_element(P, x, i, n) && !((0 <= i - value(J)) && (i - value(J) <= n)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'array-bounds', 'undefined-behavior']
c_standard_refs = ['6.5.6/8']

[[axioms]]
id = "cpp20_expr_add_ptr_arith_non_array_ub_5d6e7f8a"
content = '''Adding a value other than 0 or 1 to a pointer to a base class subobject, a member subobject, or a complete object results in undefined behavior.'''
formal_spec = '''pointer_plus_int(P, J) && (points_to_base_subobject(P) || points_to_member_subobject(P) || points_to_complete_object(P)) && !(value(J) == 0 || value(J) == 1) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'subobject', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_add_ptr_subtract_diff_array_ub_4c5d6e7f"
content = '''Subtracting two pointers that do not both point to elements of the same array object (or one past the end) and are not both null pointer values is undefined behavior.'''
formal_spec = '''pointer_minus_pointer(P, Q) && !(null_pointer(P) && null_pointer(Q)) && !same_array_object(P, Q) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/5.3"
tags = ['pointer-arithmetic', 'pointer-subtraction', 'undefined-behavior']
c_standard_refs = ['6.5.6/9']

[[axioms]]
id = "cpp20_expr_add_ptr_subtract_overflow_ub_3b4c5d6e"
content = '''If the value of pointer subtraction (i - j) is not in the range of representable values of type std::ptrdiff_t, the behavior is undefined.'''
formal_spec = '''pointer_minus_pointer(P, Q) && same_array_object(P, Q) && points_to_array_element(P, x, i, n) && points_to_array_element(Q, x, j, n) && !in_range(i - j, ptrdiff_t) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.add"
source_module = "[expr.add]/5.2"
tags = ['pointer-arithmetic', 'pointer-subtraction', 'overflow', 'undefined-behavior']
c_standard_refs = ['6.5.6/9']

[[axioms]]
id = "cpp20_expr_add_ptr_type_mismatch_ub_2a3b4c5d"
content = '''For addition or subtraction, if the pointer expression P or Q has type "pointer to cv T", where T and the array element type are not similar, the behavior is undefined.'''
formal_spec = '''(pointer_plus_int(P, J) || pointer_minus_int(P, J) || pointer_minus_pointer(P, Q)) && pointer_type(P, T) && points_to_array(P, array_x) && !similar_types(T, element_type(array_x)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/6"
tags = ['pointer-arithmetic', 'type-aliasing', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_add_operand_prvalue_req_1a2b3c4d"
content = '''Each operand of additive operators shall be a prvalue.'''
formal_spec = '''additive_expression(L, R) => prvalue(L) && prvalue(R)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/1"
tags = ['value-category', 'operand-constraint']

[[axioms]]
id = "cpp20_expr_add_null_plus_zero_valid_0f1e2d3c"
content = '''If pointer P evaluates to a null pointer value and integral J evaluates to 0, the result of P+J or P-J is a null pointer value.'''
formal_spec = '''(pointer_plus_int(P, J) || pointer_minus_int(P, J)) && null_pointer(P) && value(J) == 0 => null_pointer(result)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.1"
tags = ['pointer-arithmetic', 'null-pointer']

[[axioms]]
id = "cpp20_expr_add_null_nonzero_ub_e0f1a2b3"
content = '''Adding or subtracting a non-zero integral value to/from a null pointer is undefined behavior.'''
formal_spec = '''(pointer_plus_int(P, J) || pointer_minus_int(P, J)) && null_pointer(P) && value(J) != 0 => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.add"
source_module = "[expr.add]/4.3"
tags = ['pointer-arithmetic', 'null-pointer', 'undefined-behavior']

[[axioms]]
id = "cpp20_expr_shift_negative_right_operand_8f3a2b1c"
content = '''The behavior is undefined if the right operand of a shift operator is negative.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") && E2 < 0 => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'undefined-behavior', 'operators', 'bitwise']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_right_operand_exceeds_width_7d4e9c2a"
content = '''The behavior is undefined if the right operand of a shift operator is greater than or equal to the width of the promoted left operand.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") && E2 >= width(promoted_type(E1)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'undefined-behavior', 'operators', 'bitwise', 'width']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_operands_prvalue_integral_5b8c1f3e"
content = '''The operands of shift operators shall be prvalues of integral or unscoped enumeration type.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") => (is_prvalue(E1) && is_prvalue(E2) && (is_integral_type(E1) || is_unscoped_enum_type(E1)) && (is_integral_type(E2) || is_unscoped_enum_type(E2)))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'constraint', 'operators', 'type-requirements', 'prvalue']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_result_type_promoted_left_3a9d7e4f"
content = '''The type of the result of a shift operation is that of the promoted left operand.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") => type(result) == promoted_type(E1)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/1"
tags = ['shift', 'operators', 'type-conversion', 'promotion']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_left_value_modulo_6c2f8a1d"
content = '''The value of E1 << E2 is the unique value congruent to E1  2^E2 modulo 2^N, where N is the width of the type of the result.'''
formal_spec = '''left_shift_expr(E1, E2) => value(E1 << E2) == (E1 * pow(2, E2)) mod pow(2, width(type(result)))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/2"
tags = ['shift', 'operators', 'left-shift', 'semantics', 'modular-arithmetic']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_right_value_floor_div_4e1b9c5a"
content = '''The value of E1 >> E2 is E1/2^E2, rounded towards negative infinity (arithmetic right shift with sign-extension for signed types).'''
formal_spec = '''right_shift_expr(E1, E2) => value(E1 >> E2) == floor(E1 / pow(2, E2))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "expr.shift"
source_module = "[expr.shift]/3"
tags = ['shift', 'operators', 'right-shift', 'semantics', 'sign-extension']
c_standard_refs = ['6.5.7']

[[axioms]]
id = "cpp20_expr_shift_sequencing_e1_before_e2_2d7a4f8c"
content = '''In a shift expression, the left operand E1 is sequenced before the right operand E2.'''
formal_spec = '''shift_expr(E1, E2, op) && (op == "<<" || op == ">>") => sequenced_before(E1, E2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.shift"
source_module = "[expr.shift]/4"
tags = ['shift', 'operators', 'sequencing', 'evaluation-order']

[[axioms]]
id = "cpp20_expr_rel_operand_type_constraint_a3f8b2c1"
content = '''The converted operands of relational operators shall have arithmetic, enumeration, or pointer type.'''
formal_spec = '''relational_op(op, lhs, rhs) && converted(lhs, lhs') && converted(rhs, rhs') => (is_arithmetic(type(lhs')) || is_enumeration(type(lhs')) || is_pointer(type(lhs'))) && (is_arithmetic(type(rhs')) || is_enumeration(type(rhs')) || is_pointer(type(rhs')))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/2"
tags = ['relational', 'operators', 'type-constraint']

[[axioms]]
id = "cpp20_expr_rel_pointer_same_type_d7e4f1a9"
content = '''After conversions, pointer operands of relational operators shall have the same type.'''
formal_spec = '''relational_op(op, lhs, rhs) && is_pointer(type(converted(lhs))) && is_pointer(type(converted(rhs))) => type(converted(lhs)) == type(converted(rhs))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/3"
tags = ['relational', 'pointers', 'type-constraint', 'conversion']

[[axioms]]
id = "cpp20_expr_rel_array_subscript_order_b2c9e5f3"
content = '''If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher subscript is required to compare greater.'''
formal_spec = '''points_to_array_element(p, arr, i) && points_to_array_element(q, arr, j) && i > j => (p > q) == true && (q < p) == true'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/4.1"
tags = ['relational', 'pointers', 'array', 'ordering']

[[axioms]]
id = "cpp20_expr_rel_member_declaration_order_c8d3a7e2"
content = '''If two pointers point to different non-static data members of the same object, or to subobjects of such members, recursively, the pointer to the later declared member is required to compare greater provided neither member is a subobject of zero size and their class is not a union.'''
formal_spec = '''points_to_member(p, obj, m1) && points_to_member(q, obj, m2) && declared_after(m2, m1) && !is_zero_size_subobject(m1) && !is_zero_size_subobject(m2) && !is_union(class_of(obj)) => (q > p) == true'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/4.2"
tags = ['relational', 'pointers', 'members', 'ordering', 'non-union']

[[axioms]]
id = "cpp20_expr_rel_unrelated_pointer_unspecified_e5f2b8a1"
content = '''For pointers that do not point to elements of the same array or members of the same object, neither pointer is required to compare greater than the other; the result is unspecified.'''
formal_spec = '''is_pointer(type(p)) && is_pointer(type(q)) && !same_array(p, q) && !same_object_members(p, q) && p != q => unspecified(p < q) && unspecified(p > q) && unspecified(p <= q) && unspecified(p >= q)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/4.3"
tags = ['relational', 'pointers', 'unspecified', 'ordering']

[[axioms]]
id = "cpp20_expr_rel_equal_pointers_result_f1a4c9d6"
content = '''If two pointer operands compare equal, p<=q and p>=q both yield true and p<q and p>q both yield false.'''
formal_spec = '''is_pointer(type(p)) && is_pointer(type(q)) && (p == q) => (p <= q) == true && (p >= q) == true && (p < q) == false && (p > q) == false'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/5"
tags = ['relational', 'pointers', 'equality', 'ordering']

[[axioms]]
id = "cpp20_expr_rel_greater_pointer_consistency_a9b7c2e4"
content = '''If a pointer to object p compares greater than a pointer q, then p>=q, p>q, q<=p, and q<p all yield true, and p<=q, p<q, q>=p, and q>p all yield false.'''
formal_spec = '''is_pointer_to_object(type(p)) && is_pointer_to_object(type(q)) && pointer_greater(p, q) => (p >= q) == true && (p > q) == true && (q <= p) == true && (q < p) == true && (p <= q) == false && (p < q) == false && (q >= p) == false && (q > p) == false'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/5"
tags = ['relational', 'pointers', 'ordering', 'consistency']

[[axioms]]
id = "cpp20_expr_rel_function_pointer_unspecified_d3e8f5b2"
content = '''A relational operator applied to unequal function pointers yields an unspecified result.'''
formal_spec = '''is_function_pointer(type(p)) && is_function_pointer(type(q)) && p != q && relational_op(op, p, q) => unspecified(result(op, p, q))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/5"
tags = ['relational', 'function-pointer', 'unspecified']

[[axioms]]
id = "cpp20_expr_rel_left_to_right_grouping_b5c1d9a7"
content = '''The relational operators group left-to-right, meaning a<b<c is interpreted as (a<b)<c.'''
formal_spec = '''parse(a < b < c) == parse((a < b) < c)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/1"
tags = ['relational', 'operators', 'associativity', 'grouping']

[[axioms]]
id = "cpp20_expr_rel_result_type_bool_e2f7a4c8"
content = '''The result type of relational operators (<, >, <=, >=) is bool.'''
formal_spec = '''relational_op(op, lhs, rhs) && op in {<, >, <=, >=} => type(result(op, lhs, rhs)) == bool'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/2"
tags = ['relational', 'operators', 'result-type', 'bool']

[[axioms]]
id = "cpp20_expr_rel_arithmetic_enum_true_false_c4d9e1b5"
content = '''If both operands (after conversions) are of arithmetic or enumeration type, each of the relational operators shall yield true if the specified relationship is true and false if it is false.'''
formal_spec = '''relational_op(op, lhs, rhs) && (is_arithmetic(type(converted(lhs))) || is_enumeration(type(converted(lhs)))) && (is_arithmetic(type(converted(rhs))) || is_enumeration(type(converted(rhs)))) => result(op, lhs, rhs) == mathematical_relation(op, value(converted(lhs)), value(converted(rhs)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.rel"
source_module = "[expr.rel]/6"
tags = ['relational', 'arithmetic', 'enumeration', 'semantics']

[[axioms]]
id = "cpp20_expr_rel_zero_size_member_unspecified_f8a3b6d2"
content = '''When comparing pointers to members where one member is a subobject of zero size, the ordering result is not required (unspecified).'''
formal_spec = '''points_to_member(p, obj, m1) && points_to_member(q, obj, m2) && m1 != m2 && (is_zero_size_subobject(m1) || is_zero_size_subobject(m2)) => unspecified(p < q) && unspecified(p > q)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/4.2"
tags = ['relational', 'pointers', 'members', 'zero-size', 'unspecified']

[[axioms]]
id = "cpp20_expr_rel_union_member_unspecified_a2c5e9f1"
content = '''When comparing pointers to members of a union, the ordering result is not required (unspecified).'''
formal_spec = '''points_to_member(p, obj, m1) && points_to_member(q, obj, m2) && m1 != m2 && is_union(class_of(obj)) => unspecified(p < q) && unspecified(p > q)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.rel"
source_module = "[expr.rel]/4.2"
tags = ['relational', 'pointers', 'union', 'members', 'unspecified']

[[axioms]]
id = "cpp20_expr_eq_scalar_type_required_a7c3f1b2"
content = '''The converted operands of equality operators (== and !=) shall have scalar type.'''
formal_spec = '''equality_expr(op1, op2) => scalar_type(converted(op1)) && scalar_type(converted(op2))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/2"
tags = ['constraint', 'equality', 'scalar', 'type-requirement']

[[axioms]]
id = "cpp20_expr_eq_same_type_required_b4d2e8a1"
content = '''The operands of equality operators shall have the same type after the specified conversions have been applied.'''
formal_spec = '''equality_expr(op1, op2) => type(converted(op1)) == type(converted(op2))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/2"
tags = ['constraint', 'equality', 'type-requirement', 'conversion']

[[axioms]]
id = "cpp20_expr_eq_ptr_different_objects_unspecified_c9f5d3e7"
content = '''Comparing a pointer representing the address of a complete object with a pointer representing the address one past the last element of a different complete object yields an unspecified result.'''
formal_spec = '''pointer_compare(p1, p2) && complete_object_address(p1) && one_past_end_address(p2) && different_complete_objects(p1, p2) => unspecified_result'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.1"
tags = ['pointer', 'comparison', 'unspecified', 'one-past-end']

[[axioms]]
id = "cpp20_expr_eq_ptr_null_equal_d8a4c2f6"
content = '''Two null pointers compare equal.'''
formal_spec = '''pointer_compare(p1, p2) && null_pointer(p1) && null_pointer(p2) => compare_equal(p1, p2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.2"
tags = ['pointer', 'comparison', 'null-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptr_same_function_equal_e2b7a9d4"
content = '''Two pointers that both point to the same function compare equal.'''
formal_spec = '''pointer_compare(p1, p2) && points_to_function(p1, f) && points_to_function(p2, f) => compare_equal(p1, p2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.2"
tags = ['pointer', 'comparison', 'function-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptr_same_address_equal_f1c8d5e3"
content = '''Two pointers that represent the same address compare equal.'''
formal_spec = '''pointer_compare(p1, p2) && same_address(p1, p2) => compare_equal(p1, p2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/3.2"
tags = ['pointer', 'comparison', 'address']

[[axioms]]
id = "cpp20_expr_eq_ptm_null_equal_a3d9b7c2"
content = '''Two pointers to members that are both the null member pointer value compare equal.'''
formal_spec = '''ptm_compare(pm1, pm2) && null_member_pointer(pm1) && null_member_pointer(pm2) => compare_equal(pm1, pm2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.1"
tags = ['pointer-to-member', 'comparison', 'null-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptm_one_null_unequal_b5e2c8d1"
content = '''If only one of two pointers to members is the null member pointer value, they compare unequal.'''
formal_spec = '''ptm_compare(pm1, pm2) && (null_member_pointer(pm1) xor null_member_pointer(pm2)) => compare_unequal(pm1, pm2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.2"
tags = ['pointer-to-member', 'comparison', 'null-pointer']

[[axioms]]
id = "cpp20_expr_eq_ptm_virtual_unspecified_c4f1a6e9"
content = '''If either pointer to member is a pointer to a virtual member function, the result of the comparison is unspecified.'''
formal_spec = '''ptm_compare(pm1, pm2) && (pointer_to_virtual_member_function(pm1) || pointer_to_virtual_member_function(pm2)) => unspecified_result'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.3"
tags = ['pointer-to-member', 'comparison', 'virtual', 'unspecified']

[[axioms]]
id = "cpp20_expr_eq_ptm_different_class_unspecified_d7a3b5c8"
content = '''If one pointer to member refers to a member of class C1 and the other refers to a member of a different class C2, where neither is a base class of the other, the result of the comparison is unspecified.'''
formal_spec = '''ptm_compare(pm1, pm2) && member_of_class(pm1, C1) && member_of_class(pm2, C2) && C1 != C2 && !is_base_of(C1, C2) && !is_base_of(C2, C1) => unspecified_result'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.4"
tags = ['pointer-to-member', 'comparison', 'unspecified', 'class-hierarchy']

[[axioms]]
id = "cpp20_expr_eq_ptm_same_union_equal_e8b4c2a7"
content = '''Two pointers to members that both refer to (possibly different) members of the same union compare equal.'''
formal_spec = '''ptm_compare(pm1, pm2) && member_of_union(pm1, U) && member_of_union(pm2, U) => compare_equal(pm1, pm2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/4.5"
tags = ['pointer-to-member', 'comparison', 'union']

[[axioms]]
id = "cpp20_expr_eq_nullptr_compare_equal_f2d8a1c6"
content = '''Two operands of type std::nullptr_t or one operand of type std::nullptr_t and the other a null pointer constant compare equal.'''
formal_spec = '''(type(op1) == nullptr_t && type(op2) == nullptr_t) || (type(op1) == nullptr_t && null_pointer_constant(op2)) || (null_pointer_constant(op1) && type(op2) == nullptr_t) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/5"
tags = ['nullptr', 'comparison', 'null-pointer-constant']

[[axioms]]
id = "cpp20_expr_eq_meta_info_null_reflection_equal_a1c3d5e7"
content = '''Two operands of type std::meta::info that are both null reflection values compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && null_reflection(op1) && null_reflection(op2) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.1"
tags = ['reflection', 'meta-info', 'comparison']

[[axioms]]
id = "cpp20_expr_eq_meta_info_template_arg_equiv_equal_b2d4e6f8"
content = '''Two operands of type std::meta::info that represent values that are template-argument-equivalent compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && template_argument_equivalent(value(op1), value(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.2"
tags = ['reflection', 'meta-info', 'comparison', 'template-argument']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_object_equal_c3e5f7a9"
content = '''Two operands of type std::meta::info that represent the same object compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_object(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.3"
tags = ['reflection', 'meta-info', 'comparison', 'object']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_entity_equal_d4f6a8b1"
content = '''Two operands of type std::meta::info that represent the same entity compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_entity(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.4"
tags = ['reflection', 'meta-info', 'comparison', 'entity']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_annotation_equal_e5a7b9c2"
content = '''Two operands of type std::meta::info that represent the same annotation compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_annotation(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.5"
tags = ['reflection', 'meta-info', 'comparison', 'annotation']

[[axioms]]
id = "cpp20_expr_eq_meta_info_same_base_class_equal_f6b8c1d3"
content = '''Two operands of type std::meta::info that represent the same direct base class relationship compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && same_direct_base_class_relationship(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.6"
tags = ['reflection', 'meta-info', 'comparison', 'base-class']

[[axioms]]
id = "cpp20_expr_eq_meta_info_equal_data_member_equal_a7c9d2e4"
content = '''Two operands of type std::meta::info that represent equal data member descriptions compare equal.'''
formal_spec = '''type(op1) == meta_info && type(op2) == meta_info && equal_data_member_descriptions(represented(op1), represented(op2)) => compare_equal(op1, op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/6.7"
tags = ['reflection', 'meta-info', 'comparison', 'data-member']

[[axioms]]
id = "cpp20_expr_eq_unspecified_result_operators_b8d1e3f5"
content = '''If the comparison result is neither equal nor unequal (i.e., unspecified), the result of both == and != operators is unspecified.'''
formal_spec = '''equality_expr(op1, op2) && !compare_equal(op1, op2) && !compare_unequal(op1, op2) => unspecified_result(op1 == op2) && unspecified_result(op1 != op2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.eq"
source_module = "[expr.eq]/7"
tags = ['equality', 'comparison', 'unspecified', 'operator']

[[axioms]]
id = "cpp20_dcl_init_general_linkage_block_scope_init_a3b2c1d4"
content = '''A declaration of a variable with linkage shall not have an initializer if the declaration inhabits a block scope.'''
formal_spec = '''has_linkage(var_decl) && inhabits_block_scope(var_decl) && has_initializer(var_decl) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/5"
tags = ['initialization', 'linkage', 'block-scope', 'declaration']

[[axioms]]
id = "cpp20_dcl_init_general_const_default_init_e5f6a7b8"
content = '''If a program calls for the default-initialization of an object of a const-qualified type T, T shall be a const-default-constructible type.'''
formal_spec = '''default_initialization_required(obj) && is_const_qualified(type(obj)) && !is_const_default_constructible(type(obj)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/8"
tags = ['initialization', 'const', 'default-initialization', 'constructible']

[[axioms]]
id = "cpp20_dcl_init_general_ref_default_value_init_c9d0e1f2"
content = '''A program that calls for default-initialization or value-initialization of an entity of reference type is ill-formed.'''
formal_spec = '''(default_initialization_required(entity) || value_initialization_required(entity)) && is_reference_type(type(entity)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/10"
tags = ['initialization', 'reference', 'default-initialization', 'value-initialization']

[[axioms]]
id = "cpp20_dcl_init_general_paren_init_single_expr_a1b2c3d4"
content = '''If the entity being initialized does not have class or array type, the expression-list in a parenthesized initializer shall be a single expression.'''
formal_spec = '''!is_class_type(type(entity)) && !is_array_type(type(entity)) && is_parenthesized_init(init) && expression_list_count(init) != 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/13"
tags = ['initialization', 'expression-list', 'parenthesized-initializer']

[[axioms]]
id = "cpp20_dcl_init_general_array_too_many_init_e5f6g7h8"
content = '''When initializing an array with a parenthesized expression-list, if the number of initializers k is greater than the array size n, the program is ill-formed.'''
formal_spec = '''is_array_type(dest_type) && is_parenthesized_init(init) && expression_list_count(init) > array_size(dest_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/16.5"
tags = ['initialization', 'array', 'expression-list']

[[axioms]]
id = "cpp20_dcl_init_general_duplicate_designator_i9j0k1l2"
content = '''The same identifier shall not appear in multiple designators of a designated-initializer-list.'''
formal_spec = '''is_designated_init_list(init) && has_duplicate_designator_identifiers(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/21"
tags = ['initialization', 'designated-initializer', 'identifier']

[[axioms]]
id = "cpp20_dcl_init_aggr_designator_class_type_m3n4o5p6"
content = '''If the initializer list is a brace-enclosed designated-initializer-list, the aggregate shall be of class type.'''
formal_spec = '''is_designated_init_list(init) && is_aggregate(type(obj)) && !is_class_type(type(obj)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['initialization', 'aggregate', 'designated-initializer', 'class-type']

[[axioms]]
id = "cpp20_dcl_init_aggr_designator_names_member_q7r8s9t0"
content = '''In a designated-initializer-list, each designator identifier shall name a direct non-static data member of the class.'''
formal_spec = '''is_designated_init_list(init) && exists(d in designators(init), !is_direct_nonstatic_data_member(identifier(d), class_type)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['initialization', 'aggregate', 'designated-initializer', 'data-member']

[[axioms]]
id = "cpp20_dcl_init_aggr_single_anon_union_designator_u1v2w3x4"
content = '''When an anonymous union member is initialized by a designated-initializer-list, there shall be only one designated-initializer-clause naming a member of that anonymous union.'''
formal_spec = '''is_anonymous_union_member(element) && is_designated_init_list(init) && count_designators_for_anon_union(init, element) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.1"
tags = ['initialization', 'aggregate', 'anonymous-union', 'designated-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_narrowing_designator_y5z6a7b8"
content = '''In aggregate initialization with a designated-initializer-clause of form =assignment-expression, if a narrowing conversion is required to convert the expression, the program is ill-formed.'''
formal_spec = '''is_designated_init_clause(clause) && is_assignment_expr_form(clause) && requires_narrowing_conversion(expr(clause), element_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.2"
tags = ['initialization', 'aggregate', 'designated-initializer', 'narrowing-conversion']

[[axioms]]
id = "cpp20_dcl_init_aggr_reference_no_default_c9d0e1f2"
content = '''For a non-union aggregate element that is a reference and is not explicitly initialized and has no default member initializer, the program is ill-formed.'''
formal_spec = '''is_aggregate(type(obj)) && !is_union_type(type(obj)) && is_reference_type(element_type) && !is_explicitly_initialized(element) && !has_default_member_initializer(element) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/5.3"
tags = ['initialization', 'aggregate', 'reference', 'default-member-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_unknown_bound_empty_init_g3h4i5j6"
content = '''An array of unknown bound shall not be initialized with an empty braced-init-list {}.'''
formal_spec = '''is_array_of_unknown_bound(type(obj)) && is_empty_braced_init_list(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/10"
tags = ['initialization', 'array', 'unknown-bound', 'empty-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_too_many_initializers_k7l8m9n0"
content = '''If any initializer-clause remains that does not appertain to an element of the aggregate or one of its subaggregates, the program is ill-formed.'''
formal_spec = '''is_aggregate_init(init) && has_excess_initializer_clauses(init, aggregate) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/14"
tags = ['initialization', 'aggregate', 'excess-initializers']

[[axioms]]
id = "cpp20_dcl_init_aggr_recursive_default_init_o1p2q3r4"
content = '''If a member has a default member initializer and a potentially-evaluated subexpression thereof is an aggregate initialization that would use that default member initializer, the program is ill-formed.'''
formal_spec = '''has_default_member_initializer(member) && has_potentially_evaluated_subexpr(default_init(member), agg_init) && uses_same_default_member_initializer(agg_init, member) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/12"
tags = ['initialization', 'aggregate', 'default-member-initializer', 'recursion']

[[axioms]]
id = "cpp20_dcl_init_aggr_union_multiple_explicit_init_s5t6u7v8"
content = '''When a union is initialized with an initializer list, there shall not be more than one explicitly initialized element.'''
formal_spec = '''is_union_type(type(obj)) && is_initializer_list(init) && count_explicitly_initialized_elements(init) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/20"
tags = ['initialization', 'union', 'initializer-list']

[[axioms]]
id = "cpp20_dcl_init_string_too_many_chars_w9x0y1z2"
content = '''When initializing a character array from a string literal, there shall not be more initializers than there are array elements.'''
formal_spec = '''is_char_array(type(obj)) && is_string_literal(init) && string_literal_size(init) > array_size(type(obj)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.string"
source_module = "[dcl.init.string]/2"
tags = ['initialization', 'character-array', 'string-literal']

[[axioms]]
id = "cpp20_dcl_init_ref_must_be_initialized_a3b4c5d6"
content = '''A variable whose declared type is reference to T shall be initialized, except in parameter declaration, function return type declaration, class member declaration, or with explicit extern specifier.'''
formal_spec = '''is_reference_type(declared_type(var)) && is_variable_definition(decl) && !has_initializer(decl) && !is_parameter_decl(decl) && !is_function_return_decl(decl) && !is_class_member_decl(decl) && !has_explicit_extern(decl) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/1"
tags = ['initialization', 'reference', 'declaration']

[[axioms]]
id = "cpp20_dcl_init_ref_incompatible_binding_e7f8g9h0"
content = '''In all cases where the reference-compatible relationship is used to establish reference binding validity and the standard conversion sequence would be ill-formed, the program is ill-formed.'''
formal_spec = '''is_reference_binding(binding) && !is_valid_standard_conversion_sequence(source_type, dest_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/4"
tags = ['initialization', 'reference', 'reference-compatible', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_lvalue_nonconst_volatile_i1j2k3l4"
content = '''If the reference is an lvalue reference to a type that is not const-qualified or is volatile-qualified, and cannot bind directly, the program is ill-formed.'''
formal_spec = '''is_lvalue_reference(ref) && (!is_const_qualified(referenced_type(ref)) || is_volatile_qualified(referenced_type(ref))) && !can_bind_directly(init_expr, ref) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.2"
tags = ['initialization', 'reference', 'lvalue-reference', 'const', 'volatile']

[[axioms]]
id = "cpp20_dcl_init_ref_reference_related_indirect_m5n6o7p8"
content = '''When binding a reference through user-defined conversion (not direct binding), T1 shall not be reference-related to T2.'''
formal_spec = '''is_reference_binding(binding) && !is_direct_binding(binding) && is_reference_related(T1, T2) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['initialization', 'reference', 'reference-related', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_const_cast_temporary_ub_q9r0s1t2"
content = '''Modifying a const temporary bound to a reference through const_cast is undefined behavior.'''
formal_spec = '''is_temporary(obj) && is_const_qualified(type(obj)) && bound_to_reference(obj, ref) && const_cast_modify(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.3"
tags = ['initialization', 'reference', 'const_cast', 'temporary', 'undefined-behavior']

[[axioms]]
id = "cpp20_dcl_init_list_designator_not_ref_aggregate_u3v4w5x6"
content = '''If the braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class.'''
formal_spec = '''has_designated_init_list(braced_init) && !is_reference_type(T) && !is_aggregate_class(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['initialization', 'list-initialization', 'designated-initializer', 'aggregate']

[[axioms]]
id = "cpp20_dcl_init_list_designator_order_y7z8a9b0"
content = '''The ordered identifiers in the designators of the designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of T.'''
formal_spec = '''is_designated_init_list(init) && !is_subsequence(designator_identifiers(init), member_identifiers(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['initialization', 'list-initialization', 'designated-initializer', 'order']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_not_reachable_c1d2e3f4"
content = '''If a standard library declaration of std::initializer_list is not reachable from a use of std::initializer_list, even an implicit use, the program is ill-formed.'''
formal_spec = '''uses_initializer_list(expr) && !is_reachable(std_initializer_list_decl, expr) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/2"
tags = ['initialization', 'list-initialization', 'initializer_list', 'reachability']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_constructor_g5h6i7j8"
content = '''In list-initialization, if a narrowing conversion is required to convert any of the arguments when invoking a constructor, the program is ill-formed.'''
formal_spec = '''is_list_initialization(init) && is_class_type(T) && constructor_selected(init, ctor) && requires_narrowing_conversion_for_arg(init, ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.7"
tags = ['initialization', 'list-initialization', 'narrowing-conversion', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_aggr_paren_no_lifetime_extension_k9l0m1n2"
content = '''In parenthesized aggregate initialization, a temporary object bound to a reference does not have its lifetime extended (creating a dangling reference).'''
formal_spec = '''is_parenthesized_aggregate_init(init) && is_reference_member(member) && is_temporary(init_expr(member)) => dangling_reference(member)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.general"
source_module = "[dcl.init.general]/16.6.2.2"
tags = ['initialization', 'aggregate', 'reference', 'lifetime', 'temporary']

[[axioms]]
id = "cpp20_dcl_init_ref_must_initialize_a3f8b2c1"
content = '''A variable declared as "reference to T" shall be initialized.'''
formal_spec = '''is_reference_type(declared_type(var)) && is_variable(var) => must_be_initialized(var)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/1"
tags = ['reference', 'initialization', 'declaration']

[[axioms]]
id = "cpp20_dcl_init_ref_omit_initializer_conditions_7e4a9d12"
content = '''A reference initializer can only be omitted in: parameter declaration, function return type declaration, class member declaration within class definition, or with explicit extern specifier.'''
formal_spec = '''is_reference_type(declared_type(decl)) && omitted_initializer(decl) => (is_parameter_decl(decl) || is_function_return_type_decl(decl) || is_class_member_within_class_def(decl) || has_explicit_extern(decl))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/3"
tags = ['reference', 'initialization', 'extern', 'parameter']

[[axioms]]
id = "cpp20_dcl_init_ref_illformed_conversion_sequence_b2c4e8f0"
content = '''When reference-compatible relationship is used to establish validity of reference binding and the standard conversion sequence would be ill-formed, the program is ill-formed.'''
formal_spec = '''uses_reference_compatible_for_binding(ref, type1, type2) && illformed_standard_conversion_sequence(type2, type1) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/4"
tags = ['reference', 'conversion', 'reference-compatible']

[[axioms]]
id = "cpp20_dcl_init_ref_lvalue_nonconst_volatile_illformed_d9a1b3c5"
content = '''Binding an lvalue reference to a type that is not const-qualified or is volatile-qualified to a non-lvalue initializer makes the program ill-formed.'''
formal_spec = '''is_lvalue_reference(ref) && (!is_const_qualified(referenced_type(ref)) || is_volatile_qualified(referenced_type(ref))) && !is_lvalue(initializer) && !direct_binding_possible(ref, initializer) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.2"
tags = ['reference', 'lvalue', 'const', 'volatile', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_bitfield_not_direct_bind_lvalue_8c2f4a1e"
content = '''An lvalue reference cannot bind directly to a bit-field lvalue even if reference-compatible.'''
formal_spec = '''is_lvalue_reference(ref) && is_bitfield(initializer) => !direct_binds_to_lvalue(ref, initializer)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.1.1"
tags = ['reference', 'lvalue', 'bitfield', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_bitfield_not_direct_bind_rvalue_3e7b9c2d"
content = '''A reference cannot bind directly to a bit-field rvalue.'''
formal_spec = '''is_rvalue_reference(ref) && is_bitfield(initializer) => !direct_binds(ref, initializer)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.3.1"
tags = ['reference', 'rvalue', 'bitfield', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_const_cast_modify_temp_ub_f5d8e2a7"
content = '''Modifying a temporary bound to a const reference via const_cast is undefined behavior.'''
formal_spec = '''is_const_reference(ref) && binds_to_temporary(ref, temp) && const_cast_to_nonconst(ref, nonconst_ref) && modify_through(nonconst_ref) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.3"
tags = ['reference', 'const', 'const_cast', 'temporary', 'undefined_behavior']

[[axioms]]
id = "cpp20_dcl_init_ref_t1_not_related_t2_otherwise_c4a9f1b8"
content = '''When none of the prior reference binding rules apply, T1 shall not be reference-related to T2.'''
formal_spec = '''reference_binding_fallthrough(ref_type_cv1_T1, init_type_cv2_T2) && !applies_rule_5_1(ref, init) && !applies_rule_5_2(ref, init) && !applies_rule_5_3(ref, init) => !is_reference_related(T1, T2)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'reference-related', 'initialization']

[[axioms]]
id = "cpp20_dcl_init_ref_copy_init_illformed_propagates_e7b2c3d9"
content = '''When using user-defined conversions for reference initialization where T1 or T2 is a class type, if the corresponding non-reference copy-initialization would be ill-formed, the program is ill-formed.'''
formal_spec = '''reference_binding_rule_5_4_1(ref, init) && (is_class_type(T1) || is_class_type(T2)) && illformed_copy_init_of_cv1_T1(init) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4.1"
tags = ['reference', 'class', 'copy-initialization', 'user-defined-conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_rvalue_ref_lvalue_related_illformed_a1c5d8e2"
content = '''Binding an rvalue reference to an lvalue of reference-related type is ill-formed.'''
formal_spec = '''is_rvalue_reference(ref_type_T1) && is_lvalue(initializer) && is_reference_related(T1, type(initializer)) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'rvalue-reference', 'lvalue', 'reference-related']

[[axioms]]
id = "cpp20_dcl_init_ref_cv_qualifier_drop_illformed_8f3a2b4c"
content = '''Binding a reference where cv-qualifiers would be dropped from the source type is ill-formed.'''
formal_spec = '''reference_binding(ref_cv1_T1, init_cv2_T2) && cv_qualifiers_dropped(cv2, cv1) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'cv-qualifier', 'const', 'volatile']

[[axioms]]
id = "cpp20_dcl_init_ref_conversion_func_lvalue_related_illformed_2d9e7f1a"
content = '''When a conversion function result is an lvalue of reference-related type, binding an rvalue reference to it is ill-formed.'''
formal_spec = '''is_rvalue_reference(ref_T1) && conversion_function_result(init, result) && is_lvalue(result) && is_reference_related(T1, type(result)) => program_illformed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4"
tags = ['reference', 'rvalue-reference', 'conversion-function', 'reference-related']

[[axioms]]
id = "cpp20_dcl_init_ref_no_user_conv_direct_init_5b8c3d2e"
content = '''In the direct-initialization of a reference using the result of a conversion function (rule 5.4.1), user-defined conversions are not considered.'''
formal_spec = '''reference_binding_rule_5_4_1_direct_init(ref, conversion_result_E) => !consider_user_defined_conversions(direct_init)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/5.4.1"
tags = ['reference', 'direct-initialization', 'user-defined-conversion']

[[axioms]]
id = "cpp20_dcl_init_ref_immutable_binding_4a7e9c1f"
content = '''A reference cannot be changed to refer to another object after initialization.'''
formal_spec = '''initialized(ref) => !can_rebind(ref)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.ref"
source_module = "[dcl.init.ref]/2"
tags = ['reference', 'binding', 'immutability']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_not_reachable_a3f8c2d1"
content = '''If std::initializer_list is used (even implicitly) but no standard library declaration of std::initializer_list is reachable, the program is ill-formed.'''
formal_spec = '''uses_initializer_list(expr) && !reachable_declaration(std::initializer_list) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/2"
tags = ['list-initialization', 'initializer_list', 'reachability']

[[axioms]]
id = "cpp20_dcl_init_list_designated_requires_aggregate_b7e4a1c9"
content = '''If a braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class.'''
formal_spec = '''has_designated_initializer_list(init) && !is_reference_type(T) => is_aggregate_class(T)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate']

[[axioms]]
id = "cpp20_dcl_init_list_designator_order_subsequence_c8d3b2e5"
content = '''The ordered identifiers in the designators of a designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of T.'''
formal_spec = '''has_designated_initializer_list(init) && is_aggregate_class(T) => is_subsequence(designator_identifiers(init), member_identifiers(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate', 'member-order']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_constructor_arg_d9a4c3f6"
content = '''If a narrowing conversion is required to convert any of the arguments when constructors are considered for class type list-initialization, the program is ill-formed.'''
formal_spec = '''list_init_class(T, init) && constructor_overload_resolution(T, init) && requires_narrowing_conversion(arg, param) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.7"
tags = ['list-initialization', 'narrowing', 'constructor', 'overload-resolution']

[[axioms]]
id = "cpp20_dcl_init_list_enum_narrowing_e5b6d4a7"
content = '''For direct-list-initialization of an enumeration with fixed underlying type from a single scalar element, if a narrowing conversion is required to convert the element to the underlying type, the program is ill-formed.'''
formal_spec = '''is_enum_fixed_underlying(T) && direct_list_init(T, {v}) && is_scalar(v) && requires_narrowing_conversion(v, underlying_type(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'narrowing', 'direct-list-initialization']

[[axioms]]
id = "cpp20_dcl_init_list_enum_copy_list_init_f6c7e5b8"
content = '''For an enumeration with fixed underlying type, copy-list-initialization from a single scalar element is not permitted (only direct-list-initialization is allowed).'''
formal_spec = '''is_enum_fixed_underlying(T) && copy_list_init(T, {v}) && is_scalar(v) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'copy-list-initialization']

[[axioms]]
id = "cpp20_dcl_init_list_single_element_narrowing_a7d8f6c9"
content = '''When initializing from a single element where T is not a reference type or its referenced type is reference-related to E, if a narrowing conversion is required to convert the element to T, the program is ill-formed.'''
formal_spec = '''list_init(T, {e}) && !is_designated_init({e}) && type_of(e) == E && (!is_reference(T) || reference_related(referenced_type(T), E)) && requires_narrowing_conversion(e, T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.9"
tags = ['list-initialization', 'narrowing', 'single-element']

[[axioms]]
id = "cpp20_dcl_init_list_lvalue_ref_nonconst_b8e9a7d0"
content = '''Binding an lvalue reference to a non-const type to a prvalue generated from list-initialization is ill-formed.'''
formal_spec = '''is_lvalue_reference(T) && !is_const(referenced_type(T)) && list_init_generates_prvalue(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.10"
tags = ['list-initialization', 'reference', 'lvalue-reference', 'binding']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_backing_narrowing_c9f0b8e1"
content = '''If a narrowing conversion is required to initialize any of the elements of the backing array for std::initializer_list<E>, the program is ill-formed.'''
formal_spec = '''constructing_initializer_list(E, init) && exists(elem in init, requires_narrowing_conversion(elem, E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/5"
tags = ['list-initialization', 'initializer_list', 'narrowing', 'backing-array']

[[axioms]]
id = "cpp20_dcl_init_list_ctor_initializer_dangling_d0a1c9f2"
content = '''Initializing an initializer_list member in a constructor's ctor-initializer creates a dangling reference and the program is ill-formed.'''
formal_spec = '''is_initializer_list_member(member) && initialized_in_ctor_initializer(member, {init...}) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/6"
tags = ['list-initialization', 'initializer_list', 'lifetime', 'dangling-reference', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_int_e1b2d0a3"
content = '''A narrowing conversion occurs from a floating-point type to an integer type in list-initialization context.'''
formal_spec = '''is_floating_point(src_type) && is_integer_type(dst_type) && in_list_init_context => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.1"
tags = ['narrowing', 'conversion', 'floating-point', 'integer']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_lesser_rank_f2c3e1b4"
content = '''A narrowing conversion occurs from a floating-point type T to another floating-point type with lesser conversion rank, unless the result is a constant expression with finite value that did not overflow, or both values are not finite.'''
formal_spec = '''is_floating_point(T) && is_floating_point(U) && !greater_or_equal_rank(U, T) && !(is_constant_expr(v) && (is_finite(result) && !overflow || (!is_finite(v) && !is_finite(result)))) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.2"
tags = ['narrowing', 'conversion', 'floating-point', 'rank']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_float_a3d4f2c5"
content = '''A narrowing conversion occurs from an integer type or unscoped enumeration type to a floating-point type, unless the source is a constant expression and the value fits and round-trips.'''
formal_spec = '''(is_integer_type(src) || is_unscoped_enum(src)) && is_floating_point(dst) && !(is_constant_expr(src) && fits_in_target(src, dst) && roundtrips(src, dst)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.3"
tags = ['narrowing', 'conversion', 'integer', 'floating-point']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_int_b4e5a3d6"
content = '''A narrowing conversion occurs from an integer type or unscoped enumeration type to an integer type that cannot represent all values of the original type, except for bit-field or constant expression exceptions.'''
formal_spec = '''(is_integer_type(src) || is_unscoped_enum(src)) && is_integer_type(dst) && !can_represent_all_values(dst, src) && !bitfield_exception(src, dst) && !(is_constant_expr(src) && value_fits_after_promotion(src, dst)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.4"
tags = ['narrowing', 'conversion', 'integer']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_ptr_to_bool_c5f6b4e7"
content = '''A narrowing conversion occurs from a pointer type or pointer-to-member type to bool.'''
formal_spec = '''(is_pointer_type(src) || is_pointer_to_member(src)) && dst == bool => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.5"
tags = ['narrowing', 'conversion', 'pointer', 'bool']

[[axioms]]
id = "cpp20_dcl_init_list_evaluation_order_d6a7c5f8"
content = '''Within the initializer-list of a braced-init-list, initializer-clauses are evaluated in left-to-right order with sequenced-before relationship.'''
formal_spec = '''in_braced_init_list(init) && clause_i before clause_j in init => sequenced_before(effects(clause_i), effects(clause_j))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/4"
tags = ['list-initialization', 'evaluation-order', 'sequencing']

[[axioms]]
id = "cpp20_dcl_init_list_no_matching_init_e7b8d6a9"
content = '''If none of the list-initialization rules apply (rules 3.1 through 3.11), the program is ill-formed.'''
formal_spec = '''list_init(T, init) && !matches_any_rule_3_1_to_3_11(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.12"
tags = ['list-initialization', 'ill-formed']

[[axioms]]
id = "cpp20_dcl_init_list_copy_list_init_explicit_f8c9e7b0"
content = '''Copy-list-initialization cannot use an explicit constructor; selecting an explicit constructor via copy-list-initialization makes the program ill-formed.'''
formal_spec = '''copy_list_init(T, init) && selected_constructor_is_explicit(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.10"
tags = ['list-initialization', 'copy-list-initialization', 'explicit', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_aggr_designated_class_only_a7c3e2f1"
content = '''When using a designated-initializer-list, the aggregate shall be of class type.'''
formal_spec = '''is_designated_initializer_list(init) && !is_class_type(aggregate_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['aggregate', 'initialization', 'designated-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_designator_direct_member_b4d8f6e2"
content = '''In a designated-initializer-list, each identifier in a designator shall name a direct non-static data member of the class.'''
formal_spec = '''is_designated_initializer_list(init) && has_designator(d, identifier) && !is_direct_nonstatic_data_member(identifier, class_type) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/3.1"
tags = ['aggregate', 'initialization', 'designated-initializer', 'member']

[[axioms]]
id = "cpp20_dcl_init_aggr_anon_union_single_designator_c5e9a7d3"
content = '''When initializing an anonymous union member with a designated-initializer-list, there shall be only one designated-initializer-clause naming a member of the anonymous union.'''
formal_spec = '''is_anonymous_union_member(element) && is_designated_initializer_list(init) && count_designators_for_union(init, element) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.1"
tags = ['aggregate', 'initialization', 'anonymous-union', 'designated-initializer']

[[axioms]]
id = "cpp20_dcl_init_aggr_narrowing_designated_d6f0b8e4"
content = '''In a designated-initializer-clause of form = assignment-expression, if a narrowing conversion is required to convert the expression, the program is ill-formed.'''
formal_spec = '''is_designated_initializer_clause(d) && form_equals_assignment_expr(d) && requires_narrowing_conversion(expr(d), target_type(d)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/4.2"
tags = ['aggregate', 'initialization', 'designated-initializer', 'narrowing-conversion']

[[axioms]]
id = "cpp20_dcl_init_aggr_reference_no_default_e7a1c9f5"
content = '''For a non-union aggregate, if an element is a reference and is not explicitly initialized and has no default member initializer, the program is ill-formed.'''
formal_spec = '''is_non_union_aggregate(agg) && is_reference_type(element_type(e)) && !explicitly_initialized(e) && !has_default_member_initializer(e) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/5.3"
tags = ['aggregate', 'initialization', 'reference', 'default-initialization']

[[axioms]]
id = "cpp20_dcl_init_aggr_unknown_bound_empty_f8b2dae6"
content = '''An array of unknown bound shall not be initialized with an empty braced-init-list {}.'''
formal_spec = '''is_array_unknown_bound(T) && is_empty_braced_init_list(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/10"
tags = ['aggregate', 'initialization', 'array', 'unknown-bound']

[[axioms]]
id = "cpp20_dcl_init_aggr_recursive_default_member_init_09c3ebf7"
content = '''If a member has a default member initializer and a potentially-evaluated subexpression thereof is an aggregate initialization that would use that default member initializer, the program is ill-formed.'''
formal_spec = '''has_default_member_initializer(member) && contains_potentially_evaluated_subexpr(default_init(member), subexpr) && is_aggregate_init(subexpr) && would_use_default_member_init(subexpr, member) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/12"
tags = ['aggregate', 'initialization', 'default-member-initializer', 'recursive']

[[axioms]]
id = "cpp20_dcl_init_aggr_too_many_initializers_1ad4fcg8"
content = '''If any initializer-clause remains that does not appertain to an element of the aggregate or one of its subaggregates, the program is ill-formed.'''
formal_spec = '''is_aggregate_init(init) && exists_initializer_clause(init, clause) && !appertains_to_element(clause, aggregate) && !appertains_to_subaggregate_element(clause, aggregate) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/14"
tags = ['aggregate', 'initialization', 'initializer-list', 'excess-elements']

[[axioms]]
id = "cpp20_dcl_init_aggr_union_single_element_2be5gdh9"
content = '''When a union is initialized with an initializer list, there shall not be more than one explicitly initialized element.'''
formal_spec = '''is_union_type(T) && is_initializer_list_init(init) && count_explicitly_initialized_elements(init) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/20"
tags = ['aggregate', 'initialization', 'union']

[[axioms]]
id = "cpp20_dcl_init_aggr_element_order_sequencing_3cf6hei0"
content = '''The initializations of the elements of the aggregate are evaluated in element order. All value computations and side effects associated with a given element are sequenced before those of any element that follows it in order.'''
formal_spec = '''is_aggregate_init(agg, init) && element_index(e1) < element_index(e2) => sequenced_before(value_computations(e1), value_computations(e2)) && sequenced_before(side_effects(e1), side_effects(e2))'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/7"
tags = ['aggregate', 'initialization', 'sequencing', 'evaluation-order']

[[axioms]]
id = "cpp20_dcl_init_aggr_destructor_potentially_invoked_4dg7ifj1"
content = '''The destructor for each element of class type other than an anonymous union member is potentially invoked from the context where the aggregate initialization occurs.'''
formal_spec = '''is_aggregate_init(agg) && is_element(e, agg) && is_class_type(type(e)) && !is_anonymous_union_member(e) => potentially_invoked(destructor(type(e)), initialization_context(agg))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/9"
tags = ['aggregate', 'initialization', 'destructor', 'exception-safety']

[[axioms]]
id = "cpp20_dcl_init_aggr_array_bound_from_init_5eh8jgk2"
content = '''The number of elements in an array of unknown bound initialized with a brace-enclosed initializer-list is the number of explicitly initialized elements of the array.'''
formal_spec = '''is_array_unknown_bound(T) && is_braced_init_list(init) => array_bound(T) == count_explicitly_initialized_elements(init)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "dcl.init.aggr"
source_module = "[dcl.init.aggr]/10"
tags = ['aggregate', 'initialization', 'array', 'unknown-bound', 'deduction']

[[axioms]]
id = "cpp20_class_cdtor_refer_before_ctor_nontrivial_a7c3f8e2"
content = '''For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior.'''
formal_spec = '''has_nontrivial_constructor(obj) && refers_to_member_or_base(ref, obj) && !construction_started(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/1"
tags = ['lifetime', 'constructor', 'initialization', 'member-access']

[[axioms]]
id = "cpp20_class_cdtor_refer_after_dtor_nontrivial_b2d4e9f1"
content = '''For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior.'''
formal_spec = '''has_nontrivial_destructor(obj) && refers_to_member_or_base(ref, obj) && destruction_completed(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/1"
tags = ['lifetime', 'destructor', 'member-access']

[[axioms]]
id = "cpp20_class_cdtor_upcast_ctor_not_started_c8e5a1b3"
content = '''To convert a pointer or glvalue referring to an object of class X to a pointer or reference to a direct or indirect base class B of X, the construction of X and all its direct or indirect bases that derive from B shall have started, otherwise the conversion results in undefined behavior.'''
formal_spec = '''is_base_of(B, X) && convert_to_base(ptr_to_X, B) && (!construction_started(X) || exists(C, derives_from(C, B) && is_base_of(C, X) && !construction_started(C))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'constructor', 'conversion', 'pointer', 'upcast']

[[axioms]]
id = "cpp20_class_cdtor_upcast_dtor_completed_d9f6b2c4"
content = '''To convert a pointer or glvalue referring to an object of class X to a pointer or reference to a direct or indirect base class B of X, the destruction of X and all its direct or indirect bases that derive from B shall not have completed, otherwise the conversion results in undefined behavior.'''
formal_spec = '''is_base_of(B, X) && convert_to_base(ptr_to_X, B) && (destruction_completed(X) || exists(C, derives_from(C, B) && is_base_of(C, X) && destruction_completed(C))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'destructor', 'conversion', 'pointer', 'upcast']

[[axioms]]
id = "cpp20_class_cdtor_member_ptr_ctor_not_started_e1a7c3d5"
content = '''To form a pointer to or access the value of a direct non-static member of an object, the construction of the object shall have started, otherwise the computation of the pointer value or accessing the member value results in undefined behavior.'''
formal_spec = '''is_direct_nonstatic_member(member, obj) && (form_pointer_to(member) || access_value(member)) && !construction_started(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'constructor', 'member-access', 'pointer']

[[axioms]]
id = "cpp20_class_cdtor_member_ptr_dtor_completed_f2b8d4e6"
content = '''To form a pointer to or access the value of a direct non-static member of an object, the destruction of the object shall not have completed, otherwise the computation of the pointer value or accessing the member value results in undefined behavior.'''
formal_spec = '''is_direct_nonstatic_member(member, obj) && (form_pointer_to(member) || access_value(member)) && destruction_completed(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/3"
tags = ['lifetime', 'destructor', 'member-access', 'pointer']

[[axioms]]
id = "cpp20_class_cdtor_virtual_call_wrong_object_g3c9e5f7"
content = '''During construction or destruction, if a virtual function call uses an explicit class member access and the object expression refers to the complete object or one of its base class subobjects but not the object under construction/destruction or one of its base class subobjects, the behavior is undefined.'''
formal_spec = '''(in_constructor(x) || in_destructor(x)) && virtual_call(f) && explicit_member_access(call, obj_expr) && (refers_to_complete_object(obj_expr, x) || refers_to_base_of_complete(obj_expr, x)) && !refers_to(obj_expr, x) && !refers_to_base_of(obj_expr, x) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/4"
tags = ['lifetime', 'constructor', 'destructor', 'virtual-function', 'member-access']

[[axioms]]
id = "cpp20_class_cdtor_typeid_wrong_static_type_h4d0f6a8"
content = '''When typeid is used in a constructor or destructor (or function called from them) and the operand refers to the object under construction or destruction, if the static type of the operand is neither the constructor or destructor's class nor one of its bases, the behavior is undefined.'''
formal_spec = '''(in_constructor(C) || in_destructor(C)) && typeid_operand_refers_to(operand, object_under_construction_or_destruction) && static_type(operand) != C && !is_base_of(static_type(operand), C) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/5"
tags = ['lifetime', 'constructor', 'destructor', 'typeid', 'rtti']

[[axioms]]
id = "cpp20_class_cdtor_dynamic_cast_wrong_static_type_i5e1a7b9"
content = '''When dynamic_cast is used in a constructor or destructor (or function called from them) and the operand refers to the object under construction or destruction, if the static type of the operand is not a pointer to or object of the constructor or destructor's own class or one of its bases, the dynamic_cast results in undefined behavior.'''
formal_spec = '''(in_constructor(C) || in_destructor(C)) && dynamic_cast_operand_refers_to(operand, object_under_construction_or_destruction) && !is_pointer_to_or_object_of(static_type(operand), C) && !is_pointer_to_or_object_of_base(static_type(operand), C) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.cdtor"
source_module = "[class.cdtor]/6"
tags = ['lifetime', 'constructor', 'destructor', 'dynamic_cast', 'rtti']

[[axioms]]
id = "cpp20_class_base_init_mem_init_invalid_id_a2b3c4d5"
content = '''A mem-initializer-id must name the constructor's class, a direct non-static data member of the constructor's class, or a direct or virtual base of that class; otherwise the mem-initializer is ill-formed.'''
formal_spec = '''mem_initializer_id(id) && !names_constructor_class(id) && !names_direct_nonstatic_member(id) && !names_direct_base(id) && !names_virtual_base(id) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/2"
tags = ['initialization', 'constructor', 'mem-initializer']

[[axioms]]
id = "cpp20_class_base_init_ambiguous_base_e5f6a7b8"
content = '''If a mem-initializer-id is ambiguous because it designates both a direct non-virtual base class and an indirect virtual base class, the mem-initializer is ill-formed.'''
formal_spec = '''mem_initializer_id(id) && designates_direct_nonvirtual_base(id, B) && designates_indirect_virtual_base(id, B) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/4"
tags = ['initialization', 'constructor', 'base-class', 'ambiguity']

[[axioms]]
id = "cpp20_class_base_init_duplicate_mem_init_c9d0e1f2"
content = '''If a ctor-initializer specifies more than one mem-initializer for the same member or for the same base class, the ctor-initializer is ill-formed.'''
formal_spec = '''ctor_initializer(ctor) && count_mem_initializers_for(ctor, target) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/5"
tags = ['initialization', 'constructor', 'mem-initializer']

[[axioms]]
id = "cpp20_class_base_init_delegating_sole_init_3a4b5c6d"
content = '''If a mem-initializer-id designates the constructor's class (delegating constructor), it shall be the only mem-initializer.'''
formal_spec = '''mem_initializer_id_designates_own_class(id, ctor) && has_other_mem_initializers(ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/6"
tags = ['initialization', 'constructor', 'delegating-constructor']

[[axioms]]
id = "cpp20_class_base_init_recursive_delegation_7e8f9a0b"
content = '''If a constructor delegates to itself directly or indirectly, the program is ill-formed, no diagnostic required.'''
formal_spec = '''is_delegating_constructor(ctor) && delegates_to_self_transitively(ctor) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/6"
tags = ['initialization', 'constructor', 'delegating-constructor', 'recursion']

[[axioms]]
id = "cpp20_class_base_init_temp_bound_to_ref_member_1c2d3e4f"
content = '''A temporary expression bound to a reference member in a mem-initializer is ill-formed.'''
formal_spec = '''mem_initializer(init) && is_reference_member(target(init)) && binds_temporary(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/8"
tags = ['initialization', 'constructor', 'reference', 'temporary', 'lifetime']

[[axioms]]
id = "cpp20_class_base_init_multiple_union_members_5g6h7i8j"
content = '''An attempt to initialize more than one non-static data member of a union renders the program ill-formed.'''
formal_spec = '''is_union(class_of(ctor)) && count_initialized_members(ctor) > 1 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/9"
tags = ['initialization', 'constructor', 'union', 'variant-member']

[[axioms]]
id = "cpp20_class_base_init_temp_bound_default_init_9k0l1m2n"
content = '''A temporary expression bound to a reference member from a default member initializer is ill-formed.'''
formal_spec = '''default_member_initializer(init) && is_reference_member(target(init)) && binds_temporary(init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/11"
tags = ['initialization', 'default-member-initializer', 'reference', 'temporary', 'lifetime']

[[axioms]]
id = "cpp20_class_base_init_vfunc_before_base_init_3o4p5q6r"
content = '''Calling member functions (including virtual member functions) or using typeid/dynamic_cast during ctor-initializer evaluation before all mem-initializers for base classes have completed is undefined behavior.'''
formal_spec = '''in_ctor_initializer_evaluation(ctor) && !all_base_mem_initializers_complete(ctor) && (calls_member_function() || uses_typeid() || uses_dynamic_cast()) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/16"
tags = ['initialization', 'constructor', 'virtual-function', 'typeid', 'dynamic_cast', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_base_init_precondition_assert_ctor_7s8t9u0v"
content = '''Calling member functions or using typeid/dynamic_cast during evaluation of a precondition assertion of a constructor is undefined behavior.'''
formal_spec = '''in_precondition_assertion_of_constructor(ctor) && (calls_member_function() || uses_typeid() || uses_dynamic_cast()) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/16.2"
tags = ['initialization', 'constructor', 'contract', 'precondition', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_base_init_postcondition_assert_dtor_1w2x3y4z"
content = '''Calling member functions or using typeid/dynamic_cast during evaluation of a postcondition assertion of a destructor is undefined behavior.'''
formal_spec = '''in_postcondition_assertion_of_destructor(dtor) && (calls_member_function() || uses_typeid() || uses_dynamic_cast()) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.base.init"
source_module = "[class.base.init]/16.3"
tags = ['initialization', 'destructor', 'contract', 'postcondition', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_base_init_virt_base_first_order_5a6b7c8d"
content = '''In a non-delegating constructor of the most derived class, virtual base classes are initialized first in depth-first left-to-right traversal order of the base class DAG.'''
formal_spec = '''is_most_derived_class_ctor(ctor) && !is_delegating_constructor(ctor) => init_order_virtual_bases_first_dfs_ltr(ctor)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/13.1"
tags = ['initialization', 'constructor', 'virtual-base', 'initialization-order']

[[axioms]]
id = "cpp20_class_base_init_direct_base_decl_order_9e0f1g2h"
content = '''In a non-delegating constructor, direct base classes are initialized in declaration order as they appear in the base-specifier-list, regardless of mem-initializer order.'''
formal_spec = '''!is_delegating_constructor(ctor) => init_order_direct_bases_declaration_order(ctor)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/13.2"
tags = ['initialization', 'constructor', 'base-class', 'initialization-order']

[[axioms]]
id = "cpp20_class_base_init_member_decl_order_3i4j5k6l"
content = '''In a non-delegating constructor, non-static data members are initialized in the order they were declared in the class definition, regardless of mem-initializer order.'''
formal_spec = '''!is_delegating_constructor(ctor) => init_order_members_declaration_order(ctor)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/13.3"
tags = ['initialization', 'constructor', 'data-member', 'initialization-order']

[[axioms]]
id = "cpp20_class_base_init_virt_base_ignored_7m8n9o0p"
content = '''A mem-initializer where the mem-initializer-id denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.'''
formal_spec = '''mem_initializer_denotes_virtual_base(init) && !is_most_derived_class_ctor(ctor) => ignored(init)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/7"
tags = ['initialization', 'constructor', 'virtual-base']

[[axioms]]
id = "cpp20_class_base_init_default_init_override_1q2r3s4t"
content = '''If a non-static data member has both a default member initializer and a mem-initializer, the mem-initializer is performed and the default member initializer is ignored.'''
formal_spec = '''has_default_member_initializer(member) && has_mem_initializer(member, ctor) => use_mem_initializer(member) && ignore_default_member_initializer(member)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.base.init"
source_module = "[class.base.init]/10"
tags = ['initialization', 'constructor', 'default-member-initializer', 'mem-initializer']

[[axioms]]
id = "cpp20_class_dtor_address_not_taken_a3f8b2c1"
content = '''The address of a destructor shall not be taken.'''
formal_spec = '''address_of(destructor(C)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/5"
tags = ['destructor', 'address', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_virtual_must_define_d7e9f3a2"
content = '''If the destructor of a class is virtual and any objects of that class or any derived class are created in the program, the destructor shall be defined.'''
formal_spec = '''virtual_destructor(C) && (object_created(C) || exists(D, derived_from(D, C) && object_created(D))) => must_be_defined(destructor(C))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/11"
tags = ['destructor', 'virtual', 'definition', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_virtual_dealloc_lookup_fail_e4b2c8d1"
content = '''At the point of definition of a virtual destructor, if the non-array deallocation function lookup fails or the deallocation function has a deleted definition, the program is ill-formed.'''
formal_spec = '''virtual_destructor(C) && defined(destructor(C)) && (dealloc_lookup_fails(C) || deleted(dealloc_function(C))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/15"
tags = ['destructor', 'virtual', 'deallocation', 'delete']

[[axioms]]
id = "cpp20_class_dtor_invoke_wrong_type_ub_f5a3d9e7"
content = '''Invoking a destructor on an object that is not of the destructor's class type and not of a class derived from the destructor's class type (including when invoked via a null pointer value) is undefined behavior.'''
formal_spec = '''explicit_destructor_call(ptr, DtorClass) && !is_type_or_derived(pointee_type(ptr), DtorClass) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/16"
tags = ['destructor', 'explicit-call', 'type-mismatch', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_invoke_null_ptr_ub_c8e2b4f6"
content = '''Invoking a destructor via a null pointer value is undefined behavior.'''
formal_spec = '''explicit_destructor_call(ptr, C) && is_null(ptr) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/16"
tags = ['destructor', 'null-pointer', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_invoke_ended_lifetime_ub_b7d4e1a9"
content = '''Invoking a destructor for an object whose lifetime has ended is undefined behavior.'''
formal_spec = '''destructor_invoked(obj) && lifetime_ended(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/18"
tags = ['destructor', 'lifetime', 'double-destroy', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_double_destroy_auto_ub_a2c5f8b3"
content = '''If the destructor for an object with automatic storage duration is explicitly invoked, and the block is subsequently left in a manner that would ordinarily invoke implicit destruction of the object, the behavior is undefined.'''
formal_spec = '''automatic_storage(obj) && explicit_destructor_call(obj) && block_exit_triggers_implicit_destroy(obj) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/18"
tags = ['destructor', 'automatic-storage', 'double-destroy', 'undefined-behavior']

[[axioms]]
id = "cpp20_class_dtor_potentially_invoked_deleted_c9f3a7d2"
content = '''A program is ill-formed if a destructor that is potentially invoked is deleted or not accessible from the context of the invocation.'''
formal_spec = '''potentially_invoked(destructor(C), context) && (deleted(destructor(C)) || !accessible(destructor(C), context)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/14"
tags = ['destructor', 'deleted', 'accessibility', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_overload_resolution_fail_e6b8c2d4"
content = '''The program is ill-formed if overload resolution fails when selecting the destructor from prospective destructors.'''
formal_spec = '''class_definition_end(C) && overload_resolution_fails(prospective_destructors(C), empty_args) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/4"
tags = ['destructor', 'overload-resolution', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_no_arguments_d4e7f9a1"
content = '''A prospective destructor shall take no arguments.'''
formal_spec = '''prospective_destructor(D) && parameter_count(D) != 0 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/1"
tags = ['destructor', 'parameters', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_decl_specifiers_b3a6c8e5"
content = '''Each decl-specifier of the decl-specifier-seq of a prospective destructor declaration shall be friend, inline, virtual, or constexpr.'''
formal_spec = '''prospective_destructor(D) && has_decl_specifier(D, S) && S not_in {friend, inline, virtual, constexpr} => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/1"
tags = ['destructor', 'declaration', 'specifier', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_not_coroutine_f8c4d2e6"
content = '''A destructor shall not be a coroutine.'''
formal_spec = '''destructor(D) && is_coroutine(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/20"
tags = ['destructor', 'coroutine', 'constraint']

[[axioms]]
id = "cpp20_class_dtor_lifetime_ends_on_invoke_a5d8e3b7"
content = '''Once a destructor is invoked for an object, the object's lifetime ends.'''
formal_spec = '''destructor_invoked(obj) => lifetime_ended(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/18"
tags = ['destructor', 'lifetime', 'invariant']

[[axioms]]
id = "cpp20_class_dtor_const_volatile_stop_c2f6b9d8"
content = '''const and volatile semantics are not applied on an object under destruction. They stop being in effect when the destructor for the most derived object starts.'''
formal_spec = '''destructor_started(most_derived_object(obj)) => !apply_cv_semantics(obj)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.dtor"
source_module = "[class.dtor]/5"
tags = ['destructor', 'const', 'volatile', 'cv-qualification']

[[axioms]]
id = "cpp20_class_dtor_deleted_inaccessible_subobject_d9e4a7c3"
content = '''A defaulted destructor for a non-union class X is defined as deleted if any non-variant potentially constructed subobject has class type M where M has a destructor that is deleted or inaccessible from the defaulted destructor.'''
formal_spec = '''defaulted_destructor(X) && !is_union(X) && exists(subobj, non_variant_potentially_constructed(subobj, X) && class_type(subobj, M) && (deleted(destructor(M)) || !accessible(destructor(M), destructor(X)))) => deleted(destructor(X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/7.1"
tags = ['destructor', 'defaulted', 'deleted', 'accessibility']

[[axioms]]
id = "cpp20_class_dtor_deleted_virtual_dealloc_e7f2b5a4"
content = '''A defaulted destructor for a class is defined as deleted if for a virtual destructor, lookup of the non-array deallocation function results in an ambiguity or in a function that is deleted or inaccessible from the defaulted destructor.'''
formal_spec = '''defaulted_destructor(X) && virtual(destructor(X)) && (dealloc_lookup_ambiguous(X) || deleted(dealloc_function(X)) || !accessible(dealloc_function(X), destructor(X))) => deleted(destructor(X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/7.3"
tags = ['destructor', 'virtual', 'deallocation', 'deleted']

[[axioms]]
id = "cpp20_class_dtor_destruction_order_a8c3e6f1"
content = '''Bases and members are destroyed in the reverse order of the completion of their constructor.'''
formal_spec = '''destruction_order(class_members_and_bases(X)) == reverse(construction_completion_order(class_members_and_bases(X)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/13"
tags = ['destructor', 'construction-order', 'destruction-order', 'invariant']

[[axioms]]
id = "cpp20_class_dtor_array_destruction_order_b4d7e9c2"
content = '''Destructors for elements of an array are called in reverse order of their construction.'''
formal_spec = '''array_of_class_type(arr) => destruction_order(elements(arr)) == reverse(construction_order(elements(arr)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.dtor"
source_module = "[class.dtor]/13"
tags = ['destructor', 'array', 'destruction-order', 'invariant']

[[axioms]]
id = "cpp20_class_virtual_multiple_final_overriders_a7d3e1f2"
content = '''In a derived class, if a virtual member function of a base class subobject has more than one final overrider, the program is ill-formed.'''
formal_spec = '''derived_class(D) && base_class_subobject(S, D) && virtual_function(V, S) && final_overrider(F1, V, D) && final_overrider(F2, V, D) && F1 != F2 => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/2"
tags = ['virtual', 'override', 'inheritance', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_final_override_attempt_b8c4f2a9"
content = '''If a virtual function f in some class B is marked with the virt-specifier final and in a class D derived from B a function D::f overrides B::f, the program is ill-formed.'''
formal_spec = '''virtual_function(f, B) && has_virt_specifier(f, final) && derived_from(D, B) && overrides(D::f, B::f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/4"
tags = ['virtual', 'final', 'override', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_override_specifier_no_base_c9d5a3b1"
content = '''If a virtual function is marked with the virt-specifier override and does not override a member function of a base class, the program is ill-formed.'''
formal_spec = '''virtual_function(f) && has_virt_specifier(f, override) && NOT(exists(g, base_class_of(class_of(f)), overrides(f, g))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/5"
tags = ['virtual', 'override', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_no_requires_clause_d1e6b4c2"
content = '''A virtual function shall not have a trailing requires-clause.'''
formal_spec = '''virtual_function(f) && has_trailing_requires_clause(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/6"
tags = ['virtual', 'constraints', 'requires', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_ref_qualifier_match_e2f7c5d3"
content = '''The ref-qualifier, or lack thereof, of an overriding function shall be the same as that of the overridden function.'''
formal_spec = '''overrides(f_derived, f_base) => ref_qualifier(f_derived) == ref_qualifier(f_base)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/7"
tags = ['virtual', 'override', 'ref-qualifier', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_return_type_covariant_f3a8d6e4"
content = '''The return type of an overriding function shall be either identical to the return type of the overridden function or covariant with the classes of the functions.'''
formal_spec = '''overrides(f_derived, f_base) => (return_type(f_derived) == return_type(f_base) || covariant_return_types(f_derived, f_base))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8"
tags = ['virtual', 'override', 'return-type', 'covariant', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_covariant_pointer_ref_g4b9e7f5"
content = '''For covariant return types, both return types must be pointers to classes, both lvalue references to classes, or both rvalue references to classes.'''
formal_spec = '''covariant_return_types(f_derived, f_base) => ((is_pointer_to_class(return_type(f_base)) && is_pointer_to_class(return_type(f_derived))) || (is_lvalue_ref_to_class(return_type(f_base)) && is_lvalue_ref_to_class(return_type(f_derived))) || (is_rvalue_ref_to_class(return_type(f_base)) && is_rvalue_ref_to_class(return_type(f_derived))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8.1"
tags = ['virtual', 'covariant', 'return-type', 'pointer', 'reference']

[[axioms]]
id = "cpp20_class_virtual_covariant_base_accessible_h5c1f8a6"
content = '''For covariant return types, the class in the return type of B::f shall be the same class as or an unambiguous and accessible direct or indirect base class of the class in the return type of D::f.'''
formal_spec = '''covariant_return_types(D::f, B::f) => (class_in_return_type(B::f) == class_in_return_type(D::f) || (is_base_class_of(class_in_return_type(B::f), class_in_return_type(D::f)) && unambiguous_base(class_in_return_type(B::f), class_in_return_type(D::f)) && accessible_base(class_in_return_type(B::f), class_in_return_type(D::f))))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8.2"
tags = ['virtual', 'covariant', 'return-type', 'base-class', 'accessibility']

[[axioms]]
id = "cpp20_class_virtual_covariant_cv_qualification_i6d2a9b7"
content = '''For covariant return types, both pointers or references shall have the same cv-qualification and the class type in the return type of D::f shall have the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.'''
formal_spec = '''covariant_return_types(D::f, B::f) => (cv_qual_of_ptr_or_ref(return_type(D::f)) == cv_qual_of_ptr_or_ref(return_type(B::f)) && cv_qual_of_class(return_type(D::f)) <= cv_qual_of_class(return_type(B::f)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/8.3"
tags = ['virtual', 'covariant', 'return-type', 'cv-qualification']

[[axioms]]
id = "cpp20_class_virtual_covariant_complete_type_j7e3b1c8"
content = '''If the class type in the covariant return type of D::f differs from that of B::f, the class type in the return type of D::f shall be complete at the locus of the overriding declaration or shall be the class type D.'''
formal_spec = '''covariant_return_types(D::f, B::f) && class_in_return_type(D::f) != class_in_return_type(B::f) => (is_complete_at_locus(class_in_return_type(D::f), declaration_of(D::f)) || class_in_return_type(D::f) == D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/9"
tags = ['virtual', 'covariant', 'return-type', 'complete-type']

[[axioms]]
id = "cpp20_class_virtual_odr_define_or_pure_k8f4c2d9"
content = '''A virtual function declared in a class shall be defined, or declared pure in that class, or both; no diagnostic is required.'''
formal_spec = '''virtual_function(f, C) && declared_in(f, C) && NOT(defined(f)) && NOT(is_pure_virtual(f)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/12"
tags = ['virtual', 'odr', 'pure-virtual', 'definition', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_class_virtual_deleted_not_override_nondeleted_l9a5d3e1"
content = '''A deleted function shall not override a function that is not deleted.'''
formal_spec = '''is_deleted(f_derived) && overrides(f_derived, f_base) && NOT(is_deleted(f_base)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/17"
tags = ['virtual', 'override', 'deleted', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_nondeleted_not_override_deleted_m1b6e4f2"
content = '''A function that is not deleted shall not override a deleted function.'''
formal_spec = '''NOT(is_deleted(f_derived)) && overrides(f_derived, f_base) && is_deleted(f_base) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/17"
tags = ['virtual', 'override', 'deleted', 'ill-formed']

[[axioms]]
id = "cpp20_class_virtual_consteval_override_nonconsteval_n2c7f5a3"
content = '''A class with a consteval virtual function that overrides a virtual function that is not consteval shall have consteval-only type.'''
formal_spec = '''class_has_member(C, f) && is_consteval(f) && virtual_function(f) && overrides(f, g) && NOT(is_consteval(g)) => is_consteval_only_type(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/18"
tags = ['virtual', 'consteval', 'override', 'consteval-only']

[[axioms]]
id = "cpp20_class_virtual_consteval_not_overridden_by_nonconsteval_o3d8a6b4"
content = '''A consteval virtual function shall not be overridden by a virtual function that is not consteval.'''
formal_spec = '''is_consteval(f_base) && virtual_function(f_base) && overrides(f_derived, f_base) && virtual_function(f_derived) && NOT(is_consteval(f_derived)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.virtual"
source_module = "[class.virtual]/18"
tags = ['virtual', 'consteval', 'override', 'ill-formed']

[[axioms]]
id = "cpp20_class_abstract_virtual_call_pure_from_ctor_dtor_a7c3f2e1"
content = '''Making a virtual call to a pure virtual function directly or indirectly for the object being created or destroyed from a constructor or destructor of an abstract class is undefined behavior.'''
formal_spec = '''(in_constructor(C, obj) || in_destructor(C, obj)) && is_abstract_class(C) && virtual_call(f, obj) && is_pure_virtual(final_overrider(f, dynamic_type(obj))) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.abstract"
source_module = "[class.abstract]/6"
tags = ['lifetime', 'constructor', 'destructor', 'virtual', 'pure-virtual', 'abstract-class']

[[axioms]]
id = "cpp20_class_abstract_no_object_creation_b4d8e9f2"
content = '''No objects of an abstract class can be created except as subobjects of a class derived from it.'''
formal_spec = '''is_abstract_class(C) && create_object(C) && !is_subobject_of_derived(obj, C) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/2"
tags = ['abstract-class', 'object-creation', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_no_parameter_type_c5a7d3b8"
content = '''An abstract class type cannot be used as a parameter type of a function being defined or called.'''
formal_spec = '''is_abstract_class(T) && (is_parameter_type(T, func_def) || is_parameter_type(T, func_call)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/3"
tags = ['abstract-class', 'function', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_no_return_type_d6b9e4c7"
content = '''An abstract class type cannot be used as a return type of a function being defined or called.'''
formal_spec = '''is_abstract_class(T) && (is_return_type(T, func_def) || is_return_type(T, func_call)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/3"
tags = ['abstract-class', 'function', 'return-type', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_no_explicit_conversion_e8c2f5a9"
content = '''An abstract class type cannot be used as the type of an explicit type conversion because the resulting prvalue would be of abstract class type.'''
formal_spec = '''is_abstract_class(T) && (static_cast_to(T) || reinterpret_cast_to(T) || const_cast_to(T)) && is_prvalue_result => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/3"
tags = ['abstract-class', 'cast', 'conversion', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_pure_specifier_no_definition_f9d3a6b2"
content = '''A function declaration cannot provide both a pure-specifier and a definition in the same declaration.'''
formal_spec = '''has_pure_specifier(decl) && has_definition(decl) && same_declaration(decl) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.abstract"
source_module = "[class.abstract]/2"
tags = ['abstract-class', 'pure-virtual', 'declaration', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_pure_virtual_must_define_if_qualified_call_a2e7c8d4"
content = '''A pure virtual function need be defined only if called with, or as if with, the qualified-id syntax.'''
formal_spec = '''is_pure_virtual(f) && qualified_call(f) && !has_definition(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "class.abstract"
source_module = "[class.abstract]/2"
tags = ['abstract-class', 'pure-virtual', 'definition', 'qualified-id', 'constraint']

[[axioms]]
id = "cpp20_class_abstract_definition_class_has_pure_virtual_b3f8d9e5"
content = '''A class is an abstract class if it has at least one pure virtual function for which the final overrider is pure virtual.'''
formal_spec = '''exists(f, member_of(f, C) && is_virtual(f) && is_pure_virtual(final_overrider(f, C))) => is_abstract_class(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "class.abstract"
source_module = "[class.abstract]/4"
tags = ['abstract-class', 'pure-virtual', 'final-overrider', 'definition']

[[axioms]]
id = "cpp20_special_no_define_implicit_decl_a7c3f2b1"
content = '''Programs shall not define implicitly-declared special member functions.'''
formal_spec = '''implicitly_declared(F) && is_special_member_function(F) && program_defines(F) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/1"
tags = ['special-member-functions', 'implicit-declaration', 'definition', 'constraint']

[[axioms]]
id = "cpp20_special_implicit_decl_at_closing_brace_d4e8f1a2"
content = '''An implicitly-declared special member function is declared at the closing } of the class-specifier.'''
formal_spec = '''implicitly_declared(F) && is_special_member_function(F) => declaration_point(F) == closing_brace(class_specifier(class_of(F)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "special"
source_module = "[special]/1"
tags = ['special-member-functions', 'implicit-declaration', 'declaration-point']

[[axioms]]
id = "cpp20_special_eligible_not_deleted_c2b9e7f3"
content = '''An eligible special member function must not be deleted.'''
formal_spec = '''eligible_special_member_function(F) => !is_deleted(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/6.1"
tags = ['special-member-functions', 'eligible', 'deleted-functions']

[[axioms]]
id = "cpp20_special_eligible_constraints_satisfied_b5a1d8c4"
content = '''An eligible special member function must have its associated constraints satisfied, if any.'''
formal_spec = '''eligible_special_member_function(F) && has_constraints(F) => constraints_satisfied(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/6.2"
tags = ['special-member-functions', 'eligible', 'constraints', 'concepts']

[[axioms]]
id = "cpp20_special_eligible_most_constrained_e9f4a2d6"
content = '''An eligible special member function must not have another special member function of the same kind that is more constrained and whose constraints are satisfied.'''
formal_spec = '''eligible_special_member_function(F) => !exists(G, same_kind(F, G) && constraints_satisfied(G) && more_constrained(G, F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/6.3"
tags = ['special-member-functions', 'eligible', 'constraints', 'overload-resolution']

[[axioms]]
id = "cpp20_special_same_kind_default_ctor_f1c7b3e8"
content = '''Two special member functions are of the same kind if they are both default constructors.'''
formal_spec = '''same_kind(F, G) <= (is_default_constructor(F) && is_default_constructor(G))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/5.1"
tags = ['special-member-functions', 'same-kind', 'default-constructor']

[[axioms]]
id = "cpp20_special_same_kind_copy_move_ctor_a3d2c9f5"
content = '''Two special member functions are of the same kind if they are both copy or move constructors with the same first parameter type.'''
formal_spec = '''same_kind(F, G) <= ((is_copy_constructor(F) || is_move_constructor(F)) && (is_copy_constructor(G) || is_move_constructor(G)) && first_param_type(F) == first_param_type(G))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/5.2"
tags = ['special-member-functions', 'same-kind', 'copy-constructor', 'move-constructor']

[[axioms]]
id = "cpp20_special_same_kind_copy_move_assign_c8e1f4b7"
content = '''Two special member functions are of the same kind if they are both copy or move assignment operators with the same first parameter type and the same cv-qualifiers and ref-qualifier, if any.'''
formal_spec = '''same_kind(F, G) <= ((is_copy_assignment(F) || is_move_assignment(F)) && (is_copy_assignment(G) || is_move_assignment(G)) && first_param_type(F) == first_param_type(G) && cv_qualifiers(F) == cv_qualifiers(G) && ref_qualifier(F) == ref_qualifier(G))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/5.3"
tags = ['special-member-functions', 'same-kind', 'copy-assignment', 'move-assignment']

[[axioms]]
id = "cpp20_special_potentially_constructed_subobjects_d5f2a8c1"
content = '''For a class, its potentially constructed subobjects are: direct non-static data members, non-virtual direct base classes, and (if the class is not abstract) its virtual base classes.'''
formal_spec = '''potentially_constructed_subobject(C, S) <=> (is_direct_nonstatic_data_member(C, S) || is_nonvirtual_direct_base(C, S) || (!is_abstract(C) && is_virtual_base(C, S)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "special"
source_module = "[special]/7"
tags = ['special-member-functions', 'subobjects', 'construction', 'abstract-class']

[[axioms]]
id = "cpp20_over_match_general_resolution_fails_illformed_a3b7c2d1"
content = '''When overload resolution fails (no best viable function exists or it is not unique), the invocation is ill-formed.'''
formal_spec = '''overload_resolution(candidates, args) && (!exists_best_viable(candidates, args) || !unique_best_viable(candidates, args)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.general"
source_module = "[over.match.general]/3"
tags = ['overload-resolution', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_general_inaccessible_illformed_e4f8a1b2"
content = '''When overload resolution succeeds but the best viable function is not accessible in the context in which it is used, the program is ill-formed.'''
formal_spec = '''overload_resolution_succeeds(f, context) && !accessible(f, context) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.general"
source_module = "[over.match.general]/3"
tags = ['overload-resolution', 'accessibility', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_funcs_single_user_conversion_c7d9e3f4"
content = '''Only one user-defined conversion is allowed in an implicit conversion sequence (except in list-initialization).'''
formal_spec = '''implicit_conversion_sequence(expr, target_type) && !is_list_initialization(context) => user_defined_conversion_count(sequence) <= 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/6"
tags = ['overload-resolution', 'user-defined-conversion', 'implicit-conversion']

[[axioms]]
id = "cpp20_over_match_funcs_deleted_move_excluded_b2c4a6d8"
content = '''A defaulted move special member function that is defined as deleted is excluded from the set of candidate functions in all contexts.'''
formal_spec = '''is_move_special_member(f) && is_defaulted(f) && is_defined_as_deleted(f) => excluded_from_candidates(f)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/9"
tags = ['overload-resolution', 'move-constructor', 'move-assignment', 'deleted-function']

[[axioms]]
id = "cpp20_over_match_funcs_inherited_ctor_excluded_f1e2d3c4"
content = '''A constructor inherited from class C with first parameter of type reference to P is excluded when constructing object of type D if argument list has exactly one argument and C is reference-related to P and P is reference-related to D.'''
formal_spec = '''inherited_constructor(ctor, C) && first_param_type(ctor) == reference_to(cv1, P) && constructing_type(D) && argument_count == 1 && reference_related(C, P) && reference_related(P, D) => excluded_from_candidates(ctor)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/9"
tags = ['overload-resolution', 'inherited-constructor', 'candidate-exclusion']

[[axioms]]
id = "cpp20_over_match_call_general_member_from_address_illformed_a5b6c7d8"
content = '''If the postfix-expression is the address of an overload set and the function selected by overload resolution is an implicit object member function, the program is ill-formed.'''
formal_spec = '''is_address_of_overload_set(postfix_expr) && overload_resolution_selects(f) && is_implicit_object_member_function(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.call.general"
source_module = "[over.match.call.general]/2"
tags = ['overload-resolution', 'function-call', 'member-function', 'ill-formed']

[[axioms]]
id = "cpp20_over_call_func_precondition_assertion_illformed_d8e9f0a1"
content = '''In an unqualified function call appearing in a precondition assertion of a constructor or postcondition assertion of a destructor, if overload resolution selects a non-static member function, the call is ill-formed.'''
formal_spec = '''unqualified_function_call(call) && (in_constructor_precondition(call) || in_destructor_postcondition(call)) && overload_resolution_selects(f) && is_non_static_member_function(f) && uses_implied_this(call) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.call.func"
source_module = "[over.call.func]/3"
tags = ['overload-resolution', 'precondition', 'postcondition', 'constructor', 'destructor', 'ill-formed']

[[axioms]]
id = "cpp20_over_call_func_contrived_object_nonstatic_illformed_b1c2d3e4"
content = '''In an unqualified function call where a contrived object becomes the implied object argument, if overload resolution selects a non-static member function, the call is ill-formed.'''
formal_spec = '''unqualified_function_call(call) && uses_contrived_object(call) && overload_resolution_selects(f) && is_non_static_member_function(f) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.call.func"
source_module = "[over.call.func]/3"
tags = ['overload-resolution', 'function-call', 'contrived-object', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_oper_no_class_enum_builtin_f5a6b7c8"
content = '''If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator.'''
formal_spec = '''operator_expression(op, operands) && forall(o in operands, !is_class_type(type(o)) && !is_enum_type(type(o))) => is_builtin_operator(op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/1"
tags = ['overload-resolution', 'operators', 'built-in-operator']

[[axioms]]
id = "cpp20_over_match_oper_rewritten_eq_bool_return_c9d0e1f2"
content = '''If a rewritten operator== candidate is selected by overload resolution for an operator @, its return type shall be cv bool.'''
formal_spec = '''rewritten_operator_eq_selected(f, op) => is_cv_bool(return_type(f))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/10"
tags = ['overload-resolution', 'operators', 'rewritten-candidate', 'equality-operator']

[[axioms]]
id = "cpp20_over_match_ctor_explicit_default_init_copy_list_illformed_a2b3c4d5"
content = '''For default-initialization in the context of copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.'''
formal_spec = '''default_initialization(context) && copy_list_initialization(context) && overload_resolution_selects(ctor) && is_explicit(ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.ctor"
source_module = "[over.match.ctor]/1"
tags = ['overload-resolution', 'constructor', 'explicit', 'list-initialization', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_list_explicit_copy_list_init_illformed_e6f7a8b9"
content = '''In copy-list-initialization, if an explicit constructor is chosen by overload resolution, the initialization is ill-formed.'''
formal_spec = '''copy_list_initialization(context) && overload_resolution_selects(ctor) && is_explicit(ctor) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.list"
source_module = "[over.match.list]/1"
tags = ['overload-resolution', 'list-initialization', 'explicit-constructor', 'ill-formed']

[[axioms]]
id = "cpp20_over_match_oper_assignment_standard_conv_only_c0d1e2f3"
content = '''For the first parameter of built-in assignment operators, only standard conversion sequences are considered (no user-defined conversions).'''
formal_spec = '''builtin_assignment_operator(op) && implicit_conversion_to_first_param(conv) => is_standard_conversion_sequence(conv)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/5"
tags = ['overload-resolution', 'assignment-operator', 'standard-conversion']

[[axioms]]
id = "cpp20_over_match_oper_builtin_no_second_user_defined_g4h5i6j7"
content = '''If a built-in candidate is selected by overload resolution, the second standard conversion sequence of a user-defined conversion sequence is not applied when converting operands of class type.'''
formal_spec = '''builtin_candidate_selected(op) && operand_of_class_type(operand) && user_defined_conversion_sequence(seq, operand) => skip_second_standard_conversion(seq)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "over.match.oper"
source_module = "[over.match.oper]/11"
tags = ['overload-resolution', 'built-in-operator', 'conversion-sequence']

[[axioms]]
id = "cpp20_over_match_funcs_no_user_conv_implicit_object_param_k8l9m0n1"
content = '''No user-defined conversions can be applied to achieve a type match with the implicit object parameter.'''
formal_spec = '''implicit_object_parameter(param) && conversion_to_match(conv, arg, param) => !is_user_defined_conversion(conv)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.funcs.general"
source_module = "[over.match.funcs.general]/5"
tags = ['overload-resolution', 'implicit-object-parameter', 'user-defined-conversion']

[[axioms]]
id = "cpp20_over_match_oper_nonmember_empty_for_assign_subscript_arrow_o2p3q4r5"
content = '''For the operators =, [], or ->, the set of non-member candidates is empty.'''
formal_spec = '''(operator_name(op) == "=" || operator_name(op) == "[]" || operator_name(op) == "->") => non_member_candidates(op) == empty_set'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/3.2"
tags = ['overload-resolution', 'operators', 'non-member-candidates']

[[axioms]]
id = "cpp20_over_match_oper_builtin_empty_for_comma_addr_arrow_s6t7u8v9"
content = '''For the operator comma, the unary operator &, or the operator ->, the built-in candidates set is empty.'''
formal_spec = '''(operator_name(op) == "," || (operator_name(op) == "&" && is_unary(op)) || operator_name(op) == "->") => builtin_candidates(op) == empty_set'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/3.3"
tags = ['overload-resolution', 'operators', 'built-in-candidates']

[[axioms]]
id = "cpp20_over_match_oper_arrow_second_operand_ignored_w0x1y2z3"
content = '''The second operand of operator-> is ignored in selecting an operator-> function, and is not an argument when the operator-> function is called.'''
formal_spec = '''operator_arrow_call(expr) => !includes_second_operand_in_resolution(expr) && !includes_second_operand_in_call(expr)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/12"
tags = ['overload-resolution', 'operators', 'arrow-operator']

[[axioms]]
id = "cpp20_over_match_oper_fallback_builtin_no_viable_a4b5c6d7"
content = '''If the operator is comma, unary &, or ->, and there are no viable functions, then the operator is assumed to be the built-in operator.'''
formal_spec = '''(operator_name(op) == "," || (operator_name(op) == "&" && is_unary(op)) || operator_name(op) == "->") && no_viable_functions(candidates) => use_builtin_operator(op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.match.oper"
source_module = "[over.match.oper]/13"
tags = ['overload-resolution', 'operators', 'built-in-operator', 'fallback']

[[axioms]]
id = "cpp20_over_match_class_deduct_no_aggregate_element_e8f9a0b1"
content = '''If there is no aggregate element for any initializer element when forming the aggregate deduction candidate, the aggregate deduction candidate is not added to the set.'''
formal_spec = '''forming_aggregate_deduction_candidate(C, init_list) && exists(xi in init_list, !has_corresponding_aggregate_element(C, xi)) => !add_aggregate_deduction_candidate(C)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "over.match.class.deduct"
source_module = "[over.match.class.deduct]/1"
tags = ['overload-resolution', 'class-template-argument-deduction', 'aggregate']

[[axioms]]
id = "cpp20_over_oper_general_class_enum_param_a7b3c2d1"
content = '''An operator function shall have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.'''
formal_spec = '''operator_function(F) => exists(P in parameters(F) union {implicit_object_param(F)}, is_class(type(P)) || is_class_ref(type(P)) || is_enum(type(P)) || is_enum_ref(type(P)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/7"
tags = ['overloading', 'operator', 'constraint']

[[axioms]]
id = "cpp20_over_oper_general_valid_form_e4f5a6b8"
content = '''An operator function shall be a prefix unary, binary, function call, subscripting, class member access, increment, or decrement operator function.'''
formal_spec = '''operator_function(F) => is_prefix_unary(F) || is_binary(F) || is_function_call(F) || is_subscripting(F) || is_class_member_access(F) || is_increment(F) || is_decrement(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/8"
tags = ['overloading', 'operator', 'constraint']

[[axioms]]
id = "cpp20_over_oper_general_no_default_args_c9d8e7f6"
content = '''An operator function cannot have default arguments, except where explicitly stated below (function call and subscripting operators).'''
formal_spec = '''operator_function(F) && !is_function_call_operator(F) && !is_subscripting_operator(F) => !has_default_arguments(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/10"
tags = ['overloading', 'operator', 'default-arguments', 'constraint']

[[axioms]]
id = "cpp20_over_oper_general_param_count_b2a1c3d4"
content = '''Operator functions cannot have more or fewer parameters than the number required for the corresponding operator.'''
formal_spec = '''operator_function(F, Op) => param_count(F) == required_param_count(Op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/10"
tags = ['overloading', 'operator', 'constraint']

[[axioms]]
id = "cpp20_over_unary_member_no_params_f1e2d3c4"
content = '''A prefix unary operator function that is a non-static member function shall have no non-object parameters.'''
formal_spec = '''prefix_unary_operator_function(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.unary"
source_module = "[over.unary]/1"
tags = ['overloading', 'operator', 'unary', 'constraint']

[[axioms]]
id = "cpp20_over_unary_nonmember_one_param_a5b6c7d8"
content = '''A prefix unary operator function that is a non-member function shall have one parameter.'''
formal_spec = '''prefix_unary_operator_function(F) && is_non_member_function(F) => param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.unary"
source_module = "[over.unary]/1"
tags = ['overloading', 'operator', 'unary', 'constraint']

[[axioms]]
id = "cpp20_over_binary_member_one_param_d4e5f6a7"
content = '''A binary operator function that is a non-static member function shall have one non-object parameter.'''
formal_spec = '''binary_operator_function(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.binary.general"
source_module = "[over.binary.general]/1"
tags = ['overloading', 'operator', 'binary', 'constraint']

[[axioms]]
id = "cpp20_over_binary_nonmember_two_params_b8c9d0e1"
content = '''A binary operator function that is a non-member function shall have two parameters.'''
formal_spec = '''binary_operator_function(F) && is_non_member_function(F) => param_count(F) == 2'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.binary.general"
source_module = "[over.binary.general]/1"
tags = ['overloading', 'operator', 'binary', 'constraint']

[[axioms]]
id = "cpp20_over_assign_member_only_c2d3e4f5"
content = '''A simple assignment operator function shall be a non-static member function.'''
formal_spec = '''simple_assignment_operator_function(F) => is_member_function(F) && !is_static(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.assign"
source_module = "[over.assign]/1"
tags = ['overloading', 'operator', 'assignment', 'constraint']

[[axioms]]
id = "cpp20_over_call_member_only_a1b2c3d4"
content = '''A function call operator function shall be a member function.'''
formal_spec = '''function_call_operator_function(F) => is_member_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.call"
source_module = "[over.call]/1"
tags = ['overloading', 'operator', 'function-call', 'constraint']

[[axioms]]
id = "cpp20_over_sub_member_only_e5f6a7b8"
content = '''A subscripting operator function shall be a member function.'''
formal_spec = '''subscripting_operator_function(F) => is_member_function(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.sub"
source_module = "[over.sub]/1"
tags = ['overloading', 'operator', 'subscript', 'constraint']

[[axioms]]
id = "cpp20_over_ref_member_no_params_c9d0e1f2"
content = '''A class member access operator function shall be a non-static member function taking no non-object parameters.'''
formal_spec = '''class_member_access_operator_function(F) => is_member_function(F) && !is_static(F) && non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.ref"
source_module = "[over.ref]/1"
tags = ['overloading', 'operator', 'member-access', 'constraint']

[[axioms]]
id = "cpp20_over_inc_prefix_member_form_a3b4c5d6"
content = '''A prefix increment operator function that is a non-static member function shall have no non-object parameters.'''
formal_spec = '''increment_operator_function(F) && is_prefix_increment(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_inc_prefix_nonmember_form_d7e8f9a0"
content = '''A prefix increment operator function that is a non-member function shall have one parameter.'''
formal_spec = '''increment_operator_function(F) && is_prefix_increment(F) && is_non_member_function(F) => param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_inc_postfix_member_int_param_b1c2d3e4"
content = '''A postfix increment operator function that is a non-static member function shall have one non-object parameter of type int.'''
formal_spec = '''increment_operator_function(F) && is_postfix_increment(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 1 && type(non_object_param(F, 0)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_inc_postfix_nonmember_int_param_f5a6b7c8"
content = '''A postfix increment operator function that is a non-member function shall have two parameters, the second of which shall be of type int.'''
formal_spec = '''increment_operator_function(F) && is_postfix_increment(F) && is_non_member_function(F) => param_count(F) == 2 && type(param(F, 1)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/1"
tags = ['overloading', 'operator', 'increment', 'constraint']

[[axioms]]
id = "cpp20_over_dec_prefix_member_form_d9e0f1a2"
content = '''A prefix decrement operator function that is a non-static member function shall have no non-object parameters.'''
formal_spec = '''decrement_operator_function(F) && is_prefix_decrement(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 0'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_dec_prefix_nonmember_form_b3c4d5e6"
content = '''A prefix decrement operator function that is a non-member function shall have one parameter.'''
formal_spec = '''decrement_operator_function(F) && is_prefix_decrement(F) && is_non_member_function(F) => param_count(F) == 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_dec_postfix_member_int_param_f7a8b9c0"
content = '''A postfix decrement operator function that is a non-static member function shall have one non-object parameter of type int.'''
formal_spec = '''decrement_operator_function(F) && is_postfix_decrement(F) && is_member_function(F) && !is_static(F) => non_object_param_count(F) == 1 && type(non_object_param(F, 0)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_dec_postfix_nonmember_int_param_d1e2f3a4"
content = '''A postfix decrement operator function that is a non-member function shall have two parameters, the second of which shall be of type int.'''
formal_spec = '''decrement_operator_function(F) && is_postfix_decrement(F) && is_non_member_function(F) => param_count(F) == 2 && type(param(F, 1)) == int'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.inc"
source_module = "[over.inc]/2"
tags = ['overloading', 'operator', 'decrement', 'constraint']

[[axioms]]
id = "cpp20_over_oper_declarator_function_b5c6d7e8"
content = '''A declaration whose declarator-id is an operator-function-id shall declare a function or function template or an explicit instantiation or specialization of a function template.'''
formal_spec = '''declarator_id_is_operator_function_id(D) => declares_function(D) || declares_function_template(D) || declares_explicit_instantiation(D) || declares_specialization(D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "over.oper.general"
source_module = "[over.oper.general]/1"
tags = ['overloading', 'operator', 'declaration', 'constraint']

[[axioms]]
id = "cpp20_temp_deduct_general_all_args_required_a3b7c9d1"
content = '''When a function template specialization is referenced, all of the template arguments shall have values (explicitly specified, deduced, or from defaults).'''
formal_spec = '''function_template_specialization_referenced(F) => forall(P in template_parameters(F), has_value(P))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/1"
tags = ['template', 'deduction', 'specialization']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_template_id_e4f8a2b6"
content = '''When an explicit template argument list is specified, if the given template-id or splice-specialization-specifier is not valid, type deduction fails.'''
formal_spec = '''explicit_template_arg_list(F, Args) && !valid_template_id(F, Args) => deduction_fails(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/2"
tags = ['template', 'deduction', 'template-id']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_subst_default_c7d2e5f9"
content = '''If substitution of deduced template arguments into a default argument results in an invalid type, type deduction fails.'''
formal_spec = '''substitute(default_arg(P), deduced_args) => invalid_type => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'default-argument', 'substitution']

[[axioms]]
id = "cpp20_temp_deduct_general_constraints_not_satisfied_b1c4d7e0"
content = '''If the function template has associated constraints and those constraints are not satisfied after template argument deduction, type deduction fails.'''
formal_spec = '''has_constraints(F) && !constraints_satisfied(F, deduced_args) => deduction_fails(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'constraints', 'concepts']

[[axioms]]
id = "cpp20_temp_deduct_general_no_implicit_conversion_f9a3b5c8"
content = '''In a function call context, if a non-dependent function parameter cannot receive an implicit conversion from its corresponding argument after explicit template argument substitution, type deduction fails.'''
formal_spec = '''function_call_context && non_dependent_param(P) && !implicit_convertible(arg_type(A), param_type(P)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'conversion', 'function-call']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_final_subst_d2e6f8a1"
content = '''If substitution of deduced or default argument values into the function type results in an invalid type, type deduction fails.'''
formal_spec = '''substitute(function_type(F), all_args) => invalid_type => deduction_fails(F)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/5"
tags = ['template', 'deduction', 'substitution']

[[axioms]]
id = "cpp20_temp_deduct_general_different_instantiation_order_ndr_c5d8e2f4"
content = '''If substitution into different declarations of the same function template would cause template instantiations to occur in a different order or not at all, the program is ill-formed; no diagnostic required.'''
formal_spec = '''same_function_template(decl1, decl2) && different_instantiation_order(substitute(decl1), substitute(decl2)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/7"
tags = ['template', 'deduction', 'substitution', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_type_expr_fails_a8b1c3d5"
content = '''If a substitution results in an invalid type or expression, type deduction fails.'''
formal_spec = '''substitution(expr_or_type, args) => invalid => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/8"
tags = ['template', 'deduction', 'SFINAE', 'substitution']

[[axioms]]
id = "cpp20_temp_deduct_general_immediate_context_only_e7f9a2b4"
content = '''Invalid types and expressions can result in a deduction failure only in the immediate context of the deduction substitution loci; effects outside the immediate context can result in the program being ill-formed.'''
formal_spec = '''invalid_in_immediate_context(substitution) => deduction_fails; invalid_outside_immediate_context(substitution) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/8"
tags = ['template', 'deduction', 'SFINAE', 'immediate-context']

[[axioms]]
id = "cpp20_temp_deduct_general_lambda_body_not_immediate_d4e6f8a0"
content = '''When substituting into a lambda-expression, substitution into its body is not in the immediate context, so failures in the lambda body cause ill-formed programs rather than deduction failure.'''
formal_spec = '''lambda_expression(L) && substitution_into_body(L) => !immediate_context'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/9"
tags = ['template', 'deduction', 'lambda', 'immediate-context']

[[axioms]]
id = "cpp20_temp_deduct_general_pack_different_lengths_b2c4d6e8"
content = '''Attempting to instantiate a pack expansion containing multiple packs of differing lengths causes type deduction to fail.'''
formal_spec = '''pack_expansion(packs) && exists(p1, p2 in packs, length(p1) != length(p2)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.1"
tags = ['template', 'deduction', 'parameter-pack']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_array_type_a1b3c5d7"
content = '''Attempting to create an array with element type void, function type, or reference type, or with size zero or negative, causes type deduction to fail.'''
formal_spec = '''array_type(element, size) && (element == void || is_function_type(element) || is_reference_type(element) || size <= 0) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.2"
tags = ['template', 'deduction', 'array']

[[axioms]]
id = "cpp20_temp_deduct_general_qualified_name_non_class_c3d5e7f9"
content = '''Attempting to use a type that is not a class or enumeration type in a qualified name causes type deduction to fail.'''
formal_spec = '''qualified_name(T::member) && !is_class_or_enum(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.3"
tags = ['template', 'deduction', 'qualified-name']

[[axioms]]
id = "cpp20_temp_deduct_general_missing_member_e5f7a9b1"
content = '''Attempting to use a type in a nested-name-specifier when that type does not contain the specified member causes type deduction to fail.'''
formal_spec = '''nested_name_specifier(T::member) && !has_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_member_not_type_f7a9b1c3"
content = '''Attempting to use a member as a type when the specified member is not a type causes type deduction to fail.'''
formal_spec = '''type_context(T::member) && !is_type_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4.1"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_member_not_template_a9b1c3d5"
content = '''Attempting to use a member as a template when the specified member is not a template causes type deduction to fail.'''
formal_spec = '''template_context(T::member) && !is_template_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4.2"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_member_not_nontype_b1c3d5e7"
content = '''Attempting to use a member as a non-type, non-template when the specified member is not a non-type, non-template causes type deduction to fail.'''
formal_spec = '''nontype_context(T::member) && !is_nontype_nontemplate_member(T, member) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.4.3"
tags = ['template', 'deduction', 'member-access']

[[axioms]]
id = "cpp20_temp_deduct_general_pointer_to_reference_c3d5e7f9"
content = '''Attempting to create a pointer to reference type causes type deduction to fail.'''
formal_spec = '''pointer_type(T) && is_reference_type(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.5"
tags = ['template', 'deduction', 'pointer', 'reference']

[[axioms]]
id = "cpp20_temp_deduct_general_reference_to_void_d5e7f9a1"
content = '''Attempting to create a reference to void causes type deduction to fail.'''
formal_spec = '''reference_type(void) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.6"
tags = ['template', 'deduction', 'reference', 'void']

[[axioms]]
id = "cpp20_temp_deduct_general_ptr_to_member_non_class_e7f9a1b3"
content = '''Attempting to create "pointer to member of T" when T is not a class type causes type deduction to fail.'''
formal_spec = '''pointer_to_member_type(T, M) && !is_class_type(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.7"
tags = ['template', 'deduction', 'pointer-to-member']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_nontype_arg_f9a1b3c5"
content = '''Attempting to give an invalid type to a constant template parameter causes type deduction to fail.'''
formal_spec = '''constant_template_param(P, T) && !valid_nontype_param_type(T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.8"
tags = ['template', 'deduction', 'nontype-parameter']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_conversion_a1b3c5d7"
content = '''Attempting to perform an invalid conversion in either a template argument expression or an expression used in the function declaration causes type deduction to fail.'''
formal_spec = '''(template_arg_expr(E) || function_decl_expr(E)) && !valid_conversion(E) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.9"
tags = ['template', 'deduction', 'conversion']

[[axioms]]
id = "cpp20_temp_deduct_general_invalid_function_type_b3c5d7e9"
content = '''Attempting to create a function type in which a parameter has type void, or in which the return type is a function type or array type, causes type deduction to fail.'''
formal_spec = '''function_type(params, ret) && (void in params || is_function_type(ret) || is_array_type(ret)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.10"
tags = ['template', 'deduction', 'function-type']

[[axioms]]
id = "cpp20_temp_deduct_general_lambda_explicit_object_c5d7e9f1"
content = '''Attempting to give to an explicit object parameter of a lambda's function call operator a type not permitted for such causes type deduction to fail.'''
formal_spec = '''lambda_explicit_object_param(L, P, T) && !permitted_explicit_object_type(L, T) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.general"
source_module = "[temp.deduct.general]/11.11"
tags = ['template', 'deduction', 'lambda', 'explicit-object']

[[axioms]]
id = "cpp20_temp_deduct_call_init_list_different_types_d7e9f1a3"
content = '''If deduction from initializer list elements leads to different deduced types for the same template parameter, type deduction fails.'''
formal_spec = '''initializer_list(elements) && deduced_types(T, elements) && !all_same(deduced_types) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/1"
tags = ['template', 'deduction', 'initializer-list']

[[axioms]]
id = "cpp20_temp_deduct_call_pack_non_deduced_e9f1a3b5"
content = '''When a function parameter pack appears in a non-deduced context, the type of that pack is never deduced.'''
formal_spec = '''function_parameter_pack(P) && non_deduced_context(P) => !deducible(P)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/1"
tags = ['template', 'deduction', 'parameter-pack', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_call_multiple_deduced_fails_f1a3b5c7"
content = '''If alternatives to make deduced A compatible with A yield more than one possible deduced A, the type deduction fails.'''
formal_spec = '''deduction_alternatives(A) && count(deduction_alternatives) > 1 => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/5"
tags = ['template', 'deduction', 'ambiguity']

[[axioms]]
id = "cpp20_temp_deduct_call_overload_set_template_a3b5c7d9"
content = '''When P is a function type and the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.'''
formal_spec = '''is_function_type(P) && overload_set_contains_template(A) => non_deduced_context(P)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/6.1"
tags = ['template', 'deduction', 'overload-set', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_call_overload_different_types_b5c7d9e1"
content = '''If an overload set argument (not containing function templates) yields different deduced A values from trial deductions, the parameter is treated as a non-deduced context.'''
formal_spec = '''overload_set(A) && !contains_template(A) && !all_same(trial_deductions(A)) => non_deduced_context'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.call"
source_module = "[temp.deduct.call]/6.2"
tags = ['template', 'deduction', 'overload-set', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_funcaddr_placeholder_non_deduced_c7d9e1f3"
content = '''A placeholder type in the return type of a function template is a non-deduced context when taking the address of a function template.'''
formal_spec = '''taking_address_of_function_template(F) && placeholder_type(return_type(F)) => non_deduced_context(return_type(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.funcaddr"
source_module = "[temp.deduct.funcaddr]/2"
tags = ['template', 'deduction', 'auto', 'function-address']

[[axioms]]
id = "cpp20_temp_deduct_conv_multiple_deduced_fails_d9e1f3a5"
content = '''If ignoring certain attributes of A allows more than one possible deduced A in conversion function template argument deduction, the type deduction fails.'''
formal_spec = '''conversion_template_deduction && count(possible_deduced_A) > 1 => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.conv"
source_module = "[temp.deduct.conv]/5"
tags = ['template', 'deduction', 'conversion-function']

[[axioms]]
id = "cpp20_temp_deduct_type_inconsistent_deduction_e1f3a5b7"
content = '''If type deduction for any P/A pair leads to more than one possible set of deduced values, or if different pairs yield different deduced values for the same parameter, template argument deduction fails.'''
formal_spec = '''(exists(pair, count(deduced_values(pair)) > 1) || exists(p1, p2, deduced(p1, T) != deduced(p2, T))) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/2"
tags = ['template', 'deduction', 'consistency']

[[axioms]]
id = "cpp20_temp_deduct_type_undeduced_unspecified_f3a5b7c9"
content = '''If any template argument remains neither deduced nor explicitly specified, template argument deduction fails.'''
formal_spec = '''exists(P in template_params, !deduced(P) && !explicitly_specified(P) && !has_default(P)) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/2"
tags = ['template', 'deduction']

[[axioms]]
id = "cpp20_temp_deduct_type_non_deduced_not_specified_a5b7c9d1"
content = '''If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails.'''
formal_spec = '''only_in_non_deduced_context(P) && !explicitly_specified(P) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/4"
tags = ['template', 'deduction', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_type_pack_expansion_not_last_b7c9d1e3"
content = '''If the template argument list of P contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context.'''
formal_spec = '''template_arg_list(P, args) && pack_expansion_in(args) && !is_last(pack_expansion, args) => non_deduced_context(args)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/9"
tags = ['template', 'deduction', 'parameter-pack', 'non-deduced-context']

[[axioms]]
id = "cpp20_temp_deduct_type_partial_order_pack_mismatch_c9d1e3f5"
content = '''During partial ordering, if Ai was originally a pack expansion and Pi is not a pack expansion, template argument deduction fails.'''
formal_spec = '''partial_ordering && was_pack_expansion(Ai) && !is_pack_expansion(Pi) && has_corresponding(P, Ai) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/9.2"
tags = ['template', 'deduction', 'partial-ordering', 'parameter-pack']

[[axioms]]
id = "cpp20_temp_deduct_type_func_param_pack_mismatch_d1e3f5a7"
content = '''During partial ordering, if Ai was originally a function parameter pack and Pi is not a function parameter pack, template argument deduction fails.'''
formal_spec = '''partial_ordering && was_function_param_pack(Ai) && !is_function_param_pack(Pi) && has_corresponding(P, Ai) => deduction_fails'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.deduct.type"
source_module = "[temp.deduct.type]/10.2"
tags = ['template', 'deduction', 'partial-ordering', 'function-parameter-pack']

[[axioms]]
id = "cpp20_temp_deduct_partial_unused_param_ok_e3f5a7b9"
content = '''For partial ordering purposes, a template parameter may remain without a value provided it is not used in the types being used for partial ordering.'''
formal_spec = '''partial_ordering && !used_in_ordering_types(P) => !required_to_have_value(P)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.deduct.partial"
source_module = "[temp.deduct.partial]/12"
tags = ['template', 'deduction', 'partial-ordering']

[[axioms]]
id = "cpp20_temp_spec_general_one_explicit_inst_def_a3b7c9d1"
content = '''An explicit instantiation definition shall appear at most once in a program for a given template and a given set of template-arguments.'''
formal_spec = '''forall(template T, template_args Args) => count(explicit_instantiation_definition(T, Args)) <= 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/5.1"
tags = ['template', 'instantiation', 'odr']

[[axioms]]
id = "cpp20_temp_spec_general_one_explicit_spec_def_f2e8a4c6"
content = '''An explicit specialization shall be defined at most once in a program, as specified in the one-definition rule.'''
formal_spec = '''forall(template T, template_args Args) => count(explicit_specialization_definition(T, Args)) <= 1'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/5.2"
tags = ['template', 'specialization', 'odr']

[[axioms]]
id = "cpp20_temp_spec_general_explicit_inst_spec_reachable_c7d3e5f9"
content = '''Both an explicit instantiation and a declaration of an explicit specialization shall not appear in a program unless the explicit specialization is reachable from the explicit instantiation.'''
formal_spec = '''forall(template T, template_args Args) => (explicit_instantiation(T, Args) && explicit_specialization_decl(T, Args)) => reachable_from(explicit_specialization(T, Args), explicit_instantiation(T, Args))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/5.3"
tags = ['template', 'instantiation', 'specialization', 'reachability']

[[axioms]]
id = "cpp20_temp_spec_general_illformed_dependent_type_func_8a1b2c3d"
content = '''If a function declaration acquired its function type through a dependent type without using the syntactic form of a function declarator, the program is ill-formed.'''
formal_spec = '''function_decl(D) && acquired_type_through_dependent_type(D) && !uses_function_declarator_syntax(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.spec.general"
source_module = "[temp.spec.general]/8"
tags = ['template', 'function', 'dependent-type', 'ill-formed']

[[axioms]]
id = "cpp20_temp_inst_incomplete_class_undeclared_template_e4f5a6b7"
content = '''If the template selected for the specialization has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type.'''
formal_spec = '''template_selected(T) && declared(T) && !defined(T, point_of_instantiation) => incomplete_type(instantiation(T))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.inst"
source_module = "[temp.inst]/2"
tags = ['template', 'instantiation', 'incomplete-type']

[[axioms]]
id = "cpp20_temp_inst_infinite_recursion_undefined_d8c9e0f1"
content = '''The result of an infinite recursion in instantiation is undefined.'''
formal_spec = '''infinite_recursion(template_instantiation) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.inst"
source_module = "[temp.inst]/16"
tags = ['template', 'instantiation', 'recursion', 'undefined-behavior']

[[axioms]]
id = "cpp20_temp_inst_impl_limit_recursive_depth_a2b3c4d5"
content = '''There is an implementation-defined quantity that specifies the limit on the total depth of recursive instantiations.'''
formal_spec = '''exists(impl_defined_limit(recursive_instantiation_depth))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.inst"
source_module = "[temp.inst]/16"
tags = ['template', 'instantiation', 'implementation-defined', 'recursion']

[[axioms]]
id = "cpp20_temp_explicit_no_storage_class_except_thread_local_f6a7b8c9"
content = '''An explicit instantiation shall not use a storage-class-specifier other than thread_local.'''
formal_spec = '''explicit_instantiation(E) && has_storage_class(E, S) && S != thread_local => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/3"
tags = ['template', 'explicit-instantiation', 'storage-class', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_no_inline_constexpr_consteval_d0e1f2a3"
content = '''An explicit instantiation of a function template, member function of a class template, or variable template shall not use the inline, constexpr, or consteval specifiers.'''
formal_spec = '''explicit_instantiation(E) && (is_function_template(E) || is_member_function_of_class_template(E) || is_variable_template(E)) && (has_specifier(E, inline) || has_specifier(E, constexpr) || has_specifier(E, consteval)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/3"
tags = ['template', 'explicit-instantiation', 'inline', 'constexpr', 'consteval', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_no_attribute_specifier_b4c5d6e7"
content = '''No attribute-specifier-seq shall appertain to an explicit instantiation.'''
formal_spec = '''explicit_instantiation(E) && has_attribute_specifier_seq(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/3"
tags = ['template', 'explicit-instantiation', 'attributes', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_decl_reachable_function_template_8a9b0c1d"
content = '''A declaration of a function template, variable template, member function or static data member of a class template, or a member function template of a class or class template shall be reachable from any explicit instantiation of that entity.'''
formal_spec = '''explicit_instantiation(E) && (is_function_template(E) || is_variable_template(E) || is_member_function_of_class_template(E) || is_static_data_member_of_class_template(E) || is_member_function_template(E)) => reachable(declaration(E), explicit_instantiation(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/5"
tags = ['template', 'explicit-instantiation', 'reachability']

[[axioms]]
id = "cpp20_temp_explicit_def_reachable_class_template_2e3f4a5b"
content = '''A definition of a class template, a member class of a class template, or a member class template of a class or class template shall be reachable from any explicit instantiation of that entity unless an explicit specialization of the entity with the same template arguments is reachable therefrom.'''
formal_spec = '''explicit_instantiation(E) && (is_class_template(E) || is_member_class_of_class_template(E) || is_member_class_template(E)) && !reachable(explicit_specialization(E, same_args), explicit_instantiation(E)) => reachable(definition(E), explicit_instantiation(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/5"
tags = ['template', 'explicit-instantiation', 'reachability', 'class-template']

[[axioms]]
id = "cpp20_temp_explicit_implicit_special_member_illformed_c6d7e8f9"
content = '''If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.'''
formal_spec = '''explicit_instantiation(E) && names_implicitly_declared_special_member(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/5"
tags = ['template', 'explicit-instantiation', 'special-member-function', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_def_required_present_0a1b2c3d"
content = '''For an explicit instantiation definition, the definition of a function template, a variable template, a member function template, or a member function or static data member of a class template shall be present in every translation unit in which it is explicitly instantiated.'''
formal_spec = '''explicit_instantiation_definition(E) && (is_function_template(E) || is_variable_template(E) || is_member_function_template(E) || is_member_function_of_class_template(E) || is_static_data_member_of_class_template(E)) => definition_present_in_tu(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/7"
tags = ['template', 'explicit-instantiation', 'definition']

[[axioms]]
id = "cpp20_temp_explicit_prospective_destructor_selected_4e5f6a7b"
content = '''An explicit instantiation of a prospective destructor shall correspond to the selected destructor of the class.'''
formal_spec = '''explicit_instantiation(E) && is_prospective_destructor(E) => corresponds_to_selected_destructor(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/11"
tags = ['template', 'explicit-instantiation', 'destructor']

[[axioms]]
id = "cpp20_temp_explicit_def_follows_decl_same_tu_8c9d0e1f"
content = '''If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation definition in the same translation unit, the definition shall follow the declaration.'''
formal_spec = '''explicit_instantiation_declaration(E, TU) && explicit_instantiation_definition(E, TU) => follows(definition(E), declaration(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/12"
tags = ['template', 'explicit-instantiation', 'declaration', 'definition']

[[axioms]]
id = "cpp20_temp_explicit_used_requires_def_somewhere_ndr_2a3b4c5d"
content = '''An entity that is the subject of an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit instantiation in the translation unit shall be the subject of an explicit instantiation definition somewhere in the program; otherwise the program is ill-formed, no diagnostic required.'''
formal_spec = '''explicit_instantiation_declaration(E) && used_requiring_implicit_instantiation(E) && !exists(explicit_instantiation_definition(E)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/12"
tags = ['template', 'explicit-instantiation', 'ndr', 'ill-formed']

[[axioms]]
id = "cpp20_temp_explicit_no_internal_linkage_6e7f8a9b"
content = '''An explicit instantiation declaration shall not name a specialization of a template with internal linkage.'''
formal_spec = '''explicit_instantiation_declaration(E) && has_internal_linkage(template_of(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.explicit"
source_module = "[temp.explicit]/12"
tags = ['template', 'explicit-instantiation', 'linkage', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_export_declaration_0c1d2e3f"
content = '''The declaration in an explicit-specialization shall not be an export-declaration.'''
formal_spec = '''explicit_specialization(E) && is_export_declaration(declaration_of(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/2"
tags = ['template', 'explicit-specialization', 'export', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_storage_class_except_thread_local_4a5b6c7d"
content = '''An explicit specialization shall not use a storage-class-specifier other than thread_local.'''
formal_spec = '''explicit_specialization(E) && has_storage_class(E, S) && S != thread_local => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/2"
tags = ['template', 'explicit-specialization', 'storage-class', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_decl_reachable_8e9f0a1b"
content = '''A declaration of a function template, class template, or variable template being explicitly specialized shall be reachable from the declaration of the explicit specialization.'''
formal_spec = '''explicit_specialization(E) && (is_function_template(E) || is_class_template(E) || is_variable_template(E)) => reachable(primary_template_declaration(E), explicit_specialization_declaration(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/4"
tags = ['template', 'explicit-specialization', 'reachability']

[[axioms]]
id = "cpp20_temp_expl_spec_member_template_class_def_reachable_2c3d4e5f"
content = '''The definition of a class or class template shall be reachable from the declaration of an explicit specialization for a member template of the class or class template.'''
formal_spec = '''explicit_specialization(E) && is_member_template(E) && has_enclosing_class(E, C) => reachable(definition(C), explicit_specialization_declaration(E))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/4"
tags = ['template', 'explicit-specialization', 'member-template', 'reachability']

[[axioms]]
id = "cpp20_temp_expl_spec_implicit_special_member_illformed_6a7b8c9d"
content = '''If an explicit specialization for the member of a class template names an implicitly-declared special member function, the program is ill-formed.'''
formal_spec = '''explicit_specialization(E) && is_member_of_class_template(E) && names_implicitly_declared_special_member(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/5"
tags = ['template', 'explicit-specialization', 'special-member-function', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_member_def_reachable_0e1f2a3b"
content = '''The definition of the class template explicit specialization shall be reachable from the definition of any member of it.'''
formal_spec = '''explicit_specialization(E) && is_class_template_specialization(E) && has_member(E, M) && defined(M) => reachable(definition(E), definition(M))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/6"
tags = ['template', 'explicit-specialization', 'member', 'reachability']

[[axioms]]
id = "cpp20_temp_expl_spec_decl_reachable_from_use_ndr_4c5d6e7f"
content = '''If a template, a member template or a member of a class template is explicitly specialized, a declaration of that specialization shall be reachable from every use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required.'''
formal_spec = '''explicit_specialization(E) && use_requiring_implicit_instantiation(U, E) => reachable(explicit_specialization_declaration(E), U) || ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/7"
tags = ['template', 'explicit-specialization', 'reachability', 'ndr']

[[axioms]]
id = "cpp20_temp_expl_spec_no_def_used_or_virtual_ndr_8a9b0c1d"
content = '''If the program does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, the program is ill-formed, no diagnostic required.'''
formal_spec = '''explicit_specialization(E) && !defined(E) && (use_requiring_implicit_instantiation(E) || is_virtual_member_function(E)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/7"
tags = ['template', 'explicit-specialization', 'definition', 'virtual', 'ndr']

[[axioms]]
id = "cpp20_temp_expl_spec_enclosing_must_be_specialized_2e3f4a5b"
content = '''The declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well.'''
formal_spec = '''explicit_specialization(E) && is_class_member_template(E) && !explicitly_specialized(enclosing_class_templates(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/16"
tags = ['template', 'explicit-specialization', 'member-template', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_not_friend_declaration_6c7d8e9f"
content = '''An explicit specialization declaration shall not be a friend declaration.'''
formal_spec = '''explicit_specialization(E) && is_friend_declaration(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/18"
tags = ['template', 'explicit-specialization', 'friend', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_default_args_function_template_0a1b2c3d"
content = '''Default function arguments shall not be specified in a declaration or a definition for the explicit specialization of a function template.'''
formal_spec = '''explicit_specialization(E) && is_function_template(E) && has_default_arguments(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/19.1"
tags = ['template', 'explicit-specialization', 'default-arguments', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_default_args_member_func_template_4e5f6a7b"
content = '''Default function arguments shall not be specified in a declaration or a definition for the explicit specialization of a member function template.'''
formal_spec = '''explicit_specialization(E) && is_member_function_template(E) && has_default_arguments(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/19.2"
tags = ['template', 'explicit-specialization', 'default-arguments', 'ill-formed']

[[axioms]]
id = "cpp20_temp_expl_spec_no_default_args_member_func_implicit_8c9d0e1f"
content = '''Default function arguments shall not be specified in a declaration or a definition for the explicit specialization of a member function of a class template where the class template specialization to which the member function specialization belongs is implicitly instantiated.'''
formal_spec = '''explicit_specialization(E) && is_member_function_of_class_template(E) && implicitly_instantiated(class_template_specialization_of(E)) && has_default_arguments(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.expl.spec"
source_module = "[temp.expl.spec]/19.3"
tags = ['template', 'explicit-specialization', 'default-arguments', 'implicit-instantiation', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_incomplete_type_ill_formed_3a8f2b1c"
content = '''If the type of the exception object would be an incomplete type, the program is ill-formed.'''
formal_spec = '''throw_expr(E) && incomplete_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/3"
tags = ['exception', 'throw', 'incomplete-type', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_abstract_class_ill_formed_7c4e9d2a"
content = '''If the type of the exception object would be an abstract class type, the program is ill-formed.'''
formal_spec = '''throw_expr(E) && abstract_class_type(type(E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/3"
tags = ['exception', 'throw', 'abstract-class', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_ptr_incomplete_ill_formed_b5d1a8e3"
content = '''If the type of the exception object would be a pointer to an incomplete type other than cv void, the program is ill-formed.'''
formal_spec = '''throw_expr(E) && pointer_type(type(E)) && incomplete_type(pointee_type(type(E))) && !is_cv_void(pointee_type(type(E))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/3"
tags = ['exception', 'throw', 'pointer', 'incomplete-type', 'ill-formed']

[[axioms]]
id = "cpp20_except_throw_copy_init_well_formed_8f3c2d1e"
content = '''For exception object type T, copy-initialization of an object of type T from an lvalue of type const T in a context unrelated to T shall be well-formed.'''
formal_spec = '''throw_expr(E) && type(E) == T => copy_initializable(T, const_lvalue(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/5"
tags = ['exception', 'throw', 'copy-initialization', 'constraint']

[[axioms]]
id = "cpp20_except_throw_nested_exception_terminate_4e7a9c2f"
content = '''If the exception handling mechanism handling an uncaught exception directly invokes a function that exits via an exception, std::terminate is invoked.'''
formal_spec = '''handling_uncaught_exception() && direct_invocation(F) && exits_via_exception(F) => call_std_terminate()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/9"
tags = ['exception', 'terminate', 'nested-exception', 'undefined-behavior']

[[axioms]]
id = "cpp20_except_throw_destructor_unwind_terminate_6b2d8a1f"
content = '''If a destructor directly invoked by stack unwinding exits via an exception, std::terminate is invoked.'''
formal_spec = '''stack_unwinding() && destructor_invocation(D) && exits_via_exception(D) => call_std_terminate()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.throw"
source_module = "[except.throw]/9"
tags = ['exception', 'terminate', 'destructor', 'stack-unwinding']

[[axioms]]
id = "cpp20_except_throw_class_destructor_odr_used_2c5f8e4a"
content = '''If the exception object type T is a class type, the destructor of T is potentially invoked.'''
formal_spec = '''throw_expr(E) && class_type(type(E)) => potentially_invoked(destructor(type(E)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "except.throw"
source_module = "[except.throw]/5"
tags = ['exception', 'throw', 'destructor', 'odr-use']

[[axioms]]
id = "cpp20_except_throw_class_ctor_odr_used_9d3b7f2c"
content = '''If the exception object type T is a class type, the selected constructor for copy-initialization is odr-used.'''
formal_spec = '''throw_expr(E) && class_type(type(E)) => odr_used(selected_copy_constructor(type(E)))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "except.throw"
source_module = "[except.throw]/5"
tags = ['exception', 'throw', 'constructor', 'odr-use']

[[axioms]]
id = "cpp20_except_ctor_auto_destroy_reverse_order_7a3b2c1d"
content = '''During stack unwinding, objects with automatic storage duration that have been constructed but not yet destroyed since the try block was entered must be destroyed in reverse order of the completion of their construction.'''
formal_spec = '''stack_unwinding(exception) && automatic_storage_duration(obj) && constructed(obj) && !destroyed(obj) && in_try_block_scope(obj) => destroy_in_reverse_construction_order(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/2"
tags = ['exception', 'stack-unwinding', 'destructor', 'automatic-storage', 'lifetime']

[[axioms]]
id = "cpp20_except_ctor_return_temp_exception_e4f5a6b7"
content = '''If an exception is thrown during the destruction of temporaries or local variables for a return statement, the destructor for the returned object (if any) is also invoked.'''
formal_spec = '''exception_during_return_cleanup(exception, return_stmt) && exists(returned_object) && constructed(returned_object) => invoke_destructor(returned_object)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/2"
tags = ['exception', 'stack-unwinding', 'destructor', 'return', 'temporary']

[[axioms]]
id = "cpp20_except_ctor_partial_init_destroy_subobjects_c8d9e0f1"
content = '''If object initialization (not by delegating constructor) is terminated by an exception, the destructor is invoked for each subobject that was known to be initialized and whose initialization has completed.'''
formal_spec = '''!delegating_constructor_init(obj) && exception_terminates_init(obj, exception) && known_to_be_initialized(subobj, obj) && initialization_completed(subobj) => invoke_destructor(subobj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'constructor', 'destructor', 'initialization', 'subobject']

[[axioms]]
id = "cpp20_except_ctor_subobject_destroy_reverse_order_2a3b4c5d"
content = '''When subobjects are destroyed due to exception during initialization, they are destroyed in the reverse order of the completion of their construction.'''
formal_spec = '''exception_terminates_init(obj, exception) && subobjects_to_destroy(obj, subobjs) => destroy_in_reverse_construction_order(subobjs)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'constructor', 'destructor', 'initialization', 'subobject']

[[axioms]]
id = "cpp20_except_ctor_dtor_exception_complete_remaining_6e7f8a9b"
content = '''If the destructor of an object is terminated by an exception, each destructor invocation that would be performed after executing the body of the destructor and that has not yet begun execution is performed.'''
formal_spec = '''exception_terminates_destructor(obj, exception) && pending_destructor_invocation(subobj, obj) && !execution_begun(destructor(subobj)) => invoke_destructor(subobj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'destructor', 'subobject', 'stack-unwinding']

[[axioms]]
id = "cpp20_except_ctor_subobj_destroy_before_handler_0c1d2e3f"
content = '''Destruction of subobjects due to exception in constructor or destructor is sequenced before entering a handler of the function-try-block, if any.'''
formal_spec = '''(exception_terminates_init(obj, exception) || exception_terminates_destructor(obj, exception)) && function_try_block(obj, handler) => sequenced_before(subobject_destruction(obj), enter_handler(handler))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'destructor', 'constructor', 'function-try-block', 'sequencing']

[[axioms]]
id = "cpp20_except_ctor_delegating_exception_destroy_4g5h6i7j"
content = '''If the compound-statement of the function-body of a delegating constructor exits via an exception, the object's destructor is invoked.'''
formal_spec = '''delegating_constructor(ctor, obj) && exception_exits_body(ctor, exception) => invoke_destructor(obj)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/4"
tags = ['exception', 'delegating-constructor', 'destructor', 'stack-unwinding']

[[axioms]]
id = "cpp20_except_ctor_delegating_destroy_before_handler_8k9l0m1n"
content = '''Destruction of object due to exception in delegating constructor is sequenced before entering a handler of the function-try-block of that delegating constructor, if any.'''
formal_spec = '''delegating_constructor(ctor, obj) && exception_exits_body(ctor, exception) && function_try_block(ctor, handler) => sequenced_before(destruction(obj), enter_handler(handler))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.ctor"
source_module = "[except.ctor]/4"
tags = ['exception', 'delegating-constructor', 'function-try-block', 'sequencing']

[[axioms]]
id = "cpp20_except_ctor_anonymous_union_not_known_init_2o3p4q5r"
content = '''An anonymous union member is not considered known to be initialized for purposes of destructor invocation during exception unwinding.'''
formal_spec = '''anonymous_union_member(subobj) => !known_to_be_initialized(subobj, parent_obj)'''
layer = "cpp20_language"
confidence = 0.9
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'anonymous-union', 'initialization', 'destructor']

[[axioms]]
id = "cpp20_except_ctor_ref_member_temp_lifetime_6s7t8u9v"
content = '''If an object with a reference member that extends the lifetime of a temporary has its initialization terminated by exception, the lifetime of the reference member ends, so the temporary's lifetime is effectively not extended.'''
formal_spec = '''exception_terminates_init(obj, exception) && reference_member(obj, ref) && extends_temporary_lifetime(ref, temp) => lifetime_ends(ref) && lifetime_ends(temp)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "except.ctor"
source_module = "[except.ctor]/3"
tags = ['exception', 'reference', 'temporary', 'lifetime']

[[axioms]]
id = "cpp20_except_handle_incomplete_type_decl_a3f8b2c1"
content = '''An exception-declaration shall not denote an incomplete type.'''
formal_spec = '''exception_declaration(T) && incomplete_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'incomplete-type']

[[axioms]]
id = "cpp20_except_handle_abstract_class_decl_b4e9c3d2"
content = '''An exception-declaration shall not denote an abstract class type.'''
formal_spec = '''exception_declaration(T) && abstract_class_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'abstract-class']

[[axioms]]
id = "cpp20_except_handle_rvalue_ref_decl_c5f0d4e3"
content = '''An exception-declaration shall not denote an rvalue reference type.'''
formal_spec = '''exception_declaration(T) && rvalue_reference_type(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'rvalue-reference']

[[axioms]]
id = "cpp20_except_handle_ptr_incomplete_decl_d6a1e5f4"
content = '''An exception-declaration shall not denote a pointer or reference to an incomplete type, other than pointer to cv void.'''
formal_spec = '''exception_declaration(T) && (pointer_to(T, U) || reference_to(T, U)) && incomplete_type(U) && !is_cv_void(U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/1"
tags = ['exception-handling', 'type-constraint', 'incomplete-type', 'pointer']

[[axioms]]
id = "cpp20_except_handle_ellipsis_last_e7b2f6a5"
content = '''If present, a ... handler shall be the last handler for its try block.'''
formal_spec = '''handler_ellipsis(H) && exists(H2, handler_after(H, H2) && same_try_block(H, H2)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/5"
tags = ['exception-handling', 'ellipsis', 'handler-order']

[[axioms]]
id = "cpp20_except_handle_noexcept_terminate_f8c3a7b6"
content = '''If the search for a handler exits the function body of a function with a non-throwing exception specification, std::terminate is invoked.'''
formal_spec = '''exception_search_exits(F) && noexcept_spec(F) => invoke_std_terminate'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/7"
tags = ['exception-handling', 'noexcept', 'terminate']

[[axioms]]
id = "cpp20_except_handle_no_match_terminate_a9d4b8c7"
content = '''If no matching handler is found, std::terminate is invoked.'''
formal_spec = '''exception_thrown(E) && !exists(H, matching_handler(H, E)) => invoke_std_terminate'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/8"
tags = ['exception-handling', 'terminate', 'unhandled-exception']

[[axioms]]
id = "cpp20_except_handle_ctor_dtor_member_ub_b0e5c9d8"
content = '''Referring to any non-static member or base class of an object in the handler for a function-try-block of a constructor or destructor for that object results in undefined behavior.'''
formal_spec = '''function_try_block_handler(H, F) && (is_constructor(F) || is_destructor(F)) && refers_to_nonstatic_member_or_base(H, object_of(F)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/11"
tags = ['exception-handling', 'function-try-block', 'constructor', 'destructor', 'undefined-behavior', 'lifetime']

[[axioms]]
id = "cpp20_except_handle_static_main_not_caught_c1f6d0e9"
content = '''Exceptions thrown in destructors of objects with static storage duration or in constructors of objects associated with non-block variables with static storage duration are not caught by a function-try-block on the main function.'''
formal_spec = '''(thrown_in_destructor(E, O) && static_storage_duration(O)) || (thrown_in_constructor(E, O) && non_block_variable(O) && static_storage_duration(O)) => !caught_by_function_try_block(E, main)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/12"
tags = ['exception-handling', 'function-try-block', 'static-storage', 'main', 'initialization', 'destruction']

[[axioms]]
id = "cpp20_except_handle_thread_init_not_caught_d2a7e1f0"
content = '''Exceptions thrown in destructors of objects with thread storage duration or in constructors of objects associated with non-block variables with thread storage duration are not caught by a function-try-block on the initial function of the thread.'''
formal_spec = '''(thrown_in_destructor(E, O) && thread_storage_duration(O)) || (thrown_in_constructor(E, O) && non_block_variable(O) && thread_storage_duration(O)) => !caught_by_function_try_block(E, thread_initial_function)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/12"
tags = ['exception-handling', 'function-try-block', 'thread-storage', 'thread', 'initialization', 'destruction']

[[axioms]]
id = "cpp20_except_handle_ctor_return_illformed_e3b8f2a1"
content = '''If a return statement appears in a handler of the function-try-block of a constructor, the program is ill-formed.'''
formal_spec = '''function_try_block_handler(H, F) && is_constructor(F) && contains_return_statement(H) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/13"
tags = ['exception-handling', 'function-try-block', 'constructor', 'return-statement']

[[axioms]]
id = "cpp20_except_handle_ctor_dtor_rethrow_f4c9a3b2"
content = '''The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block of a constructor or destructor.'''
formal_spec = '''function_try_block_handler(H, F) && (is_constructor(F) || is_destructor(F)) && control_reaches_end(H) => rethrow_current_exception'''
layer = "cpp20_language"
confidence = 0.95
source_file = "except.handle"
source_module = "[except.handle]/14"
tags = ['exception-handling', 'function-try-block', 'constructor', 'destructor', 'rethrow']

[[axioms]]
id = "cpp20_intro_races_data_race_ub_a7c3e2f1"
content = '''A data race between two potentially concurrent conflicting actions, where at least one is not atomic and neither happens before the other, results in undefined behavior.'''
formal_spec = '''potentially_concurrent(A, B) && conflict(A, B) && (!atomic(A) || !atomic(B)) && !happens_before(A, B) && !happens_before(B, A) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/17"
tags = ['concurrency', 'data-race', 'undefined-behavior', 'memory-model']
c_standard_refs = ['5.1.2.4']

[[axioms]]
id = "cpp20_intro_races_conflict_modify_read_b4d8f3a2"
content = '''Two expression evaluations conflict if one modifies a memory location and the other reads or modifies the same memory location.'''
formal_spec = '''(modifies(A, loc) && (reads(B, loc) || modifies(B, loc))) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_conflict_modify_lifetime_c5e9a4b3"
content = '''Two expression evaluations conflict if one modifies a memory location and the other starts or ends the lifetime of an object occupying storage that overlaps with that memory location.'''
formal_spec = '''(modifies(A, loc) && lifetime_change(B, obj) && overlaps(storage(obj), loc)) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'lifetime', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_conflict_lifetime_read_d6f0b5c4"
content = '''Two expression evaluations conflict if one starts or ends the lifetime of an object in a memory location and the other reads or modifies that memory location.'''
formal_spec = '''(lifetime_change(A, obj) && in_memory_location(obj, loc) && (reads(B, loc) || modifies(B, loc))) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'lifetime', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_conflict_lifetime_lifetime_e7a1c6d5"
content = '''Two expression evaluations conflict if one starts or ends the lifetime of an object in a memory location and the other starts or ends the lifetime of an object occupying storage that overlaps with that memory location.'''
formal_spec = '''(lifetime_change(A, obj1) && in_memory_location(obj1, loc) && lifetime_change(B, obj2) && overlaps(storage(obj2), loc)) => conflict(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/2"
tags = ['concurrency', 'conflict', 'lifetime', 'memory-location']

[[axioms]]
id = "cpp20_intro_races_potentially_concurrent_threads_f8b2d7e6"
content = '''Two actions are potentially concurrent if they are performed by different threads.'''
formal_spec = '''(thread(A) != thread(B)) => potentially_concurrent(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/17"
tags = ['concurrency', 'threads', 'potential-concurrency']

[[axioms]]
id = "cpp20_intro_races_potentially_concurrent_signal_09c3e8f7"
content = '''Two actions are potentially concurrent if they are unsequenced, at least one is performed by a signal handler, and they are not both performed by the same signal handler invocation.'''
formal_spec = '''unsequenced(A, B) && (signal_handler(A) || signal_handler(B)) && !same_signal_handler_invocation(A, B) => potentially_concurrent(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/17"
tags = ['concurrency', 'signal-handler', 'potential-concurrency']
c_standard_refs = ['5.1.2.3']

[[axioms]]
id = "cpp20_intro_races_happens_before_sequenced_1ad4f908"
content = '''An evaluation A happens before an evaluation B if A is sequenced before B.'''
formal_spec = '''sequenced_before(A, B) => happens_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'sequencing']

[[axioms]]
id = "cpp20_intro_races_happens_before_sync_2be5a019"
content = '''An evaluation A happens before an evaluation B if A synchronizes with B.'''
formal_spec = '''synchronizes_with(A, B) => happens_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'synchronization']

[[axioms]]
id = "cpp20_intro_races_happens_before_transitive_3cf6b12a"
content = '''An evaluation A happens before an evaluation B if A happens before X and X happens before B (transitivity).'''
formal_spec = '''(happens_before(A, X) && happens_before(X, B)) => happens_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'transitivity']

[[axioms]]
id = "cpp20_intro_races_visible_side_effect_4da7c23b"
content = '''A visible side effect A on a scalar object M with respect to a value computation B satisfies: A happens before B and there is no other side effect X to M such that A happens before X and X happens before B.'''
formal_spec = '''visible_side_effect(A, M, B) <=> (side_effect(A, M) && value_computation(B, M) && happens_before(A, B) && !exists(X, side_effect(X, M) && happens_before(A, X) && happens_before(X, B)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/9"
tags = ['concurrency', 'visibility', 'side-effect', 'scalar']

[[axioms]]
id = "cpp20_intro_races_nonatomic_value_visible_5eb8d34c"
content = '''The value of a non-atomic scalar object or bit-field M, as determined by evaluation B, is the value stored by the visible side effect A.'''
formal_spec = '''(non_atomic(M) && scalar_or_bitfield(M) && value_computation(B, M)) => value(B) == value_stored_by(visible_side_effect(M, B))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/9"
tags = ['concurrency', 'visibility', 'non-atomic', 'scalar']

[[axioms]]
id = "cpp20_intro_races_atomic_value_constraint_6fc9e45d"
content = '''The value of an atomic object M, as determined by evaluation B, is the value stored by some side effect A that modifies M, where B does not happen before A.'''
formal_spec = '''(atomic(M) && value_computation(B, M)) => exists(A, side_effect(A, M) && value(B) == value_stored_by(A) && !happens_before(B, A))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/10"
tags = ['concurrency', 'atomic', 'value-computation']

[[axioms]]
id = "cpp20_intro_races_write_write_coherence_7adaf56e"
content = '''If an operation A that modifies an atomic object M happens before an operation B that modifies M, then A is earlier than B in the modification order of M (write-write coherence).'''
formal_spec = '''(atomic(M) && modifies(A, M) && modifies(B, M) && happens_before(A, B)) => earlier_in_modification_order(A, B, M)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/11"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_read_read_coherence_8bebg67f"
content = '''If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B is either the value stored by X or the value stored by a side effect Y on M where Y follows X in the modification order of M (read-read coherence).'''
formal_spec = '''(atomic(M) && value_computation(A, M) && value_computation(B, M) && happens_before(A, B) && takes_value_from(A, X) && side_effect(X, M)) => (value(B) == value_stored_by(X) || exists(Y, side_effect(Y, M) && follows_in_modification_order(Y, X, M) && value(B) == value_stored_by(Y)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/12"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_read_write_coherence_9cfch780"
content = '''If a value computation A of an atomic object M happens before an operation B that modifies M, then A takes its value from a side effect X on M where X precedes B in the modification order of M (read-write coherence).'''
formal_spec = '''(atomic(M) && value_computation(A, M) && modifies(B, M) && happens_before(A, B)) => exists(X, side_effect(X, M) && takes_value_from(A, X) && precedes_in_modification_order(X, B, M))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/13"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_write_read_coherence_0dgdi891"
content = '''If a side effect X on an atomic object M happens before a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that follows X in the modification order of M (write-read coherence).'''
formal_spec = '''(atomic(M) && side_effect(X, M) && value_computation(B, M) && happens_before(X, B)) => (takes_value_from(B, X) || exists(Y, side_effect(Y, M) && follows_in_modification_order(Y, X, M) && takes_value_from(B, Y)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/14"
tags = ['concurrency', 'atomic', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_intro_races_modification_order_total_1ehej9a2"
content = '''All modifications to a particular atomic object M occur in some particular total order, called the modification order of M.'''
formal_spec = '''atomic(M) => total_order(modification_order(M))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/4"
tags = ['concurrency', 'atomic', 'modification-order', 'total-order']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_seq_2fifkab3"
content = '''An evaluation A strongly happens before an evaluation D if A is sequenced before D.'''
formal_spec = '''sequenced_before(A, D) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'sequencing']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_seqcst_3gjglbc4"
content = '''An evaluation A strongly happens before an evaluation D if A synchronizes with D and both A and D are sequentially consistent atomic operations.'''
formal_spec = '''(synchronizes_with(A, D) && seq_cst_atomic(A) && seq_cst_atomic(D)) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'sequential-consistency', 'atomic']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_chain_4hkhmcd5"
content = '''An evaluation A strongly happens before an evaluation D if there are evaluations B and C such that A is sequenced before B, B happens before C, and C is sequenced before D.'''
formal_spec = '''(sequenced_before(A, B) && happens_before(B, C) && sequenced_before(C, D)) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'sequencing', 'happens-before']

[[axioms]]
id = "cpp20_intro_races_strongly_happens_before_trans_5ilinde6"
content = '''An evaluation A strongly happens before an evaluation D if there is an evaluation B such that A strongly happens before B and B strongly happens before D (transitivity).'''
formal_spec = '''(strongly_happens_before(A, B) && strongly_happens_before(B, D)) => strongly_happens_before(A, D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/8"
tags = ['concurrency', 'strongly-happens-before', 'transitivity']

[[axioms]]
id = "cpp20_intro_races_release_sequence_def_6jmjoef7"
content = '''A release sequence headed by a release operation A on an atomic object M is a maximal contiguous sub-sequence of side effects in the modification order of M, where the first operation is A and every subsequent operation is an atomic read-modify-write operation.'''
formal_spec = '''release_sequence(A, M, seq) <=> (release_operation(A, M) && first(seq) == A && contiguous_in_modification_order(seq, M) && forall(op, member(op, tail(seq)) => atomic_rmw(op)))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/5"
tags = ['concurrency', 'atomic', 'release-sequence', 'synchronization']

[[axioms]]
id = "cpp20_intro_races_sig_atomic_no_race_7knkpfg8"
content = '''Two accesses to the same non-bit-field object of type volatile std::sig_atomic_t do not result in a data race if both occur in the same thread, even if one or more occurs in a signal handler.'''
formal_spec = '''(type(M) == volatile_sig_atomic_t && !bitfield(M) && same_thread(A, B) && access(A, M) && access(B, M)) => !data_race(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/18"
tags = ['concurrency', 'signal-handler', 'sig_atomic_t', 'data-race-exception']
c_standard_refs = ['7.14.1.1']

[[axioms]]
id = "cpp20_intro_races_happens_before_irreflexive_8loqgh9"
content = '''An evaluation does not happen before itself (irreflexivity of happens-before relation).'''
formal_spec = '''!happens_before(A, A)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "intro.races"
source_module = "[intro.races]/7"
tags = ['concurrency', 'happens-before', 'irreflexive']

[[axioms]]
id = "cpp20_atomics_order_rmw_read_last_value_8f3a2b1c"
content = '''Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.'''
formal_spec = '''forall rmw_op : AtomicRMWOperation, M : AtomicObject .
  is_read_modify_write(rmw_op, M) =>
  reads(rmw_op) == last_in_modification_order(M, write_of(rmw_op))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/10"
tags = ['concurrency', 'atomics', 'read-modify-write', 'modification-order']

[[axioms]]
id = "cpp20_atomics_order_release_store_semantics_c4d5e6f7"
content = '''A store operation with memory_order::release, memory_order::acq_rel, or memory_order::seq_cst performs a release operation on the affected memory location.'''
formal_spec = '''forall op : AtomicOperation, M : MemoryLocation .
  is_store(op, M) && (memory_order(op) in {release, acq_rel, seq_cst}) =>
  performs_release(op, M)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/1.2"
tags = ['concurrency', 'atomics', 'memory-order', 'release']

[[axioms]]
id = "cpp20_atomics_order_acquire_load_semantics_a1b2c3d4"
content = '''A load operation with memory_order::acquire, memory_order::acq_rel, or memory_order::seq_cst performs an acquire operation on the affected memory location.'''
formal_spec = '''forall op : AtomicOperation, M : MemoryLocation .
  is_load(op, M) && (memory_order(op) in {acquire, acq_rel, seq_cst}) =>
  performs_acquire(op, M)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/1.3"
tags = ['concurrency', 'atomics', 'memory-order', 'acquire']

[[axioms]]
id = "cpp20_atomics_order_release_acquire_sync_e5f6a7b8"
content = '''An atomic operation A that performs a release operation on an atomic object M synchronizes with an atomic operation B that performs an acquire operation on M and takes its value from any side effect in the release sequence headed by A.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  performs_release(A, M) &&
  performs_acquire(B, M) &&
  takes_value_from_release_sequence(B, A) =>
  synchronizes_with(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/2"
tags = ['concurrency', 'atomics', 'synchronization', 'release-acquire']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_total_order_exists_d9e0f1a2"
content = '''There is a single total order S on all memory_order::seq_cst operations, including fences.'''
formal_spec = '''exists S : TotalOrder .
  forall op : Operation .
    (is_atomic(op) && memory_order(op) == seq_cst) || is_seq_cst_fence(op) =>
    in_order(op, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'total-order']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_strongly_hb_b3c4d5e6"
content = '''If A and B are memory_order::seq_cst operations and A strongly happens before B, then A precedes B in the total order S.'''
formal_spec = '''forall A B : AtomicOperation, S : TotalOrder .
  memory_order(A) == seq_cst &&
  memory_order(B) == seq_cst &&
  strongly_happens_before(A, B) =>
  precedes_in(A, B, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'happens-before']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_1_f7a8b9c0"
content = '''If A and B are both memory_order::seq_cst operations on object M where A is coherence-ordered before B, then A precedes B in S.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject, S : TotalOrder .
  memory_order(A) == seq_cst &&
  memory_order(B) == seq_cst &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) =>
  precedes_in(A, B, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.1"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_2_1d2e3f4a"
content = '''If A is a memory_order::seq_cst operation coherence-ordered before B, and B happens before a memory_order::seq_cst fence Y, then A precedes Y in S.'''
formal_spec = '''forall A B : AtomicOperation, Y : Fence, M : AtomicObject, S : TotalOrder .
  memory_order(A) == seq_cst &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) &&
  is_seq_cst_fence(Y) &&
  happens_before(B, Y) =>
  precedes_in(A, Y, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.2"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'fence', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_3_5b6c7d8e"
content = '''If a memory_order::seq_cst fence X happens before A, and A is coherence-ordered before B which is a memory_order::seq_cst operation, then X precedes B in S.'''
formal_spec = '''forall A B : AtomicOperation, X : Fence, M : AtomicObject, S : TotalOrder .
  is_seq_cst_fence(X) &&
  happens_before(X, A) &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) &&
  memory_order(B) == seq_cst =>
  precedes_in(X, B, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.3"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'fence', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_seq_cst_coherence_4_4_9f0a1b2c"
content = '''If a memory_order::seq_cst fence X happens before A, A is coherence-ordered before B, and B happens before a memory_order::seq_cst fence Y, then X precedes Y in S.'''
formal_spec = '''forall A B : AtomicOperation, X Y : Fence, M : AtomicObject, S : TotalOrder .
  is_seq_cst_fence(X) &&
  happens_before(X, A) &&
  operates_on(A, M) && operates_on(B, M) &&
  coherence_ordered_before(A, B) &&
  is_seq_cst_fence(Y) &&
  happens_before(B, Y) =>
  precedes_in(X, Y, S)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/4.4"
tags = ['concurrency', 'atomics', 'memory-order', 'seq_cst', 'fence', 'coherence']

[[axioms]]
id = "cpp20_atomics_order_coherence_mod_read_3_1_c3d4e5f6"
content = '''An atomic operation A on atomic object M is coherence-ordered before another atomic operation B on M if A is a modification, and B reads the value stored by A.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  is_modification(A) &&
  reads_value_stored_by(B, A) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.1"
tags = ['concurrency', 'atomics', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_atomics_order_coherence_mod_order_3_2_7a8b9c0d"
content = '''An atomic operation A on atomic object M is coherence-ordered before another atomic operation B on M if A precedes B in the modification order of M.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  precedes_in_modification_order(A, B, M) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.2"
tags = ['concurrency', 'atomics', 'coherence', 'modification-order']

[[axioms]]
id = "cpp20_atomics_order_coherence_read_mod_3_3_e1f2a3b4"
content = '''An atomic operation A on M is coherence-ordered before B on M if A and B are not the same atomic read-modify-write operation, and there exists an atomic modification X of M such that A reads the value stored by X and X precedes B in the modification order of M.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  NOT (same_rmw_operation(A, B)) &&
  (exists X : AtomicModification .
    modifies(X, M) &&
    reads_value_stored_by(A, X) &&
    precedes_in_modification_order(X, B, M)) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.3"
tags = ['concurrency', 'atomics', 'coherence', 'modification-order', 'read-modify-write']

[[axioms]]
id = "cpp20_atomics_order_coherence_transitive_3_4_5c6d7e8f"
content = '''An atomic operation A on M is coherence-ordered before B on M if there exists an atomic modification X of M such that A is coherence-ordered before X and X is coherence-ordered before B.'''
formal_spec = '''forall A B : AtomicOperation, M : AtomicObject .
  operates_on(A, M) && operates_on(B, M) &&
  (exists X : AtomicModification .
    modifies(X, M) &&
    coherence_ordered_before(A, X) &&
    coherence_ordered_before(X, B)) =>
  coherence_ordered_before(A, B)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/3.4"
tags = ['concurrency', 'atomics', 'coherence', 'transitivity']

[[axioms]]
id = "cpp20_atomics_order_relaxed_no_ordering_9a0b1c2d"
content = '''memory_order::relaxed specifies that no operation orders memory.'''
formal_spec = '''forall op : AtomicOperation .
  memory_order(op) == relaxed =>
  NOT orders_memory(op)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.order"
source_module = "[atomics.order]/1.1"
tags = ['concurrency', 'atomics', 'memory-order', 'relaxed']

[[axioms]]
id = "cpp20_atomics_order_atomic_indivisibility_3e4f5a6b"
content = '''Any given atomic access to a particular atomic object must be indivisible with respect to all other atomic accesses to that object, regardless of memory ordering.'''
formal_spec = '''forall A B : AtomicAccess, M : AtomicObject .
  accesses(A, M) && accesses(B, M) && A != B =>
  indivisible(A, B)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "atomics.order"
source_module = "[atomics.order]/1 Note 1"
tags = ['concurrency', 'atomics', 'indivisibility']

[[axioms]]
id = "cpp20_atomics_order_no_oota_recommendation_7c8d9e0f"
content = '''Implementations should ensure that no "out-of-thin-air" values are computed that circularly depend on their own computation.'''
formal_spec = '''forall v : Value, computation : Execution .
  circularly_depends_on_own_computation(v, computation) =>
  should_not_produce(v)'''
layer = "cpp20_language"
confidence = 0.75
source_file = "atomics.order"
source_module = "[atomics.order]/8"
tags = ['concurrency', 'atomics', 'out-of-thin-air', 'recommendation']

[[axioms]]
id = "cpp20_atomics_fences_release_acquire_sync_condition_a7f3c2d1"
content = '''A release fence A synchronizes with an acquire fence B only if there exist atomic operations X and Y (where Y is not an atomic read-modify-write operation) both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.'''
formal_spec = '''synchronizes_with(release_fence(A), acquire_fence(B)) <=> exists(X, Y, M) where atomic_operation(X) && atomic_operation(Y) && !atomic_rmw(Y) && atomic_object(M) && operates_on(X, M) && operates_on(Y, M) && sequenced_before(A, X) && modifies(X, M) && sequenced_before(Y, B) && (reads_value_written_by(Y, X) || reads_value_in_hypothetical_release_sequence(Y, X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/2"
tags = ['concurrency', 'fences', 'synchronization', 'memory_order', 'release_fence', 'acquire_fence']

[[axioms]]
id = "cpp20_atomics_fences_release_fence_acquire_op_sync_b8e4d3f2"
content = '''A release fence A synchronizes with an atomic operation B that performs an acquire operation on atomic object M only if there exists an atomic operation X such that A is sequenced before X, X modifies M, and B reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.'''
formal_spec = '''synchronizes_with(release_fence(A), acquire_operation(B, M)) <=> exists(X) where atomic_operation(X) && sequenced_before(A, X) && modifies(X, M) && (reads_value_written_by(B, X) || reads_value_in_hypothetical_release_sequence(B, X))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/3"
tags = ['concurrency', 'fences', 'synchronization', 'memory_order', 'release_fence', 'acquire_operation']

[[axioms]]
id = "cpp20_atomics_fences_release_op_acquire_fence_sync_c9f5e4a3"
content = '''An atomic operation A that is a release operation on atomic object M synchronizes with an acquire fence B only if there exists some atomic operation X on M such that X is sequenced before B and reads the value written by A or a value written by any side effect in the release sequence headed by A.'''
formal_spec = '''synchronizes_with(release_operation(A, M), acquire_fence(B)) <=> exists(X) where atomic_operation(X) && operates_on(X, M) && sequenced_before(X, B) && (reads_value_written_by(X, A) || reads_value_in_release_sequence(X, A))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/4"
tags = ['concurrency', 'fences', 'synchronization', 'memory_order', 'release_operation', 'acquire_fence']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_relaxed_no_effect_d1a6f5b4"
content = '''atomic_thread_fence with memory_order::relaxed has no synchronization effects.'''
formal_spec = '''atomic_thread_fence(memory_order::relaxed) => no_fence_effects()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.1"
tags = ['concurrency', 'fences', 'memory_order', 'relaxed']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_acquire_semantics_e2b7c6d5"
content = '''atomic_thread_fence with memory_order::acquire is an acquire fence.'''
formal_spec = '''atomic_thread_fence(memory_order::acquire) => acquire_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.2"
tags = ['concurrency', 'fences', 'memory_order', 'acquire']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_release_semantics_f3c8d7e6"
content = '''atomic_thread_fence with memory_order::release is a release fence.'''
formal_spec = '''atomic_thread_fence(memory_order::release) => release_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.3"
tags = ['concurrency', 'fences', 'memory_order', 'release']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_acq_rel_semantics_a4d9e8f7"
content = '''atomic_thread_fence with memory_order::acq_rel is both an acquire fence and a release fence.'''
formal_spec = '''atomic_thread_fence(memory_order::acq_rel) => acquire_fence() && release_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.4"
tags = ['concurrency', 'fences', 'memory_order', 'acq_rel']

[[axioms]]
id = "cpp20_atomics_fences_thread_fence_seq_cst_semantics_b5eaf9a8"
content = '''atomic_thread_fence with memory_order::seq_cst is a sequentially consistent acquire and release fence.'''
formal_spec = '''atomic_thread_fence(memory_order::seq_cst) => seq_cst_fence() && acquire_fence() && release_fence()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/5.5"
tags = ['concurrency', 'fences', 'memory_order', 'seq_cst', 'sequential_consistency']

[[axioms]]
id = "cpp20_atomics_fences_signal_fence_same_thread_only_c6fba0b9"
content = '''atomic_signal_fence establishes ordering constraints only between a thread and a signal handler executed in the same thread, unlike atomic_thread_fence which establishes ordering across threads.'''
formal_spec = '''atomic_signal_fence(order) => ordering_constraints_limited_to(same_thread, signal_handler_in_same_thread) && !inter_thread_synchronization()'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/6"
tags = ['concurrency', 'fences', 'signal_handler', 'memory_order', 'signal_fence']

[[axioms]]
id = "cpp20_atomics_fences_signal_fence_no_hw_fence_d7acb1ca"
content = '''atomic_signal_fence inhibits compiler optimizations and reorderings like atomic_thread_fence but does not emit hardware fence instructions.'''
formal_spec = '''atomic_signal_fence(order) => compiler_barrier(order) && !hardware_fence_instruction()'''
layer = "cpp20_language"
confidence = 0.85
source_file = "atomics.fences"
source_module = "[atomics.fences]/7"
tags = ['concurrency', 'fences', 'signal_handler', 'compiler_barrier', 'optimization']

[[axioms]]
id = "cpp20_atomics_fences_sync_requires_y_not_rmw_e8bdc2db"
content = '''For a release fence to synchronize with an acquire fence via atomic operations X and Y, the operation Y that reads from M must NOT be an atomic read-modify-write operation.'''
formal_spec = '''synchronizes_with(release_fence(A), acquire_fence(B)) via (X, Y, M) => !atomic_rmw(Y)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "atomics.fences"
source_module = "[atomics.fences]/2"
tags = ['concurrency', 'fences', 'synchronization', 'read_modify_write', 'constraint']

[[axioms]]
id = "cpp20_concept_same_type_equality_symmetric_7a3c1d8e"
content = '''The same_as concept is satisfied if and only if T and U are the same type, and this relationship is symmetric.'''
formal_spec = '''same_as<T, U> <=> is_same_v<T, U> && is_same_v<U, T>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "concept.same"
source_module = "[concept.same]/1"
tags = ['concepts', 'type_traits', 'same_as', 'symmetry']

[[axioms]]
id = "cpp20_concept_same_subsumption_bidirectional_b2f4e9a1"
content = '''same_as<T, U> subsumes same_as<U, T> and vice versa, enabling symmetric constraint satisfaction in overload resolution.'''
formal_spec = '''subsumes(same_as<T, U>, same_as<U, T>) && subsumes(same_as<U, T>, same_as<T, U>)'''
layer = "cpp20_stdlib"
confidence = 0.9
source_file = "concept.same"
source_module = "[concept.same]/1"
tags = ['concepts', 'subsumption', 'same_as', 'overload_resolution']

[[axioms]]
id = "cpp20_concept_same_impl_is_same_v_c8d2f3a7"
content = '''The exposition-only same-as-impl concept is satisfied when is_same_v<T, U> is true, meaning T and U are exactly the same type after any reference and cv-qualifier adjustments by the type trait.'''
formal_spec = '''same-as-impl<T, U> <=> is_same_v<T, U>'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "concept.same"
source_module = "[concept.same]/1"
tags = ['concepts', 'type_traits', 'is_same', 'implementation_detail']

[[axioms]]
id = "cpp20_dcl_init_list_initializer_list_not_reachable_a7b3c2d1"
content = '''If std::initializer_list is used (even implicitly) but no standard library declaration of std::initializer_list is reachable, the program is ill-formed.'''
formal_spec = '''uses_initializer_list(expr) && !reachable_declaration(std::initializer_list) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/2"
tags = ['list-initialization', 'initializer_list', 'reachability']

[[axioms]]
id = "cpp20_dcl_init_list_designated_init_aggregate_only_f8e2a1b3"
content = '''If a braced-init-list contains a designated-initializer-list and T is not a reference type, T shall be an aggregate class.'''
formal_spec = '''has_designated_initializer_list(init) && !is_reference_type(T) && !is_aggregate_class(T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate']

[[axioms]]
id = "cpp20_dcl_init_list_designator_order_subsequence_c4d5e6f7"
content = '''The ordered identifiers in the designators of a designated-initializer-list shall form a subsequence of the ordered identifiers in the direct non-static data members of T.'''
formal_spec = '''has_designated_initializer_list(init) && !is_subsequence(designator_identifiers(init), member_identifiers(T)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.1"
tags = ['list-initialization', 'designated-initializer', 'aggregate', 'member-order']

[[axioms]]
id = "cpp20_dcl_init_list_class_narrowing_conversion_b1c2d3e4"
content = '''When constructors are considered for class type list-initialization, if a narrowing conversion is required to convert any of the arguments, the program is ill-formed.'''
formal_spec = '''is_class_type(T) && list_initialization(T, init) && requires_narrowing_conversion(arg, param) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.7"
tags = ['list-initialization', 'narrowing', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_list_enum_narrowing_e5f6a7b8"
content = '''When initializing an enumeration with fixed underlying type via direct-list-initialization from a single scalar element, if a narrowing conversion is required to convert the element to the underlying type, the program is ill-formed.'''
formal_spec = '''is_enum_with_fixed_underlying_type(T, U) && direct_list_init(T, {v}) && is_scalar(v) && requires_narrowing_conversion(v, U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'narrowing']

[[axioms]]
id = "cpp20_dcl_init_list_enum_copy_list_init_c9d0e1f2"
content = '''Copy-list-initialization of an enumeration with fixed underlying type from a single scalar value is ill-formed (only direct-list-initialization is allowed).'''
formal_spec = '''is_enum_with_fixed_underlying_type(T, U) && copy_list_init(T, {v}) && is_scalar(v) && !is_type(v, T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.8"
tags = ['list-initialization', 'enumeration', 'copy-initialization']

[[axioms]]
id = "cpp20_dcl_init_list_single_element_narrowing_a3b4c5d6"
content = '''When initializing from a single-element initializer list where the element type is reference-related to T, if a narrowing conversion is required to convert the element to T, the program is ill-formed.'''
formal_spec = '''list_init(T, {e}) && !is_designated_init(init) && (reference_related(T, type(e)) || !is_reference_type(T)) && requires_narrowing_conversion(e, T) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.9"
tags = ['list-initialization', 'narrowing', 'single-element']

[[axioms]]
id = "cpp20_dcl_init_list_lvalue_ref_nonconst_e7f8a9b0"
content = '''Binding an lvalue reference to a non-const type to a prvalue generated from list-initialization is ill-formed.'''
formal_spec = '''is_lvalue_reference(T) && !is_const(referenced_type(T)) && list_init_generates_prvalue(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.10"
tags = ['list-initialization', 'reference', 'lvalue']

[[axioms]]
id = "cpp20_dcl_init_list_backing_array_narrowing_c1d2e3f4"
content = '''When constructing a std::initializer_list<E> from an initializer list, if a narrowing conversion is required to initialize any element of the backing array, the program is ill-formed.'''
formal_spec = '''is_initializer_list_type(T, E) && list_init(T, init) && exists(elem in init, requires_narrowing_conversion(elem, E)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/5"
tags = ['list-initialization', 'initializer_list', 'narrowing', 'backing-array']

[[axioms]]
id = "cpp20_dcl_init_list_member_initializer_dangling_a5b6c7d8"
content = '''Initializing an initializer_list member in a constructor's ctor-initializer creates a dangling reference because the backing array has temporary lifetime, making the program ill-formed.'''
formal_spec = '''is_initializer_list_type(member_type) && initialized_in_mem_initializer(member, braced_init_list) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/6"
tags = ['list-initialization', 'initializer_list', 'lifetime', 'dangling-reference', 'constructor']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_int_d9e0f1a2"
content = '''A narrowing conversion is an implicit conversion from a floating-point type to an integer type.'''
formal_spec = '''is_floating_point(source_type) && is_integer_type(target_type) && implicit_conversion(source, target) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.1"
tags = ['narrowing', 'floating-point', 'integer', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_float_to_float_b3c4d5e6"
content = '''A narrowing conversion is an implicit conversion from a floating-point type T to another floating-point type with lower or incomparable conversion rank, except where the result is a constant expression with finite value that did not overflow or both values are not finite.'''
formal_spec = '''is_floating_point(T) && is_floating_point(U) && !rank_greater_or_equal(U, T) && implicit_conversion(T, U) && !(is_constant_expr(v) && ((is_finite(result) && !overflow(v, U)) || (!is_finite(v) && !is_finite(result)))) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.2"
tags = ['narrowing', 'floating-point', 'conversion', 'rank']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_float_f7a8b9c0"
content = '''A narrowing conversion is an implicit conversion from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the value after conversion fits into the target type and produces the original value when converted back.'''
formal_spec = '''(is_integer_type(T) || is_unscoped_enum(T)) && is_floating_point(U) && implicit_conversion(T, U) && !(is_constant_expr(v) && fits_exactly(v, U) && roundtrip_equal(v, U)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.3"
tags = ['narrowing', 'integer', 'floating-point', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_int_to_int_d1e2f3a4"
content = '''A narrowing conversion is an implicit conversion from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except for bit-fields or constant expressions whose promoted value fits the target type.'''
formal_spec = '''(is_integer_type(T) || is_unscoped_enum(T)) && is_integer_type(U) && !can_represent_all_values(U, T) && implicit_conversion(T, U) && !is_narrow_bitfield_exception(v, T, U) && !(is_constant_expr(v) && fits_after_promotion(v, U)) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.4"
tags = ['narrowing', 'integer', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_narrowing_ptr_to_bool_b5c6d7e8"
content = '''A narrowing conversion is an implicit conversion from a pointer type or a pointer-to-member type to bool.'''
formal_spec = '''(is_pointer_type(T) || is_pointer_to_member_type(T)) && target_type == bool && implicit_conversion(T, bool) => is_narrowing_conversion'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/7.5"
tags = ['narrowing', 'pointer', 'bool', 'conversion']

[[axioms]]
id = "cpp20_dcl_init_list_no_matching_init_e9f0a1b2"
content = '''If none of the list-initialization rules apply (3.1 through 3.11), the program is ill-formed.'''
formal_spec = '''list_init(T, init) && !matches_any_list_init_rule(T, init) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.12"
tags = ['list-initialization', 'ill-formed']

[[axioms]]
id = "cpp20_dcl_init_list_evaluation_order_c3d4e5f6"
content = '''Within the initializer-list of a braced-init-list, the initializer-clauses are evaluated in the order in which they appear, with each value computation and side effect sequenced before those of subsequent clauses.'''
formal_spec = '''braced_init_list(init) && clause_i in init && clause_j in init && position(clause_i) < position(clause_j) => sequenced_before(effects(clause_i), effects(clause_j))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/4"
tags = ['list-initialization', 'evaluation-order', 'sequencing']

[[axioms]]
id = "cpp20_dcl_init_list_aggregate_narrowing_a7b8c9d0"
content = '''Aggregate initialization via list-initialization is ill-formed if a narrowing conversion is required for any element.'''
formal_spec = '''is_aggregate(T) && list_init(T, init) && exists(elem in init, requires_narrowing_conversion(elem, member_type)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.init.list"
source_module = "[dcl.init.list]/3.4"
tags = ['list-initialization', 'aggregate', 'narrowing']

[[axioms]]
id = "cpp20_expr_prim_req_general_no_default_arg_a7b3c2d1"
content = '''A local parameter of a requires-expression shall not have a default argument.'''
formal_spec = '''requires_expression(R) && local_parameter(P, R) && has_default_argument(P) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/4"
tags = ['requires-expression', 'parameter', 'constraint']

[[axioms]]
id = "cpp20_expr_prim_req_general_no_ellipsis_f8e2a1b4"
content = '''The parameter-declaration-clause of a requirement-parameter-list shall not terminate with an ellipsis.'''
formal_spec = '''requires_expression(R) && parameter_declaration_clause(PDC, R) && terminates_with_ellipsis(PDC) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/4"
tags = ['requires-expression', 'parameter', 'variadic', 'constraint']

[[axioms]]
id = "cpp20_expr_prim_req_general_invalid_non_template_c3d4e5f6"
content = '''If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a templated entity, then the program is ill-formed.'''
formal_spec = '''requires_expression(R) && contains_invalid_types_or_expressions(R) && !within_templated_entity_declaration(R) => ill_formed'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'template', 'validity', 'constraint']

[[axioms]]
id = "cpp20_expr_prim_req_general_always_failure_ndr_b2c3d4e5"
content = '''If the substitution of template arguments into a requirement would always result in a substitution failure, the program is ill-formed; no diagnostic required.'''
formal_spec = '''requirement(Req) && for_all_template_args(Args, substitution_fails(Req, Args)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'template', 'substitution', 'ndr']

[[axioms]]
id = "cpp20_expr_prim_req_compound_noexcept_check_d4e5f6a7"
content = '''In a compound-requirement with noexcept specifier, the expression shall not be a potentially-throwing expression.'''
formal_spec = '''compound_requirement(CR) && has_noexcept_specifier(CR) && expression(E, CR) && potentially_throwing(E) => requirement_not_satisfied'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1.2"
tags = ['requires-expression', 'compound-requirement', 'noexcept', 'exception']

[[axioms]]
id = "cpp20_expr_prim_req_compound_return_type_constraint_e5f6a7b8"
content = '''In a compound-requirement with return-type-requirement, the immediately-declared constraint of the type-constraint for decltype((E)) shall be satisfied.'''
formal_spec = '''compound_requirement(CR) && has_return_type_requirement(CR, RTR) && expression(E, CR) && type_constraint(TC, RTR) && !satisfies(immediately_declared_constraint(TC), decltype_parenthesized(E)) => requirement_not_satisfied'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1.3.2"
tags = ['requires-expression', 'compound-requirement', 'type-constraint', 'decltype']

[[axioms]]
id = "cpp20_expr_prim_req_nested_constraint_satisfied_f6a7b8c9"
content = '''The constraint-expression in a nested-requirement shall be satisfied by the substituted template arguments.'''
formal_spec = '''nested_requirement(NR) && constraint_expression(CE, NR) && template_arguments(Args) && substituted(CE', CE, Args) && !satisfied(CE') => requirement_not_satisfied'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.nested"
source_module = "[expr.prim.req.nested]/1"
tags = ['requires-expression', 'nested-requirement', 'constraint', 'satisfaction']

[[axioms]]
id = "cpp20_expr_prim_req_simple_unevaluated_a1b2c3d4"
content = '''The expression in a simple-requirement is an unevaluated operand.'''
formal_spec = '''simple_requirement(SR) && expression(E, SR) => unevaluated_operand(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.simple"
source_module = "[expr.prim.req.simple]/1"
tags = ['requires-expression', 'simple-requirement', 'unevaluated']

[[axioms]]
id = "cpp20_expr_prim_req_compound_unevaluated_b2c3d4e5"
content = '''The expression in a compound-requirement is an unevaluated operand.'''
formal_spec = '''compound_requirement(CR) && expression(E, CR) => unevaluated_operand(E)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1"
tags = ['requires-expression', 'compound-requirement', 'unevaluated']

[[axioms]]
id = "cpp20_expr_prim_req_general_substitution_false_c3d4e5f6"
content = '''Invalid type/expression formation or semantic constraint violation in requirements causes requires-expression to evaluate to false, not ill-formed.'''
formal_spec = '''requires_expression(R) && within_templated_entity(R) && (invalid_type_formation(R) || invalid_expression_formation(R) || semantic_constraint_violation(R)) => evaluates_to(R, false)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'SFINAE', 'substitution', 'template']

[[axioms]]
id = "cpp20_expr_prim_req_general_lexical_order_d4e5f6a7"
content = '''Substitution and semantic constraint checking in a requires-expression proceeds in lexical order and stops when a condition that determines the result is encountered.'''
formal_spec = '''requires_expression(R) && requirements(Reqs, R) && requirement_at_position(Req, N, Reqs) && determines_result(Req) => skip_requirements_after(N, Reqs)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/5"
tags = ['requires-expression', 'evaluation-order', 'short-circuit']

[[axioms]]
id = "cpp20_expr_prim_req_general_param_no_linkage_e5f6a7b8"
content = '''Local parameters of a requires-expression have no linkage, storage, or lifetime; they are only used as notation for defining requirements.'''
formal_spec = '''requires_expression(R) && local_parameter(P, R) => !has_linkage(P) && !has_storage(P) && !has_lifetime(P) && notation_only(P)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.general"
source_module = "[expr.prim.req.general]/4"
tags = ['requires-expression', 'parameter', 'linkage', 'storage', 'lifetime']

[[axioms]]
id = "cpp20_expr_prim_req_type_no_complete_f6a7b8c9"
content = '''A type-requirement that names a class template specialization does not require that type to be complete.'''
formal_spec = '''type_requirement(TR) && names_class_template_specialization(TR, S) => !requires_complete_type(TR, S)'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.type"
source_module = "[expr.prim.req.type]/2"
tags = ['requires-expression', 'type-requirement', 'complete-type', 'template']

[[axioms]]
id = "cpp20_expr_prim_req_simple_requires_token_a7b8c9d0"
content = '''A requirement that starts with a requires token is never interpreted as a simple-requirement.'''
formal_spec = '''requirement(R) && starts_with_requires_token(R) => !simple_requirement(R)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "expr.prim.req.simple"
source_module = "[expr.prim.req.simple]/2"
tags = ['requires-expression', 'simple-requirement', 'nested-requirement', 'parsing']

[[axioms]]
id = "cpp20_expr_prim_req_compound_order_b8c9d0e1"
content = '''In a compound-requirement, substitution and verification proceed in specific order: expression substitution, noexcept check, return-type-requirement substitution, then type-constraint satisfaction.'''
formal_spec = '''compound_requirement(CR) && expression(E, CR) => order(substitution(E), noexcept_check(E), return_type_substitution(CR), type_constraint_check(CR))'''
layer = "cpp20_language"
confidence = 0.85
source_file = "expr.prim.req.compound"
source_module = "[expr.prim.req.compound]/1"
tags = ['requires-expression', 'compound-requirement', 'evaluation-order']

[[axioms]]
id = "cpp20_module_unit_reserved_names_std_3f8a1b2c"
content = '''Module names beginning with 'std' followed by zero or more digits are reserved and shall not be specified in a module-declaration.'''
formal_spec = '''module_declaration(name) && (starts_with(name, "std") || starts_with(name, regex("std[0-9]*"))) => ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/1"
tags = ['module', 'reserved-names', 'declaration']

[[axioms]]
id = "cpp20_module_unit_reserved_identifier_a7c2d4e1"
content = '''Module names containing a reserved identifier are reserved and shall not be specified in a module-declaration.'''
formal_spec = '''module_declaration(name) && contains_reserved_identifier(name) => ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/1"
tags = ['module', 'reserved-names', 'identifier']

[[axioms]]
id = "cpp20_module_unit_module_import_keywords_b4e5f6a2"
content = '''The identifiers "module" and "import" shall not appear as identifiers in a module-name or module-partition.'''
formal_spec = '''(module_name(name) || module_partition(name)) && (contains_identifier(name, "module") || contains_identifier(name, "import")) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/1"
tags = ['module', 'identifier', 'keyword']

[[axioms]]
id = "cpp20_module_unit_exactly_one_primary_c8d9e0f3"
content = '''A named module shall contain exactly one module interface unit with no module-partition, known as the primary module interface unit of the module.'''
formal_spec = '''named_module(M) => count(module_interface_units(M), has_no_partition) == 1 || ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/2"
tags = ['module', 'interface-unit', 'primary']

[[axioms]]
id = "cpp20_module_unit_unique_partitions_1a2b3c4d"
content = '''A named module shall not contain multiple module partitions with the same module-partition name.'''
formal_spec = '''named_module(M) && partition(P1, M) && partition(P2, M) && P1 != P2 && partition_name(P1) == partition_name(P2) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/3"
tags = ['module', 'partition', 'unique']

[[axioms]]
id = "cpp20_module_unit_export_all_partitions_5e6f7a8b"
content = '''All module partitions of a module that are module interface units shall be directly or indirectly exported by the primary module interface unit.'''
formal_spec = '''named_module(M) && partition(P, M) && is_interface_unit(P) => exported_by_primary(P, M) || ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.unit"
source_module = "[module.unit]/3"
tags = ['module', 'partition', 'export']

[[axioms]]
id = "cpp20_module_interface_namespace_scope_9c0d1e2f"
content = '''An export-declaration shall inhabit a namespace scope and appear in the purview of a module interface unit.'''
formal_spec = '''export_declaration(D) => (inhabits_namespace_scope(D) && in_purview_of_interface_unit(D)) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'namespace-scope']

[[axioms]]
id = "cpp20_module_interface_not_unnamed_ns_3a4b5c6d"
content = '''An export-declaration shall not appear directly or indirectly within an unnamed namespace.'''
formal_spec = '''export_declaration(D) && within_unnamed_namespace(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'unnamed-namespace']

[[axioms]]
id = "cpp20_module_interface_not_private_frag_7e8f9a0b"
content = '''An export-declaration shall not appear directly or indirectly within a private-module-fragment.'''
formal_spec = '''export_declaration(D) && within_private_module_fragment(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'private-fragment']

[[axioms]]
id = "cpp20_module_interface_no_partial_spec_1c2d3e4f"
content = '''The name-declaration of an export-declaration shall not declare a partial specialization.'''
formal_spec = '''export_declaration(D) && declares_partial_specialization(name_declaration(D)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'template', 'partial-specialization']

[[axioms]]
id = "cpp20_module_interface_no_nested_export_5a6b7c8d"
content = '''The declaration-seq of an export-declaration shall not contain an export-declaration or module-import-declaration.'''
formal_spec = '''export_declaration(D) && (contains_export_declaration(declaration_seq(D)) || contains_module_import(declaration_seq(D))) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/1"
tags = ['module', 'export', 'nested']

[[axioms]]
id = "cpp20_module_interface_no_internal_linkage_9e0f1a2b"
content = '''If an exported declaration is not within a header unit, it shall not declare a name with internal linkage.'''
formal_spec = '''exported(D) && !within_header_unit(D) && has_internal_linkage(declared_name(D)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/3"
tags = ['module', 'export', 'linkage', 'internal']

[[axioms]]
id = "cpp20_module_interface_using_decl_linkage_3c4d5e6f"
content = '''If an exported using-declaration is not within a header unit, all entities named by the using-declarators shall either be a type alias or have been introduced with a name having external linkage.'''
formal_spec = '''exported(D) && is_using_declaration(D) && !within_header_unit(D) && entity_named_by(D, E) => (is_type_alias(E) || has_external_linkage(E)) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/5"
tags = ['module', 'export', 'using-declaration', 'linkage']

[[axioms]]
id = "cpp20_module_interface_redecl_export_7a8b9c0d"
content = '''A redeclaration of an entity that was not introduced by an exported declaration shall not be exported unless it is a type alias, a namespace, or a namespace alias.'''
formal_spec = '''redeclaration(D, X) && !introduced_by_exported(X) && exported(D) && !is_type_alias(D) && !is_namespace(D) && !is_namespace_alias(D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.interface"
source_module = "[module.interface]/6"
tags = ['module', 'export', 'redeclaration']

[[axioms]]
id = "cpp20_module_import_global_scope_1e2f3a4b"
content = '''A module-import-declaration shall inhabit the global namespace scope.'''
formal_spec = '''module_import_declaration(D) => inhabits_global_namespace_scope(D) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/1"
tags = ['module', 'import', 'namespace-scope']

[[axioms]]
id = "cpp20_module_import_before_other_decls_5c6d7e8f"
content = '''In a module unit, all module-import-declarations and export-declarations exporting module-import-declarations shall appear before all other declarations in the declaration-seq.'''
formal_spec = '''module_unit(U) && module_import_declaration(D) && other_declaration(O) && appears_before(O, D) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/1"
tags = ['module', 'import', 'declaration-order']

[[axioms]]
id = "cpp20_module_import_partition_same_module_9a0b1c2d"
content = '''A module-import-declaration that specifies a module-partition shall only appear after the module-declaration in a module unit of some module M.'''
formal_spec = '''module_import_declaration(D) && specifies_partition(D) => (appears_after_module_declaration(D) && in_module_unit(D)) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/4"
tags = ['module', 'import', 'partition']

[[axioms]]
id = "cpp20_module_import_header_no_module_decl_3e4f5a6b"
content = '''A header unit nominated by a header-name in a module-import-declaration shall not contain a module-declaration.'''
formal_spec = '''module_import_declaration(D) && specifies_header_name(D, H) && header_unit(H) && contains_module_declaration(H) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/5"
tags = ['module', 'import', 'header-unit']

[[axioms]]
id = "cpp20_module_import_importable_header_7c8d9e0f"
content = '''The header-name H in a module-import-declaration shall identify an importable header.'''
formal_spec = '''module_import_declaration(D) && specifies_header_name(D, H) => is_importable_header(H) || ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/5"
tags = ['module', 'import', 'header-unit', 'importable']

[[axioms]]
id = "cpp20_module_import_header_no_extern_def_1a2b3c4d"
content = '''A header unit shall not contain a definition of a non-inline function or variable whose name has external linkage.'''
formal_spec = '''header_unit(H) && contains_definition(H, D) && (is_function(D) || is_variable(D)) && !is_inline(D) && has_external_linkage(name(D)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/6"
tags = ['module', 'header-unit', 'definition', 'linkage']

[[axioms]]
id = "cpp20_module_import_impl_not_exported_5e6f7a8b"
content = '''A module implementation unit shall not be exported.'''
formal_spec = '''module_implementation_unit(U) && exported(U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/8"
tags = ['module', 'implementation-unit', 'export']

[[axioms]]
id = "cpp20_module_import_no_self_import_9c0d1e2f"
content = '''A module implementation unit of a module M that is not a module partition shall not contain a module-import-declaration nominating M.'''
formal_spec = '''module_implementation_unit(U, M) && !is_partition(U) && contains_import(U, M) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/9"
tags = ['module', 'import', 'self-reference']

[[axioms]]
id = "cpp20_module_import_no_cyclic_dependency_3a4b5c6d"
content = '''A translation unit shall not have an interface dependency on itself.'''
formal_spec = '''translation_unit(U) && interface_dependency(U, U) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.import"
source_module = "[module.import]/10"
tags = ['module', 'import', 'cyclic-dependency']

[[axioms]]
id = "cpp20_module_private_frag_primary_only_7e8f9a0b"
content = '''A private-module-fragment shall appear only in a primary module interface unit.'''
formal_spec = '''private_module_fragment(F) && !in_primary_module_interface_unit(F) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.private.frag"
source_module = "[module.private.frag]/1"
tags = ['module', 'private-fragment', 'primary-interface']

[[axioms]]
id = "cpp20_module_private_frag_only_unit_1c2d3e4f"
content = '''A module unit with a private-module-fragment shall be the only module unit of its module.'''
formal_spec = '''module_unit(U) && has_private_module_fragment(U) && module_of(U, M) && count(module_units(M)) > 1 => ill_formed_no_diagnostic_required'''
layer = "cpp20_language"
confidence = 0.95
source_file = "module.private.frag"
source_module = "[module.private.frag]/1"
tags = ['module', 'private-fragment', 'single-unit']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_variadic_params_a7f3b2c1"
content = '''The parameter-declaration-clause of a coroutine shall not terminate with an ellipsis that is not part of a parameter-declaration (i.e., C-style variadic parameters are not allowed in coroutines).'''
formal_spec = '''is_coroutine(F) && has_c_variadic_ellipsis(parameter_declaration_clause(F)) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/1"
tags = ['coroutine', 'parameters', 'variadic', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_promise_type_class_d4e5f6a7"
content = '''The promise type of a coroutine shall be a class type.'''
formal_spec = '''is_coroutine(F) && promise_type(F) = std::coroutine_traits<R, P...>::promise_type => is_class_type(promise_type(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/3"
tags = ['coroutine', 'promise_type', 'constraint', 'type']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_both_return_void_value_b8c9d0e1"
content = '''If searches for the names return_void and return_value in the scope of the promise type each find any declarations, the program is ill-formed.'''
formal_spec = '''is_coroutine(F) && has_declaration(promise_type(F), "return_void") && has_declaration(promise_type(F), "return_value") => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/7"
tags = ['coroutine', 'promise_type', 'return_void', 'return_value', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_resume_not_suspended_ub_c2d3e4f5"
content = '''Invoking a resumption member function for a coroutine that is not suspended results in undefined behavior.'''
formal_spec = '''is_coroutine_handle(H) && refers_to_coroutine(H, C) && !is_suspended(C) && invoke_resumption_member_function(H) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/9"
tags = ['coroutine', 'coroutine_handle', 'resume', 'undefined_behavior', 'lifetime']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_destroy_not_suspended_ub_f6a7b8c9"
content = '''If destroy is called for a coroutine that is not suspended, the program has undefined behavior.'''
formal_spec = '''is_coroutine_handle(H) && refers_to_coroutine(H, C) && !is_suspended(C) && call_destroy(H) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/12"
tags = ['coroutine', 'coroutine_handle', 'destroy', 'undefined_behavior', 'lifetime']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_no_deallocation_func_d0e1f2a3"
content = '''If no usual deallocation function is found for coroutine state destruction, the program is ill-formed.'''
formal_spec = '''is_coroutine(F) && !exists_usual_deallocation_function(promise_type(F)) && !exists_usual_deallocation_function(global_scope) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/13"
tags = ['coroutine', 'deallocation', 'memory', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_final_suspend_nothrow_e4f5a6b7"
content = '''The expression co_await promise.final_suspend() shall not be potentially-throwing.'''
formal_spec = '''is_coroutine(F) && is_potentially_throwing(co_await_expr(promise.final_suspend())) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/16"
tags = ['coroutine', 'final_suspend', 'exception', 'noexcept', 'constraint']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_flowoff_no_return_void_ub_a8b9c0d1"
content = '''If return_void is not found in promise type, flowing off the end of a coroutine results in undefined behavior.'''
formal_spec = '''is_coroutine(F) && !has_declaration(promise_type(F), "return_void") && flows_off_end(F) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.85
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/7"
tags = ['coroutine', 'return_void', 'undefined_behavior', 'control_flow']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_ref_param_lifetime_ub_e2f3a4b5"
content = '''If a coroutine has a parameter passed by reference, resuming the coroutine after the lifetime of the entity referred to by that parameter has ended is likely to result in undefined behavior.'''
formal_spec = '''is_coroutine(F) && has_reference_parameter(F, P) && resume_coroutine(F) && !lifetime_active(referred_entity(P)) => undefined_behavior'''
layer = "cpp20_language"
confidence = 0.75
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/14"
tags = ['coroutine', 'reference', 'parameter', 'lifetime', 'undefined_behavior']

[[axioms]]
id = "cpp20_dcl_fct_def_coroutine_alloc_fail_nothrow_c6d7e8f9"
content = '''When get_return_object_on_allocation_failure is declared in the promise type and a global allocation function is selected, the ::operator new(size_t, nothrow_t) form is used. The allocation function used in this case shall have a non-throwing noexcept-specifier.'''
formal_spec = '''is_coroutine(F) && has_declaration(promise_type(F), "get_return_object_on_allocation_failure") && uses_global_allocation(F) => is_nothrow(allocation_function(F))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "dcl.fct.def.coroutine"
source_module = "[dcl.fct.def.coroutine]/11"
tags = ['coroutine', 'allocation', 'nothrow', 'constraint']

[[axioms]]
id = "cpp20_temp_constr_constr_general_satisfaction_required_a3f7b2c1"
content = '''For a constrained template to be instantiated, its associated constraints shall be satisfied.'''
formal_spec = '''constrained_template(T) && instantiate(T) => satisfied(associated_constraints(T))'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.constr.general"
source_module = "[temp.constr.constr.general]/2"
tags = ['templates', 'constraints', 'instantiation']

[[axioms]]
id = "cpp20_temp_constr_atomic_bool_type_required_d8e4f1a9"
content = '''After substitution and lvalue-to-rvalue conversion, an atomic constraint expression E shall be a constant expression of type bool.'''
formal_spec = '''atomic_constraint(E) && substitution_valid(E) && lvalue_to_rvalue_if_needed(E) => is_constant_expr(E) && type(E) == bool'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/3"
tags = ['constraints', 'atomic', 'constant-expression', 'bool']

[[axioms]]
id = "cpp20_temp_constr_atomic_substitution_failure_not_satisfied_c2b1e5f8"
content = '''If substitution into an atomic constraint results in an invalid type or expression in the immediate context, the constraint is not satisfied.'''
formal_spec = '''atomic_constraint(C) && substitution_fails_immediate_context(C) => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/3"
tags = ['constraints', 'atomic', 'substitution', 'SFINAE']

[[axioms]]
id = "cpp20_temp_constr_atomic_satisfaction_consistency_ndr_f9a2c4d7"
content = '''If at different points in the program, the satisfaction result is different for identical atomic constraints and template arguments, the program is ill-formed, no diagnostic required.'''
formal_spec = '''identical_atomic_constraints(C1, C2) && same_template_args(A1, A2) && satisfaction(C1, A1) != satisfaction(C2, A2) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/3"
tags = ['constraints', 'atomic', 'odr', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_atomic_identity_functionally_equiv_ndr_b7c3a1e6"
content = '''If the validity or meaning of the program depends on whether two atomic constraints are equivalent, and they are functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required.'''
formal_spec = '''depends_on_equivalence(C1, C2) && functionally_equivalent(C1, C2) && NOT equivalent(C1, C2) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.atomic"
source_module = "[temp.constr.atomic]/2"
tags = ['constraints', 'atomic', 'equivalence', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_concept_substitution_failure_not_satisfied_e4d8f2a3"
content = '''If substitution into a concept-dependent constraint results in an invalid concept-id in the immediate context, the constraint is not satisfied.'''
formal_spec = '''concept_dependent_constraint(CD) && substitution_invalid_concept_id(CD) => NOT satisfied(CD)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.concept"
source_module = "[temp.constr.concept]/2"
tags = ['constraints', 'concept', 'substitution', 'SFINAE']

[[axioms]]
id = "cpp20_temp_constr_fold_conjunction_invalid_pack_not_satisfied_a1b9c7d5"
content = '''A fold expanded constraint with && operator is satisfied only if it is a valid pack expansion.'''
formal_spec = '''fold_constraint(C, '&&') && NOT valid_pack_expansion(C) => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/2"
tags = ['constraints', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_fold_disjunction_empty_not_satisfied_c5e3a8f2"
content = '''A fold expanded constraint with || operator is not satisfied if the pack expansion has zero elements (N=0).'''
formal_spec = '''fold_constraint(C, '||') && pack_size(C) == 0 => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/3"
tags = ['constraints', 'fold', 'pack-expansion', 'disjunction']

[[axioms]]
id = "cpp20_temp_constr_fold_disjunction_invalid_pack_not_satisfied_d2f4b6c8"
content = '''A fold expanded constraint with || operator is satisfied only if it is a valid pack expansion.'''
formal_spec = '''fold_constraint(C, '||') && NOT valid_pack_expansion(C) => NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/3"
tags = ['constraints', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_fold_different_size_packs_invalid_e7a1c3d9"
content = '''If a fold expanded constraint expands packs of different sizes, the pack expansion is invalid and the constraint is not satisfied.'''
formal_spec = '''fold_constraint(C) && expands_packs_different_sizes(C) => NOT valid_pack_expansion(C) && NOT satisfied(C)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.fold"
source_module = "[temp.constr.fold]/4"
tags = ['constraints', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_normal_invalid_concept_id_ndr_f8b2c4a6"
content = '''During constraint normalization of a concept-id, if substitution of non-dependent concept template arguments results in an invalid concept-id, the program is ill-formed, no diagnostic required.'''
formal_spec = '''normalizing_concept_id(CI) && substitution_invalid(non_dependent_args(CI)) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.4.2"
tags = ['constraints', 'normalization', 'concept', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_normal_invalid_type_expr_ndr_a9c5e7b1"
content = '''During constraint normalization, if substitution of template parameters in parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.'''
formal_spec = '''normalizing_concept_id(CI) && substitution_in_mapping_invalid(CI) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.4.2"
tags = ['constraints', 'normalization', 'substitution', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_normal_fold_mixed_packs_error_b3d7f1c8"
content = '''In a fold expression for constraint normalization, if E contains an unexpanded concept template parameter pack, it shall not contain an unexpanded template parameter pack of another kind.'''
formal_spec = '''fold_expr_normalization(E) && has_unexpanded_concept_pack(E) && has_unexpanded_other_pack(E) => ill_formed'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.5.3"
tags = ['constraints', 'normalization', 'fold', 'pack-expansion']

[[axioms]]
id = "cpp20_temp_constr_normal_fold_pack_size_mismatch_ndr_c4e8a2f5"
content = '''During fold expression normalization, if concept template parameter packs have corresponding arguments with different counts, the program is ill-formed, no diagnostic required.'''
formal_spec = '''fold_normalization(F) && concept_pack_arg_counts_differ(F) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.85
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.5.3.1"
tags = ['constraints', 'normalization', 'fold', 'pack-expansion', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_normal_fold_substitution_invalid_ndr_d5f9b3a7"
content = '''During fold expression normalization, if substitution of concept arguments results in an invalid type or expression, the program is ill-formed, no diagnostic required.'''
formal_spec = '''fold_normalization(F) && substitution_concept_args_invalid(F) => ill_formed_ndr'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.normal"
source_module = "[temp.constr.normal]/1.5.3.1"
tags = ['constraints', 'normalization', 'fold', 'substitution', 'ill-formed-ndr']

[[axioms]]
id = "cpp20_temp_constr_order_concept_dependent_not_eligible_e6a2c4b8"
content = '''The associated constraints of a declaration are not eligible for subsumption if they contain a concept-dependent constraint.'''
formal_spec = '''contains_concept_dependent_constraint(associated_constraints(D)) => NOT eligible_for_subsumption(D)'''
layer = "cpp20_language"
confidence = 0.95
source_file = "temp.constr.order"
source_module = "[temp.constr.order]/3"
tags = ['constraints', 'subsumption', 'partial-ordering', 'concept-dependent']

[[axioms]]
id = "cpp20_cmp_categories_pre_literal_zero_arg_4f8a2b1c"
content = '''Supplying an argument other than literal 0 to comparison category type relational/equality operators is undefined behavior.'''
formal_spec = '''is_comparison_category_type(T) && is_relational_or_equality_op(op) && arg_to_unspecified_param(op, arg) && arg != literal_0 => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.categories.pre"
source_module = "[cmp.categories.pre]/3"
tags = ['comparison', 'undefined-behavior', 'literal']

[[axioms]]
id = "cpp20_cmp_result_specialization_ub_7e3d1a9f"
content = '''Adding specializations for the compare_three_way_result template is undefined behavior.'''
formal_spec = '''user_specialization(compare_three_way_result<T, U>) => undefined_behavior'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.result"
source_module = "[cmp.result]/1"
tags = ['comparison', 'template-specialization', 'undefined-behavior']

[[axioms]]
id = "cpp20_compare_type_specialization_illformed_2c5f8e4a"
content = '''Declaring an explicit specialization or partial specialization of type_order makes the program ill-formed.'''
formal_spec = '''(explicit_specialization(type_order<T, U>) || partial_specialization(type_order<T, U>)) => ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "compare.type"
source_module = "[compare.type]/2"
tags = ['comparison', 'template-specialization', 'type-ordering']

[[axioms]]
id = "cpp20_cmp_alg_strong_order_same_type_3a9c7b2d"
content = '''strong_order(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => strong_order(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/1.1"
tags = ['comparison', 'customization-point', 'strong-order']

[[axioms]]
id = "cpp20_cmp_alg_weak_order_same_type_5d8e4f1a"
content = '''weak_order(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => weak_order(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/2.1"
tags = ['comparison', 'customization-point', 'weak-order']

[[axioms]]
id = "cpp20_cmp_alg_partial_order_same_type_8b2c3e9f"
content = '''partial_order(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => partial_order(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/3.1"
tags = ['comparison', 'customization-point', 'partial-order']

[[axioms]]
id = "cpp20_cmp_alg_strong_fallback_same_type_1e7f9a3b"
content = '''compare_strong_order_fallback(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => compare_strong_order_fallback(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/4.1"
tags = ['comparison', 'customization-point', 'fallback']

[[axioms]]
id = "cpp20_cmp_alg_weak_fallback_same_type_6c4d2e8a"
content = '''compare_weak_order_fallback(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => compare_weak_order_fallback(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/5.1"
tags = ['comparison', 'customization-point', 'fallback']

[[axioms]]
id = "cpp20_cmp_alg_partial_fallback_same_type_9f1b5c7d"
content = '''compare_partial_order_fallback(E, F) is ill-formed if the decayed types of E and F differ.'''
formal_spec = '''decay_t<decltype(E)> != decay_t<decltype(F)> => compare_partial_order_fallback(E, F) is ill_formed'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.alg"
source_module = "[cmp.alg]/6.1"
tags = ['comparison', 'customization-point', 'fallback']

[[axioms]]
id = "cpp20_cmp_common_void_non_category_a3b8c2d1"
content = '''common_comparison_category yields void if any template argument is not a comparison category type.'''
formal_spec = '''exists(T in Ts, !is_comparison_category_type(T)) => common_comparison_category<Ts...>::type == void'''
layer = "cpp20_stdlib"
confidence = 0.95
source_file = "cmp.common"
source_module = "[cmp.common]/2"
tags = ['comparison', 'type-trait', 'common-type']

[[axioms]]
id = "cpp20_cmp_concept_partially_ordered_symmetry_7d9e1f2a"
content = '''For types modeling partially-ordered-with, relational operator results must be symmetric: bool(t<u)==bool(u>t), bool(u<t)==bool(t>u), bool(t<=u)==bool(u>=t), bool(u<=t)==bool(t>=u).'''
formal_spec = '''models(partially_ordered_with<T, U>) => (bool(t<u)==bool(u>t)) && (bool(u<t)==bool(t>u)) && (bool(t<=u)==bool(u>=t)) && (bool(u<=t)==bool(t>=u))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/1"
tags = ['comparison', 'concept', 'semantic-constraint']

[[axioms]]
id = "cpp20_cmp_concept_three_way_eq_consistency_4e8f3a1b"
content = '''For types modeling three_way_comparable, (a<=>b==0)==bool(a==b) and (a<=>b!=0)==bool(a!=b) must hold.'''
formal_spec = '''models(three_way_comparable<T, Cat>) => ((a<=>b==0)==bool(a==b)) && ((a<=>b!=0)==bool(a!=b))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.1-2.2"
tags = ['comparison', 'concept', 'semantic-constraint', 'three-way']

[[axioms]]
id = "cpp20_cmp_concept_three_way_rel_consistency_5a7c9d2e"
content = '''For types modeling three_way_comparable, the three-way comparison must be consistent with relational operators.'''
formal_spec = '''models(three_way_comparable<T, Cat>) => ((a<=>b<0)==bool(a<b)) && ((a<=>b>0)==bool(a>b)) && ((a<=>b<=0)==bool(a<=b)) && ((a<=>b>=0)==bool(a>=b))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.4-2.7"
tags = ['comparison', 'concept', 'semantic-constraint', 'three-way']

[[axioms]]
id = "cpp20_cmp_concept_strong_ordering_total_8b3f1e4c"
content = '''For types modeling three_way_comparable with Cat convertible to strong_ordering, the type must also model totally_ordered.'''
formal_spec = '''models(three_way_comparable<T, Cat>) && is_convertible_v<Cat, strong_ordering> => models(totally_ordered<T>)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/2.8"
tags = ['comparison', 'concept', 'semantic-constraint', 'strong-ordering']

[[axioms]]
id = "cpp20_cmp_concept_three_way_with_domain_2c4e6f8a"
content = '''For types modeling three_way_comparable_with, t<=>u and u<=>t must have the same domain.'''
formal_spec = '''models(three_way_comparable_with<T, U, Cat>) => same_domain(t<=>u, u<=>t)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.1"
tags = ['comparison', 'concept', 'semantic-constraint', 'three-way']

[[axioms]]
id = "cpp20_cmp_concept_three_way_with_strong_total_9d1a3b5c"
content = '''For types modeling three_way_comparable_with with Cat convertible to strong_ordering, T and U must also model totally_ordered_with.'''
formal_spec = '''models(three_way_comparable_with<T, U, Cat>) && is_convertible_v<Cat, strong_ordering> => models(totally_ordered_with<T, U>)'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.concept"
source_module = "[cmp.concept]/3.10"
tags = ['comparison', 'concept', 'semantic-constraint', 'strong-ordering']

[[axioms]]
id = "cpp20_cmp_strongord_substitutability_1f8e2d4a"
content = '''For strong_ordering, equality implies substitutability: f(a)==f(b) when a==b, where f reads only comparison-salient public const state.'''
formal_spec = '''type_uses(T, strong_ordering) && a == b => forall(f: comparison_salient_function, f(a) == f(b))'''
layer = "cpp20_stdlib"
confidence = 0.85
source_file = "cmp.categories.pre"
source_module = "[cmp.categories.pre]/4"
tags = ['comparison', 'strong-ordering', 'substitutability', 'semantic-constraint']
