version = "1.0"
source = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu_profiles.hpp, /home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp, /home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp (+4 more)"
extracted_at = "2026-01-02T10:35:34+00:00"

[[axioms]]
id = "ilp::cpu::Profile.trivially_copyable"
content = '''Profile is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(Profile)'''
layer = "user_library"
confidence = 1.0
source_file = "ilp_cpu_profiles.hpp"
source_module = "ilp_cpu_profilespp"
source_line_start = 15
source_line_end = 15
function = "ilp::cpu::Profile"
header = "ilp_cpu_profiles.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if Profile contains non-trivially-copyable members'''

[[axioms]]
id = "ilp::LoopType.scoped"
content = '''LoopType is a scoped enum (enum class) - values require qualification'''
formal_spec = '''is_scoped_enum(LoopType)'''
layer = "user_library"
confidence = 1.0
source_file = "ilp_optimal_n.hpp"
source_module = "ilp_optimal_npp"
source_line_start = 22
source_line_end = 22
function = "ilp::LoopType"
header = "ilp_optimal_n.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if attempting to use unqualified enum values'''

[[axioms]]
id = "ilp::detail::compute_optimal_N.constexpr"
content = '''compute_optimal_N can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "ilp_optimal_n.hpp"
source_module = "ilp_optimal_npp"
source_line_start = 39
source_line_end = 39
function = "ilp::detail::compute_optimal_N"
header = "ilp_optimal_n.hpp"
signature = '''constexpr std::size_t compute_optimal_N()'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr arguments'''

[[axioms]]
id = "ilp::detail::compute_optimal_N.complexity.template_instantiation"
content = '''compute_optimal_N is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^2)'''
layer = "user_library"
confidence = 0.95
source_file = "ilp_optimal_n.hpp"
source_module = "ilp_optimal_npp"
source_line_start = 39
source_line_end = 39
function = "ilp::detail::compute_optimal_N"
header = "ilp_optimal_n.hpp"
signature = '''constexpr std::size_t compute_optimal_N()'''
axiom_type = "complexity"
on_violation = '''Increased binary size and compilation time with many unique template argument combinations'''

[[axioms]]
id = "ilp::detail::is_optional.trivially_copyable"
content = '''is_optional is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(is_optional)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 31
source_line_end = 31
function = "ilp::detail::is_optional"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if is_optional contains non-trivially-copyable members'''

[[axioms]]
id = "ilp::LoopCtrl.trivially_copyable"
content = '''LoopCtrl is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(LoopCtrl)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 39
source_line_end = 39
function = "ilp::LoopCtrl"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if LoopCtrl contains non-trivially-copyable members'''

[[axioms]]
id = "ilp::LoopCtrl::break_loop.complexity.template_instantiation"
content = '''break_loop is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 43
source_line_end = 43
function = "ilp::LoopCtrl::break_loop"
header = "ctrl.hpp"
signature = '''void break_loop()'''
axiom_type = "complexity"
on_violation = '''Increased binary size and compilation time with many unique template argument combinations'''

[[axioms]]
id = "ilp::LoopCtrl::break_loop.effect.writes_ok"
content = '''Writes to member ok'''
formal_spec = '''modifies(this.ok)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 43
source_line_end = 43
function = "ilp::LoopCtrl::break_loop"
header = "ctrl.hpp"
signature = '''void break_loop()'''
axiom_type = "effect"
on_violation = '''Loop continues executing instead of breaking'''

[[axioms]]
id = "ilp::LoopCtrl::return_with.complexity.template_instantiation"
content = '''return_with is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 44
source_line_end = 44
function = "ilp::LoopCtrl::return_with"
header = "ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "complexity"
on_violation = '''Increased binary size and compilation time with many unique template argument combinations'''

[[axioms]]
id = "ilp::LoopCtrl::return_with.effect.writes_ok"
content = '''Writes to member ok'''
formal_spec = '''modifies(this.ok)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 45
source_line_end = 45
function = "ilp::LoopCtrl::return_with"
header = "ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "effect"
on_violation = '''Loop continues executing instead of breaking with return value'''

[[axioms]]
id = "ilp::LoopCtrl::return_with.effect.writes_return_value"
content = '''Writes to member return_value'''
formal_spec = '''modifies(this.return_value)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 46
source_line_end = 46
function = "ilp::LoopCtrl::return_with"
header = "ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "effect"
on_violation = '''Return value is not stored, leading to undefined behavior when extracted'''

[[axioms]]
id = "ilp::LoopCtrl<>::break_loop.effect.writes_ok"
content = '''Writes to member ok'''
formal_spec = '''modifies(this.ok)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 53
source_line_end = 53
function = "ilp::LoopCtrl<>::break_loop"
header = "ctrl.hpp"
signature = '''void break_loop()'''
axiom_type = "effect"
on_violation = '''Loop continues executing instead of breaking'''

[[axioms]]
id = "ilp::SmallStorage.trivially_copyable"
content = '''SmallStorage is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(SmallStorage)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 60
source_line_end = 60
function = "ilp::SmallStorage"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if SmallStorage contains non-trivially-copyable members'''

[[axioms]]
id = "ilp::SmallStorage::set.complexity.template_instantiation"
content = '''set is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 22
source_line_end = 22
function = "ilp::SmallStorage::set"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "'''
axiom_type = "complexity"
on_violation = '''Increased binary size and compilation time with many unique template argument combinations'''

[[axioms]]
id = "ilp::SmallStorage::set.effect.allocates"
content = '''Allocates memory for U'''
formal_spec = '''allocates(U)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 73
source_line_end = 73
function = "ilp::SmallStorage::set"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "'''
axiom_type = "effect"
on_violation = '''Memory is not properly initialized for type U'''

[[axioms]]
id = "U.type_alias"
content = '''U is an alias for std::decay_t<T>'''
formal_spec = '''type(U) == std::decay_t<T>'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 65
source_line_end = 65
function = "U"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Type mismatch if U is used incorrectly in template contexts'''

[[axioms]]
id = "ctrl.hpp.static_assert.66"
content = '''Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.'''
formal_spec = '''sizeof(U) <= arch::sbo_size'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 66
source_line_end = 66
header = "ctrl.hpp"
axiom_type = "invariant"
on_violation = '''Compilation error with message: Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.'''

[[axioms]]
id = "ctrl.hpp.static_assert.68"
content = '''Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.'''
formal_spec = '''alignof(U) <= arch::sbo_size'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 68
source_line_end = 68
header = "ctrl.hpp"
axiom_type = "invariant"
on_violation = '''Compilation error with message: Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.'''

[[axioms]]
id = "ctrl.hpp.static_assert.70"
content = '''SmallStorage only supports trivially-destructible types. Use ILP_FOR_T(type, ...) for non-trivial return types.'''
formal_spec = '''std::is_trivially_destructible_v<U>'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 70
source_line_end = 70
header = "ctrl.hpp"
axiom_type = "invariant"
on_violation = '''Compilation error with message: SmallStorage only supports trivially-destructible types. Use ILP_FOR_T(type, ...) for non-trivial return types.'''

[[axioms]]
id = "loops_common.hpp.static_assert.45"
content = '''Unroll factor N must be at least 1'''
formal_spec = '''N >= 1'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 45
source_line_end = 45
header = "loops_common.hpp"
axiom_type = "invariant"
on_violation = '''Compilation error with message: Unroll factor N must be at least 1'''

[[axioms]]
id = "loops_ilp.hpp.static_assert.91"
content = '''Lambda must be invocable with (Ref) or (Ref, LoopCtrl<void>&)'''
formal_spec = '''ForRangeBody<F, Ref>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 91
source_line_end = 91
header = "loops_ilp.hpp"
axiom_type = "invariant"
on_violation = '''Compilation error with message: Lambda must be invocable with (Ref) or (Ref, LoopCtrl<void>&)'''

[[axioms]]
id = "ilp::SmallStorage::extract.complexity.template_instantiation"
content = '''extract is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 22
source_line_end = 22
function = "ilp::SmallStorage::extract"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* pt'''
axiom_type = "complexity"
on_violation = '''Increased binary size and compilation time with many unique template argument combinations'''

[[axioms]]
id = "ilp::SmallStorage::extract.precond.ptr_valid"
content = '''Pointer std::launder(reinterpret_cast<R*>(buffer)) must not be null'''
formal_spec = '''std::launder(reinterpret_cast<R*>(buffer)) != nullptr'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 78
source_line_end = 78
function = "ilp::SmallStorage::extract"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* pt'''
axiom_type = "precondition"
on_violation = '''Dereferencing null pointer causes undefined behavior'''

[[axioms]]
id = "ilp::SmallStorage::extract.precond.bounds_check"
content = ''''''
formal_spec = ''''''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 78
source_line_end = 78
function = "ilp::SmallStorage::extract"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* pt'''
axiom_type = "precondition"
on_violation = '''Reading uninitialized memory or wrong type causes undefined behavior'''

[[axioms]]
id = "ilp::TypedStorage.trivially_copyable"
content = '''TypedStorage is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(TypedStorage)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 85
source_line_end = 85
function = "ilp::TypedStorage"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if TypedStorage contains non-trivially-copyable members'''

[[axioms]]
id = "ilp::TypedStorage::set.complexity.template_instantiation"
content = '''set is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 22
source_line_end = 22
function = "ilp::TypedStorage::set"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size s'''
axiom_type = "complexity"
on_violation = '''Increased binary size and compilation time with many unique template argument combinations'''

[[axioms]]
id = "ilp::TypedStorage::set.effect.allocates"
content = '''Allocates memory for R'''
formal_spec = '''allocates(R)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 90
source_line_end = 90
function = "ilp::TypedStorage::set"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size s'''
axiom_type = "effect"
on_violation = '''Memory is not properly initialized for type R'''

[[axioms]]
id = "ilp::LoopCtrl::break_loop.postcond"
content = '''After break_loop, ok is set to false'''
formal_spec = '''ensures(this.ok == false)'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::LoopCtrl::break_loop"
axiom_type = "postcondition"
on_violation = '''Loop control flow becomes inconsistent'''

[[axioms]]
id = "ilp::LoopCtrl::return_with.postcond"
content = '''After return_with, ok is false and return_value contains the provided value'''
formal_spec = '''ensures(this.ok == false && this.return_value.has_value())'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::LoopCtrl::return_with"
axiom_type = "postcondition"
on_violation = '''Loop control flow or return value extraction becomes inconsistent'''

[[axioms]]
id = "ilp::LoopCtrl<>::break_loop.postcond"
content = '''After break_loop, ok is set to false'''
formal_spec = '''ensures(this.ok == false)'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::LoopCtrl<>::break_loop"
axiom_type = "postcondition"
on_violation = '''Loop control flow becomes inconsistent'''

[[axioms]]
id = "ilp::SmallStorage::set.postcond"
content = '''After set, buffer contains a valid object of type U constructed from the provided argument'''
formal_spec = '''ensures(buffer contains U && is_initialized(buffer))'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::SmallStorage::set"
axiom_type = "postcondition"
on_violation = '''Subsequent extract operations may return uninitialized or invalid data'''

[[axioms]]
id = "ilp::SmallStorage::extract.postcond"
content = '''Returns a reference to the object of type R stored in buffer'''
formal_spec = '''ensures(return_value == *std::launder(reinterpret_cast<R*>(buffer)))'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::SmallStorage::extract"
axiom_type = "postcondition"
on_violation = '''Caller receives invalid reference leading to undefined behavior'''

[[axioms]]
id = "ilp::TypedStorage::set.postcond"
content = '''After set, storage contains a valid object of type R constructed from the provided argument'''
formal_spec = '''ensures(storage contains R && is_initialized(storage))'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::TypedStorage::set"
axiom_type = "postcondition"
on_violation = '''Subsequent access operations may return uninitialized or invalid data'''

[[axioms]]
id = "ilp::TypedStorage::extract.complexity.template_instantiation"
content = '''extract is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 22
source_line_end = 22
function = "ilp::TypedStorage::extract"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size storage)
    template<typename R>
    struct ForCtrlTyped {
        bool ok = true;
        bool return'''
axiom_type = "complexity"
on_violation = '''Code bloat from excessive template instantiations; increased binary size and compilation time'''

[[axioms]]
id = "ilp::TypedStorage::extract.precond.bounds_check"
content = ''''''
formal_spec = ''''''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 94
source_line_end = 94
function = "ilp::TypedStorage::extract"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size storage)
    template<typename R>
    struct ForCtrlTyped {
        bool ok = true;
        bool return'''
axiom_type = "precondition"
on_violation = '''Out-of-bounds memory access; undefined behavior, potential segmentation fault'''

[[axioms]]
id = "ilp::TypedStorage::extract.precond.ptr_valid"
content = '''Pointer p must not be null'''
formal_spec = '''p != nullptr'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 95
source_line_end = 95
function = "ilp::TypedStorage::extract"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size storage)
    template<typename R>
    struct ForCtrlTyped {
        bool ok = true;
        bool return'''
axiom_type = "precondition"
on_violation = '''Null pointer dereference; undefined behavior, likely segmentation fault'''

[[axioms]]
id = "ilp::ForCtrl.trivially_copyable"
content = '''ForCtrl is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(ForCtrl)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 102
source_line_end = 102
function = "ilp::ForCtrl"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if constraint violated; potential memory corruption if bypassed with memcpy/memmove'''

[[axioms]]
id = "ilp::ForCtrlTyped.trivially_copyable"
content = '''ForCtrlTyped is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(ForCtrlTyped)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 110
source_line_end = 110
function = "ilp::ForCtrlTyped"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if constraint violated; potential memory corruption if bypassed with memcpy/memmove'''

[[axioms]]
id = "ilp::ForResult.trivially_copyable"
content = '''ForResult is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(ForResult)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 116
source_line_end = 116
function = "ilp::ForResult"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if constraint violated; potential memory corruption if bypassed with memcpy/memmove'''

[[axioms]]
id = "ilp::ForResult::operator bool.noexcept"
content = '''operator bool is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 120
source_line_end = 120
function = "ilp::ForResult::operator bool"
header = "ctrl.hpp"
signature = '''explicit operator bool() const noexcept'''
axiom_type = "exception"
on_violation = '''Compilation error if throwing code added; std::terminate if exception escapes noexcept function'''

[[axioms]]
id = "ilp::ForResult::operator bool.const"
content = '''operator bool does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 120
source_line_end = 120
function = "ilp::ForResult::operator bool"
header = "ctrl.hpp"
signature = '''explicit operator bool() const noexcept'''
axiom_type = "effect"
on_violation = '''Compilation error if non-const operations performed; logical error if mutable state modified'''

[[axioms]]
id = "ilp::ForResult::Proxy.trivially_copyable"
content = '''Proxy is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(Proxy)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 123
source_line_end = 123
function = "ilp::ForResult::Proxy"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if constraint violated; potential memory corruption if bypassed with memcpy/memmove'''

[[axioms]]
id = "ilp::ForResult::Proxy::operator type-parameter-0-0.complexity.template_instantiation"
content = '''operator type-parameter-0-0 is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 22
source_line_end = 22
function = "ilp::ForResult::Proxy::operator type-parameter-0-0"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size storage)
    template<typename R>
    struct ForCtrlTyped {
        bool ok = true;
        bool return_set = false;
        TypedStorage<R> storage;
    };

    struct [[nodiscard("ILP_RETURN value ignored - did you mean ILP_END_RETURN?")]] ForResult {
        bool has_return;
        SmallStorage storage;

        explicit operator bool() const noexcept { return has_return; }

        // deduces type from function return
        struct Proxy {
            SmallStorage& s;

#if defined(_MSC_VER) && !defined(__clang__)
            // MSVC needs explicit overloads without && qualifier
            // templated conversion operators don't deduce properly in return statements
            template<typename T>
            operator std::optional<T>() {
                return std::optional<T>(s.template extract<T>());
            }

            template<typename R, std::enable_if_t<!detail::is_optional_v<R>, int> = 0>
            operator R() {
                return s.template extract<R>();
            }
#else
            // GCC/Clang do implicit ProxyToptional
            template<typename R>
                requires(!detail::is_optional_v<R>)
            ILP_ALWAYS_INLINE operator R() && {
                return s.template extract<R>();
            }
#endif

            void operator*() && {}
        };

        ILP_ALWAYS_INLINE Proxy operator*() { return {storage}; }
    };

    // ForResult for typed version
    template<typename R>
    struct [[nodiscard("ILP_RETURN value ignored - did you mean ILP_END_RETURN?")]] ForResultTyped {
        bool has_return;
        TypedStorage<R> storage;

        explicit operator bool() const noexcept { return has_return; }

        // Proxy for consistency with'''
axiom_type = "complexity"
on_violation = '''Code bloat from excessive template instantiations; increased binary size and compilation time'''

[[axioms]]
id = "ilp::ForResultTyped.trivially_copyable"
content = '''ForResultTyped is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(ForResultTyped)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 155
source_line_end = 155
function = "ilp::ForResultTyped"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if constraint violated; potential memory corruption if bypassed with memcpy/memmove'''

[[axioms]]
id = "ilp::ForResultTyped::operator bool.noexcept"
content = '''operator bool is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 159
source_line_end = 159
function = "ilp::ForResultTyped::operator bool"
header = "ctrl.hpp"
signature = '''explicit operator bool() const noexcept'''
axiom_type = "exception"
on_violation = '''Compilation error if throwing code added; std::terminate if exception escapes noexcept function'''

[[axioms]]
id = "ilp::ForResultTyped::operator bool.const"
content = '''operator bool does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 159
source_line_end = 159
function = "ilp::ForResultTyped::operator bool"
header = "ctrl.hpp"
signature = '''explicit operator bool() const noexcept'''
axiom_type = "effect"
on_violation = '''Compilation error if non-const operations performed; logical error if mutable state modified'''

[[axioms]]
id = "ilp::ForResultTyped::operator bool.complexity.template_instantiation"
content = '''operator bool is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 159
source_line_end = 159
function = "ilp::ForResultTyped::operator bool"
header = "ctrl.hpp"
signature = '''explicit operator bool() const noexcept'''
axiom_type = "complexity"
on_violation = '''Code bloat from excessive template instantiations; increased binary size and compilation time'''

[[axioms]]
id = "ilp::ForResultTyped::Proxy.trivially_copyable"
content = '''Proxy is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(Proxy)'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 162
source_line_end = 162
function = "ilp::ForResultTyped::Proxy"
header = "ctrl.hpp"
axiom_type = "constraint"
on_violation = '''Compilation error if constraint violated; potential memory corruption if bypassed with memcpy/memmove'''

[[axioms]]
id = "ilp::ForResultTyped::operator*.complexity.template_instantiation"
content = '''operator* is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 22
source_line_end = 22
function = "ilp::ForResultTyped::operator*"
header = "ctrl.hpp"
signature = '''inline
#else
#define ILP_ALWAYS_INLINE inline
#endif

namespace ilp {

    namespace detail {
        template<typename T>
        struct is_optional : std::false_type {};
        template<typename T>
        struct is_optional<std::optional<T>> : std::true_type {};
        template<typename T>
        inline constexpr bool is_optional_v = is_optional<T>::value;
    } // namespace detail

    template<typename R = void>
    struct LoopCtrl {
        bool ok = true;
        std::optional<R> return_value;

        void break_loop() { ok = false; }
        void return_with(R val) {
            ok = false;
            return_value = std::move(val);
        }
    };

    template<>
    struct LoopCtrl<void> {
        bool ok = true;
        void break_loop() { ok = false; }
    };

    // Small buffer optimization for integral types.
    // Buffer size matches the largest integral type on this architecture (typically 8 bytes).
    // Only supports trivially destructible types to avoid lifetime management complexity.
    // Use ILP_FOR_T for non-trivial or larger return types.
    struct SmallStorage {
        alignas(arch::sbo_size) char buffer[arch::sbo_size];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            using U = std::decay_t<T>;
            static_assert(sizeof(U) <= arch::sbo_size,
                          "Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(alignof(U) <= arch::sbo_size,
                          "Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.");
            static_assert(std::is_trivially_destructible_v<U>,
                          "SmallStorage only supports trivially-destructible types. "
                          "Use ILP_FOR_T(type, ...) for non-trivial return types.");
            new (buffer) U(static_cast<T&&>(val));
        }

        template<typename R>
        ILP_ALWAYS_INLINE R extract() {
            return static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer)));
        }
    };

    // Typed storage for user-specified types (exact size)
    // Properly destructs stored object after extraction to avoid leaks.
    template<typename R>
    struct TypedStorage {
        alignas(R) char buffer[sizeof(R)];

        template<typename T>
        ILP_ALWAYS_INLINE void set(T&& val) {
            new (buffer) R(static_cast<T&&>(val));
        }

        ILP_ALWAYS_INLINE R extract() {
            R* ptr = std::launder(reinterpret_cast<R*>(buffer));
            R tmp = static_cast<R&&>(*ptr);
            ptr->~R();
            return tmp;
        }
    };

    // ok=false means early exit (simple version - 8-byte storage)
    struct ForCtrl {
        bool ok = true;
        bool return_set = false;
        SmallStorage storage;
    };

    // ok=false means early exit (typed version - exact size storage)
    template<typename R>
    struct ForCtrlTyped {
        bool ok = true;
        bool return_set = false;
        TypedStorage<R> storage;
    };

    struct [[nodiscard("ILP_RETURN value ignored - did you mean ILP_END_RETURN?")]] ForResult {
        bool has_return;
        SmallStorage storage;

        explicit operator bool() const noexcept { return has_return; }

        // deduces type from function return
        struct Proxy {
            SmallStorage& s;

#if defined(_MSC_VER) && !defined(__clang__)
            // MSVC needs explicit overloads without && qualifier
            // templated conversion operators don't deduce properly in return statements
            template<typename T>
            operator std::optional<T>() {
                return std::optional<T>(s.template extract<T>());
            }

            template<typename R, std::enable_if_t<!detail::is_optional_v<R>, int> = 0>
            operator R() {
                return s.template extract<R>();
            }
#else
            // GCC/Clang do implicit ProxyToptional
            template<typename R>
                requires(!detail::is_optional_v<R>)
            ILP_ALWAYS_INLINE operator R() && {
                return s.template extract<R>();
            }
#endif

            void operator*() && {}
        };

        ILP_ALWAYS_INLINE Proxy operator*() { return {storage}; }
    };

    // ForResult for typed version
    template<typename R>
    struct [[nodiscard("ILP_RETURN value ignored - did you mean ILP_END_RETURN?")]] ForResultTyped {
        bool has_return;
        TypedStorage<R> storage;

        explicit operator bool() const noexcept { return has_return; }

        // Proxy for consistency with ForResult (type is known here)
        struct Proxy {
            TypedStorage<R>& s;

#if defined(_MSC_VER) && !defined(__clang__)
            operator std::optional<R>() { return std::optional<R>(s.extract()); }

            operator R() { return s.extract(); }
#else
            ILP_ALWAYS_INLINE operator R() && { return s.extract(); }
#endif
        };

        ILP_ALWAYS_INLINE Proxy operator*() { return {storage}; }
    };

    namespace detail {

        [[noreturn]] inline void ilp_end_with_return_error() {
            std::fprintf(stderr, "\n*** ILP_FOR ERROR ***\n"
                                 "ILP_RETURN was called but ILP_END was used instead of ILP_END_RETURN.\n"
                                 "The return value would be silently discarded. This is a bug.\n"
                                 "Fix: Change ILP_END to ILP_END_RETURN in the enclosing function.\n\n");
            std::abort();'''
axiom_type = "complexity"
on_violation = '''Code bloat from excessive template instantiations; increased binary size and compilation time'''

[[axioms]]
id = "ilp::LoopCtrl<>::LoopCtrl.noexcept"
content = '''LoopCtrl is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 51
source_line_end = 51
function = "ilp::LoopCtrl<>::LoopCtrl"
header = "ctrl.hpp"
signature = '''void ilp::LoopCtrl<>::LoopCtrl()'''
axiom_type = "exception"
on_violation = '''Compilation error if throwing code added; std::terminate if exception escapes noexcept function'''

[[axioms]]
id = "ilp::LoopCtrl<>::LoopCtrl.constexpr"
content = '''LoopCtrl can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 51
source_line_end = 51
function = "ilp::LoopCtrl<>::LoopCtrl"
header = "ctrl.hpp"
signature = '''void ilp::LoopCtrl<>::LoopCtrl()'''
axiom_type = "constraint"
on_violation = '''Compilation error if non-constexpr operations used in constexpr context'''

[[axioms]]
id = "ilp::SmallStorage::SmallStorage.noexcept"
content = '''SmallStorage is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 60
source_line_end = 60
function = "ilp::SmallStorage::SmallStorage"
header = "ctrl.hpp"
signature = '''void ilp::SmallStorage::SmallStorage()'''
axiom_type = "exception"
on_violation = '''Compilation error if throwing code added; std::terminate if exception escapes noexcept function'''

[[axioms]]
id = "ilp::SmallStorage::SmallStorage.constexpr"
content = '''SmallStorage can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 60
source_line_end = 60
function = "ilp::SmallStorage::SmallStorage"
header = "ctrl.hpp"
signature = '''void ilp::SmallStorage::SmallStorage()'''
axiom_type = "constraint"
on_violation = '''Compilation error if non-constexpr operations used in constexpr context'''

[[axioms]]
id = "ilp::SmallStorage::~SmallStorage.noexcept"
content = '''~SmallStorage is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 60
source_line_end = 60
function = "ilp::SmallStorage::~SmallStorage"
header = "ctrl.hpp"
signature = '''void ilp::SmallStorage::~SmallStorage()'''
axiom_type = "exception"
on_violation = '''Compilation error if throwing code added; std::terminate if exception escapes noexcept destructor'''

[[axioms]]
id = "ilp::SmallStorage::~SmallStorage.constexpr"
content = '''~SmallStorage can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 60
source_line_end = 60
function = "ilp::SmallStorage::~SmallStorage"
header = "ctrl.hpp"
signature = '''void ilp::SmallStorage::~SmallStorage()'''
axiom_type = "constraint"
on_violation = '''Compilation error if non-constexpr operations used in constexpr context'''

[[axioms]]
id = "ilp::ForCtrl::ForCtrl.noexcept"
content = '''ForCtrl is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 102
source_line_end = 102
function = "ilp::ForCtrl::ForCtrl"
header = "ctrl.hpp"
signature = '''void ilp::ForCtrl::ForCtrl()'''
axiom_type = "exception"
on_violation = '''Compilation error if throwing code added; std::terminate if exception escapes noexcept function'''

[[axioms]]
id = "ilp::ForCtrl::ForCtrl.constexpr"
content = '''ForCtrl can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 102
source_line_end = 102
function = "ilp::ForCtrl::ForCtrl"
header = "ctrl.hpp"
signature = '''void ilp::ForCtrl::ForCtrl()'''
axiom_type = "constraint"
on_violation = '''Compilation error if non-constexpr operations used in constexpr context'''

[[axioms]]
id = "ilp::TypedStorage::extract.postcond.returns_extracted_value"
content = '''Returns the value stored at the specified index cast to type T'''
formal_spec = '''result == static_cast<T>(storage[index])'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::TypedStorage::extract"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior when preconditions met'''

[[axioms]]
id = "ilp::ForResult::operator bool.postcond.validity_state"
content = '''Returns true if the result contains a valid value, false otherwise'''
formal_spec = '''result == has_value()'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::ForResult::operator bool"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior'''

[[axioms]]
id = "ilp::ForResultTyped::operator bool.postcond.validity_state"
content = '''Returns true if the typed result contains a valid value, false otherwise'''
formal_spec = '''result == has_value()'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::ForResultTyped::operator bool"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior'''

[[axioms]]
id = "ilp::ForResultTyped::operator*.precond.has_value"
content = '''Result must contain a valid value before dereferencing'''
formal_spec = '''has_value() == true'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::ForResultTyped::operator*"
axiom_type = "precondition"
on_violation = '''Dereferencing invalid result; undefined behavior, potential access to uninitialized memory'''

[[axioms]]
id = "ilp::ForResultTyped::operator*.postcond.returns_stored_value"
content = '''Returns reference to the stored value of type T'''
formal_spec = '''&result == &stored_value'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::ForResultTyped::operator*"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior when preconditions met'''

[[axioms]]
id = "ilp::LoopCtrl<>::LoopCtrl.postcond.default_initialized"
content = '''Default constructor initializes LoopCtrl to a valid default state'''
formal_spec = '''is_valid(this)'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::LoopCtrl<>::LoopCtrl"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior'''

[[axioms]]
id = "ilp::SmallStorage::SmallStorage.postcond.initialized"
content = '''Constructor initializes SmallStorage to empty or default state'''
formal_spec = '''size() == 0 || is_default_initialized()'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::SmallStorage::SmallStorage"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior'''

[[axioms]]
id = "ilp::SmallStorage::~SmallStorage.postcond.resources_released"
content = '''Destructor releases all resources owned by SmallStorage'''
formal_spec = '''all_resources_released(this)'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::SmallStorage::~SmallStorage"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior'''

[[axioms]]
id = "ilp::ForCtrl::ForCtrl.postcond.control_initialized"
content = '''Constructor initializes ForCtrl with valid loop control state'''
formal_spec = '''is_valid_loop_state(this)'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::ForCtrl::ForCtrl"
axiom_type = "postcondition"
on_violation = '''N/A - postcondition describes guaranteed behavior'''

[[axioms]]
id = "ilp::ForResult::~ForResult.noexcept"
content = '''~ForResult is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 116
source_line_end = 116
function = "ilp::ForResult::~ForResult"
header = "ctrl.hpp"
signature = '''void ilp::ForResult::~ForResult()'''
axiom_type = "exception"
on_violation = '''Program termination via std::terminate() if exception escapes destructor'''

[[axioms]]
id = "ilp::ForResult::~ForResult.constexpr"
content = '''~ForResult can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "ctrl.hpp"
source_module = "ctrlpp"
source_line_start = 116
source_line_end = 116
function = "ilp::ForResult::~ForResult"
header = "ctrl.hpp"
signature = '''void ilp::ForResult::~ForResult()'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota_view.trivially_copyable"
content = '''iota_view is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(iota_view)'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 13
source_line_end = 13
function = "ilp::iota_view"
header = "iota.hpp"
axiom_type = "constraint"
on_violation = '''Undefined behavior if copied via memcpy/memmove when non-trivially copyable'''

[[axioms]]
id = "ilp::iota_view::iterator.trivially_copyable"
content = '''iterator is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(iterator)'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 16
source_line_end = 16
function = "ilp::iota_view::iterator"
header = "iota.hpp"
axiom_type = "constraint"
on_violation = '''Undefined behavior if copied via memcpy/memmove when non-trivially copyable'''

[[axioms]]
id = "ilp::iota_view::iterator::operator*.const"
content = '''operator* does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 18
source_line_end = 18
function = "ilp::iota_view::iterator::operator*"
header = "iota.hpp"
signature = '''constexpr T operator*() const'''
axiom_type = "effect"
on_violation = '''Undefined behavior from modifying const-qualified object or breaking const-correctness guarantees'''

[[axioms]]
id = "ilp::iota_view::iterator::operator*.constexpr"
content = '''operator* can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 18
source_line_end = 18
function = "ilp::iota_view::iterator::operator*"
header = "iota.hpp"
signature = '''constexpr T operator*() const'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota_view::iterator::operator++.constexpr"
content = '''operator++ can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 19
source_line_end = 19
function = "ilp::iota_view::iterator::operator++"
header = "iota.hpp"
signature = '''constexpr iterator& operator++()'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota_view::iterator::operator++.effect.writes_value"
content = '''Writes to member value'''
formal_spec = '''modifies(this.value)'''
layer = "user_library"
confidence = 0.95
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 20
source_line_end = 20
function = "ilp::iota_view::iterator::operator++"
header = "iota.hpp"
signature = '''constexpr iterator& operator++()'''
axiom_type = "effect"
on_violation = '''Iterator remains in original state; iteration does not progress'''

[[axioms]]
id = "ilp::iota_view::iterator::operator!=.const"
content = '''operator!= does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 23
source_line_end = 23
function = "ilp::iota_view::iterator::operator!="
header = "iota.hpp"
signature = '''constexpr bool operator!=(iterator o) const'''
axiom_type = "effect"
on_violation = '''Undefined behavior from modifying const-qualified object or breaking const-correctness guarantees'''

[[axioms]]
id = "ilp::iota_view::iterator::operator!=.constexpr"
content = '''operator!= can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 23
source_line_end = 23
function = "ilp::iota_view::iterator::operator!="
header = "iota.hpp"
signature = '''constexpr bool operator!=(iterator o) const'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota_view::iterator::operator!=.postcond.bool_result"
content = '''operator!= returns a boolean indicating success/validity; true typically indicates success or valid state'''
formal_spec = '''result in {true, false}'''
layer = "user_library"
confidence = 0.85
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 23
source_line_end = 23
function = "ilp::iota_view::iterator::operator!="
header = "iota.hpp"
signature = '''constexpr bool operator!=(iterator o) const'''
axiom_type = "postcondition"
on_violation = '''Logic error if return value is not properly interpreted as boolean'''

[[axioms]]
id = "ilp::iota_view::begin.const"
content = '''begin does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 26
source_line_end = 26
function = "ilp::iota_view::begin"
header = "iota.hpp"
signature = '''constexpr iterator begin() const'''
axiom_type = "effect"
on_violation = '''Undefined behavior from modifying const-qualified object or breaking const-correctness guarantees'''

[[axioms]]
id = "ilp::iota_view::begin.constexpr"
content = '''begin can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 26
source_line_end = 26
function = "ilp::iota_view::begin"
header = "iota.hpp"
signature = '''constexpr iterator begin() const'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota_view::begin.complexity.template_instantiation"
content = '''begin is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 26
source_line_end = 26
function = "ilp::iota_view::begin"
header = "iota.hpp"
signature = '''constexpr iterator begin() const'''
axiom_type = "complexity"
on_violation = '''Increased compilation time and binary bloat from excessive template instantiations'''

[[axioms]]
id = "ilp::iota_view::end.const"
content = '''end does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 27
source_line_end = 27
function = "ilp::iota_view::end"
header = "iota.hpp"
signature = '''constexpr iterator end() const'''
axiom_type = "effect"
on_violation = '''Undefined behavior from modifying const-qualified object or breaking const-correctness guarantees'''

[[axioms]]
id = "ilp::iota_view::end.constexpr"
content = '''end can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 27
source_line_end = 27
function = "ilp::iota_view::end"
header = "iota.hpp"
signature = '''constexpr iterator end() const'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota_view::end.complexity.template_instantiation"
content = '''end is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 27
source_line_end = 27
function = "ilp::iota_view::end"
header = "iota.hpp"
signature = '''constexpr iterator end() const'''
axiom_type = "complexity"
on_violation = '''Increased compilation time and binary bloat from excessive template instantiations'''

[[axioms]]
id = "ilp::iota.constexpr"
content = '''iota can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 31
source_line_end = 31
function = "ilp::iota"
header = "iota.hpp"
signature = '''constexpr iota_view<T> iota(T start, T end)'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::iota.complexity.template_instantiation"
content = '''iota is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "iota.hpp"
source_module = "iotapp"
source_line_start = 31
source_line_end = 31
function = "ilp::iota"
header = "iota.hpp"
signature = '''constexpr iota_view<T> iota(T start, T end)'''
axiom_type = "complexity"
on_violation = '''Increased compilation time and binary bloat from excessive template instantiations'''

[[axioms]]
id = "ilp::detail::no_return_t.trivially_copyable"
content = '''no_return_t is trivially copyable (safe for memcpy/memmove)'''
formal_spec = '''is_trivially_copyable(no_return_t)'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 21
source_line_end = 21
function = "ilp::detail::no_return_t"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Undefined behavior if copied via memcpy/memmove when non-trivially copyable'''

[[axioms]]
id = "ilp::detail::no_return_t::operator bool.noexcept"
content = '''operator bool is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 22
source_line_end = 22
function = "ilp::detail::no_return_t::operator bool"
header = "loops_common.hpp"
signature = '''constexpr explicit operator bool() const noexcept'''
axiom_type = "exception"
on_violation = '''Program termination via std::terminate() if exception escapes noexcept function'''

[[axioms]]
id = "ilp::detail::no_return_t::operator bool.const"
content = '''operator bool does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 22
source_line_end = 22
function = "ilp::detail::no_return_t::operator bool"
header = "loops_common.hpp"
signature = '''constexpr explicit operator bool() const noexcept'''
axiom_type = "effect"
on_violation = '''Undefined behavior from modifying const-qualified object or breaking const-correctness guarantees'''

[[axioms]]
id = "ilp::detail::no_return_t::operator bool.constexpr"
content = '''operator bool can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 22
source_line_end = 22
function = "ilp::detail::no_return_t::operator bool"
header = "loops_common.hpp"
signature = '''constexpr explicit operator bool() const noexcept'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::detail::no_return_t::operator*.noexcept"
content = '''operator* is guaranteed not to throw exceptions'''
formal_spec = '''noexcept == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 23
source_line_end = 23
function = "ilp::detail::no_return_t::operator*"
header = "loops_common.hpp"
signature = '''void operator*() const noexcept'''
axiom_type = "exception"
on_violation = '''Program termination via std::terminate() if exception escapes noexcept function'''

[[axioms]]
id = "ilp::detail::no_return_t::operator*.const"
content = '''operator* does not modify object state'''
formal_spec = '''this->state == old(this->state)'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 23
source_line_end = 23
function = "ilp::detail::no_return_t::operator*"
header = "loops_common.hpp"
signature = '''void operator*() const noexcept'''
axiom_type = "effect"
on_violation = '''Undefined behavior from modifying const-qualified object or breaking const-correctness guarantees'''

[[axioms]]
id = "ilp::detail::for_result_t.type_alias"
content = '''for_result_t is an alias for std::conditional_t<std::is_void_v<R>, no_return_t, std::optional<R> >'''
formal_spec = '''type(for_result_t) == std::conditional_t<std::is_void_v<R>, no_return_t, std::optional<R> >'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 35
source_line_end = 35
function = "ilp::detail::for_result_t"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Type mismatch compilation error if assumption about underlying type is incorrect'''

[[axioms]]
id = "ilp::detail::warn_large_unroll_factor.constexpr"
content = '''warn_large_unroll_factor can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 41
source_line_end = 41
function = "ilp::detail::warn_large_unroll_factor"
header = "loops_common.hpp"
signature = '''constexpr void warn_large_unroll_factor()'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::detail::warn_large_unroll_factor.deprecated"
content = '''warn_large_unroll_factor is deprecated and should not be used'''
formal_spec = '''[[deprecated]]'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 41
source_line_end = 41
function = "ilp::detail::warn_large_unroll_factor"
header = "loops_common.hpp"
signature = '''constexpr void warn_large_unroll_factor()'''
axiom_type = "anti_pattern"
on_violation = '''Compiler warning issued; function may be removed in future versions causing compilation failure'''

[[axioms]]
id = "ilp::detail::warn_large_unroll_factor.complexity.template_instantiation"
content = '''warn_large_unroll_factor is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 41
source_line_end = 41
function = "ilp::detail::warn_large_unroll_factor"
header = "loops_common.hpp"
signature = '''constexpr void warn_large_unroll_factor()'''
axiom_type = "complexity"
on_violation = '''Increased compilation time and binary bloat from excessive template instantiations'''

[[axioms]]
id = "ilp::detail::validate_unroll_factor.constexpr"
content = '''validate_unroll_factor can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 44
source_line_end = 44
function = "ilp::detail::validate_unroll_factor"
header = "loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in constant expression context with non-constexpr operations'''

[[axioms]]
id = "ilp::detail::validate_unroll_factor.complexity.template_instantiation"
content = '''validate_unroll_factor is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^1)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 44
source_line_end = 44
function = "ilp::detail::validate_unroll_factor"
header = "loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "complexity"
on_violation = '''Increased compilation time and binary bloat from excessive template instantiations'''

[[axioms]]
id = "ilp::detail::no_return_t::operator bool.postcond.always_false"
content = '''operator bool always returns false for no_return_t sentinel type'''
formal_spec = '''result == false'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::detail::no_return_t::operator bool"
axiom_type = "postcondition"
on_violation = '''Logic error if caller assumes return value can be true'''

[[axioms]]
id = "ilp::iota_view::iterator::operator++.postcond.increments_value"
content = '''operator++ increments the value member by 1'''
formal_spec = '''this.value == old(this.value) + 1'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::iota_view::iterator::operator++"
axiom_type = "postcondition"
on_violation = '''Iterator does not advance correctly; infinite loop or incorrect iteration range'''

[[axioms]]
id = "ilp::detail::signed_integral_type.concept"
content = '''Concept signed_integral_type requires: std::integral<T> && std::signed_integral<T>'''
formal_spec = '''std::integral<T> && std::signed_integral<T>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 52
source_line_end = 52
function = "ilp::detail::signed_integral_type"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if T is not both an integral type and signed'''
depends_on = ['cpp20_concepts_syn_signed_integral_constraint_a6c2e4f0', 'cpp20_concepts_syn_unsigned_integral_constraint_b7d3f5a1']

[[axioms]]
id = "ilp::detail::unsigned_integral_type.concept"
content = '''Concept unsigned_integral_type requires: std::integral<T> && std::unsigned_integral<T>'''
formal_spec = '''std::integral<T> && std::unsigned_integral<T>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 55
source_line_end = 55
function = "ilp::detail::unsigned_integral_type"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if T is not both an integral type and unsigned'''
depends_on = ['cpp20_concepts_syn_unsigned_integral_constraint_b7d3f5a1']

[[axioms]]
id = "ilp::detail::warn_accumulator_overflow.constexpr"
content = '''warn_accumulator_overflow can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 62
source_line_end = 62
function = "ilp::detail::warn_accumulator_overflow"
header = "loops_common.hpp"
signature = '''constexpr void warn_accumulator_overflow()'''
axiom_type = "constraint"
on_violation = '''Function cannot be used in constant expressions or compile-time contexts'''

[[axioms]]
id = "ilp::detail::warn_accumulator_overflow.deprecated"
content = '''warn_accumulator_overflow is deprecated and should not be used'''
formal_spec = '''[[deprecated]]'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 62
source_line_end = 62
function = "ilp::detail::warn_accumulator_overflow"
header = "loops_common.hpp"
signature = '''constexpr void warn_accumulator_overflow()'''
axiom_type = "anti_pattern"
on_violation = '''Compiler emits deprecation warning; function may be removed in future versions'''

[[axioms]]
id = "ilp::detail::warn_accumulator_overflow.complexity.template_instantiation"
content = '''warn_accumulator_overflow is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^2)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 62
source_line_end = 62
function = "ilp::detail::warn_accumulator_overflow"
header = "loops_common.hpp"
signature = '''constexpr void warn_accumulator_overflow()'''
axiom_type = "complexity"
on_violation = '''Excessive template argument combinations lead to code bloat and increased compilation time'''

[[axioms]]
id = "ilp::detail::check_sum_overflow.constexpr"
content = '''check_sum_overflow can be evaluated at compile time'''
formal_spec = '''constexpr == true'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 65
source_line_end = 65
function = "ilp::detail::check_sum_overflow"
header = "loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "constraint"
on_violation = '''Function cannot be used in constant expressions or compile-time contexts'''

[[axioms]]
id = "ilp::detail::check_sum_overflow.complexity.template_instantiation"
content = '''check_sum_overflow is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^2)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 65
source_line_end = 65
function = "ilp::detail::check_sum_overflow"
header = "loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "complexity"
on_violation = '''Excessive template argument combinations lead to code bloat and increased compilation time'''

[[axioms]]
id = "ilp::detail::ForBody.concept"
content = '''Concept ForBody requires: std::invocable<F, T>'''
formal_spec = '''std::invocable<F, T>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 75
source_line_end = 75
function = "ilp::detail::ForBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with argument of type T'''

[[axioms]]
id = "ilp::detail::ForCtrlBody.concept"
content = '''Concept ForCtrlBody requires: std::invocable<F, T, LoopCtrl<void> &>'''
formal_spec = '''std::invocable<F, T, LoopCtrl<void> &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 78
source_line_end = 78
function = "ilp::detail::ForCtrlBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type T and LoopCtrl<void>&'''

[[axioms]]
id = "ilp::detail::ForRetBody.concept"
content = '''Concept ForRetBody requires: std::invocable<F, T, LoopCtrl<R> &>'''
formal_spec = '''std::invocable<F, T, LoopCtrl<R> &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 81
source_line_end = 81
function = "ilp::detail::ForRetBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type T and LoopCtrl<R>&'''

[[axioms]]
id = "ilp::detail::ForUntypedCtrlBody.concept"
content = '''Concept ForUntypedCtrlBody requires: std::invocable<F, T, ForCtrl &>'''
formal_spec = '''std::invocable<F, T, ForCtrl &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 84
source_line_end = 84
function = "ilp::detail::ForUntypedCtrlBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type T and ForCtrl&'''

[[axioms]]
id = "ilp::detail::ForTypedCtrlBody.concept"
content = '''Concept ForTypedCtrlBody requires: std::invocable<F, T, ForCtrlTyped<R> &>'''
formal_spec = '''std::invocable<F, T, ForCtrlTyped<R> &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 87
source_line_end = 87
function = "ilp::detail::ForTypedCtrlBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type T and ForCtrlTyped<R>&'''

[[axioms]]
id = "ilp::detail::ForRangeBody.concept"
content = '''Concept ForRangeBody requires: std::invocable<F, Ref>'''
formal_spec = '''std::invocable<F, Ref>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 90
source_line_end = 90
function = "ilp::detail::ForRangeBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with argument of type Ref'''

[[axioms]]
id = "ilp::detail::ForRangeCtrlBody.concept"
content = '''Concept ForRangeCtrlBody requires: std::invocable<F, Ref, LoopCtrl<void> &>'''
formal_spec = '''std::invocable<F, Ref, LoopCtrl<void> &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 93
source_line_end = 93
function = "ilp::detail::ForRangeCtrlBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type Ref and LoopCtrl<void>&'''

[[axioms]]
id = "ilp::detail::ForRangeRetBody.concept"
content = '''Concept ForRangeRetBody requires: std::invocable<F, Ref, LoopCtrl<R> &>'''
formal_spec = '''std::invocable<F, Ref, LoopCtrl<R> &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 96
source_line_end = 96
function = "ilp::detail::ForRangeRetBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type Ref and LoopCtrl<R>&'''

[[axioms]]
id = "ilp::detail::ForRangeUntypedCtrlBody.concept"
content = '''Concept ForRangeUntypedCtrlBody requires: std::invocable<F, Ref, ForCtrl &>'''
formal_spec = '''std::invocable<F, Ref, ForCtrl &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 99
source_line_end = 99
function = "ilp::detail::ForRangeUntypedCtrlBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type Ref and ForCtrl&'''

[[axioms]]
id = "ilp::detail::ForRangeTypedCtrlBody.concept"
content = '''Concept ForRangeTypedCtrlBody requires: std::invocable<F, Ref, ForCtrlTyped<R> &>'''
formal_spec = '''std::invocable<F, Ref, ForCtrlTyped<R> &>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_common.hpp"
source_module = "loops_commonpp"
source_line_start = 102
source_line_end = 102
function = "ilp::detail::ForRangeTypedCtrlBody"
header = "loops_common.hpp"
axiom_type = "constraint"
on_violation = '''Compilation fails if F cannot be invoked with arguments of type Ref and ForCtrlTyped<R>&'''

[[axioms]]
id = "ilp::detail::for_loop_untyped_impl.complexity.template_instantiation"
content = '''for_loop_untyped_impl is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 22
source_line_end = 22
function = "ilp::detail::for_loop_untyped_impl"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template argument combinations lead to code bloat and increased compilation time'''

[[axioms]]
id = "ilp::detail::for_loop_typed_impl.complexity.template_instantiation"
content = '''for_loop_typed_impl is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^4)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 46
source_line_end = 46
function = "ilp::detail::for_loop_typed_impl"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::detail::for_loop_range_impl.complexity.template_instantiation"
content = '''for_loop_range_impl is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 69
source_line_end = 69
function = "ilp::detail::for_loop_range_impl"
header = "loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::detail::for_loop_range_impl.precond.bounds_check"
content = '''Index must be within bounds for it[i + j]'''
formal_spec = '''0 <= index && index < size'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 83
source_line_end = 83
function = "ilp::detail::for_loop_range_impl"
header = "loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Out-of-bounds access causes undefined behavior, potentially leading to segmentation fault or memory corruption'''

[[axioms]]
id = "Ref.type_alias"
content = '''Ref is an alias for std::ranges::range_reference_t<Range>'''
formal_spec = '''type(Ref) == std::ranges::range_reference_t<Range>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 71
source_line_end = 71
function = "Ref"
header = "loops_ilp.hpp"
axiom_type = "constraint"
on_violation = '''Type mismatch causes compilation failure due to incompatible types in template instantiation'''

[[axioms]]
id = "ilp::detail::for_loop_range_untyped_impl.complexity.template_instantiation"
content = '''for_loop_range_untyped_impl is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 107
source_line_end = 107
function = "ilp::detail::for_loop_range_untyped_impl"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::detail::for_loop_range_untyped_impl.precond.bounds_check"
content = '''Index must be within bounds for it[i + j]'''
formal_spec = '''0 <= index && index < size'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 116
source_line_end = 116
function = "ilp::detail::for_loop_range_untyped_impl"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Out-of-bounds access causes undefined behavior, potentially leading to segmentation fault or memory corruption'''

[[axioms]]
id = "ilp::detail::for_loop_range_typed_impl.complexity.template_instantiation"
content = '''for_loop_range_typed_impl is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^4)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 133
source_line_end = 133
function = "ilp::detail::for_loop_range_typed_impl"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::detail::for_loop_range_typed_impl.precond.bounds_check"
content = '''Index must be within bounds for it[i + j]'''
formal_spec = '''0 <= index && index < size'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 142
source_line_end = 142
function = "ilp::detail::for_loop_range_typed_impl"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Out-of-bounds access causes undefined behavior, potentially leading to segmentation fault or memory corruption'''

[[axioms]]
id = "ilp::detail::for_loop_range_ret_simple_impl.complexity.template_instantiation"
content = '''for_loop_range_ret_simple_impl is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 158
source_line_end = 158
function = "ilp::detail::for_loop_range_ret_simple_impl"
header = "loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::detail::for_loop_range_ret_simple_impl.precond.bounds_check"
content = '''Index must be within bounds for matches[j]'''
formal_spec = '''0 <= index && index < size'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 173
source_line_end = 173
function = "ilp::detail::for_loop_range_ret_simple_impl"
header = "loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Out-of-bounds access causes undefined behavior, potentially leading to segmentation fault or memory corruption'''

[[axioms]]
id = "Sentinel.type_alias"
content = '''Sentinel is an alias for decltype(end_it)'''
formal_spec = '''type(Sentinel) == decltype(end_it)'''
layer = "user_library"
confidence = 1.0
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 164
source_line_end = 164
function = "Sentinel"
header = "loops_ilp.hpp"
axiom_type = "constraint"
on_violation = '''Type mismatch causes compilation failure when sentinel type does not match expected iterator comparison type'''

[[axioms]]
id = "R.type_alias"
content = '''R is an alias for std::invoke_result_t<F, std::ranges::range_reference_t<Range>, Sentinel>'''
formal_spec = '''type(R) == std::invoke_result_t<F, std::ranges::range_reference_t<Range>, Sentinel>'''
layer = "user_library"
confidence = 1.0
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 166
source_line_end = 166
function = "R"
header = "loops_ilp.hpp"
axiom_type = "constraint"
on_violation = '''Type mismatch causes compilation failure when return type does not match invocation result type'''

[[axioms]]
id = "ilp::for_loop.complexity.template_instantiation"
content = '''for_loop is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 231
source_line_end = 231
function = "ilp::for_loop"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::for_loop_typed.complexity.template_instantiation"
content = '''for_loop_typed is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^4)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 237
source_line_end = 237
function = "ilp::for_loop_typed"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::for_loop_range.complexity.template_instantiation"
content = '''for_loop_range is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 243
source_line_end = 243
function = "ilp::for_loop_range"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::for_loop_range_typed.complexity.template_instantiation"
content = '''for_loop_range_typed is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^4)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 249
source_line_end = 249
function = "ilp::for_loop_range_typed"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::for_loop_range_ret_simple.complexity.template_instantiation"
content = '''for_loop_range_ret_simple is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^3)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 254
source_line_end = 254
function = "ilp::for_loop_range_ret_simple"
header = "loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::for_loop_auto.complexity.template_instantiation"
content = '''for_loop_auto is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^4)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 260
source_line_end = 260
function = "ilp::for_loop_auto"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::for_loop_typed_auto.complexity.template_instantiation"
content = '''for_loop_typed_auto is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^5)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 266
source_line_end = 266
function = "ilp::for_loop_typed_auto"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compile time and binary size bloat'''

[[axioms]]
id = "ilp::detail::for_loop_range_impl.inferred.postcond"
content = '''After execution, the callable f has been invoked for each valid index in the range'''
formal_spec = '''forall i in [0, size): f was called with it[i]'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::detail::for_loop_range_impl"
axiom_type = "postcondition"
on_violation = '''Iteration is incomplete, leading to missed elements in the range processing'''

[[axioms]]
id = "ilp::detail::for_loop_range_untyped_impl.inferred.postcond"
content = '''After execution, the callable f has been invoked for each valid index in the range'''
formal_spec = '''forall i in [0, size): f was called with it[i]'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::detail::for_loop_range_untyped_impl"
axiom_type = "postcondition"
on_violation = '''Iteration is incomplete, leading to missed elements in the range processing'''

[[axioms]]
id = "ilp::detail::for_loop_range_typed_impl.inferred.postcond"
content = '''After execution, the callable f has been invoked for each valid index in the range with typed references'''
formal_spec = '''forall i in [0, size): f was called with static_cast<Ref>(it[i])'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::detail::for_loop_range_typed_impl"
axiom_type = "postcondition"
on_violation = '''Iteration is incomplete or type conversions are not applied, leading to incorrect element processing'''

[[axioms]]
id = "ilp::detail::for_loop_range_ret_simple_impl.inferred.postcond"
content = '''After execution, returns a tuple of results from invoking f on each element'''
formal_spec = '''return_value == std::make_tuple(f(it[0]), f(it[1]), ..., f(it[size-1]))'''
layer = "c11_core"
confidence = 0.85
source_file = "enricher.py"
source_module = "llm_inferred"
function = "ilp::detail::for_loop_range_ret_simple_impl"
axiom_type = "postcondition"
on_violation = '''Returned tuple is incomplete or contains incorrect values from function invocations'''

[[axioms]]
id = "ilp::for_loop_range_auto.complexity.template_instantiation"
content = '''for_loop_range_auto is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^4)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 272
source_line_end = 272
function = "ilp::for_loop_range_auto"
header = "loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compilation time and binary size'''

[[axioms]]
id = "ilp::for_loop_range_typed_auto.complexity.template_instantiation"
content = '''for_loop_range_typed_auto is a template function; each unique combination of template arguments causes a separate instantiation'''
formal_spec = '''instantiation_count = O(unique_template_args^5)'''
layer = "user_library"
confidence = 0.95
source_file = "loops_ilp.hpp"
source_module = "loops_ilppp"
source_line_start = 278
source_line_end = 278
function = "ilp::for_loop_range_typed_auto"
header = "loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''Excessive template instantiations lead to increased compilation time and binary size'''

[[axioms]]
id = "ILP_FOR.effect.iteration"
content = '''Macro ILP_FOR performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 10
source_line_end = 10
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if condition is false; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_RANGE.effect.iteration"
content = '''Macro ILP_FOR_RANGE performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 12
source_line_end = 12
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if range is empty; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_AUTO.effect.iteration"
content = '''Macro ILP_FOR_AUTO performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 14
source_line_end = 14
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if condition is false; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_RANGE_AUTO.effect.iteration"
content = '''Macro ILP_FOR_RANGE_AUTO performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 17
source_line_end = 17
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if range is empty; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_T.effect.iteration"
content = '''Macro ILP_FOR_T performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 19
source_line_end = 19
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if condition is false; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_RANGE_T.effect.iteration"
content = '''Macro ILP_FOR_RANGE_T performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 21
source_line_end = 21
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if range is empty; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_T_AUTO.effect.iteration"
content = '''Macro ILP_FOR_T_AUTO performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 23
source_line_end = 23
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if condition is false; control flow deviates from expected iteration'''

[[axioms]]
id = "ILP_FOR_RANGE_T_AUTO.effect.iteration"
content = '''Macro ILP_FOR_RANGE_T_AUTO performs iteration over a range or condition'''
formal_spec = '''has_iteration_semantics'''
layer = "user_library"
confidence = 0.9
source_file = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
source_module = "ome.mvarendorff.Documents.Code.cpp.ilp_for.ilp_for.detail.macros_simplepp"
source_line_start = 26
source_line_end = 26
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''#define ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''Loop body is not executed if range is empty; control flow deviates from expected iteration'''
